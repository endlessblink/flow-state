[{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/__tests__/canvas.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":448,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":448,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { setActivePinia, createPinia } from 'pinia'\nimport { useCanvasStore } from '../canvas'\nimport type { Task } from '../tasks'\n\n// Mock the database composable\nvi.mock('@/composables/useSupabaseDatabase', () => ({\n  useSupabaseDatabase: () => ({\n    saveGroup: vi.fn(),\n    deleteGroup: vi.fn(),\n    fetchGroups: vi.fn().mockResolvedValue([])\n  })\n}))\n\ndescribe('CanvasStore', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia())\n  })\n\n  describe('Viewport Management', () => {\n    it('sets viewport position and zoom', () => {\n      const store = useCanvasStore()\n\n      store.setViewport(100, 200, 1.5)\n\n      expect(store.viewport.x).toBe(100)\n      expect(store.viewport.y).toBe(200)\n      expect(store.viewport.zoom).toBe(1.5)\n    })\n  })\n\n  describe('Node Selection', () => {\n    it('sets selected nodes', () => {\n      const store = useCanvasStore()\n\n      store.setSelectedNodes(['task-1', 'task-2', 'task-3'])\n\n      expect(store.selectedNodeIds).toEqual(['task-1', 'task-2', 'task-3'])\n    })\n\n    it('toggles node selection', () => {\n      const store = useCanvasStore()\n\n      store.toggleNodeSelection('task-1')\n      expect(store.selectedNodeIds).toContain('task-1')\n\n      store.toggleNodeSelection('task-1')\n      expect(store.selectedNodeIds).not.toContain('task-1')\n    })\n\n    it('clears all selections', () => {\n      const store = useCanvasStore()\n      store.setSelectedNodes(['task-1', 'task-2'])\n\n      store.clearSelection()\n\n      expect(store.selectedNodeIds).toEqual([])\n      expect(store.selectionRect).toBeNull()\n      expect(store.isSelecting).toBe(false)\n    })\n  })\n\n  describe('Section Management', () => {\n    it('creates a section', async () => {\n      const store = useCanvasStore()\n\n      const section = await store.createSection({\n        name: 'High Priority',\n        type: 'priority',\n        propertyValue: 'high',\n        position: { x: 100, y: 100, width: 300, height: 250 },\n        color: '#ef4444',\n        layout: 'grid',\n        isVisible: true,\n        isCollapsed: false\n      })\n\n      expect(section).toBeDefined()\n      expect(section.name).toBe('High Priority')\n      expect(section.type).toBe('priority')\n      expect(section.propertyValue).toBe('high')\n      expect(store.sections.length).toBe(1)\n    })\n\n    it('updates a section', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({\n        name: 'Original',\n        type: 'custom',\n        position: { x: 0, y: 0, width: 300, height: 250 },\n        color: '#000000',\n        layout: 'vertical',\n        isVisible: true,\n        isCollapsed: false\n      })\n\n      store.updateSection(section.id, {\n        name: 'Updated',\n        color: '#ffffff'\n      })\n\n      const updated = store.sections.find(s => s.id === section.id)\n      expect(updated?.name).toBe('Updated')\n      expect(updated?.color).toBe('#ffffff')\n    })\n\n    it('deletes a section', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({\n        name: 'To Delete',\n        type: 'custom',\n        position: { x: 0, y: 0, width: 300, height: 250 },\n        color: '#000000',\n        layout: 'vertical',\n        isVisible: true,\n        isCollapsed: false\n      })\n\n      expect(store.sections.length).toBe(1)\n\n      store.deleteSection(section.id)\n\n      expect(store.sections.length).toBe(0)\n    })\n\n    it('toggles section visibility', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({\n        name: 'Section',\n        type: 'custom',\n        position: { x: 0, y: 0, width: 300, height: 250 },\n        color: '#000000',\n        layout: 'vertical',\n        isVisible: true,\n        isCollapsed: false\n      })\n\n      store.toggleSectionVisibility(section.id)\n      expect(store.sections[0].isVisible).toBe(false)\n\n      store.toggleSectionVisibility(section.id)\n      expect(store.sections[0].isVisible).toBe(true)\n    })\n\n    it('toggles section collapse', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({\n        name: 'Section',\n        type: 'custom',\n        position: { x: 0, y: 0, width: 300, height: 250 },\n        color: '#000000',\n        layout: 'vertical',\n        isVisible: true,\n        isCollapsed: false\n      })\n\n      store.toggleSectionCollapse(section.id)\n      expect(store.sections[0].isCollapsed).toBe(true)\n\n      store.toggleSectionCollapse(section.id)\n      expect(store.sections[0].isCollapsed).toBe(false)\n    })\n\n\n  })\n\n  describe('Smart Section Creators', () => {\n    it('creates priority sections', async () => {\n      const store = useCanvasStore()\n\n      const high = await store.createSection({ name: 'High Priority', type: 'priority', propertyValue: 'high', color: '#ef4444', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n      const medium = await store.createSection({ name: 'Medium Priority', type: 'priority', propertyValue: 'medium', color: '#f59e0b', position: { x: 350, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n      const low = await store.createSection({ name: 'Low Priority', type: 'priority', propertyValue: 'low', color: '#3b82f6', position: { x: 700, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      expect(high.name).toBe('High Priority')\n      expect(high.type).toBe('priority')\n      expect(high.propertyValue).toBe('high')\n      expect(high.color).toBe('#ef4444')\n\n      expect(medium.name).toBe('Medium Priority')\n      expect(medium.propertyValue).toBe('medium')\n\n      expect(low.name).toBe('Low Priority')\n      expect(low.propertyValue).toBe('low')\n\n      expect(store.sections.length).toBe(3)\n    })\n\n    it('creates status sections', async () => {\n      const store = useCanvasStore()\n\n      const planned = await store.createSection({ name: 'Planned', type: 'status', propertyValue: 'planned', color: '#6366f1', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n      const inProgress = await store.createSection({ name: 'In Progress', type: 'status', propertyValue: 'in_progress', color: '#f59e0b', position: { x: 350, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n      const done = await store.createSection({ name: 'Done', type: 'status', propertyValue: 'done', color: '#10b981', position: { x: 700, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      expect(planned.name).toBe('Planned')\n      expect(planned.type).toBe('status')\n      expect(planned.propertyValue).toBe('planned')\n\n      expect(inProgress.name).toBe('In Progress')\n      expect(inProgress.propertyValue).toBe('in_progress')\n\n      expect(done.name).toBe('Done')\n      expect(done.propertyValue).toBe('done')\n\n      expect(store.sections.length).toBe(3)\n    })\n\n    it('creates project sections', async () => {\n      const store = useCanvasStore()\n\n      const section = await store.createSection({ name: 'My Project', type: 'project', propertyValue: 'project-123', color: '#3b82f6', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      expect(section.name).toBe('My Project')\n      expect(section.type).toBe('project')\n      expect(section.propertyValue).toBe('project-123')\n      expect(section.color).toBe('#3b82f6')\n    })\n  })\n\n  describe('Task Filtering', () => {\n    it('filters tasks by priority section', async () => {\n      const store = useCanvasStore()\n\n      const section = await store.createSection({ name: 'High Priority', type: 'priority', propertyValue: 'high', color: '#ef4444', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      const tasks: Task[] = [\n        {\n          id: '1',\n          title: 'High Task',\n          description: '',\n          status: 'planned',\n          priority: 'high',\n          progress: 0,\n          completedPomodoros: 0,\n          subtasks: [],\n          dueDate: '',\n          projectId: '1',\n          createdAt: new Date(),\n          updatedAt: new Date()\n        },\n        {\n          id: '2',\n          title: 'Medium Task',\n          description: '',\n          status: 'planned',\n          priority: 'medium',\n          progress: 0,\n          completedPomodoros: 0,\n          subtasks: [],\n          dueDate: '',\n          projectId: '1',\n          createdAt: new Date(),\n          updatedAt: new Date()\n        }\n      ]\n\n      // Note: getTasksInSection returns all tasks if no filters are set\n      // Priority sections use taskMatchesSection for matching, not getTasksInSection filters\n      // Let's test using taskMatchesSection instead\n      const filtered = tasks.filter(task => store.taskMatchesSection(task, section.id))\n\n      expect(filtered.length).toBe(1)\n      expect(filtered[0].id).toBe('1')\n      expect(filtered[0].priority).toBe('high')\n    })\n\n    it('filters tasks by status section', async () => {\n      const store = useCanvasStore()\n\n      const section = await store.createSection({ name: 'In Progress', type: 'status', propertyValue: 'in_progress', color: '#f59e0b', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      const tasks: Task[] = [\n        {\n          id: '1',\n          title: 'Task 1',\n          description: '',\n          status: 'in_progress',\n          priority: 'medium',\n          progress: 0,\n          completedPomodoros: 0,\n          subtasks: [],\n          dueDate: '',\n          projectId: '1',\n          createdAt: new Date(),\n          updatedAt: new Date()\n        },\n        {\n          id: '2',\n          title: 'Task 2',\n          description: '',\n          status: 'planned',\n          priority: 'medium',\n          progress: 0,\n          completedPomodoros: 0,\n          subtasks: [],\n          dueDate: '',\n          projectId: '1',\n          createdAt: new Date(),\n          updatedAt: new Date()\n        }\n      ]\n\n      // Use taskMatchesSection for smart section filtering\n      const filtered = tasks.filter(task => store.taskMatchesSection(task, section.id))\n\n      expect(filtered.length).toBe(1)\n      expect(filtered[0].id).toBe('1')\n      expect(filtered[0].status).toBe('in_progress')\n    })\n  })\n\n  describe('Task Matching', () => {\n    it('matches task to priority section', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({ name: 'High Priority', type: 'priority', propertyValue: 'high', color: '#ef4444', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      const highTask: Task = {\n        id: '1',\n        title: 'High Priority Task',\n        description: '',\n        status: 'planned',\n        priority: 'high',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n\n      const lowTask: Task = {\n        ...highTask,\n        id: '2',\n        priority: 'low'\n      }\n\n      expect(store.taskMatchesSection(highTask, section.id)).toBe(true)\n      expect(store.taskMatchesSection(lowTask, section.id)).toBe(false)\n    })\n\n    it('matches task to status section', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({ name: 'Done', type: 'status', propertyValue: 'done', color: '#10b981', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      const doneTask: Task = {\n        id: '1',\n        title: 'Done Task',\n        description: '',\n        status: 'done',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n\n      const plannedTask: Task = {\n        ...doneTask,\n        id: '2',\n        status: 'planned'\n      }\n\n      expect(store.taskMatchesSection(doneTask, section.id)).toBe(true)\n      expect(store.taskMatchesSection(plannedTask, section.id)).toBe(false)\n    })\n\n    it('matches task to project section', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({ name: 'Project 1', type: 'project', propertyValue: 'proj-1', color: '#3b82f6', position: { x: 0, y: 0, width: 300, height: 200 }, layout: 'vertical', isVisible: true, isCollapsed: false })\n\n      const task1: Task = {\n        id: '1',\n        title: 'Task 1',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: 'proj-1',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n\n      const task2: Task = {\n        ...task1,\n        id: '2',\n        projectId: 'proj-2'\n      }\n\n      expect(store.taskMatchesSection(task1, section.id)).toBe(true)\n      expect(store.taskMatchesSection(task2, section.id)).toBe(false)\n    })\n  })\n\n  describe('Multi-Selection', () => {\n    it('toggles multi-select mode', () => {\n      const store = useCanvasStore()\n\n      expect(store.multiSelectMode).toBe(false)\n\n      store.toggleMultiSelectMode()\n      expect(store.multiSelectMode).toBe(true)\n\n      store.toggleMultiSelectMode()\n      expect(store.multiSelectMode).toBe(false)\n    })\n\n    it('sets selection mode', () => {\n      const store = useCanvasStore()\n\n      store.setSelectionMode('lasso')\n      expect(store.selectionMode).toBe('lasso')\n\n      store.setSelectionMode('rectangle')\n      expect(store.selectionMode).toBe('rectangle')\n\n      store.setSelectionMode('click')\n      expect(store.selectionMode).toBe('click')\n    })\n\n    it('manages selection rect state', () => {\n      const store = useCanvasStore()\n\n      store.startSelection(50, 50)\n      expect(store.isSelecting).toBe(true)\n      expect(store.selectionRect).toEqual({ x: 50, y: 50, width: 0, height: 0 })\n\n      store.updateSelection(50, 50) // Initial update same as start\n      expect(store.selectionRect).toEqual({ x: 50, y: 50, width: 0, height: 0 })\n\n      store.updateSelection(150, 200) // Drag to new pos\n      expect(store.selectionRect).toEqual({ x: 50, y: 50, width: 100, height: 150 })\n\n      store.endSelection()\n      expect(store.isSelecting).toBe(false)\n    })\n\n    it('selects nodes in rectangle', () => {\n      const store = useCanvasStore()\n\n      const nodes = [\n        { id: 'task-1', position: { x: 100, y: 100 } },\n        { id: 'task-2', position: { x: 300, y: 100 } },\n        { id: 'task-3', position: { x: 500, y: 100 } }\n      ]\n\n      const rect = { x: 50, y: 50, width: 300, height: 200 }\n\n      store.selectNodesInRect(rect)\n\n      // Should select task-1 and task-2 (both within rect bounds)\n      expect(store.selectedNodeIds.length).toBe(2)\n      expect(store.selectedNodeIds).toContain('task-1')\n      expect(store.selectedNodeIds).toContain('task-2')\n    })\n  })\n\n  describe('Connection Mode', () => {\n    it('toggles connect mode', () => {\n      const store = useCanvasStore()\n\n      expect(store.connectMode).toBe(false)\n\n      store.toggleConnectMode()\n      expect(store.connectMode).toBe(true)\n\n      store.toggleConnectMode()\n      expect(store.connectMode).toBe(false)\n      expect(store.connectingFrom).toBeNull()\n    })\n\n    it('starts connection from node', () => {\n      const store = useCanvasStore()\n\n      store.startConnection('task-1')\n\n      expect(store.connectMode).toBe(true)\n      expect(store.connectingFrom).toBe('task-1')\n    })\n\n    it('clears connection', () => {\n      const store = useCanvasStore()\n      store.startConnection('task-1')\n\n      store.clearConnection()\n\n      expect(store.connectMode).toBe(false)\n      expect(store.connectingFrom).toBeNull()\n    })\n  })\n\n  describe('Display Preferences', () => {\n    it('toggles priority indicator', () => {\n      const store = useCanvasStore()\n\n      expect(store.showPriorityIndicator).toBe(true)\n\n      store.togglePriorityIndicator()\n      expect(store.showPriorityIndicator).toBe(false)\n\n      store.togglePriorityIndicator()\n      expect(store.showPriorityIndicator).toBe(true)\n    })\n\n    it('toggles status badge', () => {\n      const store = useCanvasStore()\n\n      expect(store.showStatusBadge).toBe(true)\n\n      store.toggleStatusBadge()\n      expect(store.showStatusBadge).toBe(false)\n    })\n\n    it('toggles duration badge', () => {\n      const store = useCanvasStore()\n\n      expect(store.showDurationBadge).toBe(true)\n\n      store.toggleDurationBadge()\n      expect(store.showDurationBadge).toBe(false)\n    })\n\n    it('toggles schedule badge', () => {\n      const store = useCanvasStore()\n\n      expect(store.showScheduleBadge).toBe(true)\n\n      store.toggleScheduleBadge()\n      expect(store.showScheduleBadge).toBe(false)\n    })\n  })\n\n  describe('Active Section', () => {\n    it('sets active section', () => {\n      const store = useCanvasStore()\n\n      store.setActiveSection('section-123')\n      expect(store.activeSectionId).toBe('section-123')\n\n      store.setActiveSection(null)\n      expect(store.activeSectionId).toBeNull()\n    })\n\n    it('clears active section when section is deleted', async () => {\n      const store = useCanvasStore()\n      const section = await store.createSection({\n        name: 'Section',\n        type: 'custom',\n        position: { x: 0, y: 0, width: 300, height: 250 },\n        color: '#000000',\n        layout: 'vertical',\n        isVisible: true,\n        isCollapsed: false\n      })\n\n      store.setActiveSection(section.id)\n      expect(store.activeSectionId).toBe(section.id)\n\n      store.deleteSection(section.id)\n      expect(store.activeSectionId).toBeNull()\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/__tests__/tasks.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":141,"column":43,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":141,"endColumn":55},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":164,"column":43,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":164,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { setActivePinia, createPinia } from 'pinia'\nimport { useTaskStore, formatDateKey, parseDateKey, getTaskInstances } from '../tasks'\nimport type { Task } from '../tasks'\n\n// Mock the database composable\nvi.mock('@/composables/useDatabase', () => ({\n  useDatabase: () => ({\n    save: vi.fn(),\n    load: vi.fn().mockResolvedValue(null)\n  }),\n  DB_KEYS: {\n    TASKS: 'tasks',\n    PROJECTS: 'projects',\n    CANVAS: 'canvas'\n  }\n}))\n\ndescribe('TaskStore', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia())\n  })\n\n  describe('Task CRUD Operations', () => {\n    it('creates a task with default values', async () => {\n      const store = useTaskStore()\n\n      const task = await store.createTask({\n        title: 'Test Task'\n      })\n\n      expect(task).toBeDefined()\n      expect(task.title).toBe('Test Task')\n      expect(task.status).toBe('planned')\n      expect(task.priority).toBe('medium')\n      expect(task.progress).toBe(0)\n      expect(task.completedPomodoros).toBe(0)\n      expect(task.isInInbox).toBe(true)\n      expect(task.projectId).toBe('1')\n    })\n\n    it('creates a task with scheduled date and time as instance', async () => {\n      const store = useTaskStore()\n\n      const task = await store.createTask({\n        title: 'Scheduled Task',\n        scheduledDate: '2025-10-11',\n        scheduledTime: '14:00',\n        estimatedDuration: 60\n      })\n\n      expect(task.instances).toBeDefined()\n      expect(task.instances?.length).toBe(1)\n      expect(task.instances?.[0].scheduledDate).toBe('2025-10-11')\n      expect(task.instances?.[0].scheduledTime).toBe('14:00')\n      expect(task.instances?.[0].duration).toBe(60)\n    })\n\n    it('updates a task', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Original' })\n\n      store.updateTask(task.id, {\n        title: 'Updated',\n        status: 'in_progress'\n      })\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.title).toBe('Updated')\n      expect(updatedTask?.status).toBe('in_progress')\n    })\n\n    it('deletes a task', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'To Delete' })\n\n      expect(store.tasks.length).toBe(1)\n\n      store.deleteTask(task.id)\n\n      expect(store.tasks.length).toBe(0)\n    })\n\n    it('moves a task to different status', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task', status: 'planned' })\n\n      store.moveTask(task.id, 'in_progress')\n\n      const movedTask = store.tasks.find(t => t.id === task.id)\n      expect(movedTask?.status).toBe('in_progress')\n    })\n\n    it('auto-archives completed tasks (removes from canvas)', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({\n        title: 'Task',\n        status: 'in_progress',\n        canvasPosition: { x: 100, y: 100 },\n        isInInbox: false\n      })\n\n      store.updateTask(task.id, { status: 'done' })\n\n      const completedTask = store.tasks.find(t => t.id === task.id)\n      expect(completedTask?.status).toBe('done')\n      expect(completedTask?.isInInbox).toBe(true)\n      expect(completedTask?.canvasPosition).toBeUndefined()\n    })\n  })\n\n  describe('Task Instance Management', () => {\n    it('creates a task instance', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Test Task' })\n\n      const instance = store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00',\n        duration: 45\n      })\n\n      expect(instance).toBeDefined()\n      expect(instance?.scheduledDate).toBe('2025-10-15')\n      expect(instance?.scheduledTime).toBe('10:00')\n      expect(instance?.duration).toBe(45)\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(1)\n    })\n\n    it('updates a task instance', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Test Task' })\n      const instance = store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n\n      if (instance) {\n        store.updateTaskInstance(task.id, instance.id!, {\n          scheduledTime: '11:00',\n          duration: 90\n        })\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      const updatedInstance = updatedTask?.instances?.find(i => i.id === instance?.id)\n      expect(updatedInstance?.scheduledTime).toBe('11:00')\n      expect(updatedInstance?.duration).toBe(90)\n    })\n\n    it('deletes a task instance', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Test Task' })\n      const instance = store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n\n      expect(task.instances?.length).toBe(1)\n\n      if (instance) {\n        store.deleteTaskInstance(task.id, instance.id!)\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(0)\n    })\n\n    it('supports multiple instances of same task', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Recurring Task' })\n\n      store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n      store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-16',\n        scheduledTime: '14:00'\n      })\n      store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-17',\n        scheduledTime: '09:00'\n      })\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(3)\n    })\n  })\n\n  describe('Project Management', () => {\n    it('creates a project', async () => {\n      const store = useTaskStore()\n\n      const project = await store.createProject({\n        name: 'Test Project',\n        color: '#ff0000',\n        colorType: 'hex'\n      })\n\n      expect(project).toBeDefined()\n      expect(project.name).toBe('Test Project')\n      expect(project.color).toBe('#ff0000')\n      expect(project.colorType).toBe('hex')\n      expect(project.viewType).toBe('status')\n    })\n\n    it('updates a project', async () => {\n      const store = useTaskStore()\n      const project = await store.createProject({ name: 'Original' })\n\n      await store.updateProject(project.id, {\n        name: 'Updated',\n        color: '#00ff00'\n      })\n\n      const updated = store.getProjectById(project.id)\n      expect(updated?.name).toBe('Updated')\n      expect(updated?.color).toBe('#00ff00')\n    })\n\n    it('deletes a project and moves tasks to default project', async () => {\n      const store = useTaskStore()\n      const project = await store.createProject({ name: 'To Delete' })\n      const task = await store.createTask({ title: 'Task', projectId: project.id })\n\n      await store.deleteProject(project.id)\n\n      expect(store.projects.find(p => p.id === project.id)).toBeUndefined()\n      const movedTask = store.tasks.find(t => t.id === task.id)\n      expect(movedTask?.projectId).toBeNull() // Moved to uncategorized (null)\n    })\n\n    it('prevents deletion of default project', async () => {\n      const store = useTaskStore()\n      const initialCount = store.projects.length\n\n      await store.deleteProject('1')\n\n      expect(store.projects.length).toBe(initialCount)\n    })\n\n    it('supports nested projects', async () => {\n      const store = useTaskStore()\n      const parent = await store.createProject({ name: 'Parent' })\n      const child = await store.createProject({\n        name: 'Child',\n        parentId: parent.id\n      })\n\n      expect(child.parentId).toBe(parent.id)\n\n      const children = store.getChildProjects(parent.id)\n      expect(children.length).toBe(1)\n      expect(children[0].id).toBe(child.id)\n    })\n\n    it('detects project hierarchy correctly', async () => {\n      const store = useTaskStore()\n      const grandparent = await store.createProject({ name: 'Grandparent' })\n      const parent = await store.createProject({ name: 'Parent', parentId: grandparent.id })\n      const child = await store.createProject({ name: 'Child', parentId: parent.id })\n\n      // Wait a tick for the hierarchy to be fully established\n      const isDescendant = store.isDescendantOf(child.id, grandparent.id)\n      // Note: isDescendantOf checks if child.parentId === grandparent.id directly\n      // but child.parentId === parent.id, so it needs to walk up the chain\n      // The current implementation walks up checking current.parentId === potentialAncestorId\n      // So child -> parent (parentId = grandparent), matches! Returns true\n      expect(isDescendant).toBe(true)\n\n      const isNotDescendant = store.isDescendantOf(grandparent.id, child.id)\n      expect(isNotDescendant).toBe(false)\n    })\n  })\n\n  describe('Task Filtering', () => {\n    it('filters tasks by active project', async () => {\n      const store = useTaskStore()\n\n      // Clear any existing tasks to start fresh\n      store.tasks.length = 0\n\n      // Note: Store initializes with default \"My Tasks\" project (id: '1')\n      // Create new projects for testing\n      const project1 = await store.createProject({ name: 'Project 1' })\n      await new Promise(resolve => setTimeout(resolve, 2))\n      const project2 = await store.createProject({ name: 'Project 2' })\n\n      // Create tasks with delays to ensure unique IDs\n      const task1 = await store.createTask({ title: 'Task 1', projectId: project1.id })\n      await new Promise(resolve => setTimeout(resolve, 2))\n      const task2 = await store.createTask({ title: 'Task 2', projectId: project1.id })\n      await new Promise(resolve => setTimeout(resolve, 2))\n      const task3 = await store.createTask({ title: 'Task 3', projectId: project2.id })\n\n      // Verify unique IDs\n      expect(task1.id).not.toBe(task2.id)\n      expect(task2.id).not.toBe(task3.id)\n\n      // Verify tasks are in correct projects\n      expect(task1.projectId).toBe(project1.id)\n      expect(task2.projectId).toBe(project1.id)\n      expect(task3.projectId).toBe(project2.id)\n\n      // Verify total tasks before filtering\n      expect(store.tasks.length).toBe(3)\n\n      store.setActiveProject(project1.id)\n\n      // Should only show tasks from project1\n      expect(store.filteredTasks.length).toBe(2)\n      expect(store.filteredTasks.every(t => t.projectId === project1.id)).toBe(true)\n      expect(store.filteredTasks.map(t => t.id)).toContain(task1.id)\n      expect(store.filteredTasks.map(t => t.id)).toContain(task2.id)\n    })\n\n    it('filters tasks by \"today\" smart view', () => {\n      const store = useTaskStore()\n      const today = new Date().toISOString().split('T')[0]\n\n      store.createTask({\n        title: 'Today Task',\n        scheduledDate: today,\n        scheduledTime: '10:00'\n      })\n      store.createTask({\n        title: 'Future Task',\n        scheduledDate: '2025-12-31',\n        scheduledTime: '10:00'\n      })\n\n      store.setSmartView('today')\n\n      expect(store.filteredTasks.length).toBeGreaterThanOrEqual(1)\n      const todayTask = store.filteredTasks.find(t => t.title === 'Today Task')\n      expect(todayTask).toBeDefined()\n    })\n  })\n\n  describe('Subtask Management', () => {\n    it('creates a subtask', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Parent Task' })\n\n      const subtask = store.createSubtask(task.id, {\n        title: 'Subtask 1'\n      })\n\n      expect(subtask).toBeDefined()\n      expect(subtask?.parentTaskId).toBe(task.id)\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.subtasks.length).toBe(1)\n    })\n\n    it('updates a subtask', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Parent Task' })\n      const subtask = store.createSubtask(task.id, { title: 'Original' })\n\n      if (subtask) {\n        store.updateSubtask(task.id, subtask.id, { title: 'Updated' })\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      const updatedSubtask = updatedTask?.subtasks.find(s => s.id === subtask?.id)\n      expect(updatedSubtask?.title).toBe('Updated')\n    })\n\n    it('deletes a subtask', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Parent Task' })\n      const subtask = store.createSubtask(task.id, { title: 'Subtask' })\n\n      if (subtask) {\n        store.deleteSubtask(task.id, subtask.id)\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.subtasks.length).toBe(0)\n    })\n  })\n\n  describe('Date Helper Functions', () => {\n    it('formats date key correctly', () => {\n      const date = new Date(2025, 9, 15) // October 15, 2025\n      const formatted = formatDateKey(date)\n      expect(formatted).toBe('2025-10-15')\n    })\n\n    it('parses date key correctly', () => {\n      const parsed = parseDateKey('2025-10-15')\n      expect(parsed).toBeInstanceOf(Date)\n      expect(parsed?.getFullYear()).toBe(2025)\n      expect(parsed?.getMonth()).toBe(9) // 0-indexed\n      expect(parsed?.getDate()).toBe(15)\n    })\n\n    it('handles invalid date key', () => {\n      const parsed = parseDateKey('invalid-date')\n      expect(parsed).toBeNull()\n    })\n  })\n\n  describe('Task Instance Helpers', () => {\n    it('returns instances array if present', () => {\n      const task: Task = {\n        id: '1',\n        title: 'Task',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        instances: [\n          {\n            id: 'inst-1',\n            scheduledDate: '2025-10-15',\n            scheduledTime: '10:00',\n            duration: 30\n          }\n        ]\n      }\n\n      const instances = getTaskInstances(task)\n      expect(instances.length).toBe(1)\n      expect(instances[0].scheduledDate).toBe('2025-10-15')\n    })\n\n    it('creates synthetic instance from legacy fields', () => {\n      const task: Task = {\n        id: '1',\n        title: 'Legacy Task',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        scheduledDate: '2025-10-15',\n        scheduledTime: '14:00',\n        estimatedDuration: 60\n      }\n\n      const instances = getTaskInstances(task)\n      expect(instances.length).toBe(1)\n      expect(instances[0].id).toContain('legacy')\n      expect(instances[0].scheduledDate).toBe('2025-10-15')\n      expect(instances[0].scheduledTime).toBe('14:00')\n    })\n\n    it('returns empty array for unscheduled tasks', () => {\n      const task: Task = {\n        id: '1',\n        title: 'Unscheduled',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n\n      const instances = getTaskInstances(task)\n      expect(instances.length).toBe(0)\n    })\n  })\n\n  describe('Computed Properties', () => {\n    it('groups tasks by status correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Planned 1', status: 'planned' })\n      await store.createTask({ title: 'Planned 2', status: 'planned' })\n      await store.createTask({ title: 'In Progress', status: 'in_progress' })\n      await store.createTask({ title: 'Done', status: 'done' })\n\n      expect(store.tasksByStatus.planned.length).toBe(2)\n      expect(store.tasksByStatus.in_progress.length).toBe(1)\n      expect(store.tasksByStatus.done.length).toBe(1)\n    })\n\n    it('calculates total tasks correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Task 1' })\n      await store.createTask({ title: 'Task 2' })\n      await store.createTask({ title: 'Task 3' })\n\n      expect(store.totalTasks).toBe(3)\n    })\n\n    it('calculates completed tasks correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Task 1', status: 'done' })\n      await store.createTask({ title: 'Task 2', status: 'done' })\n      await store.createTask({ title: 'Task 3', status: 'planned' })\n\n      expect(store.completedTasks).toBe(2)\n    })\n\n    it('calculates total pomodoros correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Task 1', completedPomodoros: 5 })\n      await store.createTask({ title: 'Task 2', completedPomodoros: 3 })\n      await store.createTask({ title: 'Task 3', completedPomodoros: 2 })\n\n      expect(store.totalPomodoros).toBe(10)\n    })\n  })\n\n  describe('Date Movement', () => {\n    it('moves task to today', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n      const today = new Date().toISOString().split('T')[0]\n\n      store.moveTaskToDate(task.id, 'today')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(1)\n      expect(updatedTask?.instances?.[0].scheduledDate).toBe(today)\n    })\n\n    it('moves task to later', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n\n      store.moveTaskToDate(task.id, 'later')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(1)\n      expect(updatedTask?.instances?.[0].isLater).toBe(true)\n    })\n\n    it('clears all instances when moved to no date', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n\n      store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n\n      store.moveTaskToDate(task.id, 'noDate')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(0)\n    })\n  })\n\n  describe('Priority Movement', () => {\n    it('updates task priority', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task', priority: 'low' })\n\n      store.moveTaskToPriority(task.id, 'high')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.priority).toBe('high')\n    })\n\n    it('removes priority with no_priority', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task', priority: 'high' })\n\n      store.moveTaskToPriority(task.id, 'no_priority')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.priority).toBeNull()\n    })\n  })\n\n  describe('Selection Management', () => {\n    it('selects and deselects tasks', async () => {\n      const store = useTaskStore()\n\n      // Create tasks with slight delay to ensure unique IDs\n      const task1 = await store.createTask({ title: 'Task 1' })\n      await new Promise(resolve => setTimeout(resolve, 2)) // 2ms delay\n      const task2 = await store.createTask({ title: 'Task 2' })\n\n      // Verify tasks have unique IDs\n      expect(task1.id).not.toBe(task2.id)\n\n      // Select first task\n      store.selectTask(task1.id)\n      expect(store.selectedTaskIds).toContain(task1.id)\n      expect(store.selectedTaskIds.length).toBe(1)\n\n      // Select second task\n      store.selectTask(task2.id)\n      expect(store.selectedTaskIds).toContain(task2.id)\n      expect(store.selectedTaskIds.length).toBe(2)\n\n      // Deselect first task\n      store.deselectTask(task1.id)\n      expect(store.selectedTaskIds).not.toContain(task1.id)\n      expect(store.selectedTaskIds.length).toBe(1)\n\n      // Clear all selections\n      store.clearSelection()\n      expect(store.selectedTaskIds.length).toBe(0)\n    })\n\n    it('prevents duplicate selections', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n\n      store.selectTask(task.id)\n      store.selectTask(task.id) // Try to select same task again\n\n      expect(store.selectedTaskIds.length).toBe(1)\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isPointInRect' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CANVAS' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Node' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1935,1938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1935,1938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5108,5111],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5108,5111],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6242,6245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6242,6245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6273,6276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6273,6276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":274,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":274,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10246,10249],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10246,10249],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":317,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12193,12196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12193,12196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":348,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":348,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1040,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1040,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38747,38750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38747,38750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1130,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1130,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42384,42387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42384,42387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1180,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1180,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[45018,45021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[45018,45021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore, acceptHMRUpdate } from 'pinia'\nimport { ref, watch, computed } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\n// Force HMR update\nimport { type Task } from './tasks'\nimport { detectPowerKeyword } from '@/composables/useTaskSmartGroups'\nimport { isPointInRect } from '@/utils/canvas/positionCalculator'\nimport { isNodeCompletelyInside, type ContainerBounds } from '@/utils/canvas/spatialContainment'\nimport { getGroupAbsolutePosition } from '@/utils/canvas/coordinates'\nimport { assertNoDuplicateIds } from '@/utils/canvas/invariants'\nimport { CANVAS } from '@/constants/canvas'\nimport { type Node } from '@vue-flow/core'\nimport type {\n  GroupFilter,\n  TaskPosition,\n  AssignOnDropSettings,\n  CollectFilterSettings,\n  CanvasGroup,\n  CanvasSection\n} from './canvas/types'\n\n// Re-export types for consumers\nexport type {\n  GroupFilter,\n  TaskPosition,\n  AssignOnDropSettings,\n  CollectFilterSettings,\n  CanvasGroup,\n  CanvasSection\n}\n\n/**\n * DIAGNOSTIC HELPER: Log group ID histogram to detect duplicates (AUTHORITATIVE)\n * Called from selectors/computeds to trace where duplicates enter the pipeline\n * Uses assertNoDuplicateIds for consistent detection across layers\n */\nconst logGroupIdHistogram = (label: string, groups: CanvasGroup[]) => {\n  if (!import.meta.env.DEV) return\n\n  const checkResult = assertNoDuplicateIds(groups, label)\n\n  if (checkResult.hasDuplicates) {\n    console.error('[GROUP-ID-HISTOGRAM] DUPLICATES', label, {\n      duplicates: checkResult.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n      totalCount: checkResult.totalCount,\n      uniqueIdCount: checkResult.uniqueIdCount\n    })\n  } else if (groups.length > 0) {\n    console.debug('[GROUP-ID-HISTOGRAM]', label, {\n      uniqueIdCount: checkResult.uniqueIdCount,\n      totalCount: checkResult.totalCount\n    })\n  }\n}\n\n// Task store import for safe sync functionality\nlet taskStore: any = null\n\n/**\n * CYCLE CLEANUP: Break any parent cycles in groups on load\n *\n * This function detects and breaks cyclic parent relationships (ABA)\n * that could cause infinite recursion in descendant collection and counting.\n *\n * Called once when loading groups from Supabase to fix any historical cycles.\n */\nfunction breakGroupCycles(groups: CanvasGroup[]): CanvasGroup[] {\n  console.log('[GROUPS] breakGroupCycles called with', groups.length, 'groups')\n\n  // Log all parent relationships for debugging\n  console.log('[GROUPS] Parent relationships:', groups.map(g => ({\n    id: g.id,\n    name: g.name,\n    parentGroupId: g.parentGroupId\n  })))\n\n  const byId = new Map(groups.map(g => [g.id, g]))\n  let cyclesBroken = 0\n\n  // Simple direct cycle detection: follow parent chain, detect if we return to start\n  for (const g of groups) {\n    if (!g.parentGroupId || g.parentGroupId === 'NONE') continue\n\n    const visited = new Set<string>()\n    let current: CanvasGroup | undefined = g\n    let hasCycle = false\n\n    // Follow parent chain until we find a cycle or reach the root\n    while (current && current.parentGroupId && current.parentGroupId !== 'NONE') {\n      if (visited.has(current.id)) {\n        // We've seen this node before - cycle detected!\n        hasCycle = true\n        break\n      }\n      visited.add(current.id)\n      current = byId.get(current.parentGroupId)\n    }\n\n    // Also check if current is back to g (the starting group)\n    if (current && visited.has(current.id)) {\n      hasCycle = true\n    }\n\n    if (hasCycle) {\n      console.warn('[GROUPS] Breaking cycle by clearing parentGroupId', {\n        groupId: g.id,\n        groupName: g.name,\n        oldParentGroupId: g.parentGroupId,\n        visitedChain: Array.from(visited),\n      })\n      g.parentGroupId = null\n      cyclesBroken++\n    }\n  }\n\n  if (cyclesBroken > 0) {\n    console.log(`[GROUPS] Broke ${cyclesBroken} parent cycle(s) on load`)\n  } else {\n    console.log('[GROUPS] No cycles detected in group parents')\n  }\n\n  return groups\n}\n\nexport const useCanvasStore = defineStore('canvas', () => {\n\n  const { fetchGroups, saveGroup, deleteGroup: deleteGroupRemote } = useSupabaseDatabase()\n\n  // TASK-155 FIX: Initialize viewport with defaults - DON'T load from localStorage synchronously\n  // Viewport is loaded asynchronously from Supabase after auth is ready via loadSavedViewport()\n  // This prevents stale localStorage viewport from showing before Supabase data is loaded\n  const getDefaultViewport = () => ({ x: 0, y: 0, zoom: 1 })\n\n  const viewport = ref(getDefaultViewport())\n  const zoomConfig = ref({ minZoom: 0.1, maxZoom: 4.0 })\n\n  // Selection state\n  const selectedNodeIds = ref<string[]>([])\n  const skipNextSelectionChange = ref(false) // Flag to prevent Vue Flow overriding manual Ctrl+click\n  const allowBulkDeselect = ref(false) // TASK-262: Flag to allow bulk deselection only from pane click\n  const connectMode = ref(false)\n  const connectingFrom = ref<string | null>(null)\n\n  // Missing states found in TS errors - adding stubs (Restored for compatibility)\n  const multiSelectMode = ref(false)\n  const selectionMode = ref('normal')\n  const selectionRect = ref<any>(null)\n  const isSelecting = ref(false)\n  const showPriorityIndicator = ref(true)\n  const showStatusBadge = ref(true)\n  const showDurationBadge = ref(true)\n  const showScheduleBadge = ref(true)\n  const activeSectionId = ref<string | null>(null)\n\n  // Groups state\n  // SAFETY: Named _rawGroups to discourage direct access - use visibleGroups (exported as 'groups') instead\n  const _rawGroups = ref<CanvasGroup[]>([])\n  const activeGroupId = ref<string | null>(null)\n  const isDragging = ref(false)\n  // NOTE: Debug watch removed - isDragging transitions are now guarded by FSM\n  const syncTrigger = ref(0)\n  // Optimistic Locking Version Map\n  const nodeVersionMap = ref<Map<string, number>>(new Map())\n\n  // SAFETY: Filtered groups for display - excludes hidden groups\n  const visibleGroups = computed(() => {\n    const result = _rawGroups.value.filter(g => g.isVisible !== false)\n    // Log histogram to detect duplicates at selector level\n    logGroupIdHistogram('visibleGroups', result)\n    return result\n  })\n  const showGroupGuides = ref(true)\n  const snapToGroups = ref(true)\n\n  // Vue Flow integration\n  const nodes = ref<any[]>([])\n  const edges = ref<any[]>([])\n\n  // --- SQL INTERACTION ---\n\n  // TASK-130: LocalStorage key for Guest Mode group persistence\n  const GUEST_GROUPS_KEY = 'pomoflow-guest-groups'\n\n  // TASK-130: Save groups to localStorage for Guest Mode\n  const saveGroupsToLocalStorage = () => {\n    try {\n      localStorage.setItem(GUEST_GROUPS_KEY, JSON.stringify(_rawGroups.value))\n    } catch (e) {\n      console.error(' [GUEST-MODE] Failed to save groups to localStorage:', e)\n    }\n  }\n\n  // TASK-130: Load groups from localStorage for Guest Mode\n  const loadGroupsFromLocalStorage = (): CanvasGroup[] => {\n    try {\n      const stored = localStorage.getItem(GUEST_GROUPS_KEY)\n      if (stored) {\n        const groups = JSON.parse(stored) as CanvasGroup[]\n        return groups\n      }\n    } catch (e) {\n      console.error(' [GUEST-MODE] Failed to load groups from localStorage:', e)\n    }\n    return []\n  }\n\n  const loadFromDatabase = async () => {\n    try {\n\n      const { useAuthStore } = await import('@/stores/auth')\n      const authStore = useAuthStore()\n\n      // Guest mode: load from localStorage (persists across refreshes)\n      if (!authStore.isAuthenticated) {\n        const localGroups = loadGroupsFromLocalStorage()\n        // Break any parent cycles before loading\n        _rawGroups.value = breakGroupCycles(localGroups)\n        return\n      }\n\n      // TASK-142 FIX: ALWAYS try Supabase first - it has the most up-to-date positions\n      // Only fall back to localStorage if Supabase fails or returns empty\n      const loadedGroups = await fetchGroups()\n\n      // ================================================================\n      // DUPLICATE DETECTION - Supabase Group Load Layer (AUTHORITATIVE)\n      // ================================================================\n      // This detects if Supabase itself is returning duplicate group IDs\n      // A duplicate here means the bug is at the database level\n      if (import.meta.env.DEV) {\n        const checkResult = assertNoDuplicateIds(loadedGroups, 'Supabase groups load')\n\n        if (checkResult.hasDuplicates) {\n          console.error('[SUPABASE-GROUP-DUPLICATES] Database returned duplicate group IDs!', {\n            duplicates: checkResult.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n            totalCount: checkResult.totalCount,\n            uniqueIdCount: checkResult.uniqueIdCount\n          })\n        }\n\n        console.debug('[GROUP-LOAD-HISTOGRAM]', {\n          fromSupabase: checkResult.totalCount,\n          uniqueIds: checkResult.uniqueIdCount\n        })\n      }\n\n      // TASK-142: Position integrity validation - detect invalid positions early\n      const invalidGroups = loadedGroups.filter(g =>\n        !g.position ||\n        !Number.isFinite(g.position.x) ||\n        !Number.isFinite(g.position.y) ||\n        !Number.isFinite(g.position.width) ||\n        !Number.isFinite(g.position.height)\n      )\n      if (invalidGroups.length > 0) {\n        console.error(` [INTEGRITY] ${invalidGroups.length} groups have invalid positions:`,\n          invalidGroups.map(g => `${g.name}: ${JSON.stringify(g.position)}`))\n\n        // Auto-repair invalid positions\n        loadedGroups.forEach(g => {\n          if (!g.position || !Number.isFinite(g.position.x) || !Number.isFinite(g.position.y)) {\n            console.warn(` [INTEGRITY] Auto-repairing position for group ${g.name}`)\n            g.position = { x: 0, y: 0, width: g.position?.width || 600, height: g.position?.height || 400 }\n          }\n        })\n      }\n\n      // TASK-150 FIX: When authenticated, Supabase is the source of truth\n      // Don't fall back to localStorage which may have stale/deleted groups\n\n      // BUG-169 FIX: Safety guard - don't overwrite existing groups with empty array\n      // during the first 10 seconds of the session (prevents auth race conditions)\n      if (loadedGroups.length === 0 && _rawGroups.value.length > 0) {\n        const sessionStart = typeof window !== 'undefined' ? (window as any).PomoFlowSessionStart || 0 : 0\n        const timeSinceSessionStart = Date.now() - sessionStart\n\n        if (timeSinceSessionStart < 10000) {\n          console.warn(` [GROUP-LOAD] BLOCKED empty overwrite - ${_rawGroups.value.length} existing groups would be lost (session ${timeSinceSessionStart}ms old)`)\n          return\n        }\n\n        console.warn(` [GROUP-LOAD] Supabase returned 0 groups but ${_rawGroups.value.length} exist locally - proceeding with empty (session ${timeSinceSessionStart}ms old)`)\n      }\n\n      // Break any parent cycles before loading\n      const cleanedGroups = breakGroupCycles(loadedGroups)\n      _rawGroups.value = cleanedGroups\n\n      // Persist any cycle fixes back to Supabase\n      const groupsWithBrokenCycles = cleanedGroups.filter((g, i) =>\n        g.parentGroupId !== loadedGroups[i]?.parentGroupId\n      )\n      if (groupsWithBrokenCycles.length > 0) {\n        console.log('[GROUPS] Persisting cycle fixes to Supabase for', groupsWithBrokenCycles.length, 'groups')\n        for (const g of groupsWithBrokenCycles) {\n          saveGroup(g).catch(err =>\n            console.error('[GROUPS] Failed to persist cycle fix for', g.id, err)\n          )\n        }\n      }\n\n      // Populate nodeVersionMap with loaded group versions for optimistic locking\n      // Defensive: ensure nodeVersionMap.value is a valid Map before clearing\n      if (!nodeVersionMap.value || !(nodeVersionMap.value instanceof Map)) {\n        nodeVersionMap.value = new Map()\n      }\n      nodeVersionMap.value.clear()\n\n      // Always initialize version entries (default to 0 if positionVersion is undefined)\n      // This ensures syncNodePosition always has a starting version to work with\n      loadedGroups.forEach(g => {\n        nodeVersionMap.value.set(g.id, g.positionVersion ?? 0)\n      })\n\n      // Also populate from taskStore if available\n      if (taskStore && taskStore.tasks) {\n        taskStore.tasks.forEach((t: any) => {\n          nodeVersionMap.value.set(t.id, t.positionVersion ?? 0)\n        })\n      }\n\n      if (loadedGroups.length > 0) {\n        console.log(` [CANVAS] Loaded ${loadedGroups.length} groups, nodeVersionMap size: ${nodeVersionMap.value.size}`)\n      }\n\n      // NOTE: Authenticated users use Supabase as single source of truth\n      // No localStorage fallback - empty means empty\n\n    } catch (e) {\n      console.error(' [SUPABASE] Failed to load canvas groups:', e)\n\n      // TASK-130: Fallback to localStorage on Supabase failure\n      const localGroups = loadGroupsFromLocalStorage()\n      if (localGroups.length > 0) {\n        // Break any parent cycles before loading\n        _rawGroups.value = breakGroupCycles(localGroups)\n      }\n    }\n  }\n\n  const saveGroupToStorage = async (group: CanvasGroup) => {\n\n    // Always save to localStorage for persistence across refreshes\n    saveGroupsToLocalStorage()\n\n    try {\n      await saveGroup(group)\n    } catch (e) {\n      // Supabase failed or skipped (guest mode) - localStorage backup is still saved\n      console.debug(` [GROUP-SAVE] Supabase skipped/failed - localStorage backup saved`)\n    }\n  }\n\n  // --- ACTIONS ---\n\n  // Helper: Normalize Smart Group names and colors\n  const applySmartGroupNormalizations = (group: Omit<CanvasGroup, 'id'> | Partial<CanvasGroup>) => {\n    if (!group.name) return\n\n    const nameLower = group.name.toLowerCase().trim()\n\n    // 1. Handle \"Overdue\" (Special Canvas Smart Group)\n    if (nameLower === 'overdue') {\n      group.name = 'Overdue'\n      group.color = '#ef4444' // Red-500\n      // Optionally set type if needed, but 'custom' is safe\n      return\n    }\n\n    // 2. Handle Power Keywords (Standard Smart Groups)\n    const powerInfo = detectPowerKeyword(group.name)\n    if (powerInfo) {\n      // Enforce canonical name\n      group.name = powerInfo.displayName\n\n      // Apply standard colors based on category/value\n      if (!group.color || group.color === '#6366f1') { // Only auto-set if default or empty\n        switch (powerInfo.category) {\n          case 'priority':\n            if (powerInfo.value === 'high') group.color = '#ef4444' // Red\n            else if (powerInfo.value === 'medium') group.color = '#f59e0b' // Amber\n            else if (powerInfo.value === 'low') group.color = '#3b82f6' // Blue (modified from indigo for distinction)\n            break\n          case 'status':\n            if (powerInfo.value === 'done') group.color = '#10b981' // Green\n            else if (powerInfo.value === 'in_progress') group.color = '#f59e0b' // Amber\n            break\n          case 'date':\n            group.color = '#8b5cf6' // Violet for time-based\n            break\n        }\n      }\n    }\n  }\n\n  const createGroup = async (groupData: Omit<CanvasGroup, 'id'>) => {\n    // Enforce Smart Group consistency\n    applySmartGroupNormalizations(groupData)\n\n    // CRITICAL: New groups are ALWAYS top-level (not auto-nested)\n    // Nesting should only happen via explicit UX action, not containment detection\n    const newGroup: CanvasGroup = {\n      ...groupData,\n      id: `group-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,\n      isVisible: true,\n      isCollapsed: false,\n      parentGroupId: null, // Explicitly top-level - never auto-nest new groups\n      positionVersion: 1, // Start at version 1\n      positionFormat: 'absolute' // Always absolute for new groups\n    }\n    _rawGroups.value.push(newGroup)\n    await saveGroupToStorage(newGroup)\n    return newGroup\n  }\n\n  const updateGroup = async (id: string, updates: Partial<CanvasGroup>) => {\n    const index = _rawGroups.value.findIndex(g => g.id === id)\n    if (index !== -1) {\n      const group = _rawGroups.value[index]\n\n      // DRIFT LOGGING: Track when parentGroupId or position is changed\n      // This helps identify non-drag flows that mutate hierarchy/positions\n      if ('parentGroupId' in updates && updates.parentGroupId !== group.parentGroupId) {\n        console.log(` [GROUP-PARENT-WRITE] Group ${id.slice(0, 8)}... (${group.name}) parentGroupId: \"${group.parentGroupId ?? 'none'}\"  \"${updates.parentGroupId ?? 'none'}\"`, {\n          stack: new Error().stack?.split('\\n').slice(2, 5).join(' <- ')\n        })\n      }\n      if ('position' in updates && updates.position) {\n        const oldPos = group.position\n        const newPos = updates.position\n        if (oldPos?.x !== newPos?.x || oldPos?.y !== newPos?.y) {\n          console.log(` [GROUP-POSITION-WRITE] Group ${id.slice(0, 8)}... (${group.name}) pos: (${oldPos?.x?.toFixed(0) ?? '?'},${oldPos?.y?.toFixed(0) ?? '?'})  (${newPos?.x?.toFixed(0) ?? '?'},${newPos?.y?.toFixed(0) ?? '?'})`, {\n            stack: new Error().stack?.split('\\n').slice(2, 5).join(' <- ')\n          })\n        }\n      }\n\n      // Apply normalizations if name is changing\n      if (updates.name) {\n        applySmartGroupNormalizations(updates)\n      }\n\n      // TASK-240: Handle position versioning\n      const currentVersion = group.positionVersion || 0\n      const newVersion = updates.position ? currentVersion + 1 : currentVersion\n\n      _rawGroups.value[index] = {\n        ..._rawGroups.value[index],\n        ...updates,\n        positionVersion: newVersion,\n        updatedAt: new Date().toISOString()\n      }\n      await saveGroupToStorage(_rawGroups.value[index])\n    }\n  }\n\n  const deleteGroup = async (id: string) => {\n    const index = _rawGroups.value.findIndex(g => g.id === id)\n    if (index !== -1) {\n      _rawGroups.value.splice(index, 1)\n\n      // Save to localStorage for guest mode persistence\n      saveGroupsToLocalStorage()\n\n      // Supabase Soft Delete\n      await deleteGroupRemote(id)\n    }\n  }\n\n  const setGroups = (newGroups: CanvasGroup[]) => {\n    // TASK-131: Deprecation warning\n    if (import.meta.env.DEV) {\n      console.warn(' setGroups() is deprecated. Use patchGroups() to respect position locks.')\n    }\n\n    // Guard against empty overwrite (common bug pattern)\n    if (newGroups.length === 0 && _rawGroups.value.length > 0) {\n      console.error(' [CANVAS] Refusing to overwrite existing groups with empty array')\n      return\n    }\n\n    _rawGroups.value = [...newGroups]\n    saveGroupsToLocalStorage()\n  }\n\n  /**\n   * TASK-131/198: Safe group update API that respects optimistic sync.\n   * Use this instead of setGroups() to prevent position resets.\n   *\n   * @param updates - Map of group ID to partial updates\n   * @returns Result object with patched, skipped (locked), and not found IDs\n   */\n  type PatchableGroupKeys = Exclude<keyof CanvasGroup, 'id'>\n  type GroupPatch = Partial<Pick<CanvasGroup, PatchableGroupKeys>>\n\n  interface PatchGroupsResult {\n    readonly patched: string[]\n    readonly skippedLocked: string[]\n    readonly notFound: string[]\n  }\n\n  const patchGroups = (updates: Map<string, GroupPatch>): PatchGroupsResult => {\n    const result: PatchGroupsResult = {\n      patched: [],\n      skippedLocked: [],\n      notFound: []\n    }\n\n    for (const [groupId, changes] of updates) {\n      // Check if group has pending local changes (optimistic sync: REMOVED)\n\n      const group = _rawGroups.value.find(g => g.id === groupId)\n      if (!group) {\n        result.notFound.push(groupId)\n        continue\n      }\n\n      // Apply the patch\n      Object.assign(group, changes, { updatedAt: new Date().toISOString() })\n      result.patched.push(groupId)\n    }\n\n    if (result.patched.length > 0) {\n      saveGroupsToLocalStorage()\n    }\n\n    return result\n  }\n\n  const setViewport = (x: number, y: number, zoom: number) => {\n    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(zoom) || zoom <= 0) {\n      console.warn(' [CANVAS] Attempted to set invalid viewport:', { x, y, zoom })\n      return\n    }\n    viewport.value = { x, y, zoom }\n    // Save viewport to local storage\n    localStorage.setItem('canvas-viewport', JSON.stringify({ x, y, zoom }))\n\n    // Viewport persistence is now purely localStorage based for this device\n  }\n\n  // TASK-155 FIX: Load viewport from Supabase first, fallback to localStorage for guests\n  const loadSavedViewport = async () => {\n    try {\n      // Priority 1: Supabase user_settings (source of truth for authenticated users)\n      const { fetchUserSettings } = useSupabaseDatabase()\n      const settings = await fetchUserSettings()\n      const savedViewport = settings?.canvas_viewport as { x: number; y: number; zoom: number } | undefined\n\n      if (savedViewport && typeof savedViewport.x === 'number' && Number.isFinite(savedViewport.zoom) && savedViewport.zoom > 0) {\n        viewport.value = savedViewport\n        return true\n      }\n\n      // Priority 2: Local Storage (fallback for guests or if Supabase returns nothing)\n      const local = localStorage.getItem('canvas-viewport')\n      if (local) {\n        const parsed = JSON.parse(local)\n        if (\n          Number.isFinite(parsed.x) &&\n          Number.isFinite(parsed.y) &&\n          Number.isFinite(parsed.zoom) &&\n          parsed.zoom > 0\n        ) {\n          viewport.value = parsed\n          return true\n        }\n        console.warn(' [CANVAS] Invalid viewport in localStorage, using defaults')\n      }\n      return false\n    } catch (e) {\n      console.error('Failed to load viewport:', e)\n      return false\n    }\n  }\n\n  // Visual Containment Count - counts tasks that are VISUALLY inside the group bounds\n  const getTaskCountInGroupRecursive = (groupId: string, tasks: Task[], visited = new Set<string>()): number => {\n    // Prevent infinite recursion in cyclic graphs\n    if (visited.has(groupId)) {\n      console.warn(` [CANVAS] Cycle detected in group hierarchy at ${groupId}`)\n      return 0\n    }\n    visited.add(groupId)\n\n    const group = _rawGroups.value.find(g => g.id === groupId)\n    if (!group) return 0\n\n    // 1. Get ABSOLUTE group position (handles nested groups correctly)\n    const groupAbsolutePos = getGroupAbsolutePosition(groupId, _rawGroups.value)\n\n    // 2. Count tasks visually inside this group (using CENTER-based spatial containment)\n    const containerBounds: ContainerBounds = {\n      position: groupAbsolutePos,\n      width: group.position.width,\n      height: group.position.height\n    }\n\n    let count = tasks.filter(t => {\n      if (!t.canvasPosition || t._soft_deleted) return false\n      const taskNode = { position: t.canvasPosition }\n      const isInside = isNodeCompletelyInside(taskNode, containerBounds)\n      return isInside\n    }).length\n\n    // 3. Recursive Children (in nested subgroups)\n    const childGroups = _rawGroups.value.filter(g => g.parentGroupId === groupId)\n    for (const child of childGroups) {\n      count += getTaskCountInGroupRecursive(child.id, tasks, visited)\n    }\n\n    return count\n  }\n\n  const recalculateAllTaskCounts = (tasks: Task[]) => {\n    _rawGroups.value.forEach(group => {\n      group.taskCount = getTaskCountInGroupRecursive(group.id, tasks)\n    })\n  }\n\n  /**\n   * Reactive version counter - incremented when task parentIds change\n   * Used to force recomputation of task counts in computed properties.\n   */\n  const taskParentVersion = ref(0)\n\n  /**\n   * Increment this to force task count recomputation.\n   * Call this whenever a task's parentId changes.\n   */\n  const bumpTaskParentVersion = () => {\n    taskParentVersion.value++\n  }\n\n  /**\n   * Computed: Task counts derived from task.parentId relationship\n   *\n   * This is the SOURCE OF TRUTH for group task counts.\n   * Use this instead of relying on cached taskCount field on groups.\n   *\n   * REACTIVITY: Depends on taskParentVersion ref to detect parentId changes.\n   * Call bumpTaskParentVersion() after updating any task's parentId.\n   *\n   * @returns Map<groupId, taskCount> - reactive count of tasks per group\n   */\n  /**\n   * Helper: Check if a task is considered \"done\" for counting purposes\n   */\n  const isTaskDone = (task: Task): boolean => {\n    return task.status === 'done'\n  }\n\n  const taskCountByGroupId = computed(() => {\n    const counts = new Map<string, number>()\n\n    // Access version to create reactive dependency for parentId changes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const _version = taskParentVersion.value\n\n    // taskStore is loaded asynchronously - check if available\n    if (!taskStore || !taskStore.tasks) {\n      return counts\n    }\n\n    // FIX: Explicitly access .length to create reactive dependency on deletions/additions\n    // Without this, Vue may not track array mutations (splice) and counts won't update on delete\n    const tasks = taskStore.tasks\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const _taskCount = tasks.length\n\n    // Count tasks by their parentId (direct membership)\n    // Only count non-done tasks (done tasks are excluded from header counts)\n    for (const task of tasks) {\n      if (task._soft_deleted) continue // Skip deleted tasks\n      if (isTaskDone(task)) continue   // Skip done/completed tasks\n      if (task.parentId) {\n        counts.set(task.parentId, (counts.get(task.parentId) ?? 0) + 1)\n      }\n    }\n\n    return counts\n  })\n\n  /**\n   * Get task count for a specific group from the derived counts\n   *\n   * @param groupId - The group ID to get count for\n   * @returns Number of tasks in this group (based on parentId)\n   */\n  const getTaskCountForGroup = (groupId: string): number => {\n    return taskCountByGroupId.value.get(groupId) ?? 0\n  }\n\n  /**\n   * Get all descendant group IDs for a given root group (depth-first)\n   *\n   * Returns rootGroupId PLUS all nested child group IDs recursively.\n   * Used for aggregating task counts across nested group hierarchies.\n   *\n   * @param rootGroupId - The root group to start from\n   * @param groups - All groups to search through\n   * @returns Array of group IDs: [rootGroupId, ...allDescendantIds]\n   */\n  const getAllDescendantGroupIds = (rootGroupId: string, groups: CanvasGroup[]): string[] => {\n    const result: string[] = [rootGroupId]\n    const visited = new Set<string>([rootGroupId])\n\n    // Recursive helper to collect descendants\n    const collectDescendants = (parentId: string) => {\n      const children = groups.filter(g => g.parentGroupId === parentId)\n      for (const child of children) {\n        if (!visited.has(child.id)) {\n          visited.add(child.id)\n          result.push(child.id)\n          collectDescendants(child.id)\n        }\n      }\n    }\n\n    collectDescendants(rootGroupId)\n    return result\n  }\n\n  /**\n   * Computed: Aggregated task counts that include tasks in descendant groups\n   *\n   * For nested groups, a parent group's count = sum of:\n   * - Tasks directly in that group (parentId === groupId)\n   * - Tasks in ALL descendant groups (children, grandchildren, etc.)\n   *\n   * This is what should be displayed in group headers for accurate counts.\n   *\n   * REACTIVITY: Depends on taskParentVersion ref to detect parentId changes.\n   * Call bumpTaskParentVersion() after updating any task's parentId.\n   *\n   * @returns Map<groupId, aggregatedCount>\n   */\n  const aggregatedTaskCountByGroupId = computed(() => {\n    const aggregatedCounts = new Map<string, number>()\n    const groups = _rawGroups.value\n\n    // Access version to create reactive dependency for parentId changes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const _version = taskParentVersion.value\n\n    // taskStore is loaded asynchronously - check if available\n    if (!taskStore || !taskStore.tasks) {\n      return aggregatedCounts\n    }\n\n    // FIX: Explicitly access .length to create reactive dependency on deletions/additions\n    const tasks = taskStore.tasks\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const _taskCount = tasks.length\n\n    // Step 1: Pre-index tasks by parentId (direct membership)\n    // Only count non-done tasks (done tasks are excluded from header counts)\n    const directCountsByGroupId = new Map<string, number>()\n    for (const task of tasks) {\n      if (task._soft_deleted) continue // Skip deleted tasks\n      if (isTaskDone(task)) continue   // Skip done/completed tasks\n      if (task.parentId) {\n        directCountsByGroupId.set(task.parentId, (directCountsByGroupId.get(task.parentId) ?? 0) + 1)\n      }\n    }\n\n    // Step 2: For each group, sum counts from itself + all descendants\n    for (const group of groups) {\n      const descendantIds = getAllDescendantGroupIds(group.id, groups)\n      let total = 0\n      for (const gid of descendantIds) {\n        total += directCountsByGroupId.get(gid) ?? 0\n      }\n      aggregatedCounts.set(group.id, total)\n    }\n\n    return aggregatedCounts\n  })\n\n  /**\n   * Get aggregated task count for a specific group (includes descendants)\n   *\n   * @param groupId - The group ID to get aggregated count for\n   * @returns Number of tasks in this group + all descendant groups\n   */\n  const getAggregatedTaskCountForGroup = (groupId: string): number => {\n    return aggregatedTaskCountByGroupId.value.get(groupId) ?? 0\n  }\n\n  /**\n   * DEBUG: Log group hierarchy and task count relationships\n   * Call this to trace why nested group counts aren't aggregating correctly\n   */\n  const debugGroupHierarchy = (groupId: string) => {\n    const group = _rawGroups.value.find(g => g.id === groupId)\n    console.log('[DEBUG GROUP]', groupId, {\n      name: group?.name,\n      parentGroupId: group?.parentGroupId,\n      exists: !!group\n    })\n\n    const children = _rawGroups.value.filter(g => g.parentGroupId === groupId)\n    console.log('[DEBUG GROUP CHILDREN]', groupId, children.map(c => ({ id: c.id, name: c.name })))\n\n    // Also log the descendant IDs and counts\n    const descendantIds = getAllDescendantGroupIds(groupId, _rawGroups.value)\n    console.log('[DEBUG DESCENDANTS]', groupId, descendantIds)\n\n    const aggregatedCount = aggregatedTaskCountByGroupId.value.get(groupId) ?? 0\n    console.log('[DEBUG AGGREGATED COUNT]', groupId, aggregatedCount)\n  }\n\n  /**\n   * DEBUG: Log all aggregated counts at once\n   */\n  const debugAllAggregatedCounts = () => {\n    console.log('[DEBUG COUNTS] All aggregated counts:', Array.from(aggregatedTaskCountByGroupId.value.entries()))\n    console.log('[DEBUG GROUPS] All groups:', _rawGroups.value.map(g => ({\n      id: g.id,\n      name: g.name,\n      parentGroupId: g.parentGroupId\n    })))\n  }\n\n  const getTasksInSection = (groupId: string, tasks?: Task[]): Task[] => {\n    // Determine source tasks: provided tasks > taskStore.tasks > empty\n    const sourceTasks = tasks || (taskStore && taskStore.tasks ? taskStore.tasks : [])\n\n    // SAFETY: Use _rawGroups to find any group including hidden ones\n    const group = _rawGroups.value.find(g => g.id === groupId)\n    if (!group) return []\n\n    // Get ABSOLUTE group position (handles nested groups correctly)\n    const groupAbsolutePos = getGroupAbsolutePosition(groupId, _rawGroups.value)\n\n    // Direct tasks in this group (using CENTER-based spatial containment with ABSOLUTE bounds)\n    const containerBounds: ContainerBounds = {\n      position: groupAbsolutePos,\n      width: group.position.width,\n      height: group.position.height\n    }\n    return sourceTasks.filter((t: Task) => {\n      if (t.canvasPosition) {\n        return isNodeCompletelyInside({ position: t.canvasPosition }, containerBounds)\n      }\n      return false\n    })\n  }\n\n  const taskMatchesSection = (task: Task, sectionId: string): boolean => {\n    // SAFETY: Use _rawGroups to find any group including hidden ones\n    const group = _rawGroups.value.find(g => g.id === sectionId)\n    if (!group || !task.canvasPosition) return false\n\n    // Get ABSOLUTE group position (handles nested groups correctly)\n    const groupAbsolutePos = getGroupAbsolutePosition(sectionId, _rawGroups.value)\n\n    // Use CENTER-based spatial containment with ABSOLUTE bounds\n    const containerBounds: ContainerBounds = {\n      position: groupAbsolutePos,\n      width: group.position.width,\n      height: group.position.height\n    }\n    return isNodeCompletelyInside({ position: task.canvasPosition }, containerBounds)\n  }\n\n  const calculateContentBounds = (tasks: Task[]) => {\n    // Initialize bounds\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n    let hasContent = false\n\n    // Process Tasks\n    if (tasks && Array.isArray(tasks)) {\n      tasks.forEach(t => {\n        if (t && t.canvasPosition && !t.isInInbox) {\n          const x = Number(t.canvasPosition.x)\n          const y = Number(t.canvasPosition.y)\n\n          if (!isNaN(x) && !isNaN(y)) {\n            hasContent = true\n            minX = Math.min(minX, x)\n            minY = Math.min(minY, y)\n            maxX = Math.max(maxX, x + 200) // Approx width\n            maxY = Math.max(maxY, y + 100) // Approx height\n          }\n        }\n      })\n    }\n\n    // Process Groups - use visibleGroups for display calculations\n    if (visibleGroups.value && Array.isArray(visibleGroups.value)) {\n      visibleGroups.value.forEach(g => {\n        if (g && g.isVisible && g.position) {\n          const x = Number(g.position.x)\n          const y = Number(g.position.y)\n          const w = Number(g.position.width) || 300\n          const h = Number(g.position.height) || 300\n\n          if (!isNaN(x) && !isNaN(y)) {\n            hasContent = true\n            minX = Math.min(minX, x)\n            minY = Math.min(minY, y)\n            maxX = Math.max(maxX, x + w)\n            maxY = Math.max(maxY, y + h)\n          }\n        }\n      })\n    }\n\n    if (!hasContent) return { x: 0, y: 0, width: 0, height: 0 }\n\n    // Final sanity check\n    if (minX === Infinity || minY === Infinity) return { x: 0, y: 0, width: 0, height: 0 }\n\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  }\n\n  // NOTE: Optimized Task Sync - matching logic from useCanvasSync\n  const syncTasksToCanvas = (tasks: Task[]) => {\n    try {\n      // 1. Filter tasks present on canvas\n      const onCanvasTasks = tasks.filter(t => !t.isInInbox && t.canvasPosition)\n\n      // 2. Identify existing nodes to preserve references (crucial for performance)\n      const existingTaskNodes = new Map(\n        nodes.value\n          .filter(n => n.type === 'taskNode' || n.type === 'task')\n          .map(n => [n.id, n])\n      )\n\n      // 3. Map to VueFlow Nodes using diff/patch strategy\n      const updatedTaskNodes = onCanvasTasks.map(t => {\n        const existingNode = existingTaskNodes.get(t.id)\n\n        // BUG-022 FIX: Comprehensive field comparison to detect all relevant changes\n        if (existingNode) {\n          const oldTask = existingNode.data?.task\n          const positionUnchanged =\n            existingNode.position.x === t.canvasPosition?.x &&\n            existingNode.position.y === t.canvasPosition?.y\n\n          // Check ALL fields that affect visual display (matches useCanvasSync.ts pattern)\n          const dataUnchanged = oldTask &&\n            oldTask.status === t.status &&\n            oldTask.priority === t.priority &&\n            oldTask.title === t.title &&\n            oldTask.updatedAt === t.updatedAt &&\n            oldTask.progress === t.progress &&\n            oldTask.dueDate === t.dueDate &&\n            oldTask.estimatedDuration === t.estimatedDuration\n\n          if (positionUnchanged && dataUnchanged) {\n            existingTaskNodes.delete(t.id) // Remove from deletion set\n            return existingNode\n          }\n        }\n\n        // Create new node object but try to preserve internal object shape for V8\n        const newNode = {\n          id: t.id,\n          type: 'taskNode', // Use the optimized component\n          position: (t.canvasPosition && !Number.isNaN(t.canvasPosition.x) && !Number.isNaN(t.canvasPosition.y))\n            ? { ...t.canvasPosition }\n            : { x: 0, y: 0 },\n          data: { task: t }, // Store full task reference\n          draggable: true,\n          connectable: true,\n          selectable: true,\n          zIndex: 10\n        }\n\n        if (existingNode) existingTaskNodes.delete(t.id)\n        return newNode\n      })\n\n      // 4. Merge: Keep non-task nodes + updated task nodes\n      // Filter out task nodes that were NOT in the new list (implicitly handled by rebuilding list)\n      const otherNodes = nodes.value.filter(n => n.type !== 'task' && n.type !== 'taskNode')\n\n      // Update store value - Vue will only diff changed object references\n      nodes.value = [...otherNodes, ...updatedTaskNodes]\n\n    } catch (e) {\n      console.error('Sync tasks to canvas failed:', e)\n    }\n  }\n\n  // Initialize\n  const initialize = async () => {\n    // Load groups (removed duplicate call)\n    await loadFromDatabase()\n\n    // Viewport is now loaded synchronously during store creation\n    // No need to load it here again\n\n    // TASK-131 FIX: DISABLED - This competing watcher caused position resets\n    // The deep:true watcher fired on ANY task property change and overwrote locked positions.\n    // useCanvasSync.ts in CanvasView.vue handles all sync with proper position locking.\n    // Keeping taskStore reference for other operations.\n    import('./tasks').then(({ useTaskStore }) => {\n      taskStore = useTaskStore()\n      // REMOVED: watch(() => taskStore.tasks, ...) - competed with useCanvasSync.ts\n      // This was the root cause of BUG-020 regression where task positions reset\n    }).catch((err) => {\n      console.error('[ASYNC-ERROR] canvas.ts: Failed to import tasks store', err)\n    })\n  }\n\n  // Auto-init\n  initialize()\n\n  // TASK-142 FIX: Watch for auth state changes to reload groups from Supabase\n  // This fixes the race condition where canvas loads before auth is ready\n  import('@/stores/auth').then(({ useAuthStore }) => {\n    try {\n      const authStore = useAuthStore()\n\n      // Watch for auth becoming ready\n      watch(\n        () => [authStore.isInitialized, authStore.isAuthenticated],\n        async ([isInitialized, isAuthenticated], [, wasAuthenticated]) => {\n          // Only reload when:\n          // 1. Auth just became initialized (first load)\n          // 2. AND user is authenticated\n          // 3. AND groups were loaded from Guest Mode (localStorage)\n          if (isInitialized && isAuthenticated && !wasAuthenticated) {\n\n            // Force reload from Supabase (not localStorage)\n            try {\n              const loadedGroups = await fetchGroups()\n\n              // BUG-169 FIX: Safety guard - don't overwrite existing groups with empty array\n              // during the first 10 seconds of the session (prevents auth race conditions)\n              if (loadedGroups.length === 0 && _rawGroups.value.length > 0) {\n                const sessionStart = typeof window !== 'undefined' ? (window as any).PomoFlowSessionStart || 0 : 0\n                const timeSinceSessionStart = Date.now() - sessionStart\n\n                if (timeSinceSessionStart < 10000) {\n                  console.warn(` [AUTH-WATCHER] BLOCKED empty overwrite - ${_rawGroups.value.length} existing groups would be lost (session ${timeSinceSessionStart}ms old)`)\n                  return\n                }\n\n                console.warn(` [AUTH-WATCHER] Supabase returned 0 groups but ${_rawGroups.value.length} exist locally - proceeding with empty`)\n              }\n\n              // Break any parent cycles before loading\n              _rawGroups.value = breakGroupCycles(loadedGroups)\n\n              // Populate nodeVersionMap with loaded group versions for optimistic locking\n              // Defensive: ensure nodeVersionMap.value is a valid Map\n              if (!nodeVersionMap.value || !(nodeVersionMap.value instanceof Map)) {\n                nodeVersionMap.value = new Map()\n              }\n\n              // Always initialize version entries (default to 0 if positionVersion is undefined)\n              loadedGroups.forEach(g => {\n                nodeVersionMap.value.set(g.id, g.positionVersion ?? 0)\n              })\n\n              if (loadedGroups.length > 0) {\n                console.log(` [AUTH-WATCHER] Reloaded ${loadedGroups.length} groups, ${nodeVersionMap.value.size} version entries`)\n              }\n            } catch (e) {\n              console.error(' [CANVAS] Failed to reload groups after auth:', e)\n            }\n          }\n        },\n        { immediate: false }\n      )\n    } catch (err) {\n      console.error('[ASYNC-ERROR] canvas.ts: Failed to setup auth watcher', err)\n    }\n  }).catch((err) => {\n    console.error('[ASYNC-ERROR] canvas.ts: Failed to import auth store', err)\n  })\n\n  // === DEV: Watch for duplicate groups in store (AUTHORITATIVE) ===\n  // Uses assertNoDuplicateIds for consistent detection across layers\n  if (import.meta.env.DEV) {\n    watch(_rawGroups, (newGroups) => {\n      const checkResult = assertNoDuplicateIds(newGroups, '_rawGroups store')\n\n      if (checkResult.hasDuplicates) {\n        // Get more details about the duplicate groups\n        const duplicateIds = checkResult.duplicates.map(d => d.id)\n        const duplicateGroups = newGroups\n          .filter(g => duplicateIds.includes(g.id))\n          .slice(0, 5)\n          .map(g => ({ id: g.id.slice(0, 8), name: g.name?.slice(0, 20) }))\n\n        console.error('[GROUP-STORE-DUPLICATE-DETECTED]', {\n          duplicates: checkResult.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n          totalCount: checkResult.totalCount,\n          uniqueIdCount: checkResult.uniqueIdCount,\n          duplicateGroups,\n          snapshotSize: newGroups.length\n        })\n      }\n    }, { deep: true }) // TASK-260: Changed to deep: true to catch mutations, not just array replacement\n  }\n\n  // Aliases for compatibility\n  // export type CanvasSection = CanvasGroup // Moved to top level\n\n  const setSelectedNodes = (ids: string[]) => {\n    selectedNodeIds.value = ids\n  }\n\n  const toggleNodeSelection = (id: string) => {\n    // Set flag to prevent Vue Flow's @selection-change from overriding this manual toggle\n    skipNextSelectionChange.value = true\n\n    const index = selectedNodeIds.value.indexOf(id)\n    if (index === -1) {\n      selectedNodeIds.value.push(id)\n    } else {\n      selectedNodeIds.value.splice(index, 1)\n    }\n  }\n\n  // Undo alias (fallback to regular update for now)\n  const updateSectionWithUndo = updateGroup\n\n  // Missing stubs to satisfy vue-tsc\n  const getMatchingTaskCount = (_groupId: string, _tasks?: any[]): number => 0\n  const toggleSectionVisibility = async (_groupId: string) => { /* ... */ }\n  const toggleSectionCollapse = async (groupId: string) => {\n    // SAFETY: Use _rawGroups to find any group including hidden ones\n    const g = _rawGroups.value.find(g => g.id === groupId)\n    if (g) await updateGroup(groupId, { isCollapsed: !g.isCollapsed })\n  }\n  const clearSelection = () => { selectedNodeIds.value = [] }\n  // =========================================================================\n  // GEOMETRY WRITE POLICY - CONTROLLED SYNC TRIGGERING (TASK-240 Phase 2.5)\n  // =========================================================================\n  // requestSync requires a source to prevent automated sync loops.\n  // ONLY user-action sources trigger actual sync:\n  //   - 'user:drag-drop': After drag operations\n  //   - 'user:create': After task/group creation\n  //   - 'user:delete': After task/group deletion\n  //   - 'user:resize': After group resize\n  //   - 'user:manual': Explicit user action\n  //\n  // BLOCKED sources (do not trigger sync):\n  //   - 'smart-group': Smart group metadata changes\n  //   - 'watcher': Store watchers\n  //   - 'reconcile': One-time reconciliation\n  //   - 'auto': Automatic operations\n  // =========================================================================\n  const USER_ACTION_SOURCES = [\n    'user:drag-drop', 'user:create', 'user:delete', 'user:undo', 'user:redo',\n    'user:resize', 'user:connect', 'user:context-menu', 'user:manual'\n  ] as const\n  type SyncSource = typeof USER_ACTION_SOURCES[number] | 'smart-group' | 'watcher' | 'reconcile' | 'auto' | 'unknown'\n\n  const requestSync = async (source: SyncSource = 'unknown') => {\n    const isUserAction = USER_ACTION_SOURCES.includes(source as typeof USER_ACTION_SOURCES[number])\n    if (isUserAction) {\n      syncTrigger.value++\n      console.log(` [CANVAS-STORE] Sync accepted from ${source} - syncTrigger:`, syncTrigger.value)\n    } else {\n      console.log(` [CANVAS-STORE] Sync blocked from ${source} (not a user action)`)\n    }\n  }\n  // Restored Selection methods\n  const setSelectionMode = (mode: string) => { selectionMode.value = mode }\n  const startSelection = (x: number, y: number) => { isSelecting.value = true; selectionRect.value = { x, y, width: 0, height: 0 } }\n  const updateSelection = (x: number, y: number) => {\n    if (selectionRect.value) {\n      selectionRect.value.width = x - selectionRect.value.x\n      selectionRect.value.height = y - selectionRect.value.y\n    }\n  }\n  const endSelection = () => { isSelecting.value = false; selectionRect.value = null }\n  const selectNodesInRect = (_rect: any) => { /* ... */ }\n  const toggleMultiSelectMode = () => { multiSelectMode.value = !multiSelectMode.value }\n\n  const togglePriorityIndicator = () => { showPriorityIndicator.value = !showPriorityIndicator.value }\n  const toggleStatusBadge = () => { showStatusBadge.value = !showStatusBadge.value }\n  const toggleDurationBadge = () => { showDurationBadge.value = !showDurationBadge.value }\n  const toggleScheduleBadge = () => { showScheduleBadge.value = !showScheduleBadge.value }\n  const setActiveSection = (id: string | null) => { activeSectionId.value = id }\n  const toggleConnectMode = () => { connectMode.value = !connectMode.value }\n  const startConnection = (nodeId: string) => { connectingFrom.value = nodeId; connectMode.value = true }\n  const clearConnection = () => { connectingFrom.value = null; connectMode.value = false }\n  const createSection = createGroup\n  const updateSection = updateGroup\n  const deleteSection = deleteGroup\n\n  return {\n    viewport,\n    zoomConfig,\n    // SAFETY: Export visibleGroups as 'groups' - this is the safe default for components\n    // Use _rawGroups only for internal operations (load, save, sync, mutations)\n    groups: visibleGroups,\n    _rawGroups,\n    activeGroupId,\n    showGroupGuides,\n    snapToGroups,\n    nodes,\n    edges,\n    selectedNodeIds,\n    skipNextSelectionChange, // Flag to prevent Vue Flow overriding manual Ctrl+click\n    allowBulkDeselect, // TASK-262: Flag to allow bulk deselection only from pane click\n    connectMode,\n    connectingFrom,\n\n    // Added State\n    multiSelectMode,\n    selectionMode,\n    selectionRect,\n    isSelecting,\n    showPriorityIndicator,\n    showStatusBadge,\n    showDurationBadge,\n    showScheduleBadge,\n    activeSectionId,\n\n    // Actions\n    loadFromDatabase,\n    createGroup,\n    updateGroup,\n    deleteGroup,\n    setGroups,\n    patchGroups,\n    setViewport,\n    loadSavedViewport,\n    getTaskCountInGroupRecursive,\n    recalculateAllTaskCounts,\n    taskCountByGroupId,      // Reactive computed: Map<groupId, count> derived from task.parentId\n    getTaskCountForGroup,    // Helper: get count for a specific group (direct only)\n    getAllDescendantGroupIds, // Helper: get rootId + all nested child group IDs\n    aggregatedTaskCountByGroupId, // Reactive computed: Map<groupId, aggregatedCount> (includes descendants)\n    getAggregatedTaskCountForGroup, // Helper: get aggregated count for a group (includes descendants)\n    bumpTaskParentVersion,   // Call this when task.parentId changes to trigger count recomputation\n    debugGroupHierarchy, // DEBUG: Log group hierarchy\n    debugAllAggregatedCounts, // DEBUG: Log all aggregated counts\n    calculateContentBounds,\n    setSelectedNodes,\n    getTasksInSection,\n    taskMatchesSection,\n    toggleNodeSelection,\n    togglePowerMode: async (groupId: string, active?: boolean) => {\n      const g = _rawGroups.value.find(g => g.id === groupId)\n      const newState = active !== undefined ? active : !(g?.isPowerMode)\n      await updateGroup(groupId, { isPowerMode: newState })\n    },\n    updateSectionWithUndo,\n\n    // Added Actions\n    getMatchingTaskCount,\n    toggleSectionVisibility,\n    toggleSectionCollapse,\n    clearSelection,\n    requestSync,\n    isDragging,\n    setSelectionMode,\n    startSelection,\n    updateSelection,\n    endSelection,\n    selectNodesInRect,\n    toggleMultiSelectMode,\n    togglePriorityIndicator,\n    toggleStatusBadge,\n    toggleDurationBadge,\n    toggleScheduleBadge,\n    setActiveSection,\n    toggleConnectMode,\n    startConnection,\n    clearConnection,\n    syncTrigger,\n    nodeVersionMap,\n    syncTasksToCanvas,\n\n    // Aliases - sections is same as groups (visibleGroups filtered)\n    sections: visibleGroups,\n    _rawSections: _rawGroups,\n    createSection,\n    updateSection,\n    deleteSection,\n  }\n})\n\n// HMR support\nif (import.meta.hot) {\n  import.meta.hot.accept(acceptHMRUpdate(useCanvasStore, import.meta.hot))\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas/canvasInteraction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas/canvasUi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas/contextMenus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas/modals.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3671,3674],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3671,3674],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia'\nimport { ref } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport type { CanvasSection } from '@/stores/canvas/types'\n\nexport const useCanvasModalsStore = defineStore('canvasModals', () => {\n    // Task Edit Modal\n    const isEditModalOpen = ref(false)\n    const selectedTask = ref<Task | null>(null)\n\n    // Quick Task Create Modal\n    const isQuickTaskCreateOpen = ref(false)\n    const quickTaskPosition = ref<{ x: number; y: number; parentId?: string }>({ x: 0, y: 0 })\n\n    // Batch Edit Modal\n    const isBatchEditModalOpen = ref(false)\n    const batchEditTaskIds = ref<string[]>([])\n\n    // Section Settings Modal\n    const isSectionSettingsOpen = ref(false)\n    const editingSection = ref<CanvasSection | null>(null)\n\n    // Group Modal (Create/Edit)\n    const isGroupModalOpen = ref(false)\n    const selectedGroup = ref<CanvasSection | null>(null)\n    const groupModalPosition = ref({ x: 100, y: 100 })\n\n    // Group Edit Modal\n    const isGroupEditModalOpen = ref(false)\n    const selectedSectionForEdit = ref<CanvasSection | null>(null)\n\n    // Delete Group Confirmation\n    const isDeleteGroupModalOpen = ref(false)\n    const groupPendingDelete = ref<CanvasSection | null>(null)\n    const deleteGroupMessage = ref('')\n\n    // Bulk Delete Confirmation\n    const isBulkDeleteModalOpen = ref(false)\n    const bulkDeleteTitle = ref('')\n    const bulkDeleteMessage = ref('')\n    const bulkDeleteItems = ref<{ id: string; name: string; type: 'task' | 'section' }[]>([])\n    const bulkDeleteIsPermanent = ref(false)\n\n    // Actions\n    const openEditModal = (task: Task) => {\n        selectedTask.value = task\n        isEditModalOpen.value = true\n    }\n    const closeEditModal = () => {\n        isEditModalOpen.value = false\n        selectedTask.value = null\n    }\n\n    const openQuickTaskCreate = (position: { x: number; y: number }) => {\n        quickTaskPosition.value = position\n        isQuickTaskCreateOpen.value = true\n    }\n    const closeQuickTaskCreate = () => {\n        isQuickTaskCreateOpen.value = false\n    }\n\n    const openBatchEditModal = (taskIds: string[]) => {\n        batchEditTaskIds.value = taskIds\n        isBatchEditModalOpen.value = true\n    }\n    const closeBatchEditModal = () => {\n        isBatchEditModalOpen.value = false\n        batchEditTaskIds.value = []\n    }\n\n    const openSectionSettings = (section: CanvasSection) => {\n        editingSection.value = section\n        isSectionSettingsOpen.value = true\n    }\n    const closeSectionSettings = () => {\n        isSectionSettingsOpen.value = false\n        editingSection.value = null\n    }\n\n    const openGroupModal = (group: CanvasSection | null, position: { x: number; y: number }) => {\n        selectedGroup.value = group\n        groupModalPosition.value = position\n        isGroupModalOpen.value = true\n    }\n    const closeGroupModal = () => {\n        isGroupModalOpen.value = false\n        selectedGroup.value = null\n    }\n\n    const openGroupEditModal = (section: CanvasSection) => {\n        selectedSectionForEdit.value = section\n        isGroupEditModalOpen.value = true\n    }\n    const closeGroupEditModal = () => {\n        isGroupEditModalOpen.value = false\n        selectedSectionForEdit.value = null\n    }\n\n    const openDeleteGroupModal = (group: CanvasSection, message: string) => {\n        groupPendingDelete.value = group\n        deleteGroupMessage.value = message\n        isDeleteGroupModalOpen.value = true\n    }\n    const closeDeleteGroupModal = () => {\n        isDeleteGroupModalOpen.value = false\n        groupPendingDelete.value = null\n    }\n\n    const openBulkDeleteModal = (title: string, message: string, items: any[], isPermanent: boolean) => {\n        bulkDeleteTitle.value = title\n        bulkDeleteMessage.value = message\n        bulkDeleteItems.value = items\n        bulkDeleteIsPermanent.value = isPermanent\n        isBulkDeleteModalOpen.value = true\n    }\n    const closeBulkDeleteModal = () => {\n        isBulkDeleteModalOpen.value = false\n    }\n\n    return {\n        isEditModalOpen, selectedTask,\n        isQuickTaskCreateOpen, quickTaskPosition,\n        isBatchEditModalOpen, batchEditTaskIds,\n        isSectionSettingsOpen, editingSection,\n        isGroupModalOpen, selectedGroup, groupModalPosition,\n        isGroupEditModalOpen, selectedSectionForEdit,\n        isDeleteGroupModalOpen, groupPendingDelete, deleteGroupMessage,\n        isBulkDeleteModalOpen, bulkDeleteTitle, bulkDeleteMessage, bulkDeleteItems, bulkDeleteIsPermanent,\n\n        openEditModal, closeEditModal,\n        openQuickTaskCreate, closeQuickTaskCreate,\n        openBatchEditModal, closeBatchEditModal,\n        openSectionSettings, closeSectionSettings,\n        openGroupModal, closeGroupModal,\n        openGroupEditModal, closeGroupEditModal,\n        openDeleteGroupModal, closeDeleteGroupModal,\n        openBulkDeleteModal, closeBulkDeleteModal\n    }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas/useSelection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/canvas/useZoom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/notifications.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":359,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":359,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Store\n * Centralized management of task reminders and notifications\n */\n\nimport { defineStore } from 'pinia'\nimport { ref, computed, watch } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { errorHandler, ErrorSeverity, ErrorCategory } from '@/utils/errorHandler'\nimport type {\n  ScheduledNotification,\n  NotificationPreferences,\n  RecurringTaskInstance as _RecurringTaskInstance\n} from '@/types/recurrence'\nimport { useTaskStore } from './tasks'\nimport { useAuthStore } from './auth'\n\nexport const useNotificationStore = defineStore('notifications', () => {\n  // Database composable\n  const supabaseDb = useSupabaseDatabase()\n  const taskStore = useTaskStore()\n  const authStore = useAuthStore()\n\n  // State\n  // SAFETY: Named _rawNotifications to discourage direct access - use activeNotifications (exported as 'scheduledNotifications') instead\n  const _rawNotifications = ref<ScheduledNotification[]>([])\n  const isPermissionGranted = ref(false)\n  const isSchedulingActive = ref(false)\n  const schedulingInterval = ref<NodeJS.Timeout | null>(null)\n  const defaultPreferences = ref<NotificationPreferences>({\n    taskId: 'default',\n    isEnabled: true,\n    reminderTimes: [15, 60, 1440], // 15min, 1hr, 1day before\n    soundEnabled: true,\n    vibrationEnabled: true,\n    notificationChannels: {\n      browser: true,\n      mobile: true\n    },\n    doNotDisturb: {\n      startHour: 22,\n      endHour: 8,\n      enabled: true\n    },\n    snoozeDuration: 10 // 10 minutes\n  })\n\n  // Computed\n  const activeNotifications = computed(() =>\n    Array.isArray(_rawNotifications.value)\n      ? _rawNotifications.value.filter(n => !n.isShown && !n.isDismissed)\n      : []\n  )\n\n  const pendingNotifications = computed(() =>\n    Array.isArray(_rawNotifications.value)\n      ? _rawNotifications.value.filter(n => !n.isShown && n.scheduledTime <= new Date())\n      : []\n  )\n\n  const snoozedNotifications = computed(() =>\n    Array.isArray(_rawNotifications.value)\n      ? _rawNotifications.value.filter(n => n.snoozedUntil && n.snoozedUntil > new Date())\n      : []\n  )\n\n  /**\n   * Initialize notification system\n   */\n  const initializeNotifications = async () => {\n    await loadScheduledNotifications()\n    await checkNotificationPermission()\n    startSchedulingService()\n  }\n\n  /**\n   * Load scheduled notifications from database\n   */\n  const loadScheduledNotifications = async () => {\n    try {\n      // Check if user is authenticated before loading\n      if (!authStore.user?.id) {\n        errorHandler.report({\n          severity: ErrorSeverity.INFO,\n          category: ErrorCategory.DATABASE,\n          message: 'User not authenticated, skipping notification load',\n          context: { operation: 'loadScheduledNotifications' },\n          showNotification: false\n        })\n        return\n      }\n\n      const saved = await supabaseDb.fetchNotifications()\n      if (saved && saved.length > 0) {\n        _rawNotifications.value = saved\n        console.log(` Loaded ${saved.length} notifications from Supabase`)\n      }\n    } catch (error) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.DATABASE,\n        message: 'Error loading notifications',\n        error: error as Error,\n        context: { operation: 'loadScheduledNotifications' },\n        showNotification: false // Don't fail the entire initialization\n      })\n    }\n  }\n\n  /**\n   * Check current notification permission status\n   * Note: Does NOT request permission - must be done in user event handler\n   */\n  const checkNotificationPermission = async (): Promise<boolean> => {\n    if (!('Notification' in window)) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.COMPONENT,\n        message: 'This browser does not support notifications',\n        context: { operation: 'checkNotificationPermission' },\n        showNotification: false\n      })\n      isPermissionGranted.value = false\n      return false\n    }\n\n    if (Notification.permission === 'granted') {\n      isPermissionGranted.value = true\n      return true\n    }\n\n    isPermissionGranted.value = (Notification.permission as NotificationPermission) === 'granted'\n    return isPermissionGranted.value\n  }\n\n  /**\n   * Request notification permission (must be called from user event handler)\n   */\n  const requestNotificationPermission = async (): Promise<boolean> => {\n    if (!('Notification' in window)) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.COMPONENT,\n        message: 'This browser does not support notifications',\n        context: { operation: 'requestNotificationPermission' },\n        showNotification: false\n      })\n      return false\n    }\n\n    if (Notification.permission === 'granted') {\n      isPermissionGranted.value = true\n      return true\n    }\n\n    if (Notification.permission !== 'denied') {\n      try {\n        const permission = await Notification.requestPermission()\n        isPermissionGranted.value = permission === 'granted'\n        return isPermissionGranted.value\n      } catch (error) {\n        errorHandler.report({\n          severity: ErrorSeverity.WARNING,\n          category: ErrorCategory.COMPONENT,\n          message: 'Notification permission request failed',\n          error: error as Error,\n          context: { operation: 'requestNotificationPermission' },\n          showNotification: false\n        })\n        isPermissionGranted.value = false\n        return false\n      }\n    }\n\n    isPermissionGranted.value = false\n    return false\n  }\n\n  /**\n   * Start the background scheduling service\n   */\n  const startSchedulingService = () => {\n    if (isSchedulingActive.value) return\n\n    isSchedulingActive.value = true\n    schedulingInterval.value = setInterval(() => {\n      checkAndShowNotifications()\n      checkAndScheduleTaskNotifications()\n    }, 60000) // Check every minute\n  }\n\n  /**\n   * Stop the scheduling service\n   */\n  const stopSchedulingService = () => {\n    if (schedulingInterval.value) {\n      clearInterval(schedulingInterval.value)\n      schedulingInterval.value = null\n    }\n    isSchedulingActive.value = false\n  }\n\n  /**\n   * Check for pending notifications and show them\n   */\n  const checkAndShowNotifications = async () => {\n    const now = new Date()\n\n    // CRITICAL FIX: Ensure _rawNotifications.value is an array\n    if (!Array.isArray(_rawNotifications.value)) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.STATE,\n        message: '_rawNotifications.value is not an array, resetting to empty array',\n        context: { operation: 'checkAndShowNotifications', type: typeof _rawNotifications.value },\n        showNotification: false\n      })\n      _rawNotifications.value = []\n    }\n\n    const readyNotifications = _rawNotifications.value.filter(n =>\n      !n.isShown &&\n      !n.isDismissed &&\n      !n.snoozedUntil &&\n      n.scheduledTime <= now\n    )\n\n    for (const notification of readyNotifications) {\n      if (isInDoNotDisturbHours(now)) {\n        continue // Skip during DND hours\n      }\n\n      await showNotification(notification)\n      notification.isShown = true\n    }\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Check if current time is in Do Not Disturb hours\n   */\n  const isInDoNotDisturbHours = (date: Date): boolean => {\n    const dnd = defaultPreferences.value.doNotDisturb\n    if (!dnd?.enabled) return false\n\n    const currentHour = date.getHours()\n\n    if (dnd.startHour > dnd.endHour) {\n      // Overnight DND (e.g., 22:00 to 08:00)\n      return currentHour >= dnd.startHour || currentHour < dnd.endHour\n    } else {\n      // Same day DND (e.g., 01:00 to 06:00)\n      return currentHour >= dnd.startHour && currentHour < dnd.endHour\n    }\n  }\n\n  /**\n   * Show a browser notification\n   */\n  const showNotification = async (notification: ScheduledNotification) => {\n    if (!isPermissionGranted.value) {\n      await checkNotificationPermission()\n    }\n\n    if (!isPermissionGranted.value) return\n\n    try {\n      const browserNotification = new Notification(notification.title, {\n        body: notification.body,\n        icon: '/favicon.ico',\n        badge: '/favicon.ico',\n        tag: notification.id,\n        requireInteraction: true\n      } as NotificationOptions)\n\n      browserNotification.onclick = () => {\n        browserNotification.close()\n        // Focus the window and navigate to the task\n        window.focus()\n        // NOTE: Task navigation requires integration with view routing system\n      }\n\n      browserNotification.onclose = () => {\n        notification.isDismissed = true\n      }\n\n    } catch (error) {\n      errorHandler.report({\n        severity: ErrorSeverity.ERROR,\n        category: ErrorCategory.COMPONENT,\n        message: 'Error showing browser notification',\n        error: error as Error,\n        context: { operation: 'showNotification', notificationId: notification.id },\n        showNotification: false // Don't show a notification about failed notification\n      })\n    }\n  }\n\n  /**\n   * Schedule notifications for a task\n   */\n  const scheduleTaskNotifications = async (\n    taskId: string,\n    taskTitle: string,\n    dueDate: string,\n    dueTime?: string,\n    preferences?: NotificationPreferences\n  ) => {\n    const prefs = preferences || defaultPreferences.value\n    if (!prefs.isEnabled) return\n\n    // Remove existing notifications for this task\n    await removeTaskNotifications(taskId)\n\n    const dueDateTime = new Date(`${dueDate} ${dueTime || '09:00'}`)\n    const reminderTimes = prefs.reminderTimes || []\n\n    for (const minutesBefore of reminderTimes) {\n      const notificationTime = new Date(dueDateTime.getTime() - minutesBefore * 60000)\n\n      // Only schedule if it's in the future\n      if (notificationTime > new Date()) {\n        const notification: ScheduledNotification = {\n          id: `${taskId}-reminder-${minutesBefore}`,\n          taskId,\n          title: `Task Reminder: ${taskTitle}`,\n          body: getReminderMessage(minutesBefore, dueDate, dueTime),\n          scheduledTime: notificationTime,\n          isShown: false,\n          isDismissed: false,\n          createdAt: new Date()\n        }\n\n        _rawNotifications.value.push(notification)\n      }\n    }\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Schedule notifications for recurring task instances\n   */\n  const scheduleRecurringTaskNotifications = async (taskId: string) => {\n    // CRITICAL FIX: Ensure taskStore.tasks is an array before calling .find()\n    const task = Array.isArray(taskStore.tasks)\n      ? taskStore.tasks.find(t => t.id === taskId)\n      : undefined\n    if (!task?.recurrence?.isEnabled || !task.notificationPreferences?.enabled) return\n\n    const prefs = task.notificationPreferences\n    const instances = task.recurrence.generatedInstances || []\n\n    for (const instance of instances) {\n      if ((instance as { isSkipped?: boolean }).isSkipped) continue\n\n      await scheduleTaskNotifications(\n        instance.id!,\n        task.title,\n        instance.scheduledDate,\n        instance.scheduledTime,\n        prefs as unknown as NotificationPreferences\n      )\n    }\n  }\n\n  /**\n   * Get reminder message based on time before task\n   */\n  const getReminderMessage = (minutesBefore: number, _dueDate: string, _dueTime?: string): string => {\n    if (minutesBefore < 60) {\n      return `Task due in ${minutesBefore} minute${minutesBefore > 1 ? 's' : ''}`\n    } else if (minutesBefore < 1440) {\n      const hours = Math.floor(minutesBefore / 60)\n      return `Task due in ${hours} hour${hours > 1 ? 's' : ''}`\n    } else {\n      const days = Math.floor(minutesBefore / 1440)\n      return `Task due in ${days} day${days > 1 ? 's' : ''}`\n    }\n  }\n\n  /**\n   * Remove all notifications for a task\n   */\n  const removeTaskNotifications = async (taskId: string) => {\n    if (Array.isArray(_rawNotifications.value)) {\n      const toDelete = _rawNotifications.value.filter(n => n.taskId === taskId)\n      _rawNotifications.value = _rawNotifications.value.filter(n => n.taskId !== taskId)\n\n      // Delete from Supabase\n      for (const n of toDelete) {\n        await supabaseDb.deleteNotification(n.id)\n      }\n    } else {\n      _rawNotifications.value = []\n    }\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Snooze a notification\n   */\n  const snoozeNotification = async (notificationId: string) => {\n    const notification = _rawNotifications.value.find(n => n.id === notificationId)\n    if (!notification) return\n\n    const snoozeDuration = defaultPreferences.value.snoozeDuration || 10\n    notification.snoozedUntil = new Date(Date.now() + snoozeDuration * 60000)\n    notification.isShown = false\n    notification.isDismissed = false\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Dismiss a notification\n   */\n  const dismissNotification = async (notificationId: string) => {\n    const notification = _rawNotifications.value.find(n => n.id === notificationId)\n    if (!notification) return\n\n    notification.isDismissed = true\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Check and schedule notifications for all tasks\n   */\n  const checkAndScheduleTaskNotifications = async () => {\n    // CRITICAL FIX: Ensure taskStore.tasks is an array before calling .filter()\n    const tasks = Array.isArray(taskStore.tasks)\n      ? taskStore.tasks.filter(t =>\n        t.dueDate &&\n        t.notificationPreferences?.enabled &&\n        new Date(t.dueDate) > new Date()\n      )\n      : []\n\n    for (const task of tasks) {\n      // Check if notifications are already scheduled for this task\n      const hasNotifications = _rawNotifications.value.some(n => n.taskId === task.id)\n\n      if (!hasNotifications) {\n        await scheduleTaskNotifications(\n          task.id,\n          task.title,\n          task.dueDate,\n          task.dueTime,\n          task.notificationPreferences as unknown as NotificationPreferences\n        )\n      }\n\n      // Schedule recurring notifications if applicable\n      if (task.recurrence?.isEnabled) {\n        await scheduleRecurringTaskNotifications(task.id)\n      }\n    }\n  }\n\n  /**\n   * Save scheduled notifications to database\n   */\n  const saveScheduledNotifications = async () => {\n    try {\n      // Check if user is authenticated before saving\n      if (!authStore.user?.id) return\n      await supabaseDb.saveNotifications(_rawNotifications.value)\n    } catch (error) {\n      errorHandler.report({\n        severity: ErrorSeverity.WARNING,\n        category: ErrorCategory.DATABASE,\n        message: 'Error saving notifications to database',\n        error: error as Error,\n        context: { operation: 'saveScheduledNotifications', count: _rawNotifications.value?.length },\n        showNotification: false\n      })\n    }\n  }\n\n  // BUG-025 FIX: Auto-save notifications when they change\n  // This eliminates the need for manual saveScheduledNotifications() calls\n  let notificationSaveTimer: ReturnType<typeof setTimeout> | null = null\n  watch(activeNotifications, () => {\n    if (notificationSaveTimer) clearTimeout(notificationSaveTimer)\n    notificationSaveTimer = setTimeout(async () => {\n      await saveScheduledNotifications()\n      console.log(' [SUPABASE] Notifications auto-saved (1s debounce)')\n    }, 1000) // Refined: 1s debounce\n  }, { deep: true })\n\n  /**\n   * Clean up old notifications (older than 7 days)\n   */\n  const cleanupOldNotifications = async () => {\n    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)\n\n    if (Array.isArray(_rawNotifications.value)) {\n      _rawNotifications.value = _rawNotifications.value.filter(n =>\n        n.createdAt > sevenDaysAgo || !n.isDismissed\n      )\n    } else {\n      _rawNotifications.value = []\n    }\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Update default notification preferences\n   */\n  const updateDefaultPreferences = async (preferences: Partial<NotificationPreferences>) => {\n    defaultPreferences.value = { ...defaultPreferences.value, ...preferences }\n    // NOTE: Persistence to be implemented when notification preferences are finalized\n  }\n\n  /**\n   * Get notification statistics\n   */\n  const getNotificationStats = () => {\n    const total = Array.isArray(_rawNotifications.value) ? _rawNotifications.value.length : 0\n    const shown = Array.isArray(_rawNotifications.value) ? _rawNotifications.value.filter(n => n.isShown).length : 0\n    const dismissed = Array.isArray(_rawNotifications.value) ? _rawNotifications.value.filter(n => n.isDismissed).length : 0\n    const pending = pendingNotifications.value.length\n\n    return {\n      total,\n      shown,\n      dismissed,\n      pending,\n      permissionGranted: isPermissionGranted.value,\n      schedulingActive: isSchedulingActive.value\n    }\n  }\n\n  return {\n    // State\n    // SAFETY: Export activeNotifications as 'scheduledNotifications' for safe default (excludes dismissed/shown)\n    scheduledNotifications: activeNotifications,\n    _rawNotifications, // For internal operations only\n    isPermissionGranted,\n    isSchedulingActive,\n    defaultPreferences,\n\n    // Computed\n    activeNotifications, // Keep for explicit usage\n    pendingNotifications,\n    snoozedNotifications,\n\n    // Methods\n    initializeNotifications,\n    checkNotificationPermission,\n    requestNotificationPermission,\n    scheduleTaskNotifications,\n    scheduleRecurringTaskNotifications,\n    removeTaskNotifications,\n    snoozeNotification,\n    dismissNotification,\n    updateDefaultPreferences,\n    getNotificationStats,\n    cleanupOldNotifications,\n    startSchedulingService,\n    stopSchedulingService\n  }\n})","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/projects.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isSyncing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":50,"column":91,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":100},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5872,5875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5872,5875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7341,7344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7341,7344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8024,8027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8024,8027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":209,"column":53,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":209,"endColumn":70},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":308,"column":31,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":308,"endColumn":45},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":348,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13865,13868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13865,13868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2440,2443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2440,2443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6101,6104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6101,6104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia'\nimport { ref, computed, watch } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport type { Project } from '@/types/tasks'\n\nexport const useProjectStore = defineStore('projects', () => {\n\n    // State\n    // SAFETY: Named _rawProjects to discourage direct access - use projects (filtered) instead\n    const _rawProjects = ref<Project[]>([])\n    const activeProjectId = ref<string | null>(null)\n    const isLoading = ref(false)\n\n    // Manual operation flag to prevent watch system conflicts\n    let manualOperationInProgress = false\n\n    // SAFETY: Filtered projects for display\n    // - Filters out corrupted projects (missing name, invalid data)\n    // - Future: could filter out _soft_deleted projects if that feature is added\n    const projects = computed(() => _rawProjects.value.filter(p => {\n        // Must have valid id\n        if (!p.id) return false\n        // Must have valid name (not null, undefined, or empty string)\n        if (!p.name || typeof p.name !== 'string' || p.name.trim() === '') {\n            console.warn(`[PROJECT-FILTER] Hiding project with invalid name:`, p.id)\n            return false\n        }\n        return true\n    }))\n\n    // Root projects - projects without parentId (uses filtered projects to exclude corrupted)\n    const rootProjects = computed(() => {\n        return projects.value.filter(p => !p.parentId || p.parentId === 'undefined' || p.parentId === undefined)\n    })\n\n    // Optimization: fast lookup map for projects\n    // Replaces O(N) array find with O(1) map lookup\n    // This significantly improves performance when rendering lists of tasks\n    // that need to look up project details (e.g. UnifiedInboxPanel)\n    // SAFETY: Use _rawProjects for lookup since we might need to find any project\n    const projectMap = computed(() => {\n        const map = new Map<string, Project>()\n        for (const p of _rawProjects.value) {\n            map.set(p.id, p)\n        }\n        return map\n    })\n\n    // -- Supabase Integration --\n    const { fetchProjects, saveProjects, saveProject, deleteProject: deleteProjectRemote, isSyncing } = useSupabaseDatabase()\n\n    // Actions\n    const saveProjectsToStorage = async (projectsToSave: Project[], context: string = 'unknown'): Promise<void> => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof window !== 'undefined' && (window as any).__STORYBOOK__) return\n\n        // TASK-142 FIX: ALWAYS try Supabase - if reads work, writes should too\n        // The auth check was causing data loss: loads came from Supabase but saves were blocked\n        try {\n            await saveProjects(projectsToSave)\n            // console.debug(` [SUPABASE] Saved ${projectsToSave.length} projects (${context})`)\n        } catch (e) {\n            console.error(` [SUPABASE] Project save failed (${context}):`, e)\n        }\n    }\n\n    const loadProjectsFromDatabase = async () => {\n        isLoading.value = true\n        try {\n            // Guest mode: skip Supabase, start with empty projects\n            const { useAuthStore } = await import('@/stores/auth')\n            const authStore = useAuthStore()\n            if (!authStore.isAuthenticated) {\n                console.log(' [GUEST-MODE] Skipping Supabase fetch - projects start empty')\n                _rawProjects.value = []\n                return\n            }\n\n            const loadedProjects = await fetchProjects()\n            _rawProjects.value = loadedProjects\n            console.log(` [SUPABASE] Loaded ${loadedProjects.length} projects`)\n        } catch (error) {\n            console.error(' [SUPABASE] Projects load failed:', error)\n        } finally {\n            isLoading.value = false\n        }\n    }\n\n    const createProject = async (projectData: Partial<Project>) => {\n        manualOperationInProgress = true\n        try {\n            const newProject: Project = {\n                id: crypto.randomUUID(), // Use standard UUID\n                name: projectData.name || 'New Project',\n                color: projectData.color || '#4ECDC4',\n                colorType: projectData.colorType || 'hex',\n                emoji: projectData.emoji,\n                viewType: projectData.viewType || 'status',\n                parentId: projectData.parentId || null,\n                createdAt: new Date(),\n                updatedAt: new Date(),\n                ...projectData\n            } as Project\n            _rawProjects.value.push(newProject)\n            await saveProject(newProject)\n            return newProject\n        } finally {\n            manualOperationInProgress = false\n        }\n    }\n\n    const updateProject = async (projectId: string, updates: Partial<Project>) => {\n        const projectIndex = _rawProjects.value.findIndex(p => p.id === projectId)\n        if (projectIndex !== -1) {\n            manualOperationInProgress = true\n            try {\n                _rawProjects.value[projectIndex] = {\n                    ..._rawProjects.value[projectIndex],\n                    ...updates,\n                    updatedAt: new Date()\n                }\n                await saveProject(_rawProjects.value[projectIndex])\n            } finally {\n                manualOperationInProgress = false\n            }\n        }\n    }\n\n    const deleteProject = async (projectId: string) => {\n        const projectIndex = _rawProjects.value.findIndex(p => p.id === projectId)\n        if (projectIndex !== -1) {\n            manualOperationInProgress = true\n            try {\n                const projectToDelete = _rawProjects.value[projectIndex]\n                const parentId = projectToDelete.parentId\n\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const { useTaskStore } = await import('./tasks')\n                const taskStore = useTaskStore() as any\n                // SAFETY: Use _rawTasks to include soft-deleted tasks in project reassignment\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                taskStore._rawTasks.forEach((task: any) => {\n                    if (task.projectId === projectId) {\n                        taskStore.updateTask(task.id, {\n                            projectId: 'uncategorized',\n                            isUncategorized: true\n                        })\n                    }\n                })\n\n                // SAFETY: Use _rawProjects for mutation\n                _rawProjects.value.forEach(project => {\n                    if (project.parentId === projectId) {\n                        project.parentId = parentId\n                    }\n                })\n\n                _rawProjects.value.splice(projectIndex, 1)\n\n                // Supabase Soft Delete\n                await deleteProjectRemote(projectId)\n\n            } catch (e) {\n                console.error('Failed to delete project:', e)\n            } finally {\n                manualOperationInProgress = false\n            }\n        }\n    }\n\n    /**\n     * Bulk delete multiple projects at once\n     */\n    const deleteProjects = async (projectIds: string[]) => {\n        if (projectIds.length === 0) return\n\n        manualOperationInProgress = true\n        try {\n            const { useTaskStore } = await import('./tasks')\n            const taskStore = useTaskStore() as any\n            const projectIdSet = new Set(projectIds)\n\n            // Build parent mapping for re-parenting children\n            // SAFETY: Use _rawProjects for lookup\n            const parentMap = new Map<string, string | null>()\n            projectIds.forEach(id => {\n                const project = _rawProjects.value.find(p => p.id === id)\n                if (project) {\n                    parentMap.set(id, project.parentId || null)\n                }\n            })\n\n            // Move tasks from all deleted projects to uncategorized\n            // SAFETY: Use _rawTasks to include soft-deleted tasks in project reassignment\n            taskStore._rawTasks.forEach((task: any) => {\n                if (projectIdSet.has(task.projectId)) {\n                    taskStore.updateTask(task.id, {\n                        projectId: 'uncategorized',\n                        isUncategorized: true\n                    })\n                }\n            })\n\n            // Re-parent children of deleted projects\n            // SAFETY: Use _rawProjects for mutation\n            _rawProjects.value.forEach(project => {\n                if (projectIdSet.has(project.parentId || '')) {\n                    // Find the nearest ancestor that's not being deleted\n                    let newParentId = parentMap.get(project.parentId!) || null\n                    while (newParentId && projectIdSet.has(newParentId)) {\n                        newParentId = parentMap.get(newParentId) || null\n                    }\n                    project.parentId = newParentId\n                }\n            })\n\n            // Remove all deleted projects\n            _rawProjects.value = _rawProjects.value.filter(p => !projectIdSet.has(p.id))\n\n            // Supabase Bulk Delete\n            for (const id of projectIds) {\n                await deleteProjectRemote(id)\n            }\n\n        } finally {\n            manualOperationInProgress = false\n        }\n    }\n\n    const setProjectColor = async (projectId: string, color: string, colorType: 'hex' | 'emoji', emoji?: string) => {\n        // SAFETY: Use _rawProjects for mutation\n        const project = _rawProjects.value.find(p => p.id === projectId)\n        if (project) {\n            manualOperationInProgress = true\n            try {\n                project.color = color\n                project.colorType = colorType\n                project.emoji = colorType === 'emoji' ? emoji : undefined\n                await saveProjectsToStorage(_rawProjects.value, `setProjectColor-${projectId}`)\n            } finally {\n                manualOperationInProgress = false\n            }\n        }\n    }\n\n    const setProjectViewType = async (projectId: string, viewType: Project['viewType']) => {\n        // SAFETY: Use _rawProjects for mutation\n        const project = _rawProjects.value.find(p => p.id === projectId)\n        if (project) {\n            project.viewType = viewType\n            await saveProjectsToStorage(_rawProjects.value, `setProjectViewType-${projectId}`)\n        }\n    }\n\n    // moveTaskToProject MOVED to taskOperations.ts to break circular dependency\n    // (tasks -> projects -> tasks)\n\n    const getProjectById = (projectId: string | null | undefined): Project | undefined => {\n        if (!projectId) return undefined\n        // Optimized O(1) lookup\n        return projectMap.value.get(projectId)\n    }\n\n    const getProjectDisplayName = (projectId: string | null | undefined): string => {\n        if (!projectId || projectId === '1' || projectId === 'uncategorized') return 'Uncategorized'\n        const project = getProjectById(projectId)\n        return project?.name || 'Uncategorized'\n    }\n\n    const getProjectEmoji = (projectId: string | null | undefined): string => {\n        if (!projectId) return ''\n        const project = getProjectById(projectId)\n        return project?.emoji || ''\n    }\n\n    const getProjectVisual = (projectId: string | null | undefined) => {\n        if (!projectId) return { type: 'default', content: '' }\n        const project = getProjectById(projectId)\n        if (!project) return { type: 'default', content: '' }\n        if (project.emoji) return { type: 'emoji', content: project.emoji }\n        if (project.colorType === 'hex' && typeof project.color === 'string') {\n            return { type: 'css-circle', content: '', color: project.color }\n        }\n        return { type: 'default', content: '' }\n    }\n\n    const isDescendantOf = (projectId: string, potentialAncestorId: string): boolean => {\n        let current = getProjectById(projectId)\n        const visited = new Set<string>()\n\n        while (current?.parentId) {\n            if (visited.has(current.id)) return false // Cycle detected\n            visited.add(current.id)\n\n            if (current.parentId === potentialAncestorId) return true\n            current = getProjectById(current.parentId)\n        }\n        return false\n    }\n\n    const getChildProjectIds = (projectId: string): string[] => {\n        const ids = [projectId]\n        const visited = new Set<string>([projectId])\n        const queue = [projectId]\n\n        // Use iterative BFS instead of recursion to prevent stack overflow\n        while (queue.length > 0) {\n            const currentId = queue.shift()!\n            const childProjects = projects.value.filter(p => p.parentId === currentId)\n\n            for (const child of childProjects) {\n                if (!visited.has(child.id)) {\n                    visited.add(child.id)\n                    ids.push(child.id)\n                    queue.push(child.id)\n                }\n            }\n        }\n        return ids\n    }\n\n    const getChildProjects = (parentId: string): Project[] => {\n        return projects.value.filter(p => p.parentId === parentId)\n    }\n\n    const getProjectHierarchy = (projectId: string): Project[] => {\n        const project = getProjectById(projectId)\n        if (!project) return []\n        const hierarchy = [project]\n        let currentId = project.parentId\n        while (currentId) {\n            const parent = getProjectById(currentId)\n            if (parent) {\n                hierarchy.unshift(parent)\n                currentId = parent.parentId\n            } else break\n        }\n        return hierarchy\n    }\n\n    const setActiveProject = (projectId: string | null) => {\n        activeProjectId.value = projectId\n    }\n\n    // Flag to prevent auto-save after sync updates (breaks circular loop)\n    let syncUpdateInProgress = false\n\n    const updateProjectFromSync = (projectId: string, data: any) => {\n        // SAFETY: Validate incoming data to prevent corrupted projects\n        if (!data || typeof data !== 'object') {\n            console.warn(`[PROJECT-SYNC] Ignoring invalid data for project ${projectId}:`, data)\n            return\n        }\n\n        // CRITICAL: Ensure name is present and valid\n        if (!data.name || typeof data.name !== 'string' || data.name.trim() === '') {\n            console.warn(`[PROJECT-SYNC] Ignoring project update with invalid name for ${projectId}:`, data.name)\n            return\n        }\n\n        // Set flag to prevent watcher from triggering auto-save\n        syncUpdateInProgress = true\n\n        try {\n            const index = _rawProjects.value.findIndex(p => p.id === projectId)\n            const normalized = {\n                id: projectId,\n                name: data.name,\n                color: data.color || '#4ECDC4',\n                colorType: data.colorType || 'hex',\n                emoji: data.emoji,\n                viewType: data.viewType || 'status',\n                parentId: data.parentId || null,\n                createdAt: new Date(data.createdAt || Date.now()),\n                updatedAt: new Date(data.updatedAt || Date.now())\n            }\n\n            if (index !== -1) {\n                // Merge with existing data to preserve fields not in sync payload\n                _rawProjects.value[index] = {\n                    ..._rawProjects.value[index],\n                    ...normalized\n                }\n            } else {\n                _rawProjects.value.push(normalized)\n            }\n        } finally {\n            // Reset flag after Vue's next tick to ensure watcher sees it\n            setTimeout(() => {\n                syncUpdateInProgress = false\n            }, 100)\n        }\n    }\n\n    const removeProjectFromSync = (projectId: string) => {\n        // SAFETY: Use _rawProjects for sync mutations\n        const index = _rawProjects.value.findIndex(p => p.id === projectId)\n        if (index !== -1) {\n            _rawProjects.value.splice(index, 1)\n        }\n    }\n\n    const initializeFromDatabase = async () => {\n        await loadProjectsFromDatabase()\n        return projects.value.length > 0\n    }\n\n    /**\n     * Removes corrupted projects (missing name, invalid data) from local state\n     * Call this if you see ghost/empty projects in the sidebar\n     */\n    const cleanupCorruptedProjects = () => {\n        const before = _rawProjects.value.length\n        _rawProjects.value = _rawProjects.value.filter(p => {\n            if (!p.id) {\n                console.log(`[PROJECT-CLEANUP] Removing project with no id`)\n                return false\n            }\n            if (!p.name || typeof p.name !== 'string' || p.name.trim() === '') {\n                console.log(`[PROJECT-CLEANUP] Removing project with invalid name:`, p.id)\n                return false\n            }\n            return true\n        })\n        const removed = before - _rawProjects.value.length\n        console.log(`[PROJECT-CLEANUP] Removed ${removed} corrupted projects`)\n        return removed\n    }\n\n    // Watchers\n    let saveTimeout: ReturnType<typeof setTimeout> | null = null\n    watch(projects, (newProjects) => {\n        // CRITICAL: Prevent circular sync loop\n        // - manualOperationInProgress: Direct CRUD operations (already saving)\n        // - isLoading: Loading from database (don't save during load)\n        // - syncUpdateInProgress: Realtime update just happened (don't echo back)\n        if (manualOperationInProgress || isLoading.value || syncUpdateInProgress) {\n            return\n        }\n        if (saveTimeout) clearTimeout(saveTimeout)\n        saveTimeout = setTimeout(() => {\n            saveProjectsToStorage([...newProjects], 'auto-save')\n        }, 1000)\n    }, { deep: true })\n\n    return {\n        // SAFETY: Export filtered projects as 'projects' - this is the safe default for components\n        // Use _rawProjects only for internal operations (load, save, sync, mutations)\n        projects,\n        _rawProjects,\n        activeProjectId,\n        isLoading,\n        rootProjects,\n        loadProjectsFromDatabase,\n        createProject,\n        updateProject,\n        deleteProject,\n        deleteProjects,\n        setProjectColor,\n        getProjectById,\n        getProjectDisplayName,\n        getProjectEmoji,\n        getProjectVisual,\n        isDescendantOf,\n        getChildProjectIds,\n        getChildProjects,\n        getProjectHierarchy,\n        setActiveProject,\n        saveProjectsToStorage,\n        setProjectViewType,\n        // moveTaskToProject, // Removed: Moved to taskOperations.ts\n        initializeFromDatabase,\n        updateProjectFromSync,\n        removeProjectFromSync,\n        cleanupCorruptedProjects\n    }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/quickSort.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/settings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/taskScheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/tasks.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1057,1060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1057,1060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'saveTasks' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":33,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'tasks' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":73,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'importTasksFromJSON' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":89,"column":157,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":176},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'importFromRecoveryTool' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":89,"column":178,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":200},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7146,7149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7146,7149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore, acceptHMRUpdate } from 'pinia'\nimport { computed } from 'vue'\nimport { useTaskStates } from './tasks/taskStates'\nimport { useTaskPersistence } from './tasks/taskPersistence'\nimport { useTaskOperations } from './tasks/taskOperations'\nimport { useTaskHistory } from './tasks/taskHistory'\nimport { useProjectStore } from './projects'\nimport { errorHandler, ErrorSeverity, ErrorCategory } from '@/utils/errorHandler'\n// TASK-129: Removed transactionManager (PouchDB WAL stub no longer needed)\n// TASK-089: Updated to use unified canvas state lock system\n// useCanvasOptimisticSync removed\n\n// Export types and utilities for backward compatibility\nexport type { Task, TaskInstance, Subtask, Project, RecurringTaskInstance } from '@/types/tasks'\nimport type { Task } from '@/types/tasks'\nexport { parseDateKey, formatDateKey } from '@/utils/dateUtils'\n\n/**\n * getTaskInstances function - for compatibility with TaskEditModal\n * Returns recurring instances for a task, simplified for current system\n */\nexport const getTaskInstances = (task: any) => task.recurringInstances || []\n\n/**\n * Clear only hardcoded test tasks while preserving user's real tasks\n * Optimized for Supabase PostgreSQL\n */\nexport const clearHardcodedTestTasks = async () => {\n  console.log(' Clearing hardcoded test tasks only (preserving real tasks)...')\n  const { useSupabaseDatabase } = await import('@/composables/useSupabaseDatabase')\n  const { useDemoGuard } = await import('@/composables/useDemoGuard')\n\n  const { fetchTasks, saveTasks, deleteTask } = useSupabaseDatabase()\n  const demoGuard = useDemoGuard()\n\n  try {\n    const allowClear = await demoGuard.allowDemoData()\n    if (!allowClear) return\n\n    const savedTasks = await fetchTasks()\n    if (!savedTasks || savedTasks.length === 0) return\n\n    const testTaskPatterns = [\n      /^Test Task$/, /^Test Task \\d+$/, /^Medium priority task/, /^Low priority task/,\n      /^No priority task/, /^Completed high priority task/, /^Task \\d+ - Performance Testing/, /^New Task$/\n    ]\n\n    const tasksToDelete = savedTasks.filter(task => testTaskPatterns.some(pattern => pattern.test(task.title)))\n\n    if (tasksToDelete.length > 0) {\n      console.log(` Deleting ${tasksToDelete.length} test tasks from Supabase...`)\n      for (const task of tasksToDelete) {\n        await deleteTask(task.id)\n      }\n      console.log(` Test tasks cleared.`)\n    } else {\n      console.log(' No test tasks found in Supabase.')\n    }\n  } catch (error) {\n    console.error(' Failed to clear test tasks:', error)\n  }\n}\n\nexport const useTaskStore = defineStore('tasks', () => {\n  const projectStore = useProjectStore()\n\n  //### BUG-218:  FIXED - Persistent Canvas Drift (Deterministic Refactor TASK-232)\n  //### BUG-220:  FIXED - Group Counter Accuracy & Movement Counters\n  // 1. Initialize State\n  const states = useTaskStates()\n  const {\n    // SAFETY: tasks is now filteredTasks (safe for dis-\n    tasks, _rawTasks, hideDoneTasks, hideCanvasDoneTasks, hideCalendarDoneTasks, hideCanvasOverdueTasks,\n    activeSmartView, activeStatusFilter,\n    activeDurationFilter, isLoadingFromDatabase, manualOperationInProgress,\n    isLoadingFilters, syncInProgress, runAllTaskMigrations, calendarFilteredTasks\n  } = states\n\n  // 2. Initialize Persistence\n  // BUG-057: Pass syncInProgress to prevent saves during sync operations\n  // SAFETY: Pass _rawTasks for load/save operations\n  const persistence = useTaskPersistence(\n    _rawTasks, hideDoneTasks, hideCanvasDoneTasks, hideCalendarDoneTasks, hideCanvasOverdueTasks,\n    activeSmartView, activeStatusFilter,\n    isLoadingFromDatabase, manualOperationInProgress, isLoadingFilters,\n    syncInProgress,\n    runAllTaskMigrations\n  )\n  const { saveTasksToStorage, saveSpecificTasks, deleteTaskFromStorage, bulkDeleteTasksFromStorage, loadFromDatabase, loadPersistedFilters, persistFilters, importTasksFromJSON, importFromRecoveryTool, importTasks } = persistence\n\n  // 3. Initialize Operations\n  // SAFETY: Pass _rawTasks for CRUD operations\n  const operations = useTaskOperations(\n    _rawTasks, states.selectedTaskIds, activeSmartView, activeStatusFilter,\n    activeDurationFilter, hideDoneTasks, hideCanvasDoneTasks, hideCalendarDoneTasks, hideCanvasOverdueTasks,\n    manualOperationInProgress, saveTasksToStorage, saveSpecificTasks, deleteTaskFromStorage, bulkDeleteTasksFromStorage, persistFilters, runAllTaskMigrations\n  )\n\n  // 4. Initialize History\n  // SAFETY: Pass _rawTasks for undo/redo state restoration\n  const history = useTaskHistory(_rawTasks, manualOperationInProgress, saveTasksToStorage)\n  const { restoreState, undoRedoEnabledActions } = history\n\n  // 5. Initialization Logic\n  const initializeFromDatabase = async () => {\n    try {\n      const dbReady = await projectStore.initializeFromDatabase()\n      if (!dbReady) console.debug(' Project store failed to initialize')\n      await loadFromDatabase()\n      await loadPersistedFilters()\n      runAllTaskMigrations()\n\n      // TASK-129: Removed PouchDB WAL crash recovery (transactionManager was a stub)\n\n    } catch (error) {\n      errorHandler.report({\n        severity: ErrorSeverity.ERROR,\n        category: ErrorCategory.DATABASE,\n        message: 'Store initialization failed',\n        error: error as Error,\n        showNotification: true\n      })\n    }\n  }\n\n  // Auto-init on store creation\n  initializeFromDatabase().catch(() => { })\n\n  // BUG-057 FIX: Incremental update from sync - updates individual task without full reload\n  // This prevents infinite loops by not triggering save watchers\n  // BUG-061 FIX: Added validation and date conversion safety\n  // SAFETY: Uses _rawTasks for mutations\n  const updateTaskFromSync = (taskId: string, taskDoc: Task | null, isDeleted = false) => {\n    syncInProgress.value = true\n\n    // ================================================================\n    // DUPLICATE DETECTION - Realtime Sync Entry Point\n    // ================================================================\n    // This tracks what's coming in from realtime and whether the task exists\n    // A duplicate after this function means the push logic is racing with initial load\n    if (import.meta.env.DEV) {\n      const existsInStore = _rawTasks.value.some(t => t.id === taskId)\n      console.debug('[SYNC-INCOMING]', {\n        taskId: taskId.slice(0, 8),\n        isDeleted,\n        existsInStore,\n        storeCount: _rawTasks.value.length,\n        taskTitle: taskDoc?.title?.slice(0, 20) || '(deleted)'\n      })\n    }\n\n    try {\n      if (isDeleted || !taskDoc) {\n        // Remove deleted task\n        const idx = _rawTasks.value.findIndex(t => t.id === taskId)\n        if (idx !== -1) {\n          _rawTasks.value.splice(idx, 1)\n        }\n      } else {\n        // BUG-061 FIX: Validate task before adding/updating\n        if (!taskDoc || !taskDoc.id || !taskDoc.title === undefined) {\n          console.warn(' [TASK STORE] Ignoring invalid task from sync (missing id or title):', taskId)\n          return\n        }\n\n        // DEBUG: Trace sync payload for connections (BUG-023)\n        // Handle strings, timestamps, or Date objects safely\n        const toDate = (val: any): Date => {\n          if (!val) return new Date()\n          if (val instanceof Date) return val\n          // If string or number, try to parse\n          const d = new Date(val)\n          return isNaN(d.getTime()) ? new Date() : d\n        }\n\n        const normalizedTask: Task = {\n          ...taskDoc,\n          createdAt: toDate(taskDoc.createdAt),\n          updatedAt: toDate(taskDoc.updatedAt)\n        }\n\n        // Update or add task\n        const idx = _rawTasks.value.findIndex(t => t.id === taskId)\n        if (idx !== -1) {\n          const currentTask = _rawTasks.value[idx]\n\n          //### ROAD-013: Sync Hardening ( COMPLETE)\n          // 1. Audit current sync issues.  DONE\n          // 2. Implement \"Triple Shield\" Drag/Resize Locks.  DONE\n          // 3. Fix conflict resolution UI.  DONE (TASK-232)\n          // 4. Test multi-device scenarios E2E.  DONE\n          // Phase 14: Conflict Prevention\n          // 1. If we are actively dragging/editing (manualOperationInProgress), ignore sync for now\n          // 2. If local task is newer than incoming task (based on updatedAt), ignore sync (Last Write Wins)\n          if (manualOperationInProgress.value) {\n            console.log(` [SYNC-PROTECT] Ignoring sync for ${taskId} during manual operation`)\n            return\n          }\n\n          if (currentTask.updatedAt > normalizedTask.updatedAt) {\n            console.log(` [SYNC-PROTECT] Ignoring sync for ${taskId} - local version is newer (${currentTask.updatedAt.toISOString()} vs ${normalizedTask.updatedAt.toISOString()})`)\n            return\n          }\n\n\n\n          // BUG-FIX: Preserve local canvasPosition if remote doesn't have one\n          // This prevents sync from clearing positions when remote has no position data\n          if (currentTask.canvasPosition && !normalizedTask.canvasPosition) {\n            console.log(` [SYNC-PROTECT] Preserving local canvasPosition for ${taskId} - remote has no position`)\n            normalizedTask.canvasPosition = currentTask.canvasPosition\n            normalizedTask.isInInbox = currentTask.isInInbox\n          }\n\n          // Update existing task\n          if (normalizedTask._soft_deleted) {\n            // If it's now deleted, remove it instead of updating\n            _rawTasks.value.splice(idx, 1)\n          } else {\n            _rawTasks.value[idx] = normalizedTask\n          }\n        } else {\n          // Add new task - ONLY if not deleted\n          if (!normalizedTask._soft_deleted) {\n            // ================================================================\n            // RACE CONDITION GUARD - Double-check before push\n            // ================================================================\n            // Even though findIndex returned -1, another async operation might\n            // have added this task between findIndex and now. Check again.\n            const existingCount = _rawTasks.value.filter(t => t.id === normalizedTask.id).length\n\n            if (existingCount > 0) {\n              // Task already exists - this is a race condition\n              // Update instead of push to avoid duplication\n              console.error('[SYNC-DUPLICATE-CREATED]', {\n                taskId: taskId.slice(0, 8),\n                existingCount,\n                taskTitle: normalizedTask.title?.slice(0, 20),\n                action: 'UPDATE_INSTEAD_OF_PUSH',\n                storeSize: _rawTasks.value.length\n              })\n\n              // Find and update the existing task instead\n              const existingIdx = _rawTasks.value.findIndex(t => t.id === normalizedTask.id)\n              if (existingIdx !== -1) {\n                _rawTasks.value[existingIdx] = normalizedTask\n              }\n            } else {\n              // Safe to push\n              _rawTasks.value.push(normalizedTask)\n\n              // Verify no duplicate was created (should never happen now)\n              if (import.meta.env.DEV) {\n                const countAfterPush = _rawTasks.value.filter(t => t.id === normalizedTask.id).length\n                if (countAfterPush > 1) {\n                  console.error('[SYNC-DUPLICATE-UNEXPECTED]', {\n                    taskId: taskId.slice(0, 8),\n                    occurrences: countAfterPush,\n                    taskTitle: normalizedTask.title?.slice(0, 20),\n                    storeSize: _rawTasks.value.length\n                  })\n                }\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      syncInProgress.value = false\n    }\n  }\n\n  return {\n    ...states,\n    ...persistence,\n    ...operations,\n    ...history,\n\n    // Project Store passthrough (compatibility)\n    projects: computed(() => projectStore.projects),\n    rootProjects: computed(() => projectStore.rootProjects),\n    activeProjectId: computed(() => projectStore.activeProjectId),\n    createProject: projectStore.createProject,\n    updateProject: projectStore.updateProject,\n    deleteProject: projectStore.deleteProject,\n    deleteProjects: projectStore.deleteProjects,\n    setProjectColor: projectStore.setProjectColor,\n    getProjectById: projectStore.getProjectById,\n    getProjectDisplayName: projectStore.getProjectDisplayName,\n    getProjectEmoji: projectStore.getProjectEmoji,\n    getProjectVisual: projectStore.getProjectVisual,\n    isDescendantOf: projectStore.isDescendantOf,\n    getChildProjects: projectStore.getChildProjects,\n    getProjectHierarchy: projectStore.getProjectHierarchy,\n    setProjectViewType: projectStore.setProjectViewType,\n    // Undo/Redo support\n    initializeFromDatabase,\n    restoreState,\n\n    // BUG-057 FIX: Incremental sync update\n    updateTaskFromSync,\n    syncInProgress,\n    calendarFilteredTasks,\n\n    // TASK-243: Expose raw tasks for accurate counters (bypasses smart view filters)\n    // Exposed as computed for reactivity\n    rawTasks: computed(() => _rawTasks.value),\n\n    // Helper functions\n    getTaskInstances,\n    importTasks, // Exposed for Markdown Import (TASK-087)\n\n    // Undo/Redo enabled actions\n    ...undoRedoEnabledActions(),\n\n    // Data integrity validation\n    validateDataConsistency: async () => {\n      // Basic check\n      return true // Supabase handles this now\n    }\n  }\n})\n\n// HMR support\nif (import.meta.hot) {\n  import.meta.hot.accept(acceptHMRUpdate(useTaskStore, import.meta.hot))\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/tasks/taskHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/tasks/taskOperations.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":550,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":550,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24497,24500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24497,24500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1660,1663],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1660,1663],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1807,1810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1807,1810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":569,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":569,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25106,25109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25106,25109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":606,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":606,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26231,26234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26231,26234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":613,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":613,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26484,26487],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26484,26487],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// TASK-129: Removed transactionManager (PouchDB WAL stub no longer needed)\nimport { type Ref } from 'vue'\nimport type { Task, Subtask, TaskInstance } from '@/types/tasks'\n// TASK-127: Removed taskDisappearanceLogger (PouchDB-era debugging tool)\nimport { guardTaskCreation } from '@/utils/demoContentGuard'\nimport { formatDateKey } from '@/utils/dateUtils'\n// TASK-089 FIX: Unlock position when removing from canvas\n// TASK-131 FIX: Protect locked positions from being overwritten by stale sync data\n\n// =============================================================================\n// GEOMETRY WRITE SOURCE (TASK-255 Geometry Invariants)\n// =============================================================================\n// Tracks the origin of geometry mutations for drift detection.\n// - 'DRAG': User drag/drop operations (ALLOWED)\n// - 'RECONCILE': One-time parent reconciliation on load (CONTROLLED)\n// - 'USER': Explicit user actions like move-to-inbox (ALLOWED)\n// - 'SYNC': Remote sync updates (SHOULD NOT change geometry)\n// - 'SMART-GROUP': Smart group property application (METADATA ONLY - no geometry!)\n// =============================================================================\nexport type GeometryWriteSource = 'DRAG' | 'RECONCILE' | 'USER' | 'SYNC' | 'SMART-GROUP'\n\nimport { useSmartViews } from '@/composables/useSmartViews'\nimport { useProjectStore } from '../projects'\n\nexport function useTaskOperations(\n    // SAFETY: Named _rawTasks to indicate this is the raw array for mutations\n    _rawTasks: Ref<Task[]>,\n    selectedTaskIds: Ref<string[]>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    activeSmartView: Ref<any>,\n    activeStatusFilter: Ref<string | null>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    activeDurationFilter: Ref<any>,\n    hideDoneTasks: Ref<boolean>,\n    hideCanvasDoneTasks: Ref<boolean>,\n    hideCalendarDoneTasks: Ref<boolean>,\n    hideCanvasOverdueTasks: Ref<boolean>,\n    manualOperationInProgress: Ref<boolean>,\n    saveTasksToStorage: (tasks: Task[], context: string) => Promise<void>,\n    saveSpecificTasks: (tasks: Task[], context: string) => Promise<void>,\n    deleteTaskFromStorage: (taskId: string) => Promise<void>,\n    bulkDeleteTasksFromStorage: (taskIds: string[]) => Promise<void>,  // BUG-025: Atomic bulk delete\n    persistFilters: () => void,\n    _runAllTaskMigrations: () => void\n) {\n    const projectStore = useProjectStore()\n\n    // Helper to trigger canvas sync after task operations\n    // This bypasses Vue's watch system which has timing issues in Tauri/WebKitGTK\n    // DRIFT FIX: Now requires explicit source to prevent automated sync loops\n    const triggerCanvasSync = (source: 'user:create' | 'user:delete' | 'user:context-menu' = 'user:create') => {\n        // Dynamic import to avoid circular dependency and context issues\n        import('../canvas/canvasUi').then(({ useCanvasUiStore }) => {\n            const canvasUiStore = useCanvasUiStore()\n            canvasUiStore.requestSync(source)\n        }).catch(_e => {\n            // Ignore if canvas store not available (e.g., in non-canvas views)\n        })\n    }\n\n    const createTask = async (taskData: Partial<Task>) => {\n        // TASK-061: Demo content guard - warn in dev mode\n        if (taskData.title) {\n            guardTaskCreation(taskData.title)\n        }\n\n        const taskId = crypto.randomUUID()\n        manualOperationInProgress.value = true\n\n        try {\n            const instances: TaskInstance[] = []\n            if (taskData.scheduledDate && taskData.scheduledTime) {\n                const now = new Date()\n                instances.push({\n                    id: `instance-${taskId}-${Date.now()}`,\n                    taskId: taskId,\n                    scheduledDate: taskData.scheduledDate,\n                    scheduledTime: taskData.scheduledTime,\n                    duration: taskData.estimatedDuration || 25,\n                    status: 'scheduled',\n                    isRecurring: false,\n                    createdAt: now,\n                    updatedAt: now\n                })\n            }\n\n            let projectId = taskData.projectId || 'uncategorized'\n            if (taskData.parentTaskId) {\n                const parentTask = _rawTasks.value.find(t => t.id === taskData.parentTaskId)\n                if (parentTask) projectId = parentTask.projectId\n            }\n\n            const { canvasPosition: explicitCanvasPosition, ...taskDataWithoutPosition } = taskData\n\n            const newTask: Task = {\n                id: taskId,\n                title: taskData.title || 'New Task',\n                description: taskData.description || 'Task description...',\n                status: taskData.status || 'planned',\n                priority: taskData.priority || 'medium',\n                progress: 0,\n                completedPomodoros: 0,\n                subtasks: [],\n                dueDate: taskData.dueDate || new Date().toISOString().split('T')[0],\n                projectId,\n                createdAt: new Date(),\n                updatedAt: new Date(),\n                instances,\n                isInInbox: taskData.isInInbox !== false,\n                canvasPosition: explicitCanvasPosition || undefined,\n                positionVersion: 1, // Start at version 1\n                positionFormat: taskData.positionFormat || 'absolute', // Default to absolute\n                ...taskDataWithoutPosition\n            }\n\n            _rawTasks.value.push(newTask)\n            await saveSpecificTasks([newTask], `createTask-${newTask.id}`)\n\n            // Trigger canvas sync for Tauri reactivity\n            triggerCanvasSync()\n\n            return newTask\n        } catch (error) {\n            const index = _rawTasks.value.findIndex(t => t.id === taskId)\n            if (index !== -1) _rawTasks.value.splice(index, 1)\n            throw error\n        } finally {\n            manualOperationInProgress.value = false\n        }\n    }\n\n    /**\n     * Update a task with optional geometry write source tracking (TASK-255)\n     *\n     * @param taskId - The ID of the task to update\n     * @param updates - Partial task updates to apply\n     * @param source - Origin of the update for drift detection (default: 'USER')\n     *\n     * GEOMETRY INVARIANT: Only 'DRAG' and 'USER' sources should include\n     * parentId or canvasPosition changes. If 'SYNC' or 'SMART-GROUP' sources\n     * include geometry changes, a warning will be logged.\n     */\n    const updateTask = async (taskId: string, updates: Partial<Task>, source: GeometryWriteSource = 'USER') => {\n        const index = _rawTasks.value.findIndex(t => t.id === taskId)\n        if (index === -1) return\n\n        // BUG-060 FIX: Suppress watcher during manual update to prevent concurrent bulk saves\n        // This prevents the \"8 conflicts in bulk save\" issue\n        const wasManualInProgress = manualOperationInProgress.value\n        if (!wasManualInProgress) manualOperationInProgress.value = true\n\n        try {\n            const task = _rawTasks.value[index]\n\n            // GEOMETRY DRIFT DETECTION (TASK-255): Track and warn about geometry changes\n            const hasGeometryChange = ('parentId' in updates && updates.parentId !== task.parentId) ||\n                ('canvasPosition' in updates && updates.canvasPosition !== undefined &&\n                    (task.canvasPosition?.x !== updates.canvasPosition?.x ||\n                        task.canvasPosition?.y !== updates.canvasPosition?.y))\n\n            // Warn if non-allowed sources try to change geometry\n            if (hasGeometryChange && (source === 'SYNC' || source === 'SMART-GROUP')) {\n                console.warn(` [GEOMETRY-DRIFT] Source '${source}' is changing geometry - this may cause position drift!`, {\n                    taskId: taskId.slice(0, 8),\n                    taskTitle: task.title?.slice(0, 30),\n                    parentIdChange: 'parentId' in updates,\n                    positionChange: 'canvasPosition' in updates\n                })\n            }\n\n            // DRIFT LOGGING: Track when parentId or canvasPosition is changed\n            // This helps identify non-drag flows that mutate hierarchy/positions\n            if ('parentId' in updates && updates.parentId !== task.parentId) {\n                console.log(` [GEOMETRY-${source}] Task ${taskId.slice(0, 8)}... parentId: \"${task.parentId ?? 'none'}\"  \"${updates.parentId ?? 'none'}\"`, {\n                    taskTitle: task.title?.slice(0, 30),\n                    source,\n                    stack: new Error().stack?.split('\\n').slice(2, 5).join(' <- ')\n                })\n            }\n            if ('canvasPosition' in updates && updates.canvasPosition !== undefined) {\n                const oldPos = task.canvasPosition\n                const newPos = updates.canvasPosition\n                if (oldPos?.x !== newPos?.x || oldPos?.y !== newPos?.y) {\n                    console.log(` [GEOMETRY-${source}] Task ${taskId.slice(0, 8)}... pos: (${oldPos?.x?.toFixed(0) ?? '?'},${oldPos?.y?.toFixed(0) ?? '?'})  (${newPos?.x?.toFixed(0) ?? 'null'},${newPos?.y?.toFixed(0) ?? 'null'})`, {\n                        taskTitle: task.title?.slice(0, 30),\n                        source,\n                        stack: new Error().stack?.split('\\n').slice(2, 5).join(' <- ')\n                    })\n                }\n            }\n\n            // BUG-045 FIX: Removed auto-archive behavior\n            // Tasks now stay on canvas when marked as done (no position/inbox changes)\n\n            // Canvas logic\n            if (updates.canvasPosition && !task.canvasPosition) {\n                updates.isInInbox = false\n            }\n\n            // BUG-FIX: Explicitly unlock position if removing from canvas\n            // This prevents sync from restoring the position due to \"Preserve local canvasPosition\" logic\n            if (updates.canvasPosition === null) {\n                // Position will be cleared by the update\n            }\n\n            // TASK-131 FIX: Protect locked positions from being overwritten by stale sync data\n            // If a position lock (pending change) exists, use that position instead of the update\n            if (updates.canvasPosition && updates.canvasPosition !== null) {\n                // Position lock protection handled by persistence logic\n            }\n\n            if (updates.canvasPosition === undefined && task.canvasPosition && !updates.instances && (!task.instances || !task.instances.length)) {\n                // updates.isInInbox = true // Wait, why force inbox true if just position is undefined but task has position? \n                // This logic implies check if task HAS position.\n                // Let's log if this triggers.\n            }\n\n            // Project logic\n            if ('projectId' in updates) {\n                const isUncategorized = !updates.projectId || updates.projectId === '1' || updates.projectId === 'uncategorized'\n                updates.isUncategorized = isUncategorized\n            }\n\n            // Orphan prevention\n            const finalInInbox = updates.isInInbox ?? task.isInInbox\n            const finalPos = updates.canvasPosition ?? task.canvasPosition\n            const finalInst = updates.instances ?? task.instances\n            if (!finalInInbox && !finalPos && (!finalInst || !finalInst.length)) {\n                // updates.isInInbox = true\n            }\n\n            // TASK-240: Handle position versioning\n            const currentVersion = task.positionVersion || 0\n            const newVersion = updates.canvasPosition ? currentVersion + 1 : currentVersion\n\n            _rawTasks.value[index] = {\n                ...task,\n                ...updates,\n                positionVersion: newVersion,\n                updatedAt: new Date()\n            }\n\n            // BUG-060 FIX: Save immediately to prevent data loss on quick refresh\n            try {\n                await saveSpecificTasks([_rawTasks.value[index]], `updateTask-${taskId}`)\n\n                // DRIFT FIX: REMOVED triggerCanvasSync() - this was causing sync loops!\n                // When Smart-Group applied properties  updateTask  triggerCanvasSync \n                // syncNodes  Smart-Group applied again  infinite loop\n                // Canvas sync should ONLY happen on explicit user drag/drop actions,\n                // not on every task property update. Vue reactivity handles UI updates.\n            } catch (error) {\n                console.error(` [BUG-060] Failed to save task update for ${taskId}:`, error)\n                // Note: We don't rollback memory state here to preserve UX, relying on \"last write wins\" locally\n            }\n        } finally {\n            if (!wasManualInProgress) manualOperationInProgress.value = false\n        }\n    }\n\n    const deleteTask = async (taskId: string) => {\n        const index = _rawTasks.value.findIndex(t => t.id === taskId)\n        if (index === -1) return\n\n        const deletedTask = _rawTasks.value[index]\n        manualOperationInProgress.value = true\n\n        try {\n            // BUGFIX: Persist deletion to Supabase FIRST (soft delete)\n            // This ensures task won't reappear on refresh\n            await deleteTaskFromStorage(taskId)\n\n            _rawTasks.value.splice(index, 1)\n\n            // Save to localStorage AFTER splice (for guest mode persistence)\n            await saveTasksToStorage(_rawTasks.value, 'deleteTask')\n\n            // TASK-131: Removed triggerCanvasSync() - surgical deletion watcher in CanvasView handles this\n            // The watcher detects the deletion and removes only the affected node, preventing position resets\n        } catch (error) {\n            _rawTasks.value.splice(index, 0, deletedTask)\n            console.error(` [DELETE] Failed to delete task ${taskId}:`, error)\n            throw error\n        } finally {\n            manualOperationInProgress.value = false\n        }\n    }\n\n    // [DEEP-DIVE FIX] Added permanent delete operation\n    const permanentlyDeleteTask = async (taskId: string) => {\n        const index = _rawTasks.value.findIndex(t => t.id === taskId)\n        if (index === -1) return\n\n        manualOperationInProgress.value = true\n        try {\n            // 1. Remove from local state immediately (Optimistic UI)\n            _rawTasks.value.splice(index, 1)\n\n            // 2. Call TrashService for DB removal (Hard Delete)\n            const { trashService } = await import('@/services/trash/TrashService')\n            await trashService.permanentlyDeleteTask(taskId)\n\n            // 3. Ensure no artifacts remain in individual storage if needed\n        } catch (error) {\n            console.error(` Failed to permanently delete ${taskId}:`, error)\n        } finally {\n            manualOperationInProgress.value = false\n        }\n    }\n\n    // BUG-025 FIX: Atomic bulk delete using Supabase .in() operator\n    const bulkDeleteTasks = async (taskIds: string[]) => {\n        if (!taskIds.length) return\n        manualOperationInProgress.value = true\n\n        try {\n            // BUG-025 FIX: Use atomic bulk delete instead of looping\n            await bulkDeleteTasksFromStorage(taskIds)\n\n            const tasksToKeep = _rawTasks.value.filter(t => !taskIds.includes(t.id))\n            _rawTasks.value = tasksToKeep\n\n            // Save to localStorage AFTER filter (for guest mode persistence)\n            await saveTasksToStorage(_rawTasks.value, 'bulkDeleteTasks')\n\n            // TASK-131: Removed triggerCanvasSync() - surgical deletion watcher in CanvasView handles this\n            // The watcher detects bulk deletions and removes only the affected nodes, preventing position resets\n        } catch (error) {\n            console.error(` [BULK-DELETE] Failed to delete ${taskIds.length} tasks:`, error)\n            throw error\n        } finally {\n            manualOperationInProgress.value = false\n        }\n    }\n\n    const moveTask = (taskId: string, newStatus: Task['status']) => {\n        updateTask(taskId, { status: newStatus })\n    }\n\n    const selectTask = (taskId: string) => {\n        if (!selectedTaskIds.value.includes(taskId)) selectedTaskIds.value.push(taskId)\n    }\n\n    const deselectTask = (taskId: string) => {\n        const idx = selectedTaskIds.value.indexOf(taskId)\n        if (idx !== -1) selectedTaskIds.value.splice(idx, 1)\n    }\n\n    const clearSelection = () => {\n        selectedTaskIds.value = []\n    }\n\n    const createSubtask = (taskId: string, subtaskData: Partial<Subtask>) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task) return null\n        const newSubtask: Subtask = {\n            id: Date.now().toString(),\n            parentTaskId: taskId,\n            title: subtaskData.title || 'New Subtask',\n            description: subtaskData.description || '',\n            completedPomodoros: 0,\n            isCompleted: false,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        }\n        task.subtasks.push(newSubtask)\n        task.updatedAt = new Date()\n        saveSpecificTasks([task], `createSubtask-${newSubtask.id}`)\n        return newSubtask\n    }\n\n    const updateSubtask = (taskId: string, subtaskId: string, updates: Partial<Subtask>) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task) return\n        const idx = task.subtasks.findIndex(st => st.id === subtaskId)\n        if (idx !== -1) {\n            task.subtasks[idx] = { ...task.subtasks[idx], ...updates, updatedAt: new Date() }\n            task.updatedAt = new Date()\n            saveSpecificTasks([task], `updateSubtask-${subtaskId}`)\n        }\n    }\n\n    const deleteSubtask = (taskId: string, subtaskId: string) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task) return\n        const idx = task.subtasks.findIndex(st => st.id === subtaskId)\n        if (idx !== -1) {\n            task.subtasks.splice(idx, 1)\n            task.updatedAt = new Date()\n            saveSpecificTasks([task], `deleteSubtask-${subtaskId}`)\n        }\n    }\n\n    const createTaskInstance = (taskId: string, instanceData: Omit<TaskInstance, 'id'>) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task) return null\n        const newInstance: TaskInstance = {\n            id: Date.now().toString(),\n            ...instanceData\n        }\n        if (!task.instances) task.instances = []\n        task.instances.push(newInstance)\n        task.updatedAt = new Date()\n        saveSpecificTasks([task], `createInstance-${newInstance.id}`)\n        return newInstance\n    }\n\n    const updateTaskInstance = (taskId: string, instanceId: string, updates: Partial<TaskInstance>) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task || !task.instances) return\n        const idx = task.instances.findIndex(inst => inst.id === instanceId)\n        if (idx !== -1) {\n            task.instances[idx] = { ...task.instances[idx], ...updates }\n            task.updatedAt = new Date()\n            saveSpecificTasks([task], `updateInstance-${instanceId}`)\n        }\n    }\n\n    const deleteTaskInstance = (taskId: string, instanceId: string) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task || !task.instances) return\n        const idx = task.instances.findIndex(inst => inst.id === instanceId)\n        if (idx !== -1) {\n            task.instances.splice(idx, 1)\n            task.updatedAt = new Date()\n            saveSpecificTasks([task], `deleteInstance-${instanceId}`)\n        }\n    }\n\n    /**\n     *  TASK-192: Atomic update for task scheduling\n     * Combines task updates and instance updates to prevent race conditions\n     */\n    const updateTaskWithSchedule = async (taskId: string, schedule: {\n        scheduledDate: string\n        scheduledTime: string\n        instanceId?: string\n    }) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task) return\n\n        const updates: Partial<Task> = {\n            scheduledDate: schedule.scheduledDate,\n            scheduledTime: schedule.scheduledTime,\n            // When scheduling on calendar, it's no longer in inbox\n            isInInbox: false\n        }\n\n        // If instance exists, update it too\n        if (schedule.instanceId && task.instances) {\n            const instances = [...task.instances]\n            const idx = instances.findIndex(i => i.id === schedule.instanceId)\n            if (idx !== -1) {\n                instances[idx] = {\n                    ...instances[idx],\n                    scheduledDate: schedule.scheduledDate,\n                    scheduledTime: schedule.scheduledTime,\n                    updatedAt: new Date()\n                }\n                updates.instances = instances\n            }\n        }\n\n        await updateTask(taskId, updates)\n    }\n\n    const startTaskNow = (taskId: string) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task) {\n            console.warn(' startTaskNow: Task not found:', taskId)\n            return\n        }\n        const now = new Date()\n        const currentMinutes = now.getMinutes()\n        const roundedMinutes = currentMinutes < 30 ? 0 : 30\n        const roundedTime = new Date(now)\n        roundedTime.setMinutes(roundedMinutes, 0, 0)\n\n        const newInstance = {\n            id: `instance-${taskId}-${Date.now()}`,\n            scheduledDate: formatDateKey(now),\n            scheduledTime: `${roundedTime.getHours().toString().padStart(2, '0')}:${roundedTime.getMinutes().toString().padStart(2, '0')}`,\n            duration: task.estimatedDuration || 60\n        }\n        updateTask(taskId, { instances: [newInstance], status: 'in_progress' })\n    }\n\n    const moveTaskToSmartGroup = (taskId: string, type: string) => {\n        const today = new Date()\n        let dueDate = ''\n        switch (type.toLowerCase()) {\n            case 'today': {\n                dueDate = formatDateKey(today)\n                break\n            }\n            case 'tomorrow': {\n                const tom = new Date(today)\n                tom.setDate(today.getDate() + 1)\n                dueDate = formatDateKey(tom)\n                break\n            }\n            case 'this weekend': {\n                const sat = new Date(today)\n                sat.setDate(today.getDate() + ((6 - today.getDay() + 7) % 7 || 7))\n                dueDate = formatDateKey(sat)\n                break\n            }\n            case 'this week': {\n                const sun = new Date(today)\n                sun.setDate(today.getDate() + ((7 - today.getDay()) % 7 || 7))\n                dueDate = formatDateKey(sun)\n                break\n            }\n            case 'later': {\n                // \"Later\" clears the due date - task is postponed indefinitely\n                dueDate = ''\n                break\n            }\n            default:\n                // BUG-016 FIX: Return early for unknown types to prevent clearing dueDate\n                console.warn(` [TASK-114] Unknown smart group type: \"${type}\" - no update performed`)\n                return\n        }\n        updateTask(taskId, { dueDate })\n    }\n\n    const moveTaskToDate = (taskId: string, dateColumn: string) => {\n        const task = _rawTasks.value.find(t => t.id === taskId)\n        if (!task) return\n        const today = new Date(); today.setHours(0, 0, 0, 0)\n        let target: Date | null = null\n        switch (dateColumn) {\n            case 'overdue': target = new Date(today); target.setDate(today.getDate() - 1); break\n            case 'today': target = today; break\n            case 'tomorrow': target = new Date(today); target.setDate(today.getDate() + 1); break\n            case 'thisWeek': target = new Date(today); target.setDate(today.getDate() + (7 - today.getDay())); break\n            case 'nextWeek': target = new Date(today); target.setDate(today.getDate() + ((8 - today.getDay()) % 7 || 7)); break\n            case 'later': target = new Date(today); target.setDate(today.getDate() + 30); break\n        }\n\n        const updates: Partial<Task> = { instances: [], isInInbox: false }\n        if (target) {\n            updates.instances = [{\n                id: `instance-${taskId}-${Date.now()}`,\n                scheduledDate: formatDateKey(target),\n                scheduledTime: '09:00',\n                duration: task.estimatedDuration || 60,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                isLater: dateColumn === 'later'\n            } as any]\n        }\n        updateTask(taskId, updates)\n    }\n\n    const unscheduleTask = (taskId: string) => {\n        updateTask(taskId, { instances: [], isInInbox: true })\n    }\n\n    const moveTaskToPriority = (taskId: string, priority: Task['priority'] | 'no_priority') => {\n        updateTask(taskId, { priority: priority === 'no_priority' ? null : priority })\n    }\n\n    const setActiveProject = (projectId: string | null) => {\n        projectStore.setActiveProject(projectId)\n        persistFilters()\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const setSmartView = (view: any) => {\n        activeSmartView.value = view\n        persistFilters()\n    }\n\n    const toggleHideDoneTasks = () => {\n        hideDoneTasks.value = !hideDoneTasks.value\n        persistFilters()\n    }\n\n    // TASK-076: View-specific done task toggles\n    const toggleCanvasDoneTasks = () => {\n        hideCanvasDoneTasks.value = !hideCanvasDoneTasks.value\n        persistFilters()\n    }\n\n    const toggleCalendarDoneTasks = () => {\n        hideCalendarDoneTasks.value = !hideCalendarDoneTasks.value\n        persistFilters()\n    }\n\n    const toggleCanvasOverdueTasks = () => {\n        hideCanvasOverdueTasks.value = !hideCanvasOverdueTasks.value\n        persistFilters()\n    }\n\n    const setActiveStatusFilter = (status: string | null) => {\n        activeStatusFilter.value = status\n        if (status) activeDurationFilter.value = null\n        persistFilters()\n    }\n\n    const toggleStatusFilter = (status: string) => {\n        setActiveStatusFilter(activeStatusFilter.value === status ? null : status)\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const setActiveDurationFilter = (duration: any) => {\n        activeDurationFilter.value = duration\n        if (duration) activeStatusFilter.value = null\n        persistFilters()\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const toggleDurationFilter = (duration: any) => {\n        setActiveDurationFilter(activeDurationFilter.value === duration ? null : duration)\n    }\n\n    const getTask = (taskId: string) => _rawTasks.value.find(t => t.id === taskId)\n\n    const getUncategorizedTaskCount = () => {\n        const { isUncategorizedTask } = useSmartViews()\n        return _rawTasks.value.filter(t => t.status !== 'done' && isUncategorizedTask(t)).length\n    }\n\n    const getNestedTasks = (parent: string | null = null) => _rawTasks.value.filter(t => t.parentTaskId === parent)\n    const getTaskChildren = (taskId: string) => _rawTasks.value.filter(t => t.parentTaskId === taskId)\n    const getTaskHierarchy = (taskId: string) => {\n        const list: Task[] = []\n        const visited = new Set<string>()\n        let curr: string | null = taskId\n\n        while (curr && !visited.has(curr)) {\n            visited.add(curr)\n            const t = getTask(curr)\n            if (!t) break\n            list.unshift(t)\n            curr = t.parentTaskId || null\n        }\n        return list\n    }\n    const isNestedTask = (id: string) => !!getTask(id)?.parentTaskId\n    const hasNestedTasks = (id: string) => _rawTasks.value.some(t => t.parentTaskId === id)\n\n    return {\n        createTask,\n        updateTask,\n        deleteTask,\n        permanentlyDeleteTask,\n        bulkDeleteTasks,\n        moveTask,\n        selectTask,\n        deselectTask,\n        clearSelection,\n        createSubtask,\n        updateSubtask,\n        deleteSubtask,\n        createTaskInstance,\n        updateTaskInstance,\n        deleteTaskInstance,\n        updateTaskWithSchedule,\n        startTaskNow,\n        moveTaskToSmartGroup,\n        moveTaskToDate,\n        unscheduleTask,\n        moveTaskToPriority,\n        moveTaskToProject: async (taskId: string, targetProjectId: string) => {\n            const task = _rawTasks.value.find(t => t.id === taskId)\n            if (task) {\n                manualOperationInProgress.value = true\n                try {\n                    task.projectId = targetProjectId\n                    task.updatedAt = new Date()\n                    console.log(`Task \"${task.title}\" moved to project \"${projectStore.getProjectDisplayName(targetProjectId)}\"`)\n                    await saveTasksToStorage(_rawTasks.value, `moveTaskToProject-${taskId}`)\n                } finally {\n                    manualOperationInProgress.value = false\n                }\n            }\n        },\n        setActiveProject,\n        setSmartView,\n        toggleHideDoneTasks,\n        toggleCanvasDoneTasks,\n        toggleCalendarDoneTasks,\n        toggleCanvasOverdueTasks,\n        setActiveStatusFilter,\n        toggleStatusFilter,\n        setActiveDurationFilter,\n        toggleDurationFilter,\n        getTask,\n        getUncategorizedTaskCount,\n        getNestedTasks,\n        getTaskChildren,\n        getTaskHierarchy,\n        isNestedTask,\n        hasNestedTasks\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/tasks/taskPersistence.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7634,7637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7634,7637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[740,743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[740,743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1257,1260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1257,1260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4954,4957],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4954,4957],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":240,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10480,10483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10480,10483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport type { Task } from '@/types/tasks'\nimport { useProjectStore } from '../projects'\nimport { validateBeforeSave, logTaskIdStats } from '@/utils/taskValidation'\nimport { logSupabaseTaskIdHistogram } from '@/utils/canvas/invariants'\n\nexport function useTaskPersistence(\n    // SAFETY: Named _rawTasks to indicate this is the raw array for load/save operations\n    _rawTasks: Ref<Task[]>,\n    hideDoneTasks: Ref<boolean>,\n    hideCanvasDoneTasks: Ref<boolean>,\n    hideCalendarDoneTasks: Ref<boolean>,\n    hideCanvasOverdueTasks: Ref<boolean>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    activeSmartView: Ref<any>,\n    activeStatusFilter: Ref<string | null>,\n    isLoadingFromDatabase: Ref<boolean>,\n    _manualOperationInProgress: Ref<boolean>,\n    isLoadingFilters: Ref<boolean>,\n    _syncInProgress: Ref<boolean>,\n    _runAllTaskMigrations: () => void\n) {\n    const projectStore = useProjectStore()\n    const FILTER_STORAGE_KEY = 'pomo-flow-filters'\n\n    interface PersistedFilterState {\n        activeProjectId: string | null\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        activeSmartView: any\n        activeStatusFilter: string | null\n        hideCanvasDoneTasks?: boolean\n        hideCalendarDoneTasks?: boolean\n        hideCanvasOverdueTasks?: boolean\n    }\n\n    // --- SQL PERSISTENCE ---\n\n    // -- Supabase Integration --\n    const { fetchTasks, saveTasks, deleteTask: deleteFromDB, bulkDeleteTasks: bulkDeleteFromDB } = useSupabaseDatabase()\n\n    // TASK-142 FIX: Guest Mode localStorage persistence for tasks\n    const GUEST_TASKS_KEY = 'pomoflow-guest-tasks'\n\n    const saveTasksToLocalStorage = () => {\n        try {\n            localStorage.setItem(GUEST_TASKS_KEY, JSON.stringify(_rawTasks.value))\n            console.log(` [GUEST-MODE] Saved ${_rawTasks.value.length} tasks to localStorage`)\n        } catch (e) {\n            console.error(' [GUEST-MODE] Failed to save tasks to localStorage:', e)\n        }\n    }\n\n    const loadTasksFromLocalStorage = (): Task[] => {\n        try {\n            const stored = localStorage.getItem(GUEST_TASKS_KEY)\n            if (stored) {\n                const tasks = JSON.parse(stored) as Task[]\n                console.log(` [GUEST-MODE] Loaded ${tasks.length} tasks from localStorage`)\n                return tasks\n            }\n        } catch (e) {\n            console.error(' [GUEST-MODE] Failed to load tasks from localStorage:', e)\n        }\n        return []\n    }\n\n    const deleteTaskFromStorage = async (taskId: string): Promise<void> => {\n        console.log(` [PERSISTENCE] deleteTaskFromStorage called for: ${taskId}`)\n\n        // NOTE: localStorage save happens in taskOperations.deleteTask AFTER splice\n        // Don't save here - the task is still in _rawTasks at this point!\n\n        // In Guest Mode, skip Supabase deletion\n        const { useAuthStore } = await import('@/stores/auth')\n        const authStore = useAuthStore()\n        if (!authStore.isAuthenticated) {\n            console.log(` [PERSISTENCE] Task ${taskId} will be removed from localStorage after splice`)\n            return\n        }\n\n        try {\n            await deleteFromDB(taskId)\n            console.log(` [PERSISTENCE] Task ${taskId} soft-deleted successfully`)\n        } catch (e) {\n            console.error(` [PERSISTENCE] Task deletion failed for ${taskId}:`, e)\n            throw e  // Re-throw so deleteTask in taskOperations knows it failed\n        }\n    }\n\n    // BUG-025 FIX: Atomic bulk delete for multiple tasks\n    const bulkDeleteTasksFromStorage = async (taskIds: string[]): Promise<void> => {\n        if (taskIds.length === 0) return\n        console.log(` [PERSISTENCE] bulkDeleteTasksFromStorage called for ${taskIds.length} tasks`)\n\n        // NOTE: localStorage save happens in caller AFTER array modification\n        // Don't save here - tasks are still in _rawTasks at this point!\n\n        // In Guest Mode, skip Supabase deletion\n        const { useAuthStore } = await import('@/stores/auth')\n        const authStore = useAuthStore()\n        if (!authStore.isAuthenticated) {\n            console.log(` [PERSISTENCE] ${taskIds.length} tasks will be removed from localStorage after splice`)\n            return\n        }\n\n        try {\n            await bulkDeleteFromDB(taskIds)\n            console.log(` [PERSISTENCE] ${taskIds.length} tasks soft-deleted atomically`)\n        } catch (e) {\n            console.error(` [PERSISTENCE] Bulk task deletion failed:`, e)\n            throw e // Re-throw so bulkDeleteTasks in taskOperations knows it failed\n        }\n    }\n\n    const saveTasksToStorage = async (tasksToSave: Task[], context: string = 'unknown'): Promise<void> => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof window !== 'undefined' && (window as any).__STORYBOOK__) return\n\n        // Always save to localStorage for persistence across refreshes (guest mode)\n        saveTasksToLocalStorage()\n\n        try {\n            // Validation\n            const validation = validateBeforeSave(tasksToSave)\n            if (validation.blockedTasks.length > 0) {\n                console.error(` [PRE-SAVE] Blocked ${validation.blockedTasks.length} tasks with invalid IDs (${context})`)\n            }\n\n            const validTasksToSave = validation.validTasks\n            if (validTasksToSave.length === 0) return\n\n            logTaskIdStats(validTasksToSave, `save-${context}`)\n\n            await saveTasks(validTasksToSave)\n            // console.debug(` [SUPABASE] Saved ${validTasksToSave.length} tasks (${context})`)\n\n        } catch (_e) {\n            // Supabase failed or skipped (guest mode) - localStorage backup is still saved\n            console.debug(` [PERSISTENCE] Supabase skipped/failed - localStorage backup saved (${context})`)\n        }\n    }\n\n    const saveSpecificTasks = saveTasksToStorage\n\n    // --- LOAD LOGIC ---\n\n    const loadFromDatabase = async () => {\n        try {\n            isLoadingFromDatabase.value = true\n\n            // Guest mode: load from localStorage (persists across refreshes)\n            const { useAuthStore } = await import('@/stores/auth')\n            const authStore = useAuthStore()\n            if (!authStore.isAuthenticated) {\n                const localTasks = loadTasksFromLocalStorage()\n                console.log(` [GUEST-MODE] Loaded ${localTasks.length} tasks from localStorage`)\n                _rawTasks.value = localTasks\n                return\n            }\n\n            const loadedTasks = await fetchTasks()\n\n            // TASK-142: Position integrity validation - detect invalid canvas positions early\n            const tasksWithPositions = loadedTasks.filter(t => t.canvasPosition)\n            const invalidTasks = tasksWithPositions.filter(t =>\n                !Number.isFinite(t.canvasPosition?.x) ||\n                !Number.isFinite(t.canvasPosition?.y)\n            )\n            if (invalidTasks.length > 0) {\n                console.error(` [INTEGRITY] ${invalidTasks.length} tasks have invalid canvas positions:`,\n                    invalidTasks.map(t => `${t.title}: ${JSON.stringify(t.canvasPosition)}`))\n            }\n\n            // BUG-169 FIX: Safety guard - don't overwrite existing tasks with empty array\n            // This prevents data loss from race conditions during auth propagation\n            if (loadedTasks.length === 0 && _rawTasks.value.length > 0) {\n                const sessionStart = typeof window !== 'undefined' ? (window as any).PomoFlowSessionStart || 0 : 0\n                const timeSinceSessionStart = Date.now() - sessionStart\n\n                // In the first 10 seconds, don't overwrite existing tasks with empty\n                if (timeSinceSessionStart < 10000) {\n                    console.warn(` [TASK-LOAD] BLOCKED empty overwrite - ${_rawTasks.value.length} existing tasks would be lost (session ${timeSinceSessionStart}ms old)`)\n                    return\n                }\n\n                console.warn(` [TASK-LOAD] Supabase returned 0 tasks but ${_rawTasks.value.length} exist locally - proceeding with empty (session ${timeSinceSessionStart}ms old)`)\n            }\n\n            // ================================================================\n            // DUPLICATE DETECTION - Supabase Load Layer (AUTHORITATIVE)\n            // ================================================================\n            // Uses centralized helper for consistent detection across all layers\n            // A duplicate here means the bug is at the database level\n            logSupabaseTaskIdHistogram(loadedTasks, 'loadFromDatabase')\n\n            _rawTasks.value = loadedTasks\n            console.log(` [SUPABASE] Loaded ${loadedTasks.length} tasks (${tasksWithPositions.length} with canvas positions)`)\n\n        } catch (error) {\n            console.error(' [SUPABASE] Load failed:', error)\n        } finally {\n            isLoadingFromDatabase.value = false\n        }\n    }\n\n    // --- FILTERS ---\n    // (Kept as localStorage only, same as before)\n\n    const loadFiltersFromLocalStorage = () => {\n        try {\n            const localSaved = localStorage.getItem(FILTER_STORAGE_KEY)\n            if (localSaved) {\n                const state: PersistedFilterState = JSON.parse(localSaved)\n                if (state.activeProjectId && !projectStore.projects.find(p => p.id === state.activeProjectId)) {\n                    state.activeProjectId = null\n                }\n                projectStore.setActiveProject(state.activeProjectId)\n                activeSmartView.value = state.activeSmartView\n                activeStatusFilter.value = state.activeStatusFilter\n                hideCanvasDoneTasks.value = state.hideCanvasDoneTasks ?? true\n                hideCalendarDoneTasks.value = state.hideCalendarDoneTasks ?? false\n                hideCanvasOverdueTasks.value = state.hideCanvasOverdueTasks ?? false\n            }\n        } catch (_e) {\n            console.warn('Failed to load filters from localStorage:', _e)\n        }\n    }\n\n    const loadPersistedFilters = async () => {\n        isLoadingFilters.value = true\n        try {\n            loadFiltersFromLocalStorage()\n        } finally {\n            isLoadingFilters.value = false\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let persistTimeout: any = null\n    const persistFilters = async () => {\n        if (isLoadingFilters.value) return\n        if (persistTimeout) clearTimeout(persistTimeout)\n        persistTimeout = setTimeout(async () => {\n            const state: PersistedFilterState = {\n                activeProjectId: projectStore.activeProjectId,\n                activeSmartView: activeSmartView.value,\n                activeStatusFilter: activeStatusFilter.value,\n                hideCanvasDoneTasks: hideCanvasDoneTasks.value,\n                hideCalendarDoneTasks: hideCalendarDoneTasks.value,\n                hideCanvasOverdueTasks: hideCanvasOverdueTasks.value\n            }\n            localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(state))\n        }, 500)\n    }\n\n    // --- EXPORTS ---\n\n    return {\n        saveTasksToStorage,\n        saveSpecificTasks,\n        deleteTaskFromStorage,\n        bulkDeleteTasksFromStorage,  // BUG-025: Atomic bulk delete\n        loadFromDatabase,\n        loadPersistedFilters,\n        persistFilters,\n        importTasksFromJSON: async () => {\n            // Disabled / TBD\n        },\n        importFromRecoveryTool: async () => {\n            // Disabled\n        },\n        recoverSoftDeletedTasks: async () => 0, // TBD: SQL Implementation needed later\n        importTasks: async (tasksToImport: Task[]) => {\n            // Basic import logic reused\n            if (!tasksToImport.length) return\n            const existingIds = new Set(_rawTasks.value.map(t => t.id))\n            const newTasks = tasksToImport.filter(t => !existingIds.has(t.id))\n            if (newTasks.length > 0) {\n                _rawTasks.value.push(...newTasks)\n                await saveTasksToStorage(_rawTasks.value, 'import-tool')\n            }\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/tasks/taskStates.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3926,3929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3926,3929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, toRef, computed, watch } from 'vue'\nimport { useProjectStore } from '../projects'\nimport { useUIStore } from '../ui' // Import UI Store\nimport { useTaskMigrations } from '@/composables/tasks/useTaskMigrations'\nimport { useTaskFiltering } from '@/composables/tasks/useTaskFiltering'\nimport { assertNoDuplicateIds } from '@/utils/canvas/invariants'\nimport type { Task } from '@/types/tasks'\n\nexport function useTaskStates() {\n    const projectStore = useProjectStore()\n    const uiStore = useUIStore() // Init UI Store\n\n    // State - Start with empty tasks array\n    // SAFETY: Named _rawTasks to discourage direct access - use filteredTasks (exported as 'tasks') instead\n    const _rawTasks = ref<Task[]>([])\n\n    // ================================================================\n    // DUPLICATE DETECTION - Store Level Watcher (Dev Only) (AUTHORITATIVE)\n    // ================================================================\n    // This watches for any moment when _rawTasks contains duplicates\n    // Helps identify if duplication happens via push, splice, or assignment\n    // Uses assertNoDuplicateIds for consistent detection across layers\n    if (import.meta.env.DEV) {\n        watch(_rawTasks, (newTasks) => {\n            const checkResult = assertNoDuplicateIds(newTasks, '_rawTasks store')\n\n            if (checkResult.hasDuplicates) {\n                // Get more details about the duplicate tasks\n                const duplicateIds = checkResult.duplicates.map(d => d.id)\n                const duplicateTasks = newTasks\n                    .filter(t => duplicateIds.includes(t.id))\n                    .slice(0, 5)\n                    .map(t => ({ id: t.id.slice(0, 8), title: t.title?.slice(0, 20) }))\n\n                console.error('[STORE-DUPLICATE-DETECTED]', {\n                    duplicates: checkResult.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                    totalCount: checkResult.totalCount,\n                    uniqueIdCount: checkResult.uniqueIdCount,\n                    duplicateTasks,\n                    snapshotSize: newTasks.length\n                })\n            }\n        }, { deep: true }) // TASK-260: Changed to deep: true to catch mutations, not just array replacement\n    }\n\n    // State for filtering\n    const activeSmartView = ref<'today' | 'week' | 'uncategorized' | 'unscheduled' | 'in_progress' | 'all_active' | 'quick' | 'short' | 'medium' | 'long' | 'unestimated' | null>(null)\n    const activeStatusFilter = ref<string | null>(null)\n    const activeDurationFilter = ref<'quick' | 'short' | 'medium' | 'long' | 'unestimated' | null>(null)\n\n    // TASK-076: Separate done filters for Canvas vs Calendar views\n    // Default to true - canvas loads with completed tasks hidden\n    const hideCanvasDoneTasks = ref(true)\n    const hideCalendarDoneTasks = ref(false)\n\n    // TASK-082: Hide overdue tasks on canvas (tasks with due date before today)\n    const hideCanvasOverdueTasks = ref(false)\n\n    // Backward compatibility computed - used by useTaskFiltering and legacy code\n    const hideDoneTasks = computed({\n        get: () => hideCanvasDoneTasks.value || hideCalendarDoneTasks.value,\n        set: (val: boolean) => {\n            hideCanvasDoneTasks.value = val\n            hideCalendarDoneTasks.value = val\n        }\n    })\n\n    // Initialize extracted composables\n    const { runAllTaskMigrations } = useTaskMigrations(_rawTasks)\n\n    const {\n        filteredTasks,\n        tasksByStatus,\n        filteredTasksWithCanvasPosition,\n        smartViewTaskCounts,\n        getProjectTaskCount,\n        totalTasks,\n        nonDoneTaskCount,\n        completedTasks,\n        totalPomodoros,\n        doneTasksForColumn,\n        tasksWithCanvasPosition,\n        calendarFilteredTasks\n    } = useTaskFiltering(\n        _rawTasks,\n        toRef(projectStore, 'projects'),\n        toRef(projectStore, 'activeProjectId'),\n        activeSmartView as any,\n        activeStatusFilter,\n        activeDurationFilter,\n        hideDoneTasks,\n        hideCalendarDoneTasks,\n        toRef(uiStore, 'selectedProjectIds') // Pass global multi-select state\n    )\n\n    // Flags to manage store state\n    const isLoadingFromDatabase = ref(false)\n    const manualOperationInProgress = ref(false)\n    const isLoadingFilters = ref(false)\n\n    // BUG-057 FIX: Flag to prevent save watchers during sync updates\n    // When true, store mutations should NOT trigger saves back to PouchDB\n    const syncInProgress = ref(false)\n\n    const currentView = ref('board')\n    const selectedTaskIds = ref<string[]>([])\n\n    return {\n        // SAFETY: Export filteredTasks as 'tasks' - this is the safe default for components\n        // Use _rawTasks only for internal operations (load, save, sync, mutations)\n        tasks: filteredTasks,\n        _rawTasks,\n        activeSmartView,\n        activeStatusFilter,\n        activeDurationFilter,\n        hideDoneTasks,\n        hideCanvasDoneTasks,\n        hideCalendarDoneTasks,\n        hideCanvasOverdueTasks,\n        runAllTaskMigrations,\n        filteredTasks, // Keep for backward compatibility\n        tasksByStatus,\n        filteredTasksWithCanvasPosition,\n        smartViewTaskCounts,\n        getProjectTaskCount,\n        totalTasks,\n        nonDoneTaskCount,\n        completedTasks,\n        totalPomodoros,\n        doneTasksForColumn,\n        tasksWithCanvasPosition,\n        calendarFilteredTasks,\n        isLoadingFromDatabase,\n        manualOperationInProgress,\n        isLoadingFilters,\n        syncInProgress,\n        currentView,\n        selectedTaskIds\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/timer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5661,5664],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5661,5664],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":309,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10750,10753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10750,10753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":318,"column":18,"nodeType":"BlockStatement","messageId":"unexpected","endLine":318,"endColumn":21,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[11297,11298],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":324,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":324,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11461,11464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11461,11464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":333,"column":18,"nodeType":"BlockStatement","messageId":"unexpected","endLine":333,"endColumn":21,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[12008,12009],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":360,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12856,12859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12856,12859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia'\nimport { ref, computed, reactive, onUnmounted } from 'vue'\nimport { useTaskStore } from './tasks'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { useSettingsStore } from './settings'\nimport { formatTime } from '@/utils/timer/formatTime'\nimport { getCrossTabSync } from '@/composables/useCrossTabSync'\nimport { useIntervalFn } from '@vueuse/core'\n\n/**\n * Timer Session Interface\n */\nexport interface PomodoroSession {\n  id: string\n  taskId: string\n  startTime: Date\n  duration: number\n  remainingTime: number\n  isActive: boolean\n  isPaused: boolean\n  isBreak: boolean\n  completedAt?: Date\n}\n\nexport const useTimerStore = defineStore('timer', () => {\n  // Initialize database composable\n  const {\n    fetchActiveTimerSession,\n    saveActiveTimerSession,\n    initRealtimeSubscription\n  } = useSupabaseDatabase()\n\n  const settingsStore = useSettingsStore()\n  const taskStore = useTaskStore()\n\n  // Constants for device synchronization\n  const DEVICE_HEARTBEAT_INTERVAL_MS = 10000 // 10 seconds\n  const DEVICE_LEADER_TIMEOUT_MS = 30000 // 30 seconds\n\n  // Bridge to settingsStore for backward compatibility\n  const settings = reactive({\n    get workDuration() { return settingsStore.workDuration },\n    set workDuration(val) { settingsStore.updateSetting('workDuration', val) },\n    get shortBreakDuration() { return settingsStore.shortBreakDuration },\n    set shortBreakDuration(val) { settingsStore.updateSetting('shortBreakDuration', val) },\n    get longBreakDuration() { return settingsStore.longBreakDuration },\n    set longBreakDuration(val) { settingsStore.updateSetting('longBreakDuration', val) },\n    get autoStartBreaks() { return settingsStore.autoStartBreaks },\n    set autoStartBreaks(val) { settingsStore.updateSetting('autoStartBreaks', val) },\n    get autoStartPomodoros() { return settingsStore.autoStartPomodoros },\n    set autoStartPomodoros(val) { settingsStore.updateSetting('autoStartPomodoros', val) },\n    get playNotificationSounds() { return settingsStore.playNotificationSounds },\n    set playNotificationSounds(val) { settingsStore.updateSetting('playNotificationSounds', val) }\n  })\n\n  // State\n  const currentSession = ref<PomodoroSession | null>(null)\n  const completedSessions = ref<PomodoroSession[]>([])\n  const sessions = computed(() => completedSessions.value)\n  const isLeader = ref(false)\n  const isDeviceLeader = ref(false)\n  const deviceId = crypto.randomUUID()\n\n  // Cross-tab sync integration\n  const crossTabSync = getCrossTabSync()\n\n  // Intervals\n  const { pause: pauseTimerInterval, resume: resumeTimerInterval } = useIntervalFn(() => {\n    if (currentSession.value && currentSession.value.isActive && !currentSession.value.isPaused) {\n      currentSession.value.remainingTime -= 1\n      if (currentSession.value.remainingTime % 5 === 0 && isDeviceLeader.value) broadcastSession()\n      if (currentSession.value.remainingTime <= 0) completeSession()\n    }\n  }, 1000, { immediate: false })\n\n  const { pause: pauseHeartbeat, resume: resumeHeartbeat } = useIntervalFn(async () => {\n    if (!currentSession.value || !isDeviceLeader.value) { pauseHeartbeat(); return }\n    await saveTimerSessionWithLeadership()\n  }, DEVICE_HEARTBEAT_INTERVAL_MS, { immediate: false })\n\n  // Computed\n  const isTimerActive = computed(() => currentSession.value?.isActive || false)\n  const isPaused = computed(() => currentSession.value?.isPaused || false)\n  const currentTaskId = computed(() => currentSession.value?.taskId || null)\n\n  const displayTime = computed(() => {\n    if (!currentSession.value) {\n      return formatTime(settings.workDuration)\n    }\n    return formatTime(currentSession.value.remainingTime)\n  })\n\n  const currentTaskName = computed(() => {\n    const session = currentSession.value\n    if (!session?.taskId) return null\n    if (session.isBreak) return session.taskId === 'break' ? 'Break Time' : 'Short Break'\n    if (session.taskId === 'general') return 'Focus Session'\n    const task = taskStore.tasks.find(t => t.id === session.taskId)\n    return task?.title || 'Unknown Task'\n  })\n\n  const sessionTypeIcon = computed(() => currentSession.value?.isBreak ? '' : '')\n\n  const tabDisplayTime = computed(() => {\n    if (!currentSession.value) return ''\n    return formatTime(currentSession.value.remainingTime)\n  })\n\n  const sessionStatusText = computed(() => {\n    const session = currentSession.value\n    if (!session) return ''\n    if (session.isBreak) return session.taskId === 'break' ? 'Short Break' : 'Long Break'\n    if (session.taskId === 'general') return 'Focus Session'\n    const task = taskStore.tasks.find(t => t.id === session.taskId)\n    return task?.title || 'Work Session'\n  })\n\n  const timerPercentage = computed(() => {\n    if (!currentSession.value) return 0\n    const totalDuration = currentSession.value.duration\n    const remainingTime = currentSession.value.remainingTime\n    return Math.round(((totalDuration - remainingTime) / totalDuration) * 100)\n  })\n\n  const faviconStatus = computed(() => {\n    if (!currentSession.value) return 'inactive'\n    return currentSession.value.isBreak ? 'break' : 'work'\n  })\n\n  const tabTitleWithTimer = computed(() => {\n    const baseTitle = 'Pomo-Flow'\n    if (!currentSession.value || !isTimerActive.value) return baseTitle\n    const time = tabDisplayTime.value\n    const icon = currentSession.value.isBreak ? '' : ''\n    return `${icon} ${time} | ${baseTitle}`\n  })\n\n  // Leadership Helpers\n  const broadcastSession = () => {\n    if (currentSession.value) {\n      crossTabSync.broadcastTimerSession(currentSession.value)\n    }\n  }\n\n  const handleRemoteTimerUpdate = (newDoc: any) => {\n    if (!newDoc) {\n      currentSession.value = null\n      pauseTimerInterval()\n      return\n    }\n\n    if (isDeviceLeader.value && newDoc.device_leader_id === deviceId) return\n\n    const lastSeen = new Date(newDoc.device_leader_last_seen).getTime()\n    if (Date.now() - lastSeen < DEVICE_LEADER_TIMEOUT_MS) {\n      isDeviceLeader.value = false\n      pauseHeartbeat()\n\n      const session = {\n        id: newDoc.id,\n        taskId: newDoc.task_id,\n        startTime: new Date(newDoc.start_time),\n        duration: newDoc.duration,\n        remainingTime: newDoc.remaining_time,\n        isActive: newDoc.is_active,\n        isPaused: newDoc.is_paused,\n        isBreak: newDoc.is_break,\n        completedAt: newDoc.completed_at ? new Date(newDoc.completed_at) : undefined,\n        deviceLeaderId: newDoc.device_leader_id,\n        deviceLeaderLastSeen: lastSeen\n      }\n\n      // Calculate adjusted remaining time based on drift\n      const now = Date.now()\n      const drift = Math.floor((now - lastSeen) / 1000)\n      if (session.isActive && !session.isPaused) {\n        session.remainingTime = Math.max(0, session.remainingTime - drift)\n      }\n\n      currentSession.value = session as PomodoroSession\n      if (session.isActive && !session.isPaused) {\n        resumeTimerInterval()\n      } else {\n        pauseTimerInterval()\n      }\n    }\n  }\n\n  const saveTimerSessionWithLeadership = async () => {\n    if (!currentSession.value) return\n    if (currentSession.value.id.length < 10) {\n      currentSession.value.id = crypto.randomUUID()\n    }\n    await saveActiveTimerSession(currentSession.value, deviceId)\n  }\n\n  const checkForActiveDeviceLeader = async (): Promise<boolean> => {\n    try {\n      const existing = await fetchActiveTimerSession()\n      if (existing?.deviceLeaderId && existing.deviceLeaderId !== deviceId) {\n        if (Date.now() - (existing.deviceLeaderLastSeen || 0) < DEVICE_LEADER_TIMEOUT_MS) return true\n      }\n      return false\n    } catch (_e) { return false }\n  }\n\n  // Timer Control Actions\n  const startTimer = async (taskId: string, duration?: number, isBreak: boolean = false) => {\n    if (await checkForActiveDeviceLeader()) return\n\n    if (!crossTabSync.claimTimerLeadership()) return\n    isLeader.value = true\n\n    const sessionDuration = duration || settings.workDuration\n    currentSession.value = {\n      id: crypto.randomUUID(),\n      taskId,\n      startTime: new Date(),\n      duration: sessionDuration,\n      remainingTime: sessionDuration,\n      isActive: true,\n      isPaused: false,\n      isBreak\n    }\n\n    isDeviceLeader.value = true\n    resumeHeartbeat()\n    broadcastSession()\n    await saveTimerSessionWithLeadership()\n    playStartSound()\n    resumeTimerInterval()\n  }\n\n  const pauseTimer = () => {\n    if (currentSession.value) {\n      currentSession.value.isPaused = true\n      pauseTimerInterval()\n      broadcastSession()\n    }\n  }\n\n  const resumeTimer = () => {\n    if (currentSession.value) {\n      currentSession.value.isPaused = false\n      resumeTimerInterval()\n      broadcastSession()\n    }\n  }\n\n  const stopTimer = async () => {\n    pauseTimerInterval()\n    pauseHeartbeat()\n    isDeviceLeader.value = false\n    if (currentSession.value) {\n      completedSessions.value.push({ ...currentSession.value, isActive: false, completedAt: new Date() })\n      currentSession.value = null\n      broadcastSession()\n    }\n  }\n\n  const completeSession = async () => {\n    const session = currentSession.value\n    if (!session) return\n    pauseTimerInterval()\n    pauseHeartbeat()\n\n    const completedSession = { ...session, isActive: false, completedAt: new Date() }\n    completedSessions.value.push(completedSession)\n\n    const wasBreak = session.isBreak\n    const lastTaskId = session.taskId\n\n    if (session.taskId && session.taskId !== 'general' && !session.isBreak) {\n      const task = taskStore.tasks.find(t => t.id === session.taskId)\n      if (task) {\n        const newCount = (task.completedPomodoros || 0) + 1\n        taskStore.updateTask(session.taskId, {\n          completedPomodoros: newCount,\n          progress: Math.min(100, Math.round((newCount / (task.estimatedPomodoros || 1)) * 100))\n        })\n      }\n    }\n\n    currentSession.value = null\n    broadcastSession()\n    playEndSound()\n\n    if ('Notification' in window && Notification.permission === 'granted') {\n      new Notification(`Session Complete! `, {\n        body: wasBreak ? 'Ready to work?' : 'Time for a break!',\n        icon: '/favicon.ico'\n      })\n    }\n\n    if (settings.autoStartBreaks && !wasBreak) {\n      isDeviceLeader.value = false\n      setTimeout(() => startTimer('break', settings.shortBreakDuration, true), 2000)\n    } else if (settings.autoStartPomodoros && wasBreak && lastTaskId !== 'break') {\n      isDeviceLeader.value = false\n      setTimeout(() => startTimer(lastTaskId, settings.workDuration, false), 2000)\n    } else {\n      isDeviceLeader.value = false\n    }\n  }\n\n  const playStartSound = () => {\n    if (!settings.playNotificationSounds) return\n    try {\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)()\n      const osc = audioContext.createOscillator()\n      const gain = audioContext.createGain()\n      osc.connect(gain); gain.connect(audioContext.destination)\n      osc.frequency.setValueAtTime(523, audioContext.currentTime)\n      osc.frequency.setValueAtTime(659, audioContext.currentTime + 0.1)\n      gain.gain.setValueAtTime(0.1, audioContext.currentTime)\n      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3)\n      osc.start(); osc.stop(audioContext.currentTime + 0.3)\n    } catch (_e) { }\n  }\n\n  const playEndSound = () => {\n    if (!settings.playNotificationSounds) return\n    try {\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)()\n      const osc = audioContext.createOscillator()\n      const gain = audioContext.createGain()\n      osc.connect(gain); gain.connect(audioContext.destination)\n      osc.frequency.setValueAtTime(783, audioContext.currentTime)\n      osc.frequency.setValueAtTime(523, audioContext.currentTime + 0.3)\n      gain.gain.setValueAtTime(0.1, audioContext.currentTime)\n      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6)\n      osc.start(); osc.stop(audioContext.currentTime + 0.6)\n    } catch (_e) { }\n  }\n\n  const requestNotificationPermission = async () => {\n    if ('Notification' in window && Notification.permission === 'default') {\n      await Notification.requestPermission()\n    }\n    return Notification.permission === 'granted'\n  }\n\n  const initializeStore = async () => {\n    const saved = await fetchActiveTimerSession()\n    if (saved && saved.isActive) {\n      currentSession.value = { ...saved, startTime: new Date(saved.startTime) }\n      if (saved.deviceLeaderId === deviceId) {\n        isDeviceLeader.value = true\n        resumeHeartbeat()\n        resumeTimerInterval()\n      } else {\n        isDeviceLeader.value = false\n        // Followers should also update their local countdown\n        resumeTimerInterval()\n      }\n    }\n\n    // Set cross-tab callbacks\n    crossTabSync.setTimerCallbacks({\n      onSessionUpdate: (session: any) => {\n        if (!isDeviceLeader.value) {\n          currentSession.value = session\n          if (session?.isActive && !session?.isPaused) {\n            resumeTimerInterval()\n          } else {\n            pauseTimerInterval()\n          }\n        }\n      },\n      onBecomeLeader: () => {\n        isLeader.value = true\n        isDeviceLeader.value = true\n        resumeHeartbeat()\n      },\n      onLoseLeadership: () => {\n        isLeader.value = false\n        isDeviceLeader.value = false\n        pauseHeartbeat()\n      }\n    })\n\n    initRealtimeSubscription(() => { }, () => { }, handleRemoteTimerUpdate)\n  }\n\n  // Cleanup\n  onUnmounted(() => {\n    pauseTimerInterval()\n    pauseHeartbeat()\n  })\n\n  initializeStore()\n\n  return {\n    currentSession, completedSessions, sessions, settings,\n    isLeader, isDeviceLeader,\n    isTimerActive, isPaused, currentTaskId, displayTime, currentTaskName,\n    sessionTypeIcon, tabDisplayTime, sessionStatusText,\n    timerPercentage, faviconStatus, tabTitleWithTimer,\n    startTimer, pauseTimer, resumeTimer, stopTimer, completeSession,\n    requestNotificationPermission, playStartSound, playEndSound\n  }\n}, {\n  share: { enable: false }\n})","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/stores/ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/AllTasksView.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Eye' is defined but never used. Allowed unused vars must match /^_/u.","line":89,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'EyeOff' is defined but never used. Allowed unused vars must match /^_/u.","line":89,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":21}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"all-tasks-view\">\n    <!-- View Controls -->\n    <ViewControls\n      v-model:view-type=\"viewType\"\n      v-model:density=\"density\"\n      v-model:sort-by=\"sortBy\"\n      :filter-status=\"filterStatus\"\n      :hide-done-tasks=\"hideDoneTasks\"\n      @update:filter-status=\"taskStore.setActiveStatusFilter\"\n      @update:hide-done-tasks=\"handleToggleDoneTasksFromControl\"\n      @expand-all=\"handleExpandAll\"\n      @collapse-all=\"handleCollapseAll\"\n    />\n\n    <!-- Content Area -->\n\n    <!-- Content Area -->\n    <div class=\"tasks-container\">\n      <!-- Table Mode -->\n      <TaskTable\n        v-if=\"viewType === 'table'\"\n        :tasks=\"sortedTasks\"\n        :density=\"density\"\n        @select=\"handleSelectTask\"\n        @start-timer=\"handleStartTimer\"\n        @edit=\"handleEditTask\"\n        @context-menu=\"handleContextMenu\"\n        @update-task=\"handleUpdateTask\"\n      />\n\n      <!-- List Mode -->\n      <TaskList\n        v-else\n        ref=\"taskListRef\"\n        :tasks=\"sortedTasks\"\n        :empty-message=\"getEmptyMessage()\"\n        @select=\"handleSelectTask\"\n        @toggle-complete=\"handleToggleComplete\"\n        @start-timer=\"handleStartTimer\"\n        @edit=\"handleEditTask\"\n        @context-menu=\"handleContextMenu\"\n        @move-task=\"handleMoveTask\"\n        @update-task=\"handleUpdateTask\"\n      />\n    </div>\n\n    <!-- Task Edit Modal -->\n    <TaskEditModal\n      :is-open=\"showEditModal\"\n      :task=\"selectedTask\"\n      @close=\"closeEditModal\"\n    />\n\n    <!-- Task Context Menu -->\n    <TaskContextMenu\n      :is-visible=\"showContextMenu\"\n      :x=\"contextMenuX\"\n      :y=\"contextMenuY\"\n      :task=\"contextMenuTask\"\n      @close=\"closeContextMenu\"\n      @edit=\"handleEditTask\"\n      @confirm-delete=\"handleConfirmDelete\"\n    />\n\n    <!-- Confirmation Modal -->\n    <ConfirmationModal\n      :is-open=\"showConfirmModal\"\n      title=\"Delete Task\"\n      message=\"Are you sure you want to delete this task? You can press Ctrl+Z to undo.\"\n      confirm-text=\"Delete\"\n      @confirm=\"confirmDeleteTask\"\n      @cancel=\"cancelDeleteTask\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport ViewControls, { type ViewType, type DensityType } from '@/components/layout/ViewControls.vue'\nimport TaskTable from '@/components/tasks/TaskTable.vue'\nimport TaskList from '@/components/tasks/TaskList.vue'\nimport TaskEditModal from '@/components/tasks/TaskEditModal.vue'\nimport TaskContextMenu from '@/components/tasks/TaskContextMenu.vue'\nimport ConfirmationModal from '@/components/common/ConfirmationModal.vue'\nimport { Eye, EyeOff } from 'lucide-vue-next'\nimport type { Task } from '@/stores/tasks'\n\n// Stores\nconst taskStore = useTaskStore()\nconst timerStore = useTimerStore()\n\n// Extract only reactive state refs, not computed properties\n// Computed properties stay on the store to maintain full reactivity chain\nconst { hideDoneTasks } = storeToRefs(taskStore)\n\n// View State (local component state, no Pinia store needed)\nconst viewType = ref<ViewType>('list')\nconst density = ref<DensityType>('comfortable')\nconst sortBy = ref('dueDate')\n// Use global status filter directly from store (maintains reactivity)\nconst filterStatus = computed(() => taskStore.activeStatusFilter || 'all')\n\n// Component Refs\nconst taskListRef = ref<InstanceType<typeof TaskList> | null>(null)\n\n// Modal State\nconst showEditModal = ref(false)\nconst selectedTask = ref<Task | null>(null)\nconst showContextMenu = ref(false)\nconst contextMenuX = ref(0)\nconst contextMenuY = ref(0)\nconst contextMenuTask = ref<Task | null>(null)\nconst showConfirmModal = ref(false)\nconst taskToDelete = ref<string | null>(null)\n\n// Computed Tasks - Access store's computed directly (maintains full reactivity)\nconst filteredTasks = computed(() => {\n  let tasks = taskStore.filteredTasks\n  \n  // TASK-076: Apply view-specific 'Hide Done' filter locally\n  if (hideDoneTasks.value) {\n    tasks = tasks.filter(t => t.status !== 'done')\n  }\n\n  console.log(' [AllTasksView] filteredTasks computed:', {\n    taskCount: tasks.length,\n    hideDoneTasks: hideDoneTasks.value,\n    tasks: tasks.slice(0, 3), // Show first 3 tasks for debugging\n    storeInitialized: taskStore.tasks.length > 0,\n    allTasksCount: taskStore.tasks.length\n  })\n  return tasks\n})\n\nconst sortedTasks = computed(() => {\n  const tasks = [...filteredTasks.value]\n  console.log(' [AllTasksView] sortedTasks computed:', {\n    beforeSort: tasks.length,\n    sortBy: sortBy.value,\n    viewType: viewType.value\n  })\n\n  switch (sortBy.value) {\n    case 'dueDate':\n      return tasks.sort((a, b) => {\n        if (!a.dueDate) return 1\n        if (!b.dueDate) return -1\n        return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()\n      })\n    case 'priority': {\n      const priorityOrder = { high: 0, medium: 1, low: 2 }\n      return tasks.sort((a, b) => {\n        const aPriority = a.priority ? priorityOrder[a.priority] : 3\n        const bPriority = b.priority ? priorityOrder[b.priority] : 3\n        return aPriority - bPriority\n      })\n    }\n    case 'title':\n      return tasks.sort((a, b) => a.title.localeCompare(b.title))\n    case 'created':\n      return tasks.sort((a, b) => {\n        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n      })\n    default:\n      return tasks\n  }\n})\n\n// Event Handlers\nconst handleSelectTask = (taskId: string) => {\n  taskStore.selectTask(taskId)\n}\n\nconst handleStartTimer = (taskId: string) => {\n  timerStore.startTimer(taskId, timerStore.settings.workDuration, false)\n}\n\nconst handleEditTask = (taskId: string) => {\n  const task = taskStore.tasks.find(t => t.id === taskId)\n  if (task) {\n    selectedTask.value = task\n    showEditModal.value = true\n  }\n}\n\nconst closeEditModal = () => {\n  showEditModal.value = false\n  selectedTask.value = null\n}\n\nconst handleContextMenu = (event: MouseEvent, task: Task) => {\n  contextMenuX.value = event.clientX\n  contextMenuY.value = event.clientY\n  contextMenuTask.value = task\n  showContextMenu.value = true\n}\n\nconst closeContextMenu = () => {\n  showContextMenu.value = false\n  contextMenuTask.value = null\n}\n\nconst handleToggleComplete = (taskId: string) => {\n  const task = taskStore.tasks.find(t => t.id === taskId)\n  if (task) {\n    const newStatus = task.status === 'done' ? 'planned' : 'done'\n    taskStore.updateTask(taskId, { status: newStatus })\n  }\n}\n\nconst handleUpdateTask = (taskId: string, updates: Partial<Task>) => {\n  taskStore.updateTask(taskId, updates)\n}\n\nconst handleConfirmDelete = (taskId: string) => {\n  taskToDelete.value = taskId\n  showConfirmModal.value = true\n}\n\nconst confirmDeleteTask = () => {\n  if (taskToDelete.value) {\n    taskStore.deleteTask(taskToDelete.value)\n    taskToDelete.value = null\n  }\n  showConfirmModal.value = false\n}\n\nconst cancelDeleteTask = () => {\n  taskToDelete.value = null\n  showConfirmModal.value = false\n}\n\nconst getEmptyMessage = () => {\n  if (taskStore.activeStatusFilter && taskStore.activeStatusFilter !== null) {\n    return `No tasks with status \"${taskStore.activeStatusFilter}\"`\n  }\n  return 'Create your first task to get started'\n}\n\nconst handleExpandAll = () => {\n  taskListRef.value?.expandAll()\n}\n\nconst handleCollapseAll = () => {\n  taskListRef.value?.collapseAll()\n}\n\nconst handleMoveTask = (taskId: string, targetProjectId: string | null, targetParentId: string | null) => {\n  // Move task to be a subtask of another task\n  taskStore.updateTask(taskId, {\n    projectId: targetProjectId || undefined,\n    parentTaskId: targetParentId || undefined\n  })\n}\n\n// Debug function to test toggle functionality\nconst handleToggleDoneTasksFromControl = (newValue?: boolean) => {\n  console.log(' AllTasksView: Toggle button clicked from ViewControls!')\n  console.log(' AllTasksView: New value requested:', newValue)\n  \n  try {\n    // We can just call toggle, or we can use the value if we exposed a setter.\n    // Since taskStore.toggleHideDoneTasks() is a toggle, let's use it. \n    // Ideally we should set it to `newValue` if possible, but store only has toggle.\n    // However, if UI sends specific value, we should respect it if we can.\n    // But `hideDoneTasks` in store is a computed setter that updates canvas+calendar.\n    \n    // Simplest: just toggle. The UI in ViewControls emits `!props.hideDoneTasks`. \n    // So it should align.\n    taskStore.toggleHideDoneTasks()\n    \n    console.log(' AllTasksView: Method call successful')\n  } catch (error) {\n    console.error(' AllTasksView: Error calling toggleHideDoneTasks:', error)\n  }\n}\n\n// Debug lifecycle hook\nonMounted(() => {\n  console.log(' [AllTasksView] Component mounted', {\n    totalTasks: taskStore.tasks.length,\n    filteredTasks: taskStore.filteredTasks.length,\n    viewType: viewType.value,\n    sortBy: sortBy.value\n  })\n})\n</script>\n\n<style scoped>\n.all-tasks-view {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n\n.view-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: var(--space-4);\n}\n\n.header-left {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n}\n\n.view-title {\n  font-size: var(--text-2xl);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  margin: 0;\n}\n\n.task-count {\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  padding: var(--space-1) var(--space-2);\n  background-color: var(--surface-tertiary);\n  border-radius: var(--radius-full);\n}\n\n.header-controls {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n}\n\n.hide-done-toggle {\n  background: linear-gradient(\n    135deg,\n    var(--glass-bg-soft) 0%,\n    var(--glass-bg-light) 100%\n  );\n  border: 1px solid var(--glass-border);\n  color: var(--text-secondary);\n  padding: var(--space-2) var(--space-4);\n  border-radius: var(--radius-lg);\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  transition: all var(--duration-normal) var(--spring-smooth);\n  box-shadow: var(--shadow-md);\n  position: relative;\n  z-index: 1000;\n  pointer-events: auto;\n  user-select: none;\n}\n\n.hide-done-toggle.icon-only {\n  padding: var(--space-2);\n  min-width: 40px;\n  min-height: 40px;\n  justify-content: center;\n}\n\n.hide-done-toggle:hover {\n  background: linear-gradient(\n    135deg,\n    var(--state-hover-bg) 0%,\n    var(--glass-bg-soft) 100%\n  );\n  border-color: var(--state-hover-border);\n  color: var(--text-primary);\n  transform: translateY(-1px);\n  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);\n}\n\n.hide-done-toggle.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  backdrop-filter: var(--state-active-glass);\n  color: var(--state-active-text);\n  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);\n}\n\n.tasks-container {\n  flex: 1;\n  overflow-y: auto;\n  min-height: 0;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/BoardView.vue","messages":[{"ruleId":"vue/singleline-html-element-content-newline","severity":1,"message":"Expected 1 line break after opening tag (`<h2>`), but no line breaks found.","line":6,"column":33,"nodeType":"HTMLTagClose","messageId":"unexpectedAfterClosingBracket","endLine":6,"endColumn":33,"fix":{"range":[244,244],"text":"\n"}},{"ruleId":"vue/singleline-html-element-content-newline","severity":1,"message":"Expected 1 line break before closing tag (`</h2>`), but no line breaks found.","line":6,"column":38,"nodeType":"HTMLEndTagOpen","messageId":"unexpectedBeforeOpeningBracket","endLine":6,"endColumn":38,"fix":{"range":[249,249],"text":"\n"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onUnmounted' is defined but never used. Allowed unused vars must match /^_/u.","line":102,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useBoardDensity' is defined but never used. Allowed unused vars must match /^_/u.","line":115,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Task' is defined but never used. Allowed unused vars must match /^_/u.","line":126,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":126,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'supabaseDb' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":134,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":245,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":245,"endColumn":17}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"<template>\n  <div class=\"board-view-wrapper\">\n    <!-- KANBAN BOARD HEADER CONTROLS - TASK-157: Simplified Todoist-style -->\n    <div class=\"kanban-header kanban-header--minimal\">\n      <div class=\"header-left\">\n        <h2 class=\"board-title\">Board</h2>\n        <span class=\"task-count--subtle\">{{ totalDisplayedTasks }}</span>\n      </div>\n      <div class=\"header-controls header-controls--minimal\">\n        <!-- Filter Toggle (collapsed by default) -->\n        <button\n          class=\"filter-toggle icon-only\"\n          :class=\"{ active: showFilters }\"\n          title=\"Toggle filters\"\n          @click=\"showFilters = !showFilters\"\n        >\n          <SlidersHorizontal :size=\"20\" :stroke-width=\"1.5\" />\n        </button>\n\n        <!-- Hide Done Tasks Toggle (TASK-243: Single control for hiding done) -->\n        <button\n          class=\"done-column-toggle icon-only\"\n          :class=\"{ active: hideDoneTasks }\"\n          :title=\"hideDoneTasks ? 'Show done tasks' : 'Hide done tasks'\"\n          @click=\"handleToggleDoneColumn\"\n        >\n          <CheckCircle v-if=\"hideDoneTasks\" :size=\"20\" :stroke-width=\"1.5\" />\n          <Circle v-else :size=\"20\" :stroke-width=\"1.5\" />\n        </button>\n      </div>\n    </div>\n\n    <!-- Collapsible Filter Bar -->\n    <Transition name=\"slide-down\">\n      <div v-if=\"showFilters\" class=\"filter-bar\">\n        <FilterControls />\n      </div>\n    </Transition>\n\n    <!-- SCROLL CONTAINER FOR KANBAN BOARD -->\n    <div class=\"kanban-scroll-container scroll-container\">\n      <div class=\"kanban-board\" @click=\"closeContextMenu\">\n        <KanbanSwimlane\n          v-for=\"project in projectsWithTasks\"\n          :key=\"project.id\"\n          :project=\"project\"\n          :tasks=\"tasksByProject[project.id] || []\"\n          :current-filter=\"taskStore.activeSmartView || 'none'\"\n          :density=\"currentDensity\"\n          :show-done-column=\"!hideDoneTasks\"\n          @select-task=\"handleSelectTask\"\n          @start-timer=\"handleStartTimer\"\n          @edit-task=\"handleEditTask\"\n          @delete-task=\"handleDeleteTask\"\n          @move-task=\"handleMoveTask\"\n          @add-task=\"handleAddTask\"\n          @context-menu=\"handleContextMenu\"\n        />\n      </div>\n    </div>\n\n    <!-- TASK EDIT MODAL -->\n    <TaskEditModal\n      :is-open=\"showEditModal\"\n      :task=\"selectedTask\"\n      @close=\"closeEditModal\"\n    />\n\n    <!-- QUICK TASK CREATE MODAL -->\n    <QuickTaskCreateModal\n      :is-open=\"showQuickTaskCreate\"\n      :loading=\"false\"\n      @cancel=\"closeQuickTaskCreate\"\n      @create=\"handleQuickTaskCreate\"\n    />\n\n    <!-- TASK CONTEXT MENU -->\n    <TaskContextMenu\n      :is-visible=\"showContextMenu\"\n      :x=\"contextMenuX\"\n      :y=\"contextMenuY\"\n      :task=\"contextMenuTask\"\n      :compact-mode=\"currentDensity === 'ultrathin'\"\n      @close=\"closeContextMenu\"\n      @edit=\"handleEditTask\"\n      @confirm-delete=\"handleConfirmDelete\"\n    />\n\n    <!-- CONFIRMATION MODAL -->\n    <ConfirmationModal\n      :is-open=\"showConfirmModal\"\n      title=\"Delete Task\"\n      message=\"Are you sure you want to delete this task? You can press Ctrl+Z to undo.\"\n      confirm-text=\"Delete\"\n      @confirm=\"confirmDeleteTask\"\n      @cancel=\"cancelDeleteTask\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onUnmounted } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useUIStore } from '@/stores/ui'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { provideProgressiveDisclosure } from '@/composables/useProgressiveDisclosure'\nimport { useSettingsStore } from '@/stores/settings'\n\n// Composables\nimport { useBoardModals } from '@/composables/board/useBoardModals'\nimport { useBoardContextMenu } from '@/composables/board/useBoardContextMenu'\nimport { useBoardActions } from '@/composables/board/useBoardActions'\nimport { useBoardDensity } from '@/composables/board/useBoardDensity'\nimport { useBoardState } from '@/composables/board/useBoardState'\n\nimport './BoardView.css'\n\nimport KanbanSwimlane from '@/components/kanban/KanbanSwimlane.vue'\nimport TaskEditModal from '@/components/tasks/TaskEditModal.vue'\nimport QuickTaskCreateModal from '@/components/tasks/QuickTaskCreateModal.vue'\nimport TaskContextMenu from '@/components/tasks/TaskContextMenu.vue'\nimport ConfirmationModal from '@/components/common/ConfirmationModal.vue'\nimport { CheckCircle, Circle, SlidersHorizontal } from 'lucide-vue-next'\nimport type { Task } from '@/stores/tasks'\nimport FilterControls from '@/components/base/FilterControls.vue'\n\n// Stores\nconst taskStore = useTaskStore()\nconst timerStore = useTimerStore()\nconst uiStore = useUIStore()\nconst settingsStore = useSettingsStore()\nconst supabaseDb = useSupabaseDatabase()\n\n// Provide progressive disclosure state for TaskCard components\nprovideProgressiveDisclosure()\n\n// Composables\nconst {\n  showEditModal,\n  selectedTask,\n  showQuickTaskCreate,\n  pendingTaskStatus,\n  showConfirmModal,\n  taskToDelete,\n  openEditModal,\n  closeEditModal,\n  openQuickTaskCreate,\n  closeQuickTaskCreate,\n  openConfirmModal,\n  closeConfirmModal\n} = useBoardModals()\n\nconst {\n  showContextMenu,\n  contextMenuX,\n  contextMenuY,\n  contextMenuTask,\n  openContextMenu: handleContextMenu,\n  closeContextMenu\n} = useBoardContextMenu()\n\nconst {\n  selectTask: handleSelectTask,\n  startTimer: handleStartTimer,\n  quickTaskCreate,\n  deleteTask: doDeleteTask,\n  moveTask: handleMoveTask,\n  addSubtask: _handleAddSubtaskFromMenu\n} = useBoardActions({ taskStore, timerStore })\n\n// TASK-243: Use hideDoneTasks from store instead of separate showDoneColumn\nconst { hideDoneTasks } = storeToRefs(taskStore)\nconst handleToggleDoneColumn = () => taskStore.toggleHideDoneTasks()\n\nconst {\n  tasksByProject,\n  projectsWithTasks,\n  totalDisplayedTasks\n} = useBoardState({ taskStore })\n\n// Density state from global settings store\nconst currentDensity = computed(() => settingsStore.boardDensity)\n\n// TASK-157: Filter bar collapsed by default for cleaner Todoist-style look\nconst showFilters = ref(false)\n\n// Load saved settings on mount\nonMounted(() => {\n  // Initialize UI store\n  uiStore.loadState()\n  \n  // Settings store is initialized automatically in its definition\n  settingsStore.loadFromStorage()\n})\n\n// Task management methods (wrappers for composables to match template emitters)\nconst handleAddTask = (status: string) => {\n  openQuickTaskCreate(status)\n}\n\nconst handleEditTask = (taskId: string) => {\n  const task = taskStore.tasks.find(t => t.id === taskId)\n  if (task) {\n    openEditModal(task)\n  }\n}\n\nconst handleDeleteTask = (taskId: string) => {\n  openConfirmModal(taskId)\n}\n\nconst handleQuickTaskCreate = async (title: string, description: string) => {\n  const newTask = await quickTaskCreate(title, description, pendingTaskStatus.value, taskStore.activeProjectId || undefined)\n  if (newTask) {\n    closeQuickTaskCreate()\n  }\n}\n\nconst handleConfirmDelete = (taskId: string) => {\n  openConfirmModal(taskId)\n}\n\nconst confirmDeleteTask = async () => {\n  if (taskToDelete.value) {\n    await doDeleteTask(taskToDelete.value)\n    closeConfirmModal()\n  }\n}\n\nconst cancelDeleteTask = () => {\n  closeConfirmModal()\n}\n\n// Toggle Today filter\nconst _handleToggleTodayFilter = (event: MouseEvent) => {\n  event.stopPropagation()\n  try {\n    if (taskStore.activeSmartView === 'today') {\n      taskStore.setSmartView(null)\n    } else {\n      taskStore.setSmartView('today')\n    }\n  } catch (error) {\n    // Error toggling Today filter\n  }\n}\n</script>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/CalendarView.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nextTick' is defined but never used. Allowed unused vars must match /^_/u.","line":132,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ProjectFilterDropdown' is defined but never used. Allowed unused vars must match /^_/u.","line":155,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":155,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ProjectEmojiIcon' is defined but never used. Allowed unused vars must match /^_/u.","line":156,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":156,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ChevronLeft' is defined but never used. Allowed unused vars must match /^_/u.","line":157,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ChevronRight' is defined but never used. Allowed unused vars must match /^_/u.","line":157,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Calendar' is defined but never used. Allowed unused vars must match /^_/u.","line":157,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Eye' is defined but never used. Allowed unused vars must match /^_/u.","line":157,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'EyeOff' is defined but never used. Allowed unused vars must match /^_/u.","line":157,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CalendarEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":159,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":159,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getWeekEventStyle' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":263,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":263,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isCurrentWeekTimeCell' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":264,"column":62,"nodeType":null,"messageId":"unusedVar","endLine":264,"endColumn":83},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'evt' is defined but never used. Allowed unused args must match /^_/u.","line":359,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":359,"endColumn":39}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"calendar-layout\">\n    <!-- Status Overlays -->\n    <CalendarStatusOverlays\n      :system-healthy=\"systemHealthy\"\n      :system-health-message=\"systemHealthMessage\"\n      :operation-error=\"operationError\"\n      :operation-loading=\"operationLoading\"\n      @validate-stores=\"handleValidateStores\"\n      @retry-failed-operation=\"handleRetryFailedOperation\"\n      @clear-operation-error=\"handleClearOperationError\"\n      @reload-page=\"handleReloadPage\"\n    />\n\n    <!-- Unified Inbox Panel -->\n    <!-- key forces Vue to recreate component when switching views -->\n    <Transition name=\"sidebar-slide\">\n      <UnifiedInboxPanel v-show=\"uiStore.secondarySidebarVisible\" key=\"calendar-inbox\" context=\"calendar\" />\n    </Transition>\n\n    <!-- Task Edit Modal -->\n    <TaskEditModal\n      :is-open=\"isEditModalOpen\"\n      :task=\"selectedTask\"\n      @close=\"closeEditModal\"\n    />\n\n    <!-- Quick Task Create Modal -->\n    <QuickTaskCreate\n      v-if=\"dragCreate.quickCreateData.startTime\"\n      :is-open=\"dragCreate.showQuickCreateModal.value\"\n      :start-time=\"dragCreate.quickCreateData.startTime || new Date()\"\n      :end-time=\"dragCreate.quickCreateData.endTime || new Date()\"\n      :duration=\"dragCreate.quickCreateData.duration\"\n      @close=\"dragCreate.showQuickCreateModal.value = false\"\n      @created=\"handleTaskCreated\"\n    />\n\n\n    <!-- Delete Confirmation Modal -->\n    <ConfirmationModal\n      :is-open=\"showConfirmModal\"\n      title=\"Delete Task\"\n      message=\"Are you sure you want to delete this task? You can press Ctrl+Z to undo.\"\n      confirm-text=\"Delete\"\n      @confirm=\"confirmDeleteTask\"\n      @cancel=\"cancelDeleteTask\"\n    />\n\n    <!-- Calendar Main Area -->\n    <div class=\"calendar-main scroll-container\">\n      <!-- Calendar Header -->\n      <CalendarHeader\n        :format-current-date=\"formatCurrentDate\"\n        :hide-calendar-done-tasks=\"hideCalendarDoneTasks\"\n        :view-mode=\"viewMode\"\n        @previous-day=\"previousDay\"\n        @next-day=\"nextDay\"\n        @go-to-today=\"goToToday\"\n        @toggle-done-tasks=\"taskStore.toggleCalendarDoneTasks()\"\n        @update:view-mode=\"viewMode = $event\"\n      />\n\n      <!-- Calendar Grid - Day View -->\n      <CalendarDayView\n        v-if=\"viewMode === 'day'\"\n        :time-slots=\"timeSlots\"\n        :hours=\"hours\"\n        :is-viewing-today=\"isViewingToday\"\n        :time-indicator-position=\"timeIndicatorPosition\"\n        :drag-ghost=\"dragGhost\"\n        :active-drop-slot=\"activeDropSlot\"\n        :current-task-id=\"timerStore.currentTaskId\"\n        :is-dragging=\"isDragging\"\n        :dragged-event-id=\"draggedEventId\"\n        :hovered-event-id=\"hoveredEventId\"\n        :resize-preview=\"resizePreview\"\n        @dragover=\"onDragOver\"\n        @dragenter=\"onDragEnter\"\n        @dragleave=\"onDragLeave\"\n        @drop=\"onDropSlot\"\n        @slot-mouse-down=\"dragCreate.handleSlotMouseDown\"\n        @event-mouse-enter=\"handleSlotTaskMouseEnter\"\n        @event-mouse-leave=\"handleSlotTaskMouseLeave\"\n        @event-drag-start=\"handleEventDragStart\"\n        @event-drag-end=\"handleEventDragEnd\"\n        @event-click=\"handleEventClick\"\n        @event-dbl-click=\"handleEventDblClick\"\n        @event-context-menu=\"handleEventContextMenu\"\n        @cycle-status=\"cycleTaskStatus\"\n        @remove-from-calendar=\"handleRemoveFromCalendar\"\n        @start-resize=\"startResize\"\n      />\n\n      <!-- Week View -->\n      <CalendarWeekView\n        v-else-if=\"viewMode === 'week'\"\n        :week-days=\"weekDays\"\n        :working-hours=\"workingHours\"\n        :week-events=\"weekEvents\"\n        :current-task-id=\"timerStore.currentTaskId\"\n        @week-drag-over=\"handleWeekDragOver\"\n        @week-drop=\"handleWeekDrop\"\n        @event-drag-start=\"handleEventDragStart\"\n        @event-drag-end=\"handleEventDragEnd\"\n        @event-click=\"handleEventClick\"\n        @event-dbl-click=\"handleEventDblClick\"\n        @event-context-menu=\"handleEventContextMenu\"\n        @cycle-status=\"cycleTaskStatus\"\n        @remove-from-calendar=\"handleRemoveFromCalendar\"\n        @start-resize=\"startWeekResize\"\n      />\n\n      <!-- Month View -->\n      <CalendarMonthView\n        v-else-if=\"viewMode === 'month'\"\n        :month-days=\"monthDays\"\n        :current-task-id=\"timerStore.currentTaskId\"\n        @month-drop=\"handleMonthDrop\"\n        @month-day-click=\"handleMonthDayClick\"\n        @event-drag-start=\"handleMonthDragStart\"\n        @event-drag-end=\"handleMonthDragEnd\"\n        @event-dbl-click=\"handleEventDblClick\"\n        @event-context-menu=\"handleEventContextMenu\"\n        @cycle-status=\"cycleTaskStatus\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onUnmounted, nextTick, watch, provide } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useUIStore } from '@/stores/ui'\nimport { useCalendarDragCreate } from '@/composables/useCalendarDragCreate'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport { useCalendarDayView } from '@/composables/calendar/useCalendarDayView'\nimport { useCalendarWeekView } from '@/composables/calendar/useCalendarWeekView'\nimport { useCalendarMonthView } from '@/composables/calendar/useCalendarMonthView'\nimport { useCalendarInteractionHandlers } from '@/composables/calendar/useCalendarInteractionHandlers'\nimport { useCalendarModals } from '@/composables/calendar/useCalendarModals'\nimport { useCalendarNavigation } from '@/composables/calendar/useCalendarNavigation'\nimport { useCalendarScroll } from '@/composables/calendar/useCalendarScroll'\nimport UnifiedInboxPanel from '@/components/inbox/UnifiedInboxPanel.vue'\nimport CalendarStatusOverlays, { type OperationError, type OperationLoading } from '@/components/calendar/CalendarStatusOverlays.vue'\nimport CalendarHeader from '@/components/calendar/CalendarHeader.vue'\nimport CalendarDayView from '@/components/calendar/CalendarDayView.vue'\nimport CalendarWeekView from '@/components/calendar/CalendarWeekView.vue'\nimport CalendarMonthView from '@/components/calendar/CalendarMonthView.vue'\nimport TaskEditModal from '@/components/tasks/TaskEditModal.vue'\nimport ConfirmationModal from '@/components/common/ConfirmationModal.vue'\nimport QuickTaskCreate from '@/components/tasks/QuickTaskCreate.vue'\nimport ProjectFilterDropdown from '@/components/projects/ProjectFilterDropdown.vue'\nimport ProjectEmojiIcon from '@/components/base/ProjectEmojiIcon.vue'\nimport { ChevronLeft, ChevronRight, Calendar, Eye, EyeOff, ListTodo as _ListTodo, Play as _Play, Check as _Check, Video as _Video, VideoOff as _VideoOff, Download as _Download } from 'lucide-vue-next'\nimport { dragRecorder as _dragRecorder, type InteractionAnalysis } from '@/utils/DragInteractionRecorder'\nimport type { CalendarEvent } from '@/types/tasks'\nimport type { TimeSlot } from '@/composables/calendar/useCalendarDayView'\n\ninterface SortableEvent {\n  item: HTMLElement\n  newIndex: number\n  [key: string]: unknown\n}\n\nconst taskStore = useTaskStore()\nconst timerStore = useTimerStore()\nconst uiStore = useUIStore()\n\n// System Health & Status Overlays\nconst operationLoading = ref<OperationLoading>({ loading: false, syncing: false })\nconst operationError = ref<OperationError | null>(null)\n// Basic system health check - ensure stores are initialized\nconst systemHealthy = computed(() => !!taskStore && !!timerStore && !!uiStore)\nconst systemHealthMessage = computed(() => !systemHealthy.value ? 'Critical stores failed to initialize' : '')\n\n//  TASK-192: Fix memory leak using AbortController\nlet dragAbortController: AbortController | null = null\nconst DRAG_CAPTURE_OPTIONS = { capture: true }\n\nconst handleValidateStores = () => {\n  // Store validation logic\n}\n\nconst handleRetryFailedOperation = () => {\n  if (operationError.value?.retryable) {\n    operationError.value = null\n    // Simple retry strategy: reload page for system-level errors\n    window.location.reload()\n  }\n}\n\nconst handleClearOperationError = () => {\n  operationError.value = null\n}\n\nconst handleReloadPage = () => {\n  window.location.reload()\n}\n\n// Extract reactive refs from store\n// TASK-076: Use calendar-specific done filter\nconst { hideCalendarDoneTasks } = storeToRefs(taskStore)\n\n// Navigation (Extracted)\nconst {\n  currentDate,\n  viewMode,\n  isViewingToday,\n  formatCurrentDate,\n  previousDay,\n  nextDay,\n  goToToday\n} = useCalendarNavigation()\n\n// Modals (Extracted)\nconst {\n  isEditModalOpen,\n  selectedTask,\n  showConfirmModal,\n  handleEditTask,\n  closeEditModal,\n  handleConfirmDelete,\n  confirmDeleteTask,\n  cancelDeleteTask\n} = useCalendarModals()\n\n// Use global status filter directly from store (maintains reactivity)\nconst statusFilter = computed(() => taskStore.activeStatusFilter)\n\n// Recording state\nconst _isRecording = ref(false)\nconst _recordingStatus = ref({ duration: 0, eventsCaptured: 0 })\nconst _lastAnalysis = ref<InteractionAnalysis | null>(null)\nconst _showRecordingPanel = ref(false)\n\n// Status filter change handler using global TaskStore\nconst _handleStatusFilterChange = (_event: MouseEvent, newFilter: 'planned' | 'in_progress' | 'done' | null) => {\n  taskStore.setActiveStatusFilter(newFilter)\n}\n\n// Composables - Refactored logic into focused modules\nconst dragCreate = useCalendarDragCreate()\nconst eventHelpers = useCalendarCore()\nconst calendarScroll = useCalendarScroll()\nconst dayView = useCalendarDayView(currentDate, statusFilter)\nconst weekView = useCalendarWeekView(currentDate, statusFilter)\nconst monthView = useCalendarMonthView(currentDate, statusFilter)\n\n// Reactive current time for time indicator\nconst currentTime = ref(new Date())\nlet timeUpdateInterval: NodeJS.Timeout | null = null\n\n// Hover state tracking (Moved to useCalendarInteractionHandlers)\n\n// Destructure commonly used items from composables\nconst { hours, timeSlots, calendarEvents: _calendarEvents, dragGhost, dragMode: _dragMode, getEventStyle: _getEventStyle, getGhostStyle: _getGhostStyle,\n        isDragging, draggedEventId, activeDropSlot, handleDragEnter, handleDragOver, handleDragLeave, handleDrop, handleEventDragStart, handleEventDragEnd,\n        handleEventMouseDown: _handleEventMouseDown, startResize, resizePreview, getTasksForSlot, isTaskPrimarySlot, getSlotTaskStyle } = dayView\n\nconst { workingHours, weekDays, weekEvents, getWeekEventStyle, handleWeekEventMouseDown: _handleWeekEventMouseDown,\n        handleWeekDragOver, handleWeekDrop, startWeekResize, isCurrentWeekTimeCell } = weekView\n\nconst { monthDays, handleMonthDragStart, handleMonthDrop, handleMonthDragEnd, handleMonthDayClick: monthDayClickHandler } = monthView\n\nconst { formatHour, formatEventTime, getPriorityClass, getPriorityLabel,\n        getTaskStatus, getStatusLabel, getStatusIcon, cycleTaskStatus,\n        getProjectColor, getProjectEmoji: _getProjectEmoji, getProjectName, getProjectVisual,\n        formatSlotTime, isCurrentTimeSlot: checkCurrentTimeSlot } = eventHelpers\n\n// Destructure scroll composable\nconst { setupScrollSync, cleanupScrollSync, scrollToCurrentTime } = calendarScroll\n\n// Wrapper for isCurrentTimeSlot that passes current time\nconst isCurrentTimeSlot = (slot: TimeSlot) => checkCurrentTimeSlot(slot, currentTime.value)\n\n// Interaction Handlers (Extracted)\nconst {\n  hoveredEventId,\n  handleSlotTaskMouseEnter,\n  handleSlotTaskMouseLeave,\n  handleEventDblClick,\n  handleEventContextMenu,\n  handleRemoveFromCalendar,\n  handleEventClick,\n  handleKeyDown,\n  handleMonthDayClick\n} = useCalendarInteractionHandlers(\n  isDragging,\n  viewMode,\n  handleEditTask,\n  handleConfirmDelete,\n  monthDayClickHandler\n)\n\n// Time indicator position\n\nconst timeIndicatorPosition = computed(() => {\n  // Calculate position in pixels from top of slots container\n  // Each 30-minute slot is 30px, so 1 minute = 1px\n  const hours = currentTime.value.getHours()\n  const minutes = currentTime.value.getMinutes()\n  return (hours * 60) + minutes\n})\n\n// Provide helpers to sub-components (Day/Week views) to reduce props\nprovide('calendar-helpers', {\n  formatHour,\n  formatEventTime,\n  getPriorityClass,\n  getPriorityLabel,\n  getTaskStatus,\n  getStatusLabel,\n  getStatusIcon,\n  cycleTaskStatus,\n  getProjectColor,\n  getProjectName,\n  getProjectVisual,\n  formatSlotTime,\n  isCurrentTimeSlot,\n  getTasksForSlot,\n  isTaskPrimarySlot,\n  getSlotTaskStyle,\n  handleRemoveFromCalendar\n})\n\n// Positioning and sizing for slot tasks are handled by getSlotTaskStyle from useCalendarDayView\n\n// vuedraggable integration for calendar time grid drop zone\n// This provides an alternative to native HTML5 drag-drop for better mobile support\nconst timeGridDropList = ref<unknown[]>([])\n\nconst _handleVueDraggableAdd = (evt: SortableEvent) => {\n  // When a task is dropped via vuedraggable, schedule it to the drop time\n  const droppedElement = evt.item\n  const taskId = droppedElement?.dataset?.taskId\n\n  if (!taskId) {\n    return\n  }\n\n  // Find the target time slot from drop position\n  const dropIndex = evt.newIndex\n  const slot = timeSlots.value[dropIndex]\n\n  if (slot) {\n    const targetDate = new Date(currentDate.value)\n    targetDate.setHours(slot.hour, slot.minute, 0, 0)\n\n    taskStore.updateTaskWithUndo(taskId, { scheduledDate: targetDate.toISOString() })\n  }\n\n  // Clear the drop list since we don't actually display items in it\n  timeGridDropList.value = []\n}\n\nconst _handleVueDraggableChange = (evt: unknown) => {\n  // Optional: handle change events for debugging\n  \n}\n\n// Native HTML5 Drag-Drop handlers for inbox  calendar (per PomoFlow Development Prompt)\n// CRITICAL: @dragover.prevent is required or @drop never fires\n// These wrap the composable handlers with proper event handling\nconst onDragOver = (e: DragEvent, slot: TimeSlot) => {\n  // CRITICAL: preventDefault() already called by @dragover.prevent modifier\n  // BUT we must set dropEffect to validate this as a drop target\n  if (e.dataTransfer) {\n    e.dataTransfer.dropEffect = 'move'\n  }\n\n  \n\n  // Call the existing handler from composable\n  handleDragOver(e, slot)\n}\n\nconst onDragEnter = (e: DragEvent, slot: TimeSlot) => {\n  // CRITICAL: preventDefault() already called by @dragenter.prevent modifier\n  // Set dropEffect to validate this as a drop target\n  if (e.dataTransfer) {\n    e.dataTransfer.dropEffect = 'move'\n  }\n\n  \n\n  // Track active drop slot for visual feedback (handled by composable)\n  handleDragEnter(e, slot)\n}\n\nconst onDragLeave = () => {\n  handleDragLeave()\n}\n\nconst onDropSlot = (e: DragEvent, slot: TimeSlot) => {\n  // CRITICAL: preventDefault() already called by @drop.prevent modifier\n  // BUT be explicit for clarity and add stopPropagation\n  e.preventDefault()\n  e.stopPropagation()\n\n  \n\n  // Use existing handleDrop from composable\n  handleDrop(e, slot)\n}\n\n//  CAPTURE PHASE HANDLERS\nconst handleDragEnterCapture = (e: Event) => {\n  const dragEvent = e as DragEvent\n  const slot = (dragEvent.target as HTMLElement).closest('.time-slot')\n  if (!slot) return\n  dragEvent.stopImmediatePropagation()\n  const idx = parseInt(slot.getAttribute('data-slot-index') || '-1')\n  if (idx === -1) return\n  const slotObj = timeSlots.value[idx]\n  if (slotObj) handleDragEnter(dragEvent, slotObj)\n}\n\nconst handleDragOverCapture = (e: Event) => {\n  const dragEvent = e as DragEvent\n  const slot = (dragEvent.target as HTMLElement).closest('.time-slot')\n  if (!slot) return\n  dragEvent.preventDefault()\n  dragEvent.stopImmediatePropagation()\n  if (dragEvent.dataTransfer) dragEvent.dataTransfer.dropEffect = 'move'\n  const idx = parseInt(slot.getAttribute('data-slot-index') || '-1')\n  if (idx === -1) return\n  const slotObj = timeSlots.value[idx]\n  if (slotObj) {\n    activeDropSlot.value = idx\n    handleDragOver(dragEvent, slotObj)\n  }\n}\n\nconst handleDragLeaveCapture = (e: Event) => {\n  const dragEvent = e as DragEvent\n  const slot = (dragEvent.target as HTMLElement).closest('.time-slot')\n  if (!slot) return\n  dragEvent.stopImmediatePropagation()\n  const idx = parseInt(slot.getAttribute('data-slot-index') || '-1')\n  if (idx === -1) return\n  activeDropSlot.value = null\n  const slotObj = timeSlots.value[idx]\n  if (slotObj) handleDragLeave()\n}\n\nconst handleDropCapture = (e: Event) => {\n  const dragEvent = e as DragEvent\n  const slot = (dragEvent.target as HTMLElement).closest('.time-slot')\n  if (!slot) return\n  dragEvent.preventDefault()\n  dragEvent.stopImmediatePropagation()\n  const idx = parseInt(slot.getAttribute('data-slot-index') || '-1')\n  if (idx === -1) return\n  activeDropSlot.value = null\n  const slotObj = timeSlots.value[idx]\n  if (slotObj) handleDrop(dragEvent, slotObj)\n}\n\n// Listen for start-task-now events\nconst handleStartTaskNow = () => {\n  // Ensure we're in day view\n  if (viewMode.value !== 'day') {\n    viewMode.value = 'day'\n  }\n\n  // Navigate to today if not already there\n  const today = new Date()\n  if (currentDate.value.toDateString() !== today.toDateString()) {\n    currentDate.value = today\n  }\n\n  // Scroll to current time after a short delay to ensure DOM is updated\n  setTimeout(() => {\n    scrollToCurrentTime()\n  }, 100)\n}\n\nonMounted(() => {\n  setupScrollSync()\n\n  // Update current time every 30 seconds for smoother time indicator movement\n  currentTime.value = new Date()\n  timeUpdateInterval = setInterval(() => {\n    currentTime.value = new Date()\n  }, 30000) // Update every 30 seconds\n\n  // Scroll to current time on mount\n  scrollToCurrentTime()\n\n  // Add event listeners\n  window.addEventListener('start-task-now', handleStartTaskNow)\n  window.addEventListener('keydown', handleKeyDown)\n\n  //  ADD CAPTURE PHASE DRAG EVENT LISTENERS\n  const calendarEl = document.querySelector('.calendar-main')\n  if (calendarEl) {\n    dragAbortController = new AbortController()\n    const { signal } = dragAbortController\n\n    // Third parameter = { capture: true, signal } enables CAPTURE PHASE and AUTO-CLEANUP\n    calendarEl.addEventListener('dragenter', handleDragEnterCapture, { ...DRAG_CAPTURE_OPTIONS, signal })\n    calendarEl.addEventListener('dragover', handleDragOverCapture, { ...DRAG_CAPTURE_OPTIONS, signal })\n    calendarEl.addEventListener('dragleave', handleDragLeaveCapture, { ...DRAG_CAPTURE_OPTIONS, signal })\n    calendarEl.addEventListener('drop', handleDropCapture, { ...DRAG_CAPTURE_OPTIONS, signal })\n  }\n})\n\nonUnmounted(() => {\n  cleanupScrollSync()\n\n  // Clean up time update interval\n  if (timeUpdateInterval) {\n    clearInterval(timeUpdateInterval)\n    timeUpdateInterval = null\n  }\n\n  // Remove event listeners\n  window.removeEventListener('start-task-now', handleStartTaskNow)\n  window.removeEventListener('keydown', handleKeyDown)\n\n  //  CLEANUP CAPTURE PHASE DRAG EVENT LISTENERS\n  dragAbortController?.abort()\n  dragAbortController = null\n})\n\n// Watchers for auto-scrolling to current time\nwatch(viewMode, (newMode) => {\n  if (newMode === 'day') {\n    // Scroll to current time when switching to day view\n    setTimeout(() => scrollToCurrentTime(), 100)\n  }\n})\n\nwatch(currentDate, (newDate, _oldDate) => {\n  if (viewMode.value === 'day') {\n    // Check if it's today's date\n    const today = new Date()\n    const isToday = newDate.toDateString() === today.toDateString()\n\n    if (isToday) {\n      // Scroll to current time when navigating to today\n      setTimeout(() => scrollToCurrentTime(), 100)\n    }\n  }\n}, { immediate: false })\n\n// DATE FORMATTED (Moved to useCalendarNavigation)\n\n// NAVIGATION HANDLERS (Moved to useCalendarNavigation)\n\nconst _handleAddTask = () => {\n  // Open QuickTaskCreate modal instead of creating a hardcoded task\n  const now = new Date()\n  const dateStr = currentDate.value.toISOString().split('T')[0]\n  const timeStr = `${now.getHours().toString().padStart(2, '0')}:00`\n\n  // Store task data for the modal\n  dragCreate.quickCreateData.startTime = new Date(`${dateStr}T${timeStr}`)\n  dragCreate.quickCreateData.duration = 60\n  dragCreate.showQuickCreateModal.value = true\n}\n\nconst _handleStartTimer = (taskId: string) => {\n  timerStore.startTimer(taskId)\n}\n\n// MODAL HANDLERS (Moved to useCalendarModals)\n\n// CONTEXT MENU HANDLERS (Moved to useCalendarInteractionHandlers)\n\n// DELETE HANDLERS (Moved to useCalendarModals)\n\nconst handleTaskCreated = (_task: Task) => {\n  \n  dragCreate.showQuickCreateModal.value = false\n  dragCreate.resetCreateDrag()\n}\n\n// Event interaction handlers\n// EVENT HANDLERS (Moved to useCalendarInteractionHandlers)\n\n// Toggle hide done tasks (TASK-076: calendar-specific)\nconst _handleToggleDoneTasks = (_event: MouseEvent) => {\n  taskStore.toggleCalendarDoneTasks()\n}\n</script>\n\n<style scoped>\n.calendar-layout {\n  display: flex;\n  flex: 1;\n  background: var(--app-background-gradient);\n  overflow: visible;\n  min-height: 0;\n  position: relative;\n  z-index: 1;\n}\n\n/* Uses .scroll-container utility for flex:1, overflow-y:auto, min-height:0 */\n.calendar-main {\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  z-index: 1;\n}\n\n/* Transitions */\n.sidebar-slide-enter-active,\n.sidebar-slide-leave-active {\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.sidebar-slide-enter-from,\n.sidebar-slide-leave-to {\n  transform: translateX(-100%);\n  opacity: 0;\n}\n\n/* Custom scrollbar for calendar-main */\n.calendar-main::-webkit-scrollbar {\n  width: 6px;\n}\n\n.calendar-main::-webkit-scrollbar-track {\n  background: transparent;\n}\n\n.calendar-main::-webkit-scrollbar-thumb {\n  background: var(--glass-border);\n  border-radius: var(--radius-md);\n}\n\n.calendar-main {\n  scrollbar-width: thin;\n  scrollbar-color: var(--glass-border) transparent;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/CalendarViewVueCal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/CanvasView.vue","messages":[{"ruleId":"vue/multiline-html-element-content-newline","severity":2,"message":"Expected 1 line break after opening tag (`<div>`), but 2 line breaks found.","line":45,"column":6,"nodeType":"HTMLTagClose","messageId":"unexpectedAfterClosingBracket","endLine":47,"endColumn":7,"fix":{"range":[1526,1540],"text":"\n"}},{"ruleId":"vue/v-on-event-hyphenation","severity":1,"message":"v-on event '@addTask' must be hyphenated.","line":56,"column":9,"nodeType":"VDirectiveKey","messageId":"mustBeHyphenated","endLine":56,"endColumn":33,"fix":{"range":[1883,1890],"text":"add-task"}},{"ruleId":"vue/v-on-event-hyphenation","severity":1,"message":"v-on event '@createGroup' must be hyphenated.","line":57,"column":9,"nodeType":"VDirectiveKey","messageId":"mustBeHyphenated","endLine":57,"endColumn":37,"fix":{"range":[1916,1927],"text":"create-group"}},{"ruleId":"vue/v-on-event-hyphenation","severity":1,"message":"v-on event '@addTask' must be hyphenated.","line":71,"column":9,"nodeType":"VDirectiveKey","messageId":"mustBeHyphenated","endLine":71,"endColumn":33,"fix":{"range":[2355,2362],"text":"add-task"}},{"ruleId":"vue/v-on-event-hyphenation","severity":1,"message":"v-on event '@createGroup' must be hyphenated.","line":72,"column":9,"nodeType":"VDirectiveKey","messageId":"mustBeHyphenated","endLine":72,"endColumn":48,"fix":{"range":[2388,2399],"text":"create-group"}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 8 spaces but found 10 spaces.","line":83,"column":1,"nodeType":null,"endLine":83,"endColumn":11,"fix":{"range":[2680,2690],"text":"        "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":84,"column":1,"nodeType":null,"endLine":84,"endColumn":13,"fix":{"range":[2699,2711],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":85,"column":1,"nodeType":null,"endLine":85,"endColumn":13,"fix":{"range":[2728,2740],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":86,"column":1,"nodeType":null,"endLine":86,"endColumn":13,"fix":{"range":[2755,2767],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":87,"column":1,"nodeType":null,"endLine":87,"endColumn":13,"fix":{"range":[2782,2794],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":88,"column":1,"nodeType":null,"endLine":88,"endColumn":13,"fix":{"range":[2837,2849],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":89,"column":1,"nodeType":null,"endLine":89,"endColumn":13,"fix":{"range":[2876,2888],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":90,"column":1,"nodeType":null,"endLine":90,"endColumn":13,"fix":{"range":[2912,2924],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":91,"column":1,"nodeType":null,"endLine":91,"endColumn":13,"fix":{"range":[2940,2952],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":92,"column":1,"nodeType":null,"endLine":92,"endColumn":13,"fix":{"range":[2985,2997],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":93,"column":1,"nodeType":null,"endLine":93,"endColumn":13,"fix":{"range":[3021,3033],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":94,"column":1,"nodeType":null,"endLine":94,"endColumn":13,"fix":{"range":[3048,3060],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":95,"column":1,"nodeType":null,"endLine":95,"endColumn":13,"fix":{"range":[3083,3095],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":96,"column":1,"nodeType":null,"endLine":96,"endColumn":13,"fix":{"range":[3109,3121],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":97,"column":1,"nodeType":null,"endLine":97,"endColumn":13,"fix":{"range":[3164,3176],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":98,"column":1,"nodeType":null,"endLine":98,"endColumn":13,"fix":{"range":[3223,3235],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":99,"column":1,"nodeType":null,"endLine":99,"endColumn":13,"fix":{"range":[3283,3295],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":100,"column":1,"nodeType":null,"endLine":100,"endColumn":13,"fix":{"range":[3308,3320],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":101,"column":1,"nodeType":null,"endLine":101,"endColumn":13,"fix":{"range":[3342,3354],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":102,"column":1,"nodeType":null,"endLine":102,"endColumn":13,"fix":{"range":[3387,3399],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":103,"column":1,"nodeType":null,"endLine":103,"endColumn":13,"fix":{"range":[3416,3428],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":104,"column":1,"nodeType":null,"endLine":104,"endColumn":13,"fix":{"range":[3444,3456],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":105,"column":1,"nodeType":null,"endLine":105,"endColumn":13,"fix":{"range":[3482,3494],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":106,"column":1,"nodeType":null,"endLine":106,"endColumn":13,"fix":{"range":[3525,3537],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":107,"column":1,"nodeType":null,"endLine":107,"endColumn":13,"fix":{"range":[3568,3580],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":108,"column":1,"nodeType":null,"endLine":108,"endColumn":13,"fix":{"range":[3613,3625],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":109,"column":1,"nodeType":null,"endLine":109,"endColumn":13,"fix":{"range":[3643,3655],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":110,"column":1,"nodeType":null,"endLine":110,"endColumn":13,"fix":{"range":[3691,3703],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":111,"column":1,"nodeType":null,"endLine":111,"endColumn":13,"fix":{"range":[3713,3725],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":112,"column":1,"nodeType":null,"endLine":112,"endColumn":13,"fix":{"range":[3751,3763],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":113,"column":1,"nodeType":null,"endLine":113,"endColumn":13,"fix":{"range":[3802,3814],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":114,"column":1,"nodeType":null,"endLine":114,"endColumn":13,"fix":{"range":[3842,3854],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":115,"column":1,"nodeType":null,"endLine":115,"endColumn":13,"fix":{"range":[3891,3903],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":116,"column":1,"nodeType":null,"endLine":116,"endColumn":13,"fix":{"range":[3937,3949],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":117,"column":1,"nodeType":null,"endLine":117,"endColumn":13,"fix":{"range":[3983,3995],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":118,"column":1,"nodeType":null,"endLine":118,"endColumn":13,"fix":{"range":[4037,4049],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":119,"column":1,"nodeType":null,"endLine":119,"endColumn":13,"fix":{"range":[4079,4091],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":120,"column":1,"nodeType":null,"endLine":120,"endColumn":13,"fix":{"range":[4134,4146],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":121,"column":1,"nodeType":null,"endLine":121,"endColumn":13,"fix":{"range":[4189,4201],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":122,"column":1,"nodeType":null,"endLine":122,"endColumn":13,"fix":{"range":[4244,4256],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":123,"column":1,"nodeType":null,"endLine":123,"endColumn":13,"fix":{"range":[4281,4293],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 8 spaces but found 10 spaces.","line":124,"column":1,"nodeType":null,"endLine":124,"endColumn":11,"fix":{"range":[4318,4328],"text":"        "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":125,"column":1,"nodeType":null,"endLine":125,"endColumn":13,"fix":{"range":[4330,4342],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":126,"column":1,"nodeType":null,"endLine":126,"endColumn":13,"fix":{"range":[4395,4407],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 14 spaces.","line":127,"column":1,"nodeType":null,"endLine":127,"endColumn":15,"fix":{"range":[4419,4433],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 14 spaces.","line":128,"column":1,"nodeType":null,"endLine":128,"endColumn":15,"fix":{"range":[4457,4471],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 14 spaces.","line":129,"column":1,"nodeType":null,"endLine":129,"endColumn":15,"fix":{"range":[4486,4500],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 14 spaces.","line":130,"column":1,"nodeType":null,"endLine":130,"endColumn":15,"fix":{"range":[4510,4524],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":131,"column":1,"nodeType":null,"endLine":131,"endColumn":13,"fix":{"range":[4534,4546],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":133,"column":1,"nodeType":null,"endLine":133,"endColumn":13,"fix":{"range":[4550,4562],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":134,"column":1,"nodeType":null,"endLine":134,"endColumn":13,"fix":{"range":[4593,4605],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 14 spaces.","line":135,"column":1,"nodeType":null,"endLine":135,"endColumn":15,"fix":{"range":[4646,4660],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":136,"column":1,"nodeType":null,"endLine":136,"endColumn":17,"fix":{"range":[4677,4693],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":137,"column":1,"nodeType":null,"endLine":137,"endColumn":17,"fix":{"range":[4773,4789],"text":"              "}},{"ruleId":"vue/attributes-order","severity":1,"message":"Attribute \":id\" should go before \"v-memo\".","line":137,"column":17,"nodeType":"VAttribute","messageId":"expectedOrder","endLine":137,"endColumn":35,"fix":{"range":[4693,4807],"text":":id=\"nodeProps.id\"\n                v-memo=\"[nodeProps.id, nodeProps.data, nodeProps.selected, nodeProps.dragging]\""}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":138,"column":1,"nodeType":null,"endLine":138,"endColumn":17,"fix":{"range":[4808,4824],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":139,"column":1,"nodeType":null,"endLine":139,"endColumn":17,"fix":{"range":[4847,4863],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":140,"column":1,"nodeType":null,"endLine":140,"endColumn":17,"fix":{"range":[4894,4910],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":141,"column":1,"nodeType":null,"endLine":141,"endColumn":17,"fix":{"range":[4941,4957],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":142,"column":1,"nodeType":null,"endLine":142,"endColumn":17,"fix":{"range":[5017,5033],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":143,"column":1,"nodeType":null,"endLine":143,"endColumn":17,"fix":{"range":[5067,5083],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":144,"column":1,"nodeType":null,"endLine":144,"endColumn":17,"fix":{"range":[5124,5140],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":145,"column":1,"nodeType":null,"endLine":145,"endColumn":17,"fix":{"range":[5183,5199],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":146,"column":1,"nodeType":null,"endLine":146,"endColumn":17,"fix":{"range":[5240,5256],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 16 spaces.","line":147,"column":1,"nodeType":null,"endLine":147,"endColumn":17,"fix":{"range":[5286,5302],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 14 spaces.","line":148,"column":1,"nodeType":null,"endLine":148,"endColumn":15,"fix":{"range":[5339,5353],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":149,"column":1,"nodeType":null,"endLine":149,"endColumn":13,"fix":{"range":[5356,5368],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 14 spaces.","line":153,"column":1,"nodeType":null,"endLine":153,"endColumn":15,"fix":{"range":[5383,5397],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 14 spaces.","line":154,"column":1,"nodeType":null,"endLine":154,"endColumn":15,"fix":{"range":[5432,5446],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 16 spaces.","line":155,"column":1,"nodeType":null,"endLine":155,"endColumn":17,"fix":{"range":[5484,5500],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":156,"column":1,"nodeType":null,"endLine":156,"endColumn":19,"fix":{"range":[5510,5528],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":157,"column":1,"nodeType":null,"endLine":157,"endColumn":19,"fix":{"range":[5642,5660],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":158,"column":1,"nodeType":null,"endLine":158,"endColumn":19,"fix":{"range":[5688,5706],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":159,"column":1,"nodeType":null,"endLine":159,"endColumn":19,"fix":{"range":[5740,5758],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":160,"column":1,"nodeType":null,"endLine":160,"endColumn":19,"fix":{"range":[5792,5810],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":161,"column":1,"nodeType":null,"endLine":161,"endColumn":19,"fix":{"range":[5859,5877],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":162,"column":1,"nodeType":null,"endLine":162,"endColumn":19,"fix":{"range":[5928,5946],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":163,"column":1,"nodeType":null,"endLine":163,"endColumn":19,"fix":{"range":[5989,6007],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":164,"column":1,"nodeType":null,"endLine":164,"endColumn":19,"fix":{"range":[6054,6072],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":165,"column":1,"nodeType":null,"endLine":165,"endColumn":19,"fix":{"range":[6119,6137],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":166,"column":1,"nodeType":null,"endLine":166,"endColumn":19,"fix":{"range":[6160,6178],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":167,"column":1,"nodeType":null,"endLine":167,"endColumn":19,"fix":{"range":[6205,6223],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 16 spaces.","line":168,"column":1,"nodeType":null,"endLine":168,"endColumn":17,"fix":{"range":[6261,6277],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 14 spaces.","line":169,"column":1,"nodeType":null,"endLine":169,"endColumn":15,"fix":{"range":[6280,6294],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 14 spaces.","line":171,"column":1,"nodeType":null,"endLine":171,"endColumn":15,"fix":{"range":[6307,6321],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 14 spaces.","line":172,"column":1,"nodeType":null,"endLine":172,"endColumn":15,"fix":{"range":[6364,6378],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 16 spaces.","line":173,"column":1,"nodeType":null,"endLine":173,"endColumn":17,"fix":{"range":[6455,6471],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":174,"column":1,"nodeType":null,"endLine":174,"endColumn":19,"fix":{"range":[6478,6496],"text":"              "}},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'refX' should be on a new line.","line":174,"column":77,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":174,"endColumn":85,"fix":{"range":[6553,6554],"text":"\n"}},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'refY' should be on a new line.","line":174,"column":86,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":174,"endColumn":94},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'orient' should be on a new line.","line":174,"column":95,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":174,"endColumn":108},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'markerUnits' should be on a new line.","line":174,"column":109,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":174,"endColumn":134},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 16 spaces but found 20 spaces.","line":175,"column":1,"nodeType":null,"endLine":175,"endColumn":21,"fix":{"range":[6613,6633],"text":"                "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":176,"column":1,"nodeType":null,"endLine":176,"endColumn":19,"fix":{"range":[6700,6718],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":177,"column":1,"nodeType":null,"endLine":177,"endColumn":19,"fix":{"range":[6728,6746],"text":"              "}},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'refX' should be on a new line.","line":177,"column":83,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":177,"endColumn":91,"fix":{"range":[6809,6810],"text":"\n"}},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'refY' should be on a new line.","line":177,"column":92,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":177,"endColumn":100},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'orient' should be on a new line.","line":177,"column":101,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":177,"endColumn":114},{"ruleId":"vue/max-attributes-per-line","severity":2,"message":"'markerUnits' should be on a new line.","line":177,"column":115,"nodeType":"VAttribute","messageId":"shouldBeOnNewLine","endLine":177,"endColumn":140},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 16 spaces but found 20 spaces.","line":178,"column":1,"nodeType":null,"endLine":178,"endColumn":21,"fix":{"range":[6869,6889],"text":"                "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 14 spaces but found 18 spaces.","line":179,"column":1,"nodeType":null,"endLine":179,"endColumn":19,"fix":{"range":[6956,6974],"text":"              "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 12 spaces but found 16 spaces.","line":180,"column":1,"nodeType":null,"endLine":180,"endColumn":17,"fix":{"range":[6984,7000],"text":"            "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 14 spaces.","line":181,"column":1,"nodeType":null,"endLine":181,"endColumn":15,"fix":{"range":[7008,7022],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 8 spaces but found 12 spaces.","line":182,"column":1,"nodeType":null,"endLine":182,"endColumn":13,"fix":{"range":[7029,7041],"text":"        "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 8 spaces but found 10 spaces.","line":185,"column":1,"nodeType":null,"endLine":185,"endColumn":11,"fix":{"range":[7054,7064],"text":"        "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":186,"column":1,"nodeType":null,"endLine":186,"endColumn":13,"fix":{"range":[7086,7098],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 10 spaces but found 12 spaces.","line":187,"column":1,"nodeType":null,"endLine":187,"endColumn":13,"fix":{"range":[7120,7132],"text":"          "}},{"ruleId":"vue/html-indent","severity":2,"message":"Expected indentation of 8 spaces but found 10 spaces.","line":188,"column":1,"nodeType":null,"endLine":188,"endColumn":11,"fix":{"range":[7165,7175],"text":"        "}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ref' is defined but never used. Allowed unused vars must match /^_/u.","line":233,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":233,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":233,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":233,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'EdgeMouseEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":234,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":234,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'modalsStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":265,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":265,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10435,10438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10435,10438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fitCanvas' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":281,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":281,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'zoomToSelection' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":281,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":281,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'retryFailedOperation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":281,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":281,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'showNodeContextMenu' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":284,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nodeContextMenuX' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":284,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nodeContextMenuY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":284,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'showEdgeContextMenu' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":285,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":285,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'edgeContextMenuX' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":285,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":285,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'edgeContextMenuY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":285,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":285,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeEdgeContextMenu' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":288,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":288,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeNodeContextMenu' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":288,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":288,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isQuickTaskCreateOpen' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":289,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isBatchEditModalOpen' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":289,"column":57,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":77},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'batchEditTaskIds' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":290,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":290,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isGroupModalOpen' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":290,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":290,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectedGroup' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":291,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":291,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'groupModalPosition' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":291,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":291,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isGroupEditModalOpen' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":291,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":291,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectedSectionForEdit' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":291,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":291,"endColumn":82},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isDeleteGroupModalOpen' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":292,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":292,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'deleteGroupMessage' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":292,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":292,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isBulkDeleteModalOpen' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":292,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":292,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bulkDeleteTitle' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":293,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":293,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bulkDeleteMessage' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":293,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":293,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bulkDeleteItems' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":293,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":293,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bulkDeleteIsPermanent' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":293,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":293,"endColumn":77},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeEditModal' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":294,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":294,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeQuickTaskCreate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":294,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":294,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeBatchEditModal' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":294,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":294,"endColumn":83},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeSectionSettingsModal' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":295,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":295,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeGroupModal' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":296,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":296,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeGroupEditModal' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":296,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":296,"endColumn":79},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'cancelDeleteGroup' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":297,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":297,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'cancelBulkDelete' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":298,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":298,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":319,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":319,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13149,13152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13149,13152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":320,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13224,13227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13224,13227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13788,13791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13788,13791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":334,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":334,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13862,13865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13862,13865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":335,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":335,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14012,14015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14012,14015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":343,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14310,14313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14310,14313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":359,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14948,14951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14948,14951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":360,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14985,14988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14985,14988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"vue/padding-line-between-blocks","severity":2,"message":"Expected blank line before this block.","line":370,"column":1,"nodeType":"VElement","messageId":"always","endLine":370,"endColumn":57,"fix":{"range":[15153,15153],"text":"\n"}}],"suppressedMessages":[],"errorCount":147,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":103,"fixableWarningCount":5,"source":"<!-- /// <reference types=\"vite/client\" /> -->\n<!--\n   CRITICAL: Vue Flow Integration Rules - DO NOT VIOLATE\n\n  During refactoring, the following Vue Flow elements MUST NEVER be extracted\n  from this component into separate components:\n\n   DO NOT EXTRACT:\n    - v-model:nodes and v-model:edges bindings (lines ~153-154)\n    - @node-drag-stop, @connect, @edge-created event handlers (lines ~172-181)\n    - VueFlow component itself and its direct children (lines ~151-236)\n    - Node/edge calculation and synchronization logic\n    - useVueFlow() composable usage and its return values\n    - syncNodes() function calls that refresh VueFlow state\n\n   SAFE TO EXTRACT (these don't depend on Vue Flow):\n    - Canvas controls (zoom, pan, toolbar buttons)\n    - Modals and overlays\n    - Context menus (if they don't depend on VueFlow state)\n    - Sidebar panels\n\n  VIOLATION OF THESE RULES WILL BREAK:\n    - Drag and drop functionality\n    - Node connections and edges\n    - State synchronization\n    - Canvas viewport controls\n\n  These rules are based on analysis of previous refactoring failures in\n  old-pomo-flow-worktrees where Vue Flow extraction caused complete\n  breakage of canvas functionality.\n-->\n\n<template>\n  <div\n    class=\"canvas-layout canvas-contour\"\n    :class=\"{ 'shift-selecting': shift }\"\n  >\n    <!-- MAIN CANVAS AREA -->\n    <!-- Vue Flow Canvas -->\n    <div\n      class=\"canvas-drop-zone relative\"\n      @drop=\"handleDrop\"\n      @dragover.prevent\n      @contextmenu.prevent=\"handleCanvasRightClick\"\n    >\n      \n      <!-- Loading overlay while canvas initializes -->\n      <CanvasLoadingOverlay \n        v-if=\"!isCanvasReady && !hasNoTasks && tasksWithCanvasPositions && tasksWithCanvasPositions.length > 0\"\n        message=\"Loading canvas...\"\n      />\n\n      <!-- Empty state when no tasks exist -->\n      <CanvasEmptyState\n        v-if=\"hasNoTasks\"\n        @addTask=\"handleAddTask\"\n        @createGroup=\"createGroup()\"\n      />\n\n      <!-- Filter Status Indicator -->\n      <CanvasStatusBanner \n        :active-status-filter=\"taskStore.activeStatusFilter\"\n        @clear-filter=\"clearStatusFilter\"\n      />\n\n      <!-- Inbox Sidebar -->\n      <UnifiedInboxPanel key=\"canvas-inbox\" context=\"canvas\" />\n\n      <!-- Canvas Toolbar - Actions & Filters (MUST be after InboxPanel for z-index stacking) -->\n      <CanvasToolbar\n        @addTask=\"handleAddTask\"\n        @createGroup=\"handleToolbarCreateGroup\"\n      />\n\n      <!-- Canvas Container -->\n      <div\n        class=\"canvas-container\"\n        @mousedown.capture=\"handleMouseDown\"\n        @mousemove=\"handleMouseMove\"\n        @mouseup=\"handleMouseUp\"\n        @click=\"handleCanvasContainerClick\"\n      >\n          <VueFlow\n            ref=\"vueFlowRef\"\n            :nodes=\"nodes\"\n            :edges=\"edges\"\n            :class=\"{ 'canvas-ready': isCanvasReady }\"\n            class=\"vue-flow-container\"\n            :node-types=\"nodeTypes\"\n            edges-focusable\n            :elevate-nodes-on-select=\"false\"\n            elevate-edges-on-select\n            zoom-on-scroll\n            :pan-on-scroll=\"false\"\n            zoom-on-pinch\n            :pan-on-drag=\"!shift && !control && !meta\"\n            :nodes-draggable=\"!shift && !control && !meta\"\n            :multi-selection-key-code=\"['Control', 'Meta']\"\n            snap-to-grid\n            :snap-grid=\"[16, 16]\"\n            :node-extent=\"dynamicNodeExtent\"\n            :min-zoom=\"0.05\"\n            :max-zoom=\"4.0\"\n            :fit-view-on-init=\"false\"\n            :connect-on-drag-nodes=\"false\"\n            :zoom-scroll-sensitivity=\"1.0\"\n            :zoom-activation-key-code=\"null\"\n            prevent-scrolling\n            :default-viewport=\"initialViewport\"\n            dir=\"ltr\"\n            @pane-ready=\"onPaneReady\"\n            @node-drag-start=\"handleNodeDragStart\"\n            @node-drag=\"handleNodeDrag\"\n            @node-drag-stop=\"handleNodeDragStop\"\n            @nodes-change=\"handleNodesChange\"\n            @edges-change=\"handleEdgesChange\"\n            @selection-change=\"handleSelectionChange\"\n            @pane-click=\"handlePaneClick\"\n            @pane-context-menu=\"handlePaneContextMenu\"\n            @node-context-menu=\"handleNodeContextMenu\"\n            @edge-context-menu=\"handleEdgeContextMenu\"\n            @connect=\"handleConnect\"\n            @keydown=\"handleKeyDown\"\n          >\n            <CanvasSelectionBox :selection-box=\"selectionBox\" />\n            <Background\n              pattern-color=\"#e5e7eb\"\n              pattern=\"dots\"\n              :gap=\"16\"\n              :size=\"1\"\n            />\n\n            <!-- Section Node Template -->\n            <template #node-sectionNode=\"nodeProps\">\n              <GroupNodeSimple\n                v-memo=\"[nodeProps.id, nodeProps.data, nodeProps.selected, nodeProps.dragging]\"\n                :id=\"nodeProps.id\"\n                :data=\"nodeProps.data\"\n                :selected=\"nodeProps.selected\"\n                :dragging=\"nodeProps.dragging\"\n                @update=\"(data) => handleSectionUpdate(nodeProps.id, data)\"\n                @collect=\"collectTasksForSection\"\n                @context-menu=\"handleSectionContextMenu\"\n                @open-settings=\"handleOpenSectionSettings\"\n                @resize-start=\"handleSectionResizeStart\"\n                @resize=\"handleSectionResize\"\n                @resize-end=\"handleSectionResizeEnd\"\n              />\n            </template>\n\n\n\n              <!-- Custom Task Node Template -->\n              <template #node-taskNode=\"nodeProps\">\n                <TaskNode\n                  v-memo=\"[nodeProps.id, nodeProps.data.task, nodeProps.selected, nodeProps.dragging, canvasStore.multiSelectMode]\"\n                  :task=\"nodeProps.data.task\"\n                  :is-selected=\"nodeProps.selected\"\n                  :is-dragging=\"nodeProps.dragging\"\n                  :multi-select-mode=\"canvasStore.multiSelectMode\"\n                  :show-priority=\"canvasStore.showPriorityIndicator\"\n                  :show-status=\"canvasStore.showStatusBadge\"\n                  :show-duration=\"canvasStore.showDurationBadge\"\n                  :show-schedule=\"canvasStore.showScheduleBadge\"\n                  @edit=\"handleEditTask\"\n                  @select=\"handleTaskSelect\"\n                  @context-menu=\"handleTaskContextMenu\"\n                />\n              </template>\n\n              <!-- SVG markers for connection arrows -->\n              <svg style=\"position: absolute; width: 0; height: 0; pointer-events: none;\">\n                <defs>\n                  <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n                    <polygon points=\"0 0, 10 3, 0 6\" fill=\"var(--border-secondary)\" />\n                  </marker>\n                  <marker id=\"arrowhead-hover\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n                    <polygon points=\"0 0, 10 3, 0 6\" fill=\"var(--color-navigation)\" />\n                  </marker>\n                </defs>\n              </svg>\n            </VueFlow>\n\n\n          <CanvasLoadingOverlay\n            v-if=\"!isCanvasReady\"\n            message=\"Initializing Canvas...\"\n          />\n      </div>\n    </div>\n\n    <!-- Modals -->\n    <CanvasModals\n      @handle-quick-task-create=\"handleQuickTaskCreate\"\n      @handle-batch-edit-applied=\"handleBatchEditApplied\"\n      @handle-section-settings-save=\"handleSectionSettingsSave\"\n      @handle-group-created=\"handleGroupCreated\"\n      @handle-group-updated=\"handleGroupUpdated\"\n      @handle-group-edit-save=\"handleGroupEditSave\"\n      @confirm-delete-group=\"confirmDeleteGroup\"\n      @confirm-bulk-delete=\"confirmBulkDelete\"\n    />\n\n    <CanvasContextMenus\n      @create-task-here=\"createTaskHere\"\n      @create-group=\"createGroup\"\n      @edit-group=\"editGroup\"\n      @delete-group=\"deleteGroup\"\n      @move-to-inbox=\"moveSelectedTasksToInbox\"\n      @delete-tasks=\"deleteSelectedTasks\"\n      @align-left=\"alignLeft\"\n      @align-right=\"alignRight\"\n      @align-top=\"alignTop\"\n      @align-bottom=\"alignBottom\"\n      @align-center-horizontal=\"alignCenterHorizontal\"\n      @align-center-vertical=\"alignCenterVertical\"\n      @distribute-horizontal=\"distributeHorizontal\"\n      @distribute-vertical=\"distributeVertical\"\n      @arrange-in-row=\"arrangeInRow\"\n      @arrange-in-column=\"arrangeInColumn\"\n      @arrange-in-grid=\"arrangeInGrid\"\n      @create-task-in-group=\"createTaskInGroup\"\n      @open-group-settings=\"handleOpenSectionSettingsFromContext\"\n      @toggle-power-mode=\"handleToggleFocusMode\"\n      @collect-tasks=\"handleCollectTasksFromMenu\"\n      @disconnect-edge=\"disconnectEdge\"\n      @delete-node=\"deleteNode\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, markRaw } from 'vue'\nimport { VueFlow, type EdgeMouseEvent } from '@vue-flow/core'\nimport { Background } from '@vue-flow/background'\nimport '@vue-flow/node-resizer/dist/style.css'\nimport '@vue-flow/core/dist/style.css'\nimport '@vue-flow/core/dist/theme-default.css'\nimport '../assets/vue-flow-overrides.css'\nimport { useEventListener } from '@vueuse/core'\n\nimport { useTaskStore } from '../stores/tasks'\nimport { useCanvasStore } from '../stores/canvas'\nimport { useUIStore } from '../stores/ui'\nimport { useCanvasContextMenuStore } from '../stores/canvas/contextMenus'\n\nimport TaskNode from '../components/canvas/TaskNode.vue'\nimport GroupNodeSimple from '../components/canvas/GroupNodeSimple.vue'\nimport UnifiedInboxPanel from '../components/inbox/UnifiedInboxPanel.vue'\nimport CanvasModals from '../components/canvas/CanvasModals.vue'\nimport CanvasEmptyState from '../components/canvas/CanvasEmptyState.vue'\nimport CanvasContextMenus from '../components/canvas/CanvasContextMenus.vue'\n\nimport { useCanvasModalsStore } from '@/stores/canvas/modals'\nimport CanvasToolbar from '../components/canvas/CanvasToolbar.vue'\nimport CanvasStatusBanner from '../components/canvas/CanvasStatusBanner.vue'\nimport CanvasLoadingOverlay from '../components/canvas/CanvasLoadingOverlay.vue'\nimport CanvasSelectionBox from '../components/canvas/CanvasSelectionBox.vue'\n\nimport { useCanvasOrchestrator } from '../composables/canvas/useCanvasOrchestrator'\n\nconst taskStore = useTaskStore()\nconst canvasStore = useCanvasStore()\nconst uiStore = useUIStore()\nconst modalsStore = useCanvasModalsStore()\nconst contextMenuStore = useCanvasContextMenuStore()\n\n// Register custom node types\nconst nodeTypes: Record<string, any> = {\n  taskNode: markRaw(TaskNode),\n  sectionNode: markRaw(GroupNodeSimple)\n}\n\n// Initialize Orchestrator\nconst orchestrator = useCanvasOrchestrator()\nconst {\n  nodes, edges, isCanvasReady, initialViewport, shift, control, meta, vueFlowRef,\n  tasksWithCanvasPosition, dynamicNodeExtent, hasNoTasks,\n  handleNodeDragStart, handleNodeDrag, handleNodeDragStop, handleKeyDown,\n  handleSectionResizeStart, handleSectionResize, handleSectionResizeEnd,\n  onPaneReady, fitCanvas, zoomToSelection, retryFailedOperation,\n  handlePaneClick, handleCanvasRightClick, handlePaneContextMenu, handleDrop,\n  // BUG-208: Canvas context menu state now comes from contextMenuStore, not orchestrator\n  showNodeContextMenu, nodeContextMenuX, nodeContextMenuY,\n  showEdgeContextMenu, edgeContextMenuX, edgeContextMenuY,\n  closeCanvasContextMenu, createTaskHere, createGroup, editGroup, deleteGroup,\n  moveSelectedTasksToInbox, deleteSelectedTasks, createTaskInGroup,\n  closeEdgeContextMenu, closeNodeContextMenu, deleteNode,\n  isEditModalOpen, selectedTask, isQuickTaskCreateOpen, isBatchEditModalOpen,\n  batchEditTaskIds, isSectionSettingsOpen, editingSection, isGroupModalOpen,\n  selectedGroup, groupModalPosition, isGroupEditModalOpen, selectedSectionForEdit,\n  isDeleteGroupModalOpen, deleteGroupMessage, isBulkDeleteModalOpen,\n  bulkDeleteTitle, bulkDeleteMessage, bulkDeleteItems, bulkDeleteIsPermanent,\n  closeEditModal, closeQuickTaskCreate, handleQuickTaskCreate, closeBatchEditModal,\n  handleBatchEditApplied, closeSectionSettingsModal, handleSectionSettingsSave,\n  closeGroupModal, handleGroupCreated, handleGroupUpdated, closeGroupEditModal,\n  handleGroupEditSave, confirmDeleteGroup, cancelDeleteGroup, confirmBulkDelete,\n  cancelBulkDelete, handleConnect, handleEdgesChange, handleNodesChange,\n  handleNodeContextMenu, handleEdgeContextMenu,\n  \n  // From consolidated features\n  selectionBox, handleMouseDown, handleMouseMove, handleMouseUp, handleCanvasContainerClick, handleTaskSelect,\n  alignLeft, alignRight, alignTop, alignBottom, alignCenterHorizontal, alignCenterVertical, \n  distributeHorizontal, distributeVertical, arrangeInRow, arrangeInColumn, arrangeInGrid,\n  collectTasksForSection, autoCollectOverdueTasks: handleCollectTasksFromMenu, disconnectEdge\n} = orchestrator\n\n// Register global hotkeys\nuseEventListener(window, 'keydown', (e) => {\n  // Only handle if canvas is active/visible\n  handleKeyDown(e)\n})\n\n// Aliases for template compatibility\nconst tasksWithCanvasPositions = tasksWithCanvasPosition\nconst handleToolbarCreateGroup = createGroup\nconst handleAddTask = () => createTaskHere()\nconst clearStatusFilter = () => { taskStore.activeStatusFilter = null }\nconst handleSelectionChange = (params: any) => {\n  if (params) canvasStore.selectedNodeIds = params.nodes.map((n: any) => n.id)\n}\n\n// UI Wrappers\nconst handleOpenSectionSettings = (id: string) => {\n    const section = canvasStore.groups.find(g => g.id === id)\n    if (section) { editingSection.value = section; isSectionSettingsOpen.value = true }\n}\nconst handleOpenSectionSettingsFromContext = () => {\n    // BUG-208: Use store for context menu state\n    if (contextMenuStore.canvasContextSection) handleOpenSectionSettings(contextMenuStore.canvasContextSection.id)\n}\nconst handleToggleFocusMode = () => uiStore.toggleFocusMode()\nconst handleSectionUpdate = (id: string, data: any) => canvasStore.updateSection(id, data)\nconst handleEditTask = (task: any) => { selectedTask.value = task; isEditModalOpen.value = true; closeCanvasContextMenu() }\nconst handleTaskContextMenu = (event: MouseEvent, task: any) => {\n    if (event) event.preventDefault()\n    // Dispatch global event for ModalManager to handle (shared TaskContextMenu)\n    window.dispatchEvent(new CustomEvent('task-context-menu', {\n        detail: { event, task }\n    }))\n}\n\nconst handleSectionContextMenu = (event: MouseEvent, section: any) => {\n    console.debug('[BUG-251] handleSectionContextMenu called', {\n        sectionId: section?.id,\n        sectionName: section?.name,\n        eventType: event?.type\n    })\n    if (event) {\n        event.preventDefault()\n        event.stopPropagation() // STOP PROPAGATION to prevent pane menu\n    }\n    // BUG-208 FIX: Use Pinia store instead of local refs\n    // CanvasContextMenus.vue reads from the store, so we must write to it\n    contextMenuStore.openCanvasContextMenu(event.clientX, event.clientY, section)\n}\n\n// Expose for testing purposes (Fundamental Stability)\nif (process.env.NODE_ENV === 'development' || (window as any).PLAYWRIGHT_TEST) {\n  (window as any).__POMO_FLOW_DEBUG__ = {\n    orchestrator,\n    canvasStore,\n    taskStore,\n    uiStore\n  }\n}\n</script>\n\n<style scoped src=\"@/assets/canvas-view-layout.css\"></style>\n<style src=\"@/assets/canvas-view-overrides.css\"></style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/FocusView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/PerformanceView.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useRouter' is defined but never used. Allowed unused vars must match /^_/u.","line":135,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4568,4571],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4568,4571],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5426,5429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5426,5429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5473,5476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5473,5476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6235,6238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6235,6238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6340,6343],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6340,6343],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7230,7233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7230,7233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7716,7719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7716,7719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8839,8842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8839,8842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"performance-view\">\n    <header class=\"page-header glass\">\n      <div class=\"header-content--performance\">\n        <h1>Performance Dashboard</h1>\n        <p>System health and benchmarking suite for Pomo-Flow</p>\n      </div>\n      <div class=\"actions\">\n        <button \n          class=\"btn btn-primary glass flex items-center gap-2\" \n          :disabled=\"isRunning\" \n          aria-label=\"Run full performance benchmark suite\"\n          @click=\"runFullSuite\"\n        >\n          <span>{{ isRunning ? ' Running...' : ' Run Full Suite' }}</span>\n        </button>\n      </div>\n    </header>\n\n    <div class=\"dashboard-grid\">\n      <!-- Summary Cards -->\n      <div class=\"summary-cards\">\n        <div class=\"card glass score-card\" :class=\"performanceGradeClass\">\n          <h3>Overall Grade</h3>\n          <div class=\"grade-display\">\n            {{ performanceGrade }}\n          </div>\n          <p>{{ statusMessage }}</p>\n        </div>\n\n        <div class=\"card glass stat-card\">\n          <h3>Canvas Latency</h3>\n          <div class=\"stat-value\">\n            {{ canvasLatency }}ms\n          </div>\n          <div class=\"stat-label\">\n            1000 nodes sync\n          </div>\n        </div>\n\n        <div class=\"card glass stat-card\">\n          <h3>Memory Usage</h3>\n          <div class=\"stat-value\">\n            {{ memoryUsage }}MB\n          </div>\n          <div class=\"stat-label\">\n            Heap size\n          </div>\n        </div>\n      </div>\n\n      <!-- Main Results Table -->\n      <div class=\"results-container glass\">\n        <h2>Benchmark Results</h2>\n        <div class=\"table-wrapper\">\n          <table v-if=\"hasResults\">\n            <thead>\n              <tr>\n                <th>Test Category</th>\n                <th>Average</th>\n                <th>Min/Max</th>\n                <th>Throughput</th>\n                <th>Success</th>\n                <th>Status</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr v-for=\"(result, key) in results\" :key=\"key\">\n                <td class=\"test-name\">\n                  {{ result.name }}\n                </td>\n                <td>{{ result.averageTime.toFixed(2) }}ms</td>\n                <td>{{ result.minTime.toFixed(1) }} / {{ result.maxTime.toFixed(1) }}ms</td>\n                <td>{{ (result.throughput || 0).toFixed(1) }} ops/s</td>\n                <td>\n                  <div class=\"progress-bar\">\n                    <div class=\"progress\" :style=\"{ width: result.successRate + '%' }\" />\n                  </div>\n                  {{ Math.round(result.successRate) }}%\n                </td>\n                <td>\n                  <span class=\"status-badge\" :class=\"getStatusClass(result)\">\n                    {{ getStatusLabel(result) }}\n                  </span>\n                </td>\n              </tr>\n            </tbody>\n          </table>\n          <div v-else class=\"empty-state\">\n            <p>No results yet. Run the benchmark suite to see metrics.</p>\n          </div>\n        </div>\n      </div>\n\n      <!-- Documentation/Recommendations -->\n      <div class=\"sidebar glass\">\n        <h2>Recommendations</h2>\n        <ul v-if=\"recommendations.length > 0\">\n          <li v-for=\"(rec, i) in recommendations\" :key=\"i\">\n            <strong>{{ rec.type }}:</strong> {{ rec.message }}\n          </li>\n        </ul>\n        <p v-else>\n          System is performing optimally. No recommendations at this time.\n        </p>\n\n        <div class=\"baseline-tools\">\n          <div class=\"flex items-center justify-between mb-4\">\n            <h3 class=\"text-lg font-semibold flex items-center gap-2\">\n              <Zap :size=\"20\" class=\"text-indigo-400\" />\n              Baseline Management\n            </h3>\n          </div>\n          <button \n            class=\"btn btn-secondary glass w-full flex items-center justify-center gap-2\"\n            :disabled=\"!hasResults\"\n            aria-label=\"Save current results as new performance baseline\"\n            @click=\"saveAsBaseline\"\n          >\n            <Save :size=\"18\" />\n            <span>Save as New Baseline</span>\n          </button>\n          <div class=\"footer-note\">\n            Baselines are stored in <code>docs/performance/</code>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted } from 'vue'\nimport { performanceBenchmark } from '@/utils/performanceBenchmark'\nimport { useRouter } from 'vue-router'\nimport { Zap, Save } from 'lucide-vue-next' // Import icons\n\nconst results = ref<any>({})\nconst isRunning = ref(false) // Renamed from isBenchmarkRunning\nconst currentProgress = ref(0)\nconst hasResults = computed(() => Object.keys(results.value).length > 0)\n\nconst runFullSuite = async () => { // Renamed from runBenchmark\n  isRunning.value = true\n  currentProgress.value = 0\n  \n  // Update progress in background\n  const progressInterval = setInterval(() => {\n    currentProgress.value = performanceBenchmark.currentProgress\n  }, 100)\n\n  try {\n    const suiteResponse = await performanceBenchmark.runFullSuite()\n    results.value = suiteResponse\n  } catch (err) {\n    console.error('Benchmark failed:', err)\n  } finally {\n    clearInterval(progressInterval)\n    isRunning.value = false\n    currentProgress.value = 100\n  }\n}\n\nonMounted(async () => {\n  const latest = await performanceBenchmark.getLatestReport()\n  if (latest && (latest as any).results) {\n    results.value = (latest as any).results\n  }\n})\n\n// Metrics helpers\nconst canvasLatency = computed(() => {\n  if (results.value?.canvasPerformance) {\n    return results.value.canvasPerformance.averageTime.toFixed(1)\n  }\n  return '0.0'\n})\n\nconst memoryUsage = computed(() => {\n  if (results.value?.memoryEfficiency?.memoryUsage) {\n    return (results.value.memoryEfficiency.memoryUsage / 1024 / 1024).toFixed(1)\n  }\n  return '0.0'\n})\n\nconst performanceGrade = computed(() => {\n  if (!hasResults.value) return '-'\n  // Weight the grade more towards critical UI metrics (Canvas & Render)\n  const canvasTime = results.value.canvasPerformance?.averageTime || 0\n  const renderTime = results.value.renderPerformance?.averageTime || 0\n  const otherAvg = Object.values(results.value)\n    .filter((r: any) => r.name !== 'Canvas Performance' && r.name !== 'Render Performance')\n    .reduce((sum: number, r: any) => sum + r.averageTime, 0) / (Object.keys(results.value).length - 2 || 1)\n\n  const weightedAvg = (canvasTime * 0.4) + (renderTime * 0.4) + (otherAvg * 0.2)\n  \n  if (weightedAvg < 16) return 'A+'\n  if (weightedAvg < 48) return 'A'\n  if (weightedAvg < 96) return 'B'\n  if (weightedAvg < 192) return 'C'\n  return 'D'\n})\n\nconst performanceGradeClass = computed(() => {\n  const grade = performanceGrade.value\n  if (grade === 'A+' || grade === 'A') return 'grade-a'\n  if (grade === 'B') return 'grade-b'\n  if (grade === 'C') return 'grade-c'\n  return 'grade-d'\n})\n\nconst statusMessage = computed(() => {\n  if (!hasResults.value) return 'System status unknown'\n  const grade = performanceGrade.value\n  if (grade === 'A+' || grade === 'A') return 'Excellent Performance'\n  if (grade === 'B') return 'Good Performance'\n  return 'Performance Needs Attention'\n})\n\nconst getStatusClass = (result: any) => {\n  // Relaxed thresholds for batch operations (Canvas)\n  if (result.name === 'Canvas Performance') {\n    if (result.averageTime < 100) return 'status-fast'\n    if (result.averageTime < 250) return 'status-medium'\n    return 'status-badge slow'\n  }\n  // Strict thresholds for frame-based ops (Render, Store)\n  if (result.averageTime < 16) return 'status-fast'\n  if (result.averageTime < 50) return 'status-medium'\n  return 'status-badge slow'\n}\n\nconst getStatusLabel = (result: any) => {\n  if (result.name === 'Canvas Performance') {\n    if (result.averageTime < 100) return 'FAST'\n    if (result.averageTime < 250) return 'OK'\n    return 'SLOW'\n  }\n  if (result.averageTime < 16) return 'FAST'\n  if (result.averageTime < 50) return 'OK'\n  return 'SLOW'\n}\n\nconst recommendations = computed(() => {\n  const recs = []\n  if (results.value?.canvasPerformance?.averageTime > 50) {\n    recs.push({ type: 'Canvas', message: 'High latency detected with many nodes. Consider LOD optimization.' })\n  }\n  if (results.value?.memoryEfficiency?.memoryUsage > 200 * 1024 * 1024) {\n    recs.push({ type: 'Memory', message: 'Memory usage is elevated. Check for leaks in node pooling.' })\n  }\n  if (results.value?.renderPerformance?.averageTime > 20) {\n    recs.push({ type: 'Render', message: 'Main thread is taking too long for UI updates. Review watcher complexity.' })\n  }\n  return recs\n})\n\nconst saveAsBaseline = () => {\n  const data = JSON.stringify({\n    timestamp: new Date().toISOString(),\n    results: results.value,\n    environment: {\n      userAgent: navigator.userAgent,\n      memoryLimit: (performance as any).memory?.jsHeapSizeLimit || 'unknown'\n    }\n  }, null, 2)\n  \n  const blob = new Blob([data], { type: 'application/json' })\n  const url = URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = `performance-baseline-${new Date().toISOString().split('T')[0]}.json`\n  a.click()\n  URL.revokeObjectURL(url)\n}\n</script>\n\n<style scoped>\n.performance-view {\n  padding: 2rem;\n  max-width: 1400px;\n  margin: 0 auto;\n  color: #e2e8f0;\n  height: 100vh;\n  overflow-y: auto;\n  scrollbar-width: auto; /* Revert to auto for better accessibility grab area */\n  scrollbar-color: rgba(99, 102, 241, 0.5) rgba(15, 23, 42, 0.1);\n}\n\n/* Custom scrollbar for Webkit browsers with wider handle */\n.performance-view::-webkit-scrollbar {\n  width: 14px;\n}\n\n.performance-view::-webkit-scrollbar-track {\n  background: rgba(15, 23, 42, 0.1);\n}\n\n.performance-view::-webkit-scrollbar-thumb {\n  background: rgba(99, 102, 241, 0.3);\n  border-radius: 7px;\n  border: 3px solid transparent;\n  background-clip: content-box;\n}\n\n.performance-view::-webkit-scrollbar-thumb:hover {\n  background: rgba(99, 102, 241, 0.5);\n  background-clip: content-box;\n}\n\n.glass {\n  background: rgba(255, 255, 255, 0.03);\n  backdrop-filter: blur(12px);\n  border: 1px solid rgba(255, 255, 255, 0.08);\n  border-radius: 16px;\n}\n\n.page-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1.5rem 2rem;\n  margin-bottom: 2rem;\n}\n\n.header-content--performance h1 {\n  margin: 0;\n  font-size: 1.75rem;\n  background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n}\n\n.header-content--performance p {\n  margin: 0.25rem 0 0;\n  opacity: 0.6;\n}\n\n.dashboard-grid {\n  display: grid;\n  grid-template-columns: 1fr 300px;\n  gap: 2rem;\n}\n\n.summary-cards {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 1.5rem;\n  grid-column: 1 / -1;\n}\n\n.card {\n  padding: 1.5rem;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  transition: transform 0.2s;\n}\n\n.card:hover {\n  transform: translateY(-4px);\n}\n\n.card h3 {\n  margin: 0;\n  font-size: 0.875rem;\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n  opacity: 0.5;\n}\n\n.stat-value {\n  font-size: 2rem;\n  font-weight: 700;\n  margin: 0.5rem 0;\n  color: #6366f1;\n}\n\n.grade-display {\n  font-size: 5rem;\n  font-weight: 800;\n  margin: 1rem 0;\n  line-height: 1;\n  text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);\n  color: #ff6b6b; /* Brighter red for accessibility */\n}\n\n.grade-a { color: #10b981; border-color: rgba(16, 185, 129, 0.3); }\n.grade-b { color: #f59e0b; border-color: rgba(245, 158, 11, 0.3); }\n.grade-c { color: #ef4444; border-color: rgba(239, 68, 68, 0.3); }\n.grade-d { color: #ef4444; border-color: rgba(239, 68, 68, 0.3); } /* Added for consistency */\n\n.results-container {\n  padding: 1.5rem;\n}\n\n.table-wrapper {\n  margin-top: 1.5rem;\n  overflow-x: auto;\n}\n\ntable {\n  width: 100%;\n  border-collapse: collapse;\n}\n\nth {\n  text-align: left;\n  padding: 1rem;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n  opacity: 0.6;\n  font-weight: 500;\n}\n\ntd {\n  padding: 1rem;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.05);\n}\n\n.test-name {\n  font-weight: 600;\n}\n\n.sidebar {\n  padding: 1.5rem;\n  height: fit-content;\n}\n\n.sidebar h2 {\n  font-size: 1.25rem;\n  margin-top: 0;\n}\n\n.sidebar ul {\n  padding-left: 1.25rem;\n  margin: 1rem 0;\n}\n\n.sidebar li {\n  margin-bottom: 0.75rem;\n  font-size: 0.9rem;\n  line-height: 1.4;\n}\n\n.baseline-tools {\n  margin-top: 2rem;\n  padding-top: 1.5rem;\n  border-top: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.footer-note {\n  margin-top: 1rem;\n  font-size: 0.75rem;\n  opacity: 0.5;\n}\n\n.status-badge {\n  padding: 0.25rem 0.6rem;\n  border-radius: 4px;\n  font-size: 0.7rem;\n  font-weight: 700;\n}\n\n.status-fast { background: rgba(16, 185, 129, 0.15); color: #10b981; }\n.status-medium { background: rgba(245, 158, 11, 0.15); color: #f59e0b; }\n.status-badge.slow {\n  background: rgba(239, 68, 68, 0.15);\n  color: #ff8a8a; /* Brighter red for contrast on dark background */\n  border: 1px solid rgba(239, 68, 68, 0.3);\n}\n\n.btn {\n  padding: 0.6rem 1.2rem;\n  border-radius: 8px;\n  border: none;\n  font-weight: 600;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.btn-primary { background: #6366f1; color: white; }\n.btn-primary:hover { background: #4f46e5; }\n.btn-secondary { background: rgba(255, 255, 255, 0.1); color: white; }\n.btn-secondary:hover { background: rgba(255, 255, 255, 0.15); }\n.btn:disabled { opacity: 0.5; cursor: not-allowed; }\n\n.progress-bar {\n  width: 60px;\n  height: 6px;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 3px;\n  display: inline-block;\n  margin-right: 0.5rem;\n  vertical-align: middle;\n}\n\n.progress {\n  height: 100%;\n  background: #6366f1;\n  border-radius: 3px;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/views/QuickSortView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]}]
