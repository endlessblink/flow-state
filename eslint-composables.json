[{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/__tests__/useDateTransition.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'expect' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useDateTransition' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":27}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { setActivePinia, createPinia } from 'pinia'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useDateTransition } from '@/composables/useDateTransition'\n\n// Mock the date transition composable to avoid real timers\nvi.mock('@/composables/useDateTransition', () => ({\n    useDateTransition: vi.fn(({ onDayChange }) => ({\n        startWatching: vi.fn(),\n        stopWatching: vi.fn(),\n        simulateTransition: () => onDayChange(new Date(), new Date())\n    }))\n}))\n\ndescribe('Date Transition Logic (TASK-082)', () => {\n    let canvasStore: any\n    let taskStore: any\n\n    beforeEach(() => {\n        setActivePinia(createPinia())\n        canvasStore = useCanvasStore()\n        taskStore = useTaskStore()\n    })\n\n    afterEach(() => {\n        vi.clearAllMocks()\n    })\n\n    it('moves tasks from \"Today\" to \"Overdue\" group on midnight transition', async () => {\n        // 1. Setup Groups\n        const todayGroup = {\n            id: 'group-today',\n            type: 'sectionNode',\n            name: 'Today', // Case insensitive check in implementation\n            position: { x: 0, y: 0, width: 300, height: 400 }\n        }\n\n        const overdueGroup = {\n            id: 'group-overdue',\n            type: 'sectionNode',\n            name: 'Overdue',\n            position: { x: 400, y: 0, width: 300, height: 400 }\n        }\n\n        // Add groups to store\n        // Note: Adjust based on actual store structure (groups vs sections)\n        canvasStore.sections = [todayGroup, overdueGroup]\n\n        // 2. Setup Task in \"Today\" group\n        const taskInToday = {\n            id: 'task-1',\n            title: 'Task in Today',\n            // Position visually inside Today group\n            canvasPosition: { x: 100, y: 100 },\n            isInInbox: false\n        }\n\n        const taskOutside = {\n            id: 'task-2',\n            title: 'Task Outside',\n            canvasPosition: { x: 800, y: 800 },\n            isInInbox: false\n        }\n\n        // Initialize tasks\n        taskStore.tasks = [taskInToday, taskOutside]\n\n        // 3. Trigger the logic\n        // We recreate the logic here since it lives in CanvasView.vue (which is hard to mount purely)\n        // or we verify the composable trigger. \n\n        // OPTION: We should move the logic from CanvasView to a composable/action to test it properly.\n        // For now, let's verify if we can extract the logic.\n    })\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/app/useAppInitialization.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1224,1227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1224,1227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1384,1387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1384,1387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2961,2964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2961,2964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3351,3354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3351,3354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3407,3410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3407,3410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3463,3466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3463,3466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4114,4117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4114,4117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4498,4501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4498,4501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4554,4557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4554,4557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4610,4613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4610,4613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5770,5773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5770,5773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":170,"column":22,"nodeType":"BlockStatement","messageId":"unexpected","endLine":172,"endColumn":10,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6839,6849],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onMounted, onUnmounted } from 'vue'\nimport { useTimerStore } from '@/stores/timer'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useProjectStore } from '@/stores/projects'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useUIStore } from '@/stores/ui'\nimport { useNotificationStore } from '@/stores/notifications'\nimport { useAuthStore } from '@/stores/auth'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { useSafariITPProtection } from '@/utils/safariITPProtection'\nimport { initGlobalKeyboardShortcuts } from '@/utils/globalKeyboardHandlerSimple'\nimport { clearGuestData } from '@/utils/guestModeStorage'\n// BUG-FIX: Import mappers to properly convert realtime data\nimport { fromSupabaseTask, fromSupabaseProject, type SupabaseTask, type SupabaseProject } from '@/utils/supabaseMappers'\n\nexport function useAppInitialization() {\n    const timerStore = useTimerStore()\n    const taskStore = useTaskStore()\n    const projectStore = useProjectStore()\n    const canvasStore = useCanvasStore()\n    const uiStore = useUIStore()\n    const notificationStore = useNotificationStore()\n    const itpProtection = useSafariITPProtection()\n    const activeChannel = ref<any>(null)\n\n    onMounted(async () => {\n        // MARK: SESSION START for stability guards\n        if (typeof window !== 'undefined') {\n            (window as any).PomoFlowSessionStart = Date.now()\n        }\n\n\n        // 0. Initialize auth and clear guest data if not authenticated\n        const authStore = useAuthStore()\n        await authStore.initialize()\n\n        if (!authStore.isAuthenticated) {\n            // Guest mode: clear all persisted data for fresh experience\n            clearGuestData()\n\n        }\n\n        // 1. Initial Load from Supabase\n\n        uiStore.loadState()\n\n        await Promise.all([\n            taskStore.loadFromDatabase(),\n            projectStore.loadProjectsFromDatabase(),\n            canvasStore.loadFromDatabase()\n        ])\n\n\n\n        // Initialize notification system\n        try {\n            await notificationStore.initializeNotifications()\n        } catch (error) {\n            console.warn('⚠️ Notification system initialization failed:', error)\n        }\n\n        // Request notification permission for timer\n        try {\n            await timerStore.requestNotificationPermission()\n        } catch (error) {\n            console.warn('⚠️ Timer notification permission request failed:', error)\n        }\n\n        // Safari ITP Protection\n        try {\n            itpProtection.initialize()\n            itpProtection.recordInteraction()\n        } catch (error) {\n            console.warn('⚠️ Safari ITP check failed:', error)\n        }\n\n        // Initialize global keyboard shortcuts\n        await initGlobalKeyboardShortcuts()\n\n        // 3. Initialize Realtime Subscriptions\n        const { initRealtimeSubscription } = useSupabaseDatabase()\n\n        const onProjectChange = (payload: any) => {\n            // BUG-FIX: Fetch FRESH store instance inside callback to prevent stale closures\n            const canvas = useCanvasStore()\n            const projects = useProjectStore()\n\n            // HARDENED LOCK: Check store, dragging, resizing, and settling flags\n            const isLocked = canvas.isDragging || (typeof window !== 'undefined' && (\n                (window as any).__PomoFlowIsDragging ||\n                (window as any).__PomoFlowIsResizing ||\n                (window as any).__PomoFlowIsSettling\n            ))\n\n            if (isLocked) {\n\n                return\n            }\n\n            const { eventType, new: newDoc, old: oldDoc } = payload\n            if (eventType === 'DELETE' || (newDoc && newDoc.is_deleted)) {\n                projects.removeProjectFromSync(newDoc?.id || oldDoc?.id)\n            } else if (newDoc) {\n                // BUG-FIX: Map raw Supabase data to app format\n                const mappedProject = fromSupabaseProject(newDoc as SupabaseProject)\n                projects.updateProjectFromSync(mappedProject.id, mappedProject)\n            }\n        }\n\n        const onTaskChange = (payload: any) => {\n            // BUG-FIX: Fetch FRESH store instance inside callback to prevent stale closures\n            const canvas = useCanvasStore()\n            const tasks = useTaskStore()\n\n            // HARDENED LOCK: Check store, dragging, resizing, and settling flags\n            const isLocked = canvas.isDragging || (typeof window !== 'undefined' && (\n                (window as any).__PomoFlowIsDragging ||\n                (window as any).__PomoFlowIsResizing ||\n                (window as any).__PomoFlowIsSettling\n            ))\n\n            if (isLocked) {\n\n                return\n            }\n\n            const { eventType, new: newDoc, old: oldDoc } = payload\n            const taskId = newDoc?.id || oldDoc?.id\n            if (!taskId) return\n\n            // BUG-169 DEBUG: Log ALL realtime events to diagnose task disappearance\n            /* console.log(`[REALTIME] Task event:`, {\n                eventType,\n                taskId: taskId?.substring(0, 8),\n                is_deleted: newDoc?.is_deleted,\n                title: newDoc?.title?.substring(0, 20) || oldDoc?.title?.substring(0, 20)\n            }) */\n\n            // BUG-169 FIX: Safety guards to prevent spurious task deletions\n            // 1. Check for hard DELETE event (eventType === 'DELETE')\n            // 2. Check for soft delete ONLY if is_deleted is EXPLICITLY true (not just truthy)\n            const isHardDelete = eventType === 'DELETE'\n            const isSoftDelete = newDoc && newDoc.is_deleted === true\n\n            if (isHardDelete || isSoftDelete) {\n                // Extra safety: Check session start time\n                const sessionStart = (window as any).PomoFlowSessionStart || 0\n                const timeSinceSessionStart = Date.now() - sessionStart\n\n                // Don't process deletions in the first 5 seconds of the session (anti-race guard)\n                if (timeSinceSessionStart < 5000) {\n                    console.warn(`[REALTIME] BLOCKED deletion for task ${taskId.substring(0, 8)} - session just started`)\n                    return\n                }\n\n                console.warn(`[REALTIME] Removing task ${taskId.substring(0, 8)}`)\n                tasks.updateTaskFromSync(taskId, null, true)\n            } else if (newDoc) {\n                // BUG-FIX: Map raw Supabase data to app format\n                // This ensures is_deleted -> _soft_deleted, position -> canvasPosition, etc.\n                const mappedTask = fromSupabaseTask(newDoc as SupabaseTask)\n\n                tasks.updateTaskFromSync(taskId, mappedTask, false)\n            }\n        }\n\n        const channel = initRealtimeSubscription(onProjectChange, onTaskChange)\n        activeChannel.value = channel\n\n        if (channel) {\n\n        }\n\n\n    })\n\n    onUnmounted(() => {\n        if (activeChannel.value) {\n\n            activeChannel.value.unsubscribe()\n            activeChannel.value = null\n        }\n    })\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/app/useAppShortcuts.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'undoHistory' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":8,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRouter } from 'vue-router'\nimport { useTaskStore } from '@/stores/tasks'\nimport { getUndoSystem } from '@/composables/undoSingleton'\n\nexport function useAppShortcuts() {\n    const router = useRouter()\n    const taskStore = useTaskStore()\n    const undoHistory = getUndoSystem()\n\n    // Route mapping for keyboard shortcuts\n    const viewRouteMap = {\n        '1': '/',\n        '2': '/calendar',\n        '3': '/canvas',\n        '4': '/catalog',\n        '5': '/quick-sort'\n    }\n\n    const shouldIgnoreElement = (target: HTMLElement | null): boolean => {\n        if (!target) return false\n        // Guard against non-Element targets (like document)\n        if (!target.classList) return false\n        if (target.classList.contains('quick-task-input') ||\n            target.closest('.quick-task-section')) {\n            return false\n        }\n        if (target.tagName === 'INPUT' ||\n            target.tagName === 'TEXTAREA' ||\n            target.isContentEditable) {\n            return true\n        }\n        const closestModal = target.closest('[role=\"dialog\"], .modal, .n-modal')\n        if (closestModal) return true\n        return false\n    }\n\n    const handleDeleteSelectedTasks = async () => {\n        const selectedTaskIds = [...taskStore.selectedTaskIds]\n        if (selectedTaskIds.length === 0) return\n\n        // Instead of showing confirmation here, we could emit an event\n        // or just call a taskStore method that triggers the confirmation\n        // For now, let's emit a global event that ModalManager can catch\n        window.dispatchEvent(new CustomEvent('confirm-delete-selected'))\n    }\n\n    const handleKeydown = (event: KeyboardEvent) => {\n        const target = event.target as HTMLElement\n        if (shouldIgnoreElement(target)) return\n\n        // Cmd/Ctrl+K to open Command Palette\n        if ((event.ctrlKey || event.metaKey) && event.key === 'k') {\n            event.preventDefault()\n            window.dispatchEvent(new CustomEvent('open-command-palette'))\n        }\n\n        // Cmd/Ctrl+P to open search\n        if ((event.ctrlKey || event.metaKey) && event.key === 'p') {\n            event.preventDefault()\n            window.dispatchEvent(new CustomEvent('open-search'))\n        }\n\n        // Shift+Delete to delete selected tasks\n        if (event.shiftKey && event.key === 'Delete') {\n            event.preventDefault()\n            handleDeleteSelectedTasks()\n        }\n\n        // Ctrl+E (or Cmd+E) to edit selected task\n        if ((event.ctrlKey || event.metaKey) && event.key === 'e') {\n            event.preventDefault()\n            if (taskStore.selectedTaskIds.length === 1) {\n                window.dispatchEvent(new CustomEvent('open-task-edit', {\n                    detail: { taskId: taskStore.selectedTaskIds[0] }\n                }))\n            }\n        }\n\n        // Shift+1-5 for view switching\n        if (event.shiftKey && !event.ctrlKey && !event.metaKey && !event.altKey) {\n            const key = event.key\n            if (key >= '1' && key <= '5') {\n                const route = viewRouteMap[key as keyof typeof viewRouteMap]\n                if (route) {\n                    event.preventDefault()\n                    router.push(route)\n                }\n            }\n        }\n    }\n\n    return {\n        handleKeydown,\n        handleDeleteSelectedTasks\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/app/useSidebarManagement.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":71,"column":32,"nodeType":"BlockStatement","messageId":"unexpected","endLine":73,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2368,2374],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":437,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14434,14437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14434,14437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, toRefs } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useUIStore } from '@/stores/ui'\nimport { useRouter } from 'vue-router'\nimport type { Project } from '@/types/tasks'\n\n/**\n * Sidebar Management State Management Composable\n *\n * Extracted from App.vue to centralize all sidebar-related state and functionality\n * including project navigation, smart views, quick task creation, and project management.\n *\n * This composable manages:\n * - Quick task creation and input state\n * - Project tree navigation and expansion\n * - Smart view selection and filtering\n * - Project hierarchy management\n * - Context menu handling for projects\n * - Drag and drop functionality for projects\n */\n\n// Shared state instances to ensure all components see the same sidebar state\nconst newTaskTitle = ref('')\nconst showCreateProject = ref(false)\n// const expandedProjects = ref<string[]>([]) // Moved to UI Store\nconst showProjectModal = ref(false)\nconst editingProject = ref<Project | null>(null)\n// const isDurationSectionExpanded = ref(true) // Moved to UI Store\n\nexport function useSidebarManagement() {\n  const taskStore = useTaskStore()\n  const uiStore = useUIStore()\n  const { isDurationSectionExpanded, expandedProjectIds: expandedProjects } = toRefs(uiStore)\n\n  const router = useRouter()\n\n  // Platform detection\n  const isMac = typeof navigator !== 'undefined' && navigator.platform.toUpperCase().indexOf('MAC') >= 0\n\n  // Helper function to filter projects for sidebar display\n  const filterSidebarProjects = (projects: Project[]): Project[] => {\n    // ... (rest of function unchanged, just need to make sure we don't break indentation)\n\n\n    // FIX: More robust filtering logic\n    const filtered = projects.filter((p): p is Project => {\n      if (!p) return false // Remove null/undefined projects\n\n      if (!p.id) {\n        return false // Remove projects without ID\n      }\n\n      // Keep ALL real projects, filter out only synthetic ones\n      const isSynthetic = p.id.startsWith('synthetic')\n      if (isSynthetic) {\n        return false\n      }\n\n      // FIX: Additional validation for real projects\n      if (!p.name || p.name.trim() === '') {\n        return false\n      }\n\n\n      return true\n    })\n\n\n\n    // No projects is valid - user can have uncategorized tasks without any projects\n    if (filtered.length === 0) {\n\n    }\n\n    return filtered\n  }\n\n  // Computed Properties for Project Hierarchy\n  // Use centralized rootProjects from task store\n  const rootProjects = computed(() => {\n    const result = taskStore.rootProjects || []\n    return result\n  })\n\n  const getChildren = (parentId: string) => {\n    try {\n      const allProjects = Array.isArray(taskStore.projects) ? taskStore.projects : []\n      const childrenOnly = allProjects.filter(p => p && p.id && p.parentId === parentId)\n      return filterSidebarProjects(childrenOnly) // Exclude synthetic projects\n    } catch (error) {\n      console.error('❌ Error in getChildren computation:', error)\n      return []\n    }\n  }\n\n  const hasChildren = (projectId: string) => {\n    try {\n      const allProjects = Array.isArray(taskStore.projects) ? taskStore.projects : []\n      const childrenOnly = allProjects.filter(p => p && p.id && p.parentId === projectId)\n      return filterSidebarProjects(childrenOnly).length > 0 // Check if there are any child projects\n    } catch (error) {\n      console.error('❌ Error in hasChildren computation:', error)\n      return false\n    }\n  }\n\n  // Smart View Counts\n  const todayTaskCount = computed(() => {\n    const todayStr = new Date().toISOString().split('T')[0]\n    const today = new Date()\n    today.setHours(0, 0, 0, 0)\n\n    return taskStore.tasks.filter(task => {\n      // BUG-FIX: Exclude soft-deleted tasks\n      if (task._soft_deleted) return false\n      // Exclude done tasks from today count (matches filteredTasks logic)\n      if (task.status === 'done') {\n        return false\n      }\n\n      // Check if task is due today (matches filteredTasks logic)\n      if (task.dueDate && task.dueDate === todayStr) {\n        return true\n      }\n\n      // Check if task has instances scheduled for today (matches filteredTasks logic)\n      if (task.instances && task.instances.length > 0) {\n        const hasTodayInstance = task.instances.some(inst =>\n          inst && inst.scheduledDate === todayStr\n        )\n        if (hasTodayInstance) {\n          return true\n        }\n      }\n\n      // Check legacy scheduled date for today (matches filteredTasks logic)\n      if (task.scheduledDate && task.scheduledDate === todayStr) {\n        return true\n      }\n\n      // Tasks currently in progress (matches filteredTasks logic)\n      if (task.status === 'in_progress') {\n        return true\n      }\n\n      return false\n    }).length\n  })\n\n  const weekTaskCount = computed(() => {\n    // Calculate tasks for the current week (today through Sunday) using same logic as store\n    const today = new Date()\n    today.setHours(0, 0, 0, 0)\n    const todayStr = today.toISOString().split('T')[0]\n\n    // Calculate end of current week (Sunday)\n    const weekEnd = new Date(today)\n    const dayOfWeek = today.getDay()\n    const daysUntilSunday = (7 - dayOfWeek) % 7 || 7 // If today is Sunday (0), daysUntilSunday = 7\n    weekEnd.setDate(today.getDate() + daysUntilSunday)\n    const weekEndStr = weekEnd.toISOString().split('T')[0]\n\n    return taskStore.tasks.filter(task => {\n      // BUG-FIX: Exclude soft-deleted tasks\n      if (task._soft_deleted) return false\n      // Exclude done tasks from week count (matches filteredTasks logic)\n      if (task.status === 'done') {\n        return false\n      }\n\n      // Include tasks due within the current week (today through Sunday)\n      if (task.dueDate && task.dueDate >= todayStr && task.dueDate <= weekEndStr) {\n        return true\n      }\n\n      // Check if task has instances scheduled within the week (matches filteredTasks logic)\n      if (task.instances && task.instances.length > 0) {\n        const hasWeekInstance = task.instances.some(inst =>\n          inst && inst.scheduledDate >= todayStr && inst.scheduledDate <= weekEndStr\n        )\n        if (hasWeekInstance) {\n          return true\n        }\n      }\n\n      // Check legacy scheduled dates within the week (matches filteredTasks logic)\n      if (task.scheduledDate && task.scheduledDate >= todayStr && task.scheduledDate <= weekEndStr) {\n        return true\n      }\n\n      // Tasks currently in progress (matches filteredTasks logic)\n      if (task.status === 'in_progress') {\n        return true\n      }\n\n      // FIX (Dec 5, 2025): Include tasks created today (matches useSmartViews.isWeekTask)\n      // This ensures new tasks appear in \"This Week\" until scheduled\n      if (task.createdAt) {\n        const createdDate = new Date(task.createdAt)\n        if (!isNaN(createdDate.getTime())) {\n          createdDate.setHours(0, 0, 0, 0)\n          if (createdDate.getTime() === today.getTime()) {\n            return true\n          }\n        }\n      }\n\n      return false\n    }).length\n  })\n\n  // All Active task count - counts all non-done tasks\n  const allActiveCount = computed(() => {\n    // Use the centralized counter from task store for consistency\n    if (taskStore && typeof taskStore.nonDoneTaskCount === 'number') {\n      return taskStore.nonDoneTaskCount\n    }\n\n    // Fallback to manual filtering\n    return taskStore.tasks.filter(task => {\n      // BUG-FIX: Exclude soft-deleted tasks\n      if (task._soft_deleted) return false\n      // Count all tasks that are not marked as done\n      // This matches the \"all_active\" smart view logic\n      return task.status !== 'done'\n    }).length\n  })\n\n  // Uncategorized task count for Quick Sort badge\n  const uncategorizedCount = computed(() => {\n    // Use the exact same logic as the store's uncategorized filter for consistency\n    const filteredTasks = taskStore.tasks.filter(task => {\n      // BUG-FIX: Exclude soft-deleted tasks\n      if (task._soft_deleted) return false\n      // Apply same filtering logic as uncategorized smart view in taskStore.filteredTasks\n      // Check isUncategorized flag first\n      if (task.isUncategorized === true) {\n        return true\n      }\n\n      // Backward compatibility: treat tasks without proper project assignment as uncategorized\n      // REMOVED: projectId === '1' check - \"My Tasks\" concept removed\n      if (!task.projectId || task.projectId === '' || task.projectId === null) {\n        return true\n      }\n\n      return false\n    })\n\n    // Apply the same hideDoneTasks logic as the task store\n    const finalCount = taskStore.hideDoneTasks\n      ? filteredTasks.filter(task => task.status !== 'done').length\n      : filteredTasks.length\n\n    return finalCount\n  })\n\n  // Duration Counts - Proxy from store\n  const quickCount = computed(() => taskStore.smartViewTaskCounts.quick)\n  const shortCount = computed(() => taskStore.smartViewTaskCounts.short)\n  const mediumCount = computed(() => taskStore.smartViewTaskCounts.medium)\n  const longCount = computed(() => taskStore.smartViewTaskCounts.long)\n  const unestimatedCount = computed(() => taskStore.smartViewTaskCounts.unestimated)\n\n  // Task management methods\n  const createQuickTask = async () => {\n    if (newTaskTitle.value.trim()) {\n      // Use the unified undo system\n      const { useUnifiedUndoRedo } = await import('@/composables/useUnifiedUndoRedo')\n      const undoRedoActions = useUnifiedUndoRedo()\n      undoRedoActions.createTaskWithUndo({\n        title: newTaskTitle.value.trim(),\n        description: '',\n        status: 'planned',\n        projectId: undefined // ✅ FIXED: Use undefined instead of forbidden '1'\n      })\n      newTaskTitle.value = ''\n    }\n  }\n\n  // Project Navigation Methods\n  const toggleProjectExpansion = (projectId: string) => {\n    const index = expandedProjects.value.indexOf(projectId)\n    if (index > -1) {\n      expandedProjects.value.splice(index, 1)\n    } else {\n      expandedProjects.value.push(projectId)\n    }\n    uiStore.persistState() // Manual save trigger since we're modifying the array in place\n  }\n\n  const selectProject = (project: Project) => {\n    taskStore.setActiveProject(project.id)\n    taskStore.setSmartView(null)\n  }\n\n  // Keyboard navigation for project tree\n  const handleProjectTreeKeydown = (event: KeyboardEvent) => {\n    const { key } = event\n\n    switch (key) {\n      case 'ArrowDown':\n        event.preventDefault()\n        navigateToNextProject()\n        break\n      case 'ArrowUp':\n        event.preventDefault()\n        navigateToPreviousProject()\n        break\n      case 'ArrowRight':\n        event.preventDefault()\n        expandCurrentProject()\n        break\n      case 'ArrowLeft':\n        event.preventDefault()\n        collapseCurrentProjectOrNavigateToParent()\n        break\n      case 'Enter':\n      case ' ':\n        event.preventDefault()\n        activateCurrentProject()\n        break\n      case 'Home':\n        event.preventDefault()\n        navigateToFirstProject()\n        break\n      case 'End':\n        event.preventDefault()\n        navigateToLastProject()\n        break\n    }\n  }\n\n  // Navigation helpers\n  const navigateToNextProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    const allProjects = getFlattenedProjectList()\n    const currentIndex = allProjects.findIndex(p => p.id === currentProjectId)\n\n    if (currentIndex < allProjects.length - 1) {\n      taskStore.setActiveProject(allProjects[currentIndex + 1].id)\n    }\n  }\n\n  const navigateToPreviousProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    const allProjects = getFlattenedProjectList()\n    const currentIndex = allProjects.findIndex(p => p.id === currentProjectId)\n\n    if (currentIndex > 0) {\n      taskStore.setActiveProject(allProjects[currentIndex - 1].id)\n    }\n  }\n\n  const expandCurrentProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    if (currentProjectId && hasChildren(currentProjectId)) {\n      if (!expandedProjects.value.includes(currentProjectId)) {\n        expandedProjects.value.push(currentProjectId)\n        uiStore.persistState()\n      }\n    }\n  }\n\n  const collapseCurrentProjectOrNavigateToParent = () => {\n    const currentProjectId = taskStore.activeProjectId\n    if (!currentProjectId) return\n\n    // If project has children and is expanded, collapse it\n    if (hasChildren(currentProjectId) && expandedProjects.value.includes(currentProjectId)) {\n      const index = expandedProjects.value.indexOf(currentProjectId)\n      expandedProjects.value.splice(index, 1)\n      uiStore.persistState()\n    } else {\n      // Otherwise, navigate to parent if exists\n      const project = taskStore.getProjectById(currentProjectId)\n      if (project?.parentId) {\n        taskStore.setActiveProject(project.parentId)\n      }\n    }\n  }\n\n  const activateCurrentProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    if (currentProjectId) {\n      const project = taskStore.getProjectById(currentProjectId)\n      if (project) {\n        selectProject(project)\n      }\n    }\n  }\n\n  const navigateToFirstProject = () => {\n    const allProjects = getFlattenedProjectList()\n    if (allProjects.length > 0) {\n      taskStore.setActiveProject(allProjects[0].id)\n    }\n  }\n\n  const navigateToLastProject = () => {\n    const allProjects = getFlattenedProjectList()\n    if (allProjects.length > 0) {\n      taskStore.setActiveProject(allProjects[allProjects.length - 1].id)\n    }\n  }\n\n  // Helper functions for navigation\n  const getFlattenedProjectList = (): Project[] => {\n    const flatten = (projects: Project[], _level = 1): Project[] => {\n      const result: Project[] = []\n\n      for (const project of projects) {\n        if (!project.parentId) { // Only include root projects initially\n          result.push(project)\n\n          if (expandedProjects.value.includes(project.id)) {\n            const children = taskStore.projects.filter(p => p.parentId === project.id)\n            result.push(...flatten(children, _level + 1))\n          }\n        }\n      }\n\n      return result\n    }\n\n    return flatten(taskStore.projects)\n  }\n\n\n\n  const toggleDurationSection = () => {\n    isDurationSectionExpanded.value = !isDurationSectionExpanded.value\n    uiStore.persistState()\n  }\n\n  const selectSmartView = (view: 'today' | 'week' | 'uncategorized' | 'all_active' | 'quick' | 'short' | 'medium' | 'long' | 'unestimated') => {\n    taskStore.setSmartView(view as any)\n  }\n\n  // Start Quick Sort from uncategorized view\n  const handleStartQuickSort = () => {\n\n    router.push({ name: 'quick-sort' })\n  }\n\n  const getProjectTaskCount = (projectId: string) => {\n    // Include tasks from child projects recursively\n    const countTasksRecursive = (pid: string): number => {\n      const directTasks = taskStore.tasks.filter(task => task.projectId === pid).length\n      const children = getChildren(pid)\n      const childTasks = children.reduce((sum, child) => sum + countTasksRecursive(child.id), 0)\n      return directTasks + childTasks\n    }\n\n    return countTasksRecursive(projectId)\n  }\n\n  // Project management methods\n  const openCreateProject = () => {\n    editingProject.value = null\n    showProjectModal.value = true\n  }\n\n  const openEditProject = (project: Project) => {\n    editingProject.value = project\n    showProjectModal.value = true\n  }\n\n  // Handle project un-nesting (drag to \"All Projects\")\n  const handleProjectUnnest = (data: { projectId?: string; title?: string }) => {\n    if (data.projectId) {\n      // Remove parent relationship by setting parentId to null\n      taskStore.updateProject(data.projectId, { parentId: null })\n\n    }\n  }\n\n  return {\n    // State\n    newTaskTitle,\n    showCreateProject,\n    expandedProjects,\n    showProjectModal,\n    editingProject,\n    isMac,\n    isDurationSectionExpanded,\n\n    // Computed properties\n    rootProjects,\n    todayTaskCount,\n    weekTaskCount,\n    allActiveCount,\n    uncategorizedCount,\n    quickCount,\n    shortCount,\n    mediumCount,\n    longCount,\n    unestimatedCount,\n\n    // Task management methods\n    createQuickTask,\n\n    // Project navigation methods\n    toggleProjectExpansion,\n    toggleDurationSection,\n    selectProject,\n    handleProjectTreeKeydown,\n    selectSmartView,\n    handleStartQuickSort,\n    getProjectTaskCount,\n\n    // Project management methods\n    openCreateProject,\n    openEditProject,\n    handleProjectUnnest,\n\n    // Helper methods\n    getChildren,\n    hasChildren\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Task' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'errorMessage' is defined but never used. Allowed unused args must match /^_/u.","line":14,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":18,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":23}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Task, useTaskStore } from '@/stores/tasks'\nimport type { useTimerStore } from '@/stores/timer'\n\ninterface BoardActionsDependencies {\n    taskStore: ReturnType<typeof useTaskStore>\n    timerStore: ReturnType<typeof useTimerStore>\n}\n\nexport function useBoardActions(deps: BoardActionsDependencies) {\n    const { taskStore, timerStore } = deps\n\n    const handleWithError = async <T>(\n        operation: () => Promise<T>,\n        errorMessage: string\n    ): Promise<T | null> => {\n        try {\n            return await operation()\n        } catch (error) {\n            return null\n        }\n    }\n\n    const selectTask = (taskId: string) => {\n        taskStore.selectTask(taskId)\n    }\n\n    const startTimer = (taskId: string) => {\n        timerStore.startTimer(taskId, timerStore.settings.workDuration, false)\n    }\n\n    const quickTaskCreate = async (title: string, description: string, status: string, projectId?: string) => {\n        return handleWithError(\n            () => taskStore.createTaskWithUndo({\n                title,\n                description,\n                status: status as 'planned' | 'in_progress' | 'done',\n                projectId: projectId\n            }),\n            '❌ Error creating task:'\n        )\n    }\n\n    const deleteTask = async (taskId: string) => {\n        return handleWithError(\n            () => taskStore.deleteTaskWithUndo(taskId),\n            '❌ Error deleting task:'\n        )\n    }\n\n    const moveTask = async (taskId: string, newStatus: string) => {\n        return handleWithError(\n            () => taskStore.moveTaskWithUndo(taskId, newStatus as 'planned' | 'in_progress' | 'done'),\n            '❌ Error moving task:'\n        )\n    }\n\n    const addSubtask = async (taskId: string, title: string = 'New Subtask') => {\n        return handleWithError(\n            () => taskStore.createSubtaskWithUndo(taskId, { title }),\n            '❌ Error creating subtask:'\n        )\n    }\n\n    return {\n        selectTask,\n        startTimer,\n        quickTaskCreate,\n        deleteTask,\n        moveTask,\n        addSubtask\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardContextMenu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardDensity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardModals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":82,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed } from 'vue'\nimport type { Task, useTaskStore, RecurringTaskInstance } from '@/stores/tasks'\nimport { parseDateKey, getTaskInstances } from '@/stores/tasks'\n\ninterface BoardStateDependencies {\n    taskStore: ReturnType<typeof useTaskStore>\n}\n\nexport function useBoardState(deps: BoardStateDependencies) {\n    const { taskStore } = deps\n\n    // Helper to get a project and all its descendants recursively with cycle detection\n    const getProjectAndChildren = (projectId: string, visited = new Set<string>()): string[] => {\n        if (visited.has(projectId)) return []\n        visited.add(projectId)\n\n        const ids = [projectId]\n        const childProjects = taskStore.projects.filter(p => p.parentId === projectId)\n        childProjects.forEach(child => {\n            ids.push(...getProjectAndChildren(child.id, visited))\n        })\n        return ids\n    }\n\n    // Group tasks by project (using filtered tasks from store)\n    // TASK-243: Filter done tasks locally based on hideDoneTasks setting\n    const tasksByProject = computed(() => {\n        const grouped: Record<string, Task[]> = {}\n\n        taskStore.filteredTasks\n            .filter(task => !(taskStore.hideDoneTasks && task.status === 'done'))\n            .forEach(task => {\n                const projectId = task.projectId || 'uncategorized'\n                if (!grouped[projectId]) {\n                    grouped[projectId] = []\n                }\n                grouped[projectId].push(task)\n            })\n\n        return grouped\n    })\n\n    // Get projects to display (TASK-243: Filter out empty projects)\n    const projectsWithTasks = computed(() => {\n        // If a specific project is selected, show that project AND its children\n        if (taskStore.activeProjectId) {\n            const projectIds = getProjectAndChildren(taskStore.activeProjectId)\n            return taskStore.projects.filter(project => projectIds.includes(project.id))\n        }\n\n        // Get real projects that have tasks (filter out empty ones)\n        const projects = taskStore.projects.filter(project => {\n            const tasksInProject = tasksByProject.value[project.id] || []\n            return tasksInProject.length > 0\n        })\n\n        // Add virtual \"Uncategorized\" project only if there are VISIBLE uncategorized tasks\n        // TASK-243: Use tasksByProject which already applies hideDoneTasks filter\n        const uncategorizedTasks = tasksByProject.value['uncategorized'] || []\n        if (uncategorizedTasks.length > 0) {\n            projects.push({\n                id: 'uncategorized',\n                name: 'Uncategorized',\n                color: '#6B7280',\n                colorType: 'hex' as const,\n                viewType: 'status' as const,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            })\n        }\n\n        return projects\n    })\n\n    // Total displayed tasks\n    const totalDisplayedTasks = computed(() => {\n        try {\n            if (taskStore && typeof taskStore.nonDoneTaskCount === 'number') {\n                return taskStore.nonDoneTaskCount\n            }\n            return taskStore?.filteredTasks?.length || 0\n        } catch (error) {\n            return 0\n        }\n    })\n\n    return {\n        tasksByProject,\n        projectsWithTasks,\n        totalDisplayedTasks,\n        getProjectAndChildren\n    }\n}\n\n// --- Grouping Helpers ---\n\nexport const addDays = (date: Date, amount: number) => {\n    const next = new Date(date)\n    next.setDate(next.getDate() + amount)\n    next.setHours(0, 0, 0, 0)\n    return next\n}\n\nexport const isSameDay = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport const getUpcomingFriday = (base: Date) => {\n    const friday = new Date(base)\n    const diff = (5 - base.getDay() + 7) % 7\n    friday.setDate(base.getDate() + diff)\n    friday.setHours(0, 0, 0, 0)\n    return friday\n}\n\nexport const getNextMonday = (base: Date) => {\n    const monday = new Date(base)\n    const diff = (8 - base.getDay()) % 7 || 7\n    monday.setDate(base.getDate() + diff)\n    monday.setHours(0, 0, 0, 0)\n    return monday\n}\n\nexport function groupTasksByStatus(tasks: Task[]) {\n    const result: Record<string, Task[]> = {\n        planned: [],\n        in_progress: [],\n        backlog: [],\n        on_hold: [],\n        done: []\n    }\n    tasks.forEach(task => {\n        if (result[task.status]) {\n            result[task.status].push(task)\n        }\n    })\n    return result\n}\n\nexport function groupTasksByPriority(tasks: Task[]) {\n    const result: Record<string, Task[]> = {\n        high: [],\n        medium: [],\n        low: [],\n        no_priority: []\n    }\n    tasks.forEach(task => {\n        const p = task.priority || 'no_priority'\n        if (result[p]) {\n            result[p].push(task)\n        }\n    })\n    return result\n}\n\nexport function groupTasksByDate(tasks: Task[], hideDoneTasks: boolean = false) {\n    const result: Record<string, Task[]> = {\n        overdue: [],\n        inbox: [],\n        today: [],\n        tomorrow: [],\n        thisWeek: [],\n        later: [],\n        noDate: []\n    }\n\n    const today = new Date()\n    today.setHours(0, 0, 0, 0)\n    const todayStr = today.toISOString().split('T')[0]\n    const tomorrow = addDays(today, 1)\n    const weekendStart = getUpcomingFriday(today)\n    const weekendEnd = addDays(weekendStart, 2)\n    const nextWeekStart = getNextMonday(today)\n    const nextWeekEnd = addDays(nextWeekStart, 6)\n    const afterNextWeekStart = addDays(nextWeekEnd, 1)\n\n    tasks.forEach(task => {\n        const instances = getTaskInstances(task)\n        const taskCreatedDate = new Date(task.createdAt)\n        taskCreatedDate.setHours(0, 0, 0, 0)\n        const oneDayAgo = new Date(today)\n        oneDayAgo.setDate(oneDayAgo.getDate() - 1)\n\n        const isCreatedToday = taskCreatedDate.getTime() === today.getTime()\n        const isDueToday = task.dueDate === todayStr\n        const isInProgress = task.status === 'in_progress'\n        const isOverdueByDate = task.dueDate && task.dueDate < todayStr\n\n        const hasPastInstance = instances.length > 0 && instances.some((instance: RecurringTaskInstance) => {\n            const instanceDate = parseDateKey(instance.scheduledDate)\n            return instanceDate && instanceDate < today\n        })\n        const isOldAndUnscheduled = taskCreatedDate < oneDayAgo && instances.length === 0 &&\n            !task.dueDate && task.status !== 'backlog'\n\n        // Overdue check\n        if (task.status !== 'done' && (isOverdueByDate || hasPastInstance || isOldAndUnscheduled)) {\n            result.overdue.push(task)\n            return\n        }\n\n        if (instances.length === 0) {\n            if (isCreatedToday || isDueToday || isInProgress) {\n                result.today.push(task)\n            } else {\n                result.noDate.push(task)\n            }\n            return\n        }\n\n        instances.forEach((instance: RecurringTaskInstance) => {\n            if (instance.isLater) {\n                result.later.push(task)\n                return\n            }\n\n            const instanceDate = parseDateKey(instance.scheduledDate)\n            if (!instanceDate) return\n\n            if (instanceDate < today) {\n                result.overdue.push(task)\n            } else if (isSameDay(instanceDate, today)) {\n                result.today.push(task)\n            } else if (isSameDay(instanceDate, tomorrow) && !(instanceDate >= weekendStart && instanceDate <= weekendEnd)) {\n                result.tomorrow.push(task)\n            } else if ((instanceDate >= weekendStart && instanceDate <= weekendEnd) || (instanceDate >= nextWeekStart && instanceDate <= nextWeekEnd)) {\n                result.thisWeek.push(task)\n            } else if (instanceDate >= afterNextWeekStart) {\n                result.later.push(task)\n            }\n        })\n    })\n\n    if (!hideDoneTasks) {\n        tasks.forEach(task => {\n            if (task.status === 'done' && !result.noDate.includes(task)) {\n                result.noDate.push(task)\n            }\n        })\n    }\n\n    return result\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/bulk/useBulkActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useSupabaseDatabase' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[643,646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[643,646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useAuthStore } from '@/stores/auth' // Added import for useAuthStore\nimport { supabase } from '@/services/auth/supabase'\n\nexport function useBulkActions() {\n    // const { getUserId } = useSupabaseDatabase() // Removed this line\n    const taskStore = useTaskStore()\n    const authStore = useAuthStore() // Added initialization for authStore\n\n    /**\n     * Batch update tasks with a partial payload (e.g. { status: 'done', priority: 1 })\n     */\n    const updateTasks = async (ids: string[], payload: Record<string, any>) => {\n        if (ids.length === 0) return\n\n        const userId = authStore.user?.id\n        if (!userId) return\n\n        // 1. Optimistic Update\n        ids.forEach(id => {\n            taskStore.updateTask(id, payload)\n        })\n\n        // 2. Persist to Supabase\n        const { error } = await supabase\n            .from('tasks')\n            .update({\n                ...payload,\n                updated_at: new Date().toISOString()\n            })\n            .in('id', ids)\n            .eq('user_id', userId)\n\n        if (error) {\n            console.error('Batch update failed:', error)\n            // TODO: Revert optimistic update or show toast\n            // For now, we rely on Realtime or refresh to correct state if it failed\n            throw error // Propagate so UI can handle (e.g. show toast)\n        }\n\n        return { success: true, count: ids.length }\n    }\n\n    /**\n     * Batch delete tasks (Soft Delete)\n     */\n    const deleteTasks = async (ids: string[]) => {\n        if (ids.length === 0) return\n\n        const userId = authStore.user?.id\n        if (!userId) return\n\n        // 1. Optimistic Update\n        ids.forEach(id => {\n            taskStore.deleteTask(id)\n        })\n\n        // 2. Persist to Supabase (Soft Delete via is_deleted flag or hard delete?)\n        // Note: Project currently uses hard delete for tasks usually, or soft delete pattern?\n        // Checking TaskStore: deleteTask calls store.tasks.delete(id)\n        // Checking Supabase implementation: usually hard delete.\n        // Let's assume hard delete for now to match current store behavior, \n        // OR check if we have deleted_at.\n        // In `useSupabaseDatabase`, `deleteTask` calls `.delete().eq('id', id)`.\n\n        const { error } = await supabase\n            .from('tasks')\n            .delete()\n            .in('id', ids)\n            .eq('user_id', userId)\n\n        if (error) {\n            console.error('Batch delete failed:', error)\n            // TODO: Revert\n            throw error\n        }\n\n        return { success: true, count: ids.length }\n    }\n\n    return {\n        updateTasks,\n        deleteTasks\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/bulk/useBulkSelection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarDateNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarDayView.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nextTick' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'taskError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":179,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'positionError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":188,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":188,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":192,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":192,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":320,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":320,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":418,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":418,"endColumn":19},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":418,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":419,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[13606,13611],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":555,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":555,"endColumn":23},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":560,"column":12,"nodeType":"BlockStatement","messageId":"unexpected","endLine":561,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[18551,18556],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":567,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":567,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'calendarEvent' is defined but never used. Allowed unused args must match /^_/u.","line":567,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":567,"endColumn":62}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, nextTick, type Ref } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport type { CalendarEvent, DragGhost } from '@/types/tasks'\nimport { calculateOverlappingPositions } from '@/utils/calendar/overlapCalculation'\n\nexport interface TimeSlot {\n  id: string\n  hour: number\n  minute: number\n  slotIndex: number\n  date: string\n}\n\n// Drag data from calendar drag operations\ninterface CalendarDragData {\n  taskId?: string\n  title?: string\n  source?: string\n  [key: string]: unknown\n}\n\n// Re-export for consumers\nexport type { DragGhost } from '@/types/tasks'\n\n/**\n * Day view specific logic for calendar\n * Handles event computation, drag-and-drop, resizing, and time slots\n */\n// Helper function to snap time to 15-minute intervals\nfunction snapTo15Minutes(hour: number, minute: number): { hour: number; minute: number } {\n  const totalMinutes = hour * 60 + minute\n\n  // Round to nearest 15-minute interval\n  const snappedMinutes = Math.round(totalMinutes / 15) * 15\n\n  // Convert back to hour and minute\n  const snappedHour = Math.floor(snappedMinutes / 60)\n  const snappedMinute = snappedMinutes % 60\n\n  return { hour: snappedHour, minute: snappedMinute }\n}\n\nexport function useCalendarDayView(currentDate: Ref<Date>, _statusFilter: Ref<string | null>) {\n  const taskStore = useTaskStore()\n  const { getPriorityColor, getDateString } = useCalendarCore()\n\n  const hours = Array.from({ length: 24 }, (_, i) => i)\n\n  // Drag ghost state\n  const dragGhost = ref<DragGhost>({\n    visible: false,\n    title: '',\n    duration: 30,\n    slotIndex: 0\n  })\n\n  // Drag mode state - enable dragging by default\n  const dragMode = ref<'none' | 'shift'>('shift')\n\n  // Drag state for visual feedback\n  const isDragging = ref(false)\n  const draggedEventId = ref<string | null>(null)\n  const activeDropSlot = ref<number | null>(null)\n\n  // Resize preview state - shows visual feedback during resize without updating store\n  const resizePreview = ref<{\n    taskId: string\n    direction: 'top' | 'bottom'\n    originalDuration: number\n    originalStartSlot: number\n    previewDuration: number\n    previewStartTime: string\n    isResizing: boolean\n  } | null>(null)\n\n  // Generate time slots for current day\n  const timeSlots = computed<TimeSlot[]>(() => {\n    const slots: TimeSlot[] = []\n    const dateStr = getDateString(currentDate.value)\n    let slotIndex = 0\n\n    hours.forEach(hour => {\n      [0, 30].forEach(minute => {\n        slots.push({\n          id: `${dateStr}-${hour}-${minute}`,\n          hour,\n          minute,\n          slotIndex,\n          date: dateStr\n        })\n        slotIndex++\n      })\n    })\n\n    return slots\n  })\n\n  // Generate calendar events with overlap positioning - simplified and error-resistant\n  const calendarEvents = computed<CalendarEvent[]>(() => {\n    try {\n      const dateStr = getDateString(currentDate.value)\n      const events: CalendarEvent[] = []\n\n      // Use filteredTasks to respect sidebar smart view and project filters\n      const filteredTasks = taskStore.filteredTasks || []\n\n      filteredTasks.forEach(task => {\n        if (!task) return // Skip invalid tasks\n\n        try {\n          // GUARD: Limit instance processing to prevent OOM from corrupted data\n          // If a task has > 100 instances for a single day, something is wrong.\n          const MAX_INSTANCES_PER_TASK = 50\n\n          // Check if task has instances scheduled for today\n          let instanceCount = 0\n          const hasInstanceForToday = task.instances && task.instances.some(instance => {\n            if (instanceCount++ > MAX_INSTANCES_PER_TASK) return false\n            return instance && instance.scheduledDate === dateStr\n          })\n\n          // Check for legacy schedule\n          const hasLegacyScheduleToday = task.scheduledDate === dateStr && task.scheduledTime\n\n          // Create calendar events only for tasks with explicit scheduling\n          if (hasInstanceForToday || hasLegacyScheduleToday) {\n            let startTime: Date\n            let duration: number\n            let instanceId: string | undefined\n\n            if (hasInstanceForToday) {\n              // Use instance-specific schedule\n              const todayInstance = task.instances?.find(instance => instance && instance.scheduledDate === dateStr)\n              if (!todayInstance || !todayInstance.scheduledTime) return\n\n              const [hour, minute] = todayInstance.scheduledTime.split(':').map(Number)\n              if (isNaN(hour) || isNaN(minute)) return\n\n              startTime = new Date(`${dateStr}T${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`)\n              duration = todayInstance.duration || task.estimatedDuration || 30\n              instanceId = todayInstance.id\n            } else if (task.scheduledTime) {\n              // Legacy schedule - use scheduledTime\n              const [hour, minute] = task.scheduledTime.split(':').map(Number)\n              if (isNaN(hour) || isNaN(minute)) return\n\n              startTime = new Date(`${dateStr}T${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`)\n              duration = task.estimatedDuration || 30\n            } else {\n              return\n            }\n\n            // Validate startTime\n            if (isNaN(startTime.getTime())) return\n\n            const endTime = new Date(startTime.getTime() + duration * 60000)\n            const startSlot = (startTime.getHours() * 2) + (startTime.getMinutes() >= 30 ? 1 : 0)\n            const slotSpan = Math.max(1, Math.ceil(duration / 30))\n\n            const event = {\n              id: instanceId || task.id,\n              taskId: task.id,\n              instanceId: instanceId || '',\n              title: task.title || 'Untitled Task',\n              startTime,\n              endTime,\n              duration,\n              startSlot,\n              slotSpan,\n              color: getPriorityColor(task.priority),\n              column: 0,\n              totalColumns: 1,\n              isDueDate: false\n            }\n\n            events.push(event)\n          }\n        } catch (taskError) {\n          // Continue with other tasks\n        }\n      })\n\n      // Calculate overlapping positions with error handling\n      try {\n        const positionedEvents = calculateOverlappingPositions(events)\n        return positionedEvents as CalendarEvent[]\n      } catch (positionError) {\n        // Return events without positioning if calculation fails\n        return events as CalendarEvent[]\n      }\n    } catch (error) {\n      // Return empty array to prevent template rendering failure\n      return []\n    }\n  })\n\n  /**\n   * Get tasks that should be rendered inside a specific time slot\n   * For slot-based rendering (tasks as children of slots, not floating events)\n   * Multi-slot tasks appear in each slot they span\n   */\n  const getTasksForSlot = (slot: TimeSlot): CalendarEvent[] => {\n    const allEvents = calendarEvents.value\n    const slotEvents = allEvents.filter(event => {\n      // Check if this slot is within the event's time range\n      const eventEndSlot = event.startSlot + event.slotSpan\n      return slot.slotIndex >= event.startSlot && slot.slotIndex < eventEndSlot\n    })\n\n    return slotEvents\n  }\n\n  /**\n   * Check if a task is the \"primary\" slot (first slot of multi-slot task)\n   * Used to determine if we should render full task content vs continuation indicator\n   */\n  const isTaskPrimarySlot = (slot: TimeSlot, event: CalendarEvent): boolean => {\n    return slot.slotIndex === event.startSlot\n  }\n\n  // use overlapCalculation utility\n\n  // Event styling\n  const getEventStyle = (event: CalendarEvent) => {\n    const slotHeight = 30\n    const widthPercentage = 100 / event.totalColumns\n    const leftPercentage = widthPercentage * event.column\n\n    return {\n      top: `${event.startSlot * slotHeight}px`,\n      height: `${event.slotSpan * slotHeight}px`,\n      left: `${leftPercentage}%`,\n      width: `${widthPercentage}%`\n    }\n  }\n\n  /**\n   * Compute positioning style for slot tasks (handles overlapping tasks side-by-side)\n   */\n  const getSlotTaskStyle = (calEvent: CalendarEvent) => {\n    const baseHeight = (calEvent.slotSpan * 30) - 4\n\n    // If no overlap (totalColumns is 1 or undefined), use normal flow with full width\n    if (!calEvent.totalColumns || calEvent.totalColumns <= 1) {\n      return {\n        height: `${baseHeight}px`,\n        minHeight: `${baseHeight}px`,\n        zIndex: 10\n      }\n    }\n\n    // Calculate width and position for overlapping events (like Google Calendar)\n    const gapPercent = 1 // 1% gap between columns\n    const totalGaps = calEvent.totalColumns - 1\n    const availableWidth = 100 - (totalGaps * gapPercent)\n    const widthPercentage = availableWidth / calEvent.totalColumns\n    const leftPercentage = (widthPercentage + gapPercent) * (calEvent.column || 0)\n\n    return {\n      position: 'absolute' as const,\n      top: '2px',\n      height: `${baseHeight}px`,\n      minHeight: `${baseHeight}px`,\n      width: `calc(${widthPercentage}% - 4px)`,\n      left: `calc(${leftPercentage}% + 2px)`,\n      zIndex: 10 + (calEvent.column || 0) // Later columns render on top\n    }\n  }\n\n  const getGhostStyle = () => {\n    const slotHeight = 30\n    const slotSpan = Math.ceil(dragGhost.value.duration / 30)\n\n    return {\n      top: `${dragGhost.value.slotIndex * slotHeight}px`,\n      height: `${slotSpan * slotHeight}px`,\n      left: '0',\n      width: '100%'\n    }\n  }\n\n  // Drag-and-drop handlers for sidebar → calendar\n  const handleDragEnter = (event: DragEvent, slot: TimeSlot) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    let parsedData: CalendarDragData | null = null\n\n    // FALLBACK: Check for global dragging state when dataTransfer is empty\n    // This handles mouse-based dragging where dataTransfer might not be populated\n    if (!data) {\n\n\n      // Try to get dragged task from global state (CalendarInboxPanel sets this)\n      const draggingTaskId = (window as Window & typeof globalThis).__draggingTaskId ||\n        document.querySelector('[data-dragging-task-id]')?.getAttribute('data-dragging-task-id')\n\n      if (draggingTaskId) {\n        const task = taskStore.tasks.find(t => t.id === draggingTaskId)\n        if (task) {\n\n          parsedData = {\n            ...task,\n            taskId: task.id,\n            source: 'calendar-inbox'\n          }\n\n        }\n      }\n\n      if (!parsedData) {\n        return\n      }\n    } else {\n      // Parse dataTransfer data\n      try {\n        parsedData = JSON.parse(data) as CalendarDragData\n\n      } catch (error) {\n        return\n      }\n    }\n\n    if (!parsedData) {\n      return\n    }\n\n    // Use the parsedData we already created above\n    const { title, taskId } = parsedData\n    const task = taskStore.tasks.find(t => t.id === taskId)\n\n    if (!task) {\n      return\n    }\n\n    dragGhost.value = {\n      visible: true,\n      title: title || 'New Task',\n      duration: task?.estimatedDuration || 30,\n      slotIndex: slot.slotIndex\n    }\n  }\n\n  const handleDragOver = (event: DragEvent, slot: TimeSlot) => {\n    event.preventDefault()\n    // Check if dataTransfer exists before setting dropEffect\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = 'move'\n    }\n\n    // Track active drop slot for visual feedback\n    activeDropSlot.value = slot.slotIndex\n\n    if (dragGhost.value.visible) {\n      dragGhost.value.slotIndex = slot.slotIndex\n    }\n  }\n\n  const handleDragLeave = () => {\n    // Keep ghost visible, only hide on drop\n  }\n\n  const handleDrop = async (event: DragEvent, slot: TimeSlot) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (!data) {\n      // Try fallback for browser compatibility\n      const draggingTaskId = (window as Window & typeof globalThis).__draggingTaskId\n      if (!draggingTaskId) {\n        return\n      }\n    }\n\n    try {\n      const parsedData = data ? JSON.parse(data) : { taskId: (window as Window & typeof globalThis).__draggingTaskId, source: 'calendar-event' }\n      const taskId = parsedData.taskId || parsedData.taskIds?.[0]\n      const source = parsedData.source\n\n      if (!taskId) {\n        return\n      }\n\n      // Calculate snapped time with 15-minute precision\n      const snappedTime = snapTo15Minutes(slot.hour, slot.minute)\n      const timeStr = `${snappedTime.hour.toString().padStart(2, '0')}:${snappedTime.minute.toString().padStart(2, '0')}`\n\n      const task = taskStore.tasks.find(t => t.id === taskId)\n\n\n\n      if (source === 'calendar-event') {\n        const instanceToUpdate = task?.instances?.find(i => i.id)\n\n        await taskStore.updateTaskWithSchedule(taskId, {\n          scheduledDate: slot.date,\n          scheduledTime: timeStr,\n          instanceId: instanceToUpdate?.id\n        })\n      } else {\n        // Drag from inbox or other sources\n        // Create task instance and update task to remove from inbox\n        const instance = taskStore.createTaskInstance(taskId, {\n          scheduledDate: slot.date,\n          scheduledTime: timeStr\n        })\n\n        // If instance was created successfully, log it\n        // Dec 16, 2025 fix: DO NOT modify isInInbox or canvasPosition here\n        // Calendar and Canvas are INDEPENDENT systems:\n        // - Creating an instance removes task from CALENDAR inbox (filtered by !hasInstances)\n        // - Canvas state (isInInbox, canvasPosition) should NOT be affected\n        if (instance) {\n          // Successfully created instance\n        }\n      }\n    } catch (error) {\n    }\n\n    dragGhost.value.visible = false\n\n    // Reset drag state\n    isDragging.value = false\n    draggedEventId.value = null\n    activeDropSlot.value = null\n\n  }\n\n  // Event drag-and-drop (repositioning within calendar)\n  const _startEventDrag = (event: MouseEvent, calendarEvent: CalendarEvent) => {\n    event.preventDefault()\n\n    const container = document.querySelector('.calendar-events-container') as HTMLElement\n    if (!container) return\n\n    const rect = container.getBoundingClientRect()\n    const SLOT_HEIGHT = 30\n    const eventElement = (event.target as HTMLElement).closest('.calendar-event') as HTMLElement\n    if (!eventElement) return\n\n    const eventRect = eventElement.getBoundingClientRect()\n    const clickOffsetY = event.clientY - eventRect.top\n\n    const isDuplicateMode = event.altKey\n\n    const initialSlot = calendarEvent.startSlot\n    let lastUpdatedSlot = initialSlot\n\n    const handleMouseMove = (e: MouseEvent) => {\n      requestAnimationFrame(() => {\n        const containerScrollTop = container.scrollTop || 0\n        const targetY = e.clientY - rect.top + containerScrollTop - clickOffsetY\n        const targetSlot = Math.max(0, Math.min(47, Math.floor(targetY / SLOT_HEIGHT)))\n\n        if (targetSlot !== lastUpdatedSlot) {\n          lastUpdatedSlot = targetSlot\n\n          const newHour = Math.floor((targetSlot * 30) / 60)\n          const newMinute = (targetSlot * 30) % 60\n          const newTime = `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')} `\n          const newDate = currentDate.value.toISOString().split('T')[0]\n\n          if (isDuplicateMode) {\n            // In duplicate mode, create a copy of the task with new schedule\n            const originalTask = taskStore.getTask(calendarEvent.taskId)\n            if (originalTask) {\n              taskStore.createTask({\n                title: originalTask.title,\n                description: originalTask.description,\n                scheduledDate: newDate,\n                scheduledTime: newTime,\n                estimatedDuration: calendarEvent.duration,\n                projectId: originalTask.projectId,\n                priority: originalTask.priority,\n                status: originalTask.status,\n                isInInbox: false\n              })\n            }\n          } else {\n            // Simple update: modify task's scheduledDate and scheduledTime directly\n            taskStore.updateTask(calendarEvent.taskId, {\n              scheduledDate: newDate,\n              scheduledTime: newTime\n            })\n          }\n        }\n      })\n    }\n\n    const handleMouseUp = () => {\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n  }\n\n  const handleEventMouseDown = (event: MouseEvent, _calendarEvent: CalendarEvent) => {\n    // Only handle mouse down for resize handles, let HTML5 drag handle dragging\n    // Don't interfere with dragstart events\n    if (event.shiftKey) {\n      dragMode.value = 'shift'\n      return\n    }\n\n    // Let HTML5 drag events handle the dragging - don't block them\n    // Remove preventDefault and stopPropagation to allow drag events\n  }\n\n  const handleEventDragStart = (event: DragEvent, calendarEvent: CalendarEvent) => {\n\n    // Set drag state for visual feedback\n    isDragging.value = true\n    draggedEventId.value = calendarEvent.id\n\n    // Allow dragging calendar events without Shift key or restrictions\n    if (event.dataTransfer) {\n      const dragData = {\n        taskId: calendarEvent.taskId,\n        instanceId: calendarEvent.instanceId,\n        source: 'calendar-event'\n      }\n\n\n\n      event.dataTransfer.setData('application/json', JSON.stringify(dragData))\n      event.dataTransfer.effectAllowed = 'move'\n\n      // Create a custom drag image for better visual feedback\n      const dragElement = event.target as HTMLElement\n      if (dragElement) {\n        // Create a clone for the drag image\n        const dragImage = dragElement.cloneNode(true) as HTMLElement\n        dragImage.style.opacity = '0.8'\n        dragImage.style.transform = 'rotate(-2deg)'\n        dragImage.style.maxWidth = '200px'\n        dragImage.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)'\n\n        // Temporarily add to body to create image\n        document.body.appendChild(dragImage)\n\n        // Set the drag image\n        try {\n          event.dataTransfer.setDragImage(dragImage, 20, 20)\n\n\n          // Remove the temporary element after a short delay\n          setTimeout(() => {\n            if (document.body.contains(dragImage)) {\n              document.body.removeChild(dragImage)\n            }\n          }, 100)\n        } catch (error) {\n          // Fallback: use the original element\n          event.dataTransfer.setDragImage(dragElement, 20, 20)\n        }\n      }\n    } else {\n    }\n\n    // Don't prevent default - let HTML5 drag work naturally\n\n  }\n\n  const handleEventDragEnd = (event: DragEvent, calendarEvent: CalendarEvent) => {\n\n    // Clean up drag state to prevent stuck states\n    if (isDragging.value) {\n\n      isDragging.value = false\n      draggedEventId.value = null\n      activeDropSlot.value = null\n\n      // Clean up any visual dragging classes that might be stuck\n      setTimeout(() => {\n        const draggingElements = document.querySelectorAll('.calendar-event.dragging')\n        draggingElements.forEach(el => {\n          el.classList.remove('dragging')\n\n        })\n\n        const dragOverSlots = document.querySelectorAll('.time-slot.drag-over')\n        dragOverSlots.forEach(slot => {\n          slot.classList.remove('drag-over')\n\n        })\n      }, 50) // Small delay to ensure DOM updates are processed\n    }\n\n    // Add fallback cleanup timeout as safety net\n    setTimeout(() => {\n      if (isDragging.value || draggedEventId.value || activeDropSlot.value !== null) {\n        isDragging.value = false\n        draggedEventId.value = null\n        activeDropSlot.value = null\n      }\n    }, 2000) // 2 second fallback\n\n\n  }\n\n  // Event resizing - uses preview state during drag, commits on mouseup\n  const startResize = (event: MouseEvent, calendarEvent: CalendarEvent, direction: 'top' | 'bottom') => {\n    event.preventDefault()\n    event.stopPropagation() // Prevent drag events from interfering\n\n    const startY = event.clientY\n    const SLOT_HEIGHT = 30\n    const originalStartSlot = calendarEvent.startSlot\n    const originalDuration = calendarEvent.duration\n    const MIN_DURATION = 15 // 15-minute minimum\n\n    // Get current time information\n    const [currentHour, currentMinute] = calendarEvent.startTime.toTimeString().slice(0, 5).split(':').map(Number)\n    const currentStartTime = currentHour * 60 + currentMinute\n    const originalTimeStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')} `\n\n    // Initialize resize preview state\n    resizePreview.value = {\n      taskId: calendarEvent.taskId,\n      direction,\n      originalDuration,\n      originalStartSlot,\n      previewDuration: originalDuration,\n      previewStartTime: originalTimeStr,\n      isResizing: true\n    }\n\n    // Track final values to commit on mouseup\n    let finalDuration = originalDuration\n    let finalStartTime = originalTimeStr\n\n    const handleMouseMove = (e: MouseEvent) => {\n      requestAnimationFrame(() => {\n        if (!resizePreview.value) return\n\n        const deltaY = e.clientY - startY\n        const deltaSlots = Math.round(deltaY / SLOT_HEIGHT)\n\n        let newDuration = originalDuration\n        let newStartHour = currentHour\n        let newStartMinute = currentMinute\n\n        if (direction === 'bottom') {\n          // Resize from bottom - change duration only\n          const deltaMinutes = deltaSlots * 30\n          newDuration = Math.max(MIN_DURATION, originalDuration + deltaMinutes)\n\n          // Update preview state only (NOT the store)\n          resizePreview.value.previewDuration = newDuration\n          finalDuration = newDuration\n\n\n\n        } else {\n          // Resize from top - change start time and maintain end time\n          const deltaMinutes = deltaSlots * 30\n          const newStartTime = currentStartTime + deltaMinutes\n\n          if (newStartTime >= 0) {\n            // Snap new start time to 15-minute intervals\n            const snappedTime = snapTo15Minutes(\n              Math.floor(newStartTime / 60),\n              newStartTime % 60\n            )\n\n            newStartHour = snappedTime.hour\n            newStartMinute = snappedTime.minute\n\n            // Calculate new duration to maintain end time\n            const currentEndTime = currentStartTime + originalDuration\n            const actualNewStartTime = newStartHour * 60 + newStartMinute\n            newDuration = Math.max(MIN_DURATION, currentEndTime - actualNewStartTime)\n\n            const newTimeStr = `${newStartHour.toString().padStart(2, '0')}:${newStartMinute.toString().padStart(2, '0')} `\n\n            // Update preview state only (NOT the store)\n            resizePreview.value.previewDuration = newDuration\n            resizePreview.value.previewStartTime = newTimeStr\n            finalDuration = newDuration\n            finalStartTime = newTimeStr\n\n\n          }\n        }\n      })\n    }\n\n    const handleMouseUp = () => {\n\n\n      // Commit final values to store\n      if (direction === 'bottom') {\n        taskStore.updateTask(calendarEvent.taskId, {\n          estimatedDuration: finalDuration\n        })\n\n        // Update instance if present\n        const task = taskStore.tasks.find(t => t.id === calendarEvent.taskId)\n        if (task?.instances && task.instances.length > 0) {\n          const todayInstance = task.instances.find(instance =>\n            instance && instance.scheduledDate === currentDate.value.toISOString().split('T')[0]\n          )\n          if (todayInstance && todayInstance.id) {\n            taskStore.updateTaskInstance(calendarEvent.taskId, todayInstance.id, {\n              duration: finalDuration\n            })\n          }\n        }\n      } else {\n        // Top resize - update both start time and duration\n        taskStore.updateTask(calendarEvent.taskId, {\n          scheduledTime: finalStartTime,\n          estimatedDuration: finalDuration\n        })\n\n        // Update instance if present\n        const task = taskStore.tasks.find(t => t.id === calendarEvent.taskId)\n        if (task?.instances && task.instances.length > 0) {\n          const todayInstance = task.instances.find(instance =>\n            instance && instance.scheduledDate === currentDate.value.toISOString().split('T')[0]\n          )\n          if (todayInstance && todayInstance.id) {\n            taskStore.updateTaskInstance(calendarEvent.taskId, todayInstance.id, {\n              scheduledTime: finalStartTime,\n              duration: finalDuration\n            })\n          }\n        }\n      }\n\n      // Clear preview state\n      resizePreview.value = null\n\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n  }\n\n  return {\n    hours,\n    timeSlots,\n    calendarEvents,\n    dragGhost,\n    dragMode,\n\n    // Slot-based rendering (tasks inside slots)\n    getTasksForSlot,\n    isTaskPrimarySlot,\n\n    // Drag state for visual feedback\n    isDragging,\n    draggedEventId,\n    activeDropSlot,\n\n    // Styling\n    getEventStyle,\n    getSlotTaskStyle,\n    getGhostStyle,\n\n    // Drag handlers\n    handleDragEnter,\n    handleDragOver,\n    handleDragLeave,\n    handleDrop,\n    handleEventDragStart,\n    handleEventDragEnd,\n    handleEventMouseDown,\n\n    // Resize handlers\n    startResize,\n    resizePreview\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarDrag.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'viewMode' is defined but never used. Allowed unused args must match /^_/u.","line":120,"column":83,"nodeType":null,"messageId":"unusedVar","endLine":120,"endColumn":91},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":157,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":244,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":244,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":294,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":294,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'rollbackError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":299,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":299,"endColumn":29},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":299,"column":31,"nodeType":"BlockStatement","messageId":"unexpected","endLine":300,"endColumn":8,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8917,8924],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":364,"column":14,"nodeType":"BlockStatement","messageId":"unexpected","endLine":365,"endColumn":8,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[10801,10808],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":377,"column":14,"nodeType":"BlockStatement","messageId":"unexpected","endLine":378,"endColumn":8,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[11110,11117],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, type Ref as _Ref } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport type { CalendarEvent, DragGhost, Task } from '@/types/tasks'\n\nexport interface DragState {\n  isDragging: boolean\n  draggedTaskId: string | null\n  draggedInstanceId: string | null\n  source: 'calendar-event' | 'calendar-inbox' | 'sidebar' | null\n  dragMode: 'move' | 'duplicate' | null\n}\n\n// Re-export for consumers\nexport type { DragGhost } from '@/types/tasks'\n\nexport interface DropTarget {\n  type: 'time-slot' | 'day-cell' | 'week-grid' | 'month-day'\n  date: string\n  time?: string // for time slots\n  slotIndex?: number // for time slots\n  dayIndex?: number // for week grid\n}\n\nexport interface DragData {\n  taskId: string\n  instanceId?: string\n  title?: string\n  source: 'calendar-event' | 'calendar-inbox' | 'sidebar' | 'unified-inbox' | string\n}\n\n/**\n * Unified drag-and-drop system for all calendar views\n * Consolidates duplicate drag logic from day/week/month views (200+ lines)\n */\nexport function useCalendarDrag() {\n  const taskStore = useTaskStore()\n  const core = useCalendarCore()\n\n  // Shared drag state across all views\n  const dragState = ref<DragState>({\n    isDragging: false,\n    draggedTaskId: null,\n    draggedInstanceId: null,\n    source: null,\n    dragMode: null\n  })\n\n  const dragGhost = ref<DragGhost>({\n    visible: false,\n    title: '',\n    duration: 30,\n    slotIndex: 0\n  })\n\n  const activeDropTarget = ref<DropTarget | null>(null)\n\n  // === DOCUMENT-LEVEL DRAG TRACKING ===\n  // Provides smooth ghost positioning by tracking mouse position during drag\n\n  let documentDragHandler: ((e: DragEvent) => void) | null = null\n\n  /**\n   * Calculate slot index from mouse Y position relative to slots container\n   * @param clientY - Mouse Y position in viewport coordinates\n   * @returns slot index (0-47 for 24 hours * 2 slots/hour)\n   */\n  const calculateSlotFromMouseY = (clientY: number): number => {\n    const container = document.querySelector('.slots-container') as HTMLElement\n    if (!container) return dragGhost.value.slotIndex // Keep current if no container\n\n    const rect = container.getBoundingClientRect()\n    const scrollTop = container.scrollTop || 0\n    const SLOT_HEIGHT = 30\n\n    // Calculate Y position relative to container content (accounting for scroll)\n    const relativeY = clientY - rect.top + scrollTop\n\n    // Calculate slot index and clamp to valid range (0-47)\n    const slotIndex = Math.floor(relativeY / SLOT_HEIGHT)\n    return Math.max(0, Math.min(47, slotIndex))\n  }\n\n  /**\n   * Start document-level drag tracking for smooth ghost updates\n   */\n  const startDocumentDragTracking = () => {\n    if (documentDragHandler) return // Already tracking\n\n    documentDragHandler = (e: DragEvent) => {\n      if (!dragGhost.value.visible) return\n\n      // Update ghost slot position based on mouse Y\n      const newSlotIndex = calculateSlotFromMouseY(e.clientY)\n      if (newSlotIndex !== dragGhost.value.slotIndex) {\n        dragGhost.value.slotIndex = newSlotIndex\n      }\n    }\n\n    // Use capture phase to ensure we get the event even over non-drop-target elements\n    document.addEventListener('dragover', documentDragHandler, { capture: true, passive: true })\n  }\n\n  /**\n   * Stop document-level drag tracking\n   */\n  const stopDocumentDragTracking = () => {\n    if (documentDragHandler) {\n      document.removeEventListener('dragover', documentDragHandler, { capture: true })\n      documentDragHandler = null\n    }\n  }\n\n  // === COMMON DRAG HANDLERS ===\n\n  /**\n   * Start dragging a calendar event\n   * Used by day/week/month views for dragging existing events\n   */\n  const startDrag = (event: DragEvent | MouseEvent, calendarEvent: CalendarEvent, viewMode: 'day' | 'week' | 'month') => {\n    dragState.value = {\n      isDragging: true,\n      draggedTaskId: calendarEvent.taskId,\n      draggedInstanceId: calendarEvent.instanceId,\n      source: 'calendar-event',\n      dragMode: (event as MouseEvent).altKey ? 'duplicate' : 'move'\n    }\n\n    // Set drag data for HTML5 drag API\n    if ('dataTransfer' in event && event.dataTransfer) {\n      event.dataTransfer.setData('application/json', JSON.stringify({\n        taskId: calendarEvent.taskId,\n        instanceId: calendarEvent.instanceId,\n        source: 'calendar-event'\n      }))\n    }\n\n    // Set global fallback for browser compatibility\n    (window as Window & typeof globalThis).__draggingTaskId = calendarEvent.taskId\n  }\n\n  /**\n   * Handle drag enter on drop targets\n   * Shows ghost preview and tracks active drop zone\n   */\n  const handleDragEnter = (event: DragEvent, target: DropTarget) => {\n    event.preventDefault()\n    activeDropTarget.value = target\n\n    // Parse drag data\n    let dragData: DragData | null = null\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (data) {\n      try {\n        dragData = JSON.parse(data) as DragData\n      } catch (error) {\n        return\n      }\n    } else {\n      // Fallback to global state\n      const globalTaskId = (window as Window & typeof globalThis).__draggingTaskId\n      if (globalTaskId) {\n        const task = taskStore.tasks.find(t => t.id === globalTaskId)\n        if (task) {\n          dragData = {\n            taskId: task.id,\n            title: task.title,\n            source: 'calendar-inbox'\n          }\n        }\n      }\n    }\n\n    if (!dragData) {\n      return\n    }\n\n    // Update ghost preview for time slot targets\n    if (target.type === 'time-slot' && target.slotIndex !== undefined) {\n      const task = taskStore.tasks.find(t => t.id === dragData.taskId)\n      dragGhost.value = {\n        visible: true,\n        title: dragData.title || 'New Task',\n        duration: task?.estimatedDuration || 30,\n        slotIndex: target.slotIndex,\n        taskId: dragData.taskId\n      }\n      // Start document-level tracking for smooth ghost updates\n      startDocumentDragTracking()\n    }\n  }\n\n  /**\n   * Handle drag over drop targets\n   * Updates visual feedback and ghost position\n   */\n  const handleDragOver = (event: DragEvent, target?: DropTarget) => {\n    event.preventDefault()\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = dragState.value.dragMode === 'duplicate' ? 'copy' : 'move'\n    }\n\n    if (target) {\n      activeDropTarget.value = target\n\n      // Update ghost position for time slots\n      if (target.type === 'time-slot' && target.slotIndex !== undefined && dragGhost.value.visible) {\n        dragGhost.value.slotIndex = target.slotIndex\n      }\n    }\n  }\n\n  /**\n   * Handle drag leave from drop targets\n   * Manages visual feedback when drag leaves a valid drop zone\n   */\n  const handleDragLeave = (event?: DragEvent, target?: DropTarget) => {\n    event?.preventDefault()\n\n    // Clear active drop target for visual feedback\n    // Note: Keep ghost visible until drag end for better UX\n    if (target && activeDropTarget.value?.type === target.type) {\n      activeDropTarget.value = null\n    }\n  }\n\n  /**\n   * Handle drop on targets\n   * Processes the actual drop operation based on target type\n   */\n  const handleDrop = async (event: DragEvent, target: DropTarget) => {\n    event.preventDefault()\n    activeDropTarget.value = null\n    dragGhost.value.visible = false\n\n    // Parse drag data\n    let dragData: DragData | null = null\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (data) {\n      try {\n        dragData = JSON.parse(data) as DragData\n      } catch (error) {\n        return\n      }\n    } else {\n      // Fallback to global state\n      const globalTaskId = (window as Window & typeof globalThis).__draggingTaskId\n      if (globalTaskId) {\n        dragData = { taskId: globalTaskId, source: 'calendar-event' }\n      }\n    }\n\n    if (!dragData || !dragData.taskId) {\n      return\n    }\n\n    const taskId = dragData.taskId\n    const task = taskStore.tasks.find(t => t.id === taskId)\n\n    if (!task) {\n      return\n    }\n\n    // Create transaction backup for rollback\n    const taskBackup = JSON.parse(JSON.stringify(task))\n    let operationSuccess = false\n\n    try {\n      switch (target.type) {\n        case 'time-slot':\n          await handleTimeSlotDrop(task, target, dragData)\n          operationSuccess = true\n          break\n        case 'day-cell':\n        case 'month-day':\n          await handleDayDrop(task, target, dragData)\n          operationSuccess = true\n          break\n        case 'week-grid':\n          await handleWeekGridDrop(task, target, dragData)\n          operationSuccess = true\n          break\n        default:\n          return\n      }\n\n      if (operationSuccess) {\n        // Success handled by switch\n      } else {\n        throw new Error('Drop operation returned false')\n      }\n    } catch (error) {\n\n      // Rollback task state to prevent data loss\n      try {\n        taskStore.updateTask(task.id, taskBackup)\n      } catch (rollbackError) {\n      }\n    }\n\n    // Clear drag state\n    clearDragState()\n  }\n\n  /**\n   * Handle drag end\n   * Cleanup drag state and visual feedback\n   */\n  const handleDragEnd = () => {\n    // Stop document-level tracking\n    stopDocumentDragTracking()\n\n    clearDragState()\n  }\n\n  // === DROP HANDLERS BY TARGET TYPE ===\n\n  /**\n   * Handle drop on time slot (day/week views)\n   */\n  const handleTimeSlotDrop = async (task: Task, target: DropTarget, dragData: DragData) => {\n    if (target.type !== 'time-slot' || !target.time) return\n\n    const snappedTime = core.snapTo15Minutes(\n      parseInt(target.time.split(':')[0]),\n      parseInt(target.time.split(':')[1])\n    )\n    const timeStr = `${snappedTime.hour.toString().padStart(2, '0')}:${snappedTime.minute.toString().padStart(2, '0')}`\n\n    if (dragData.source === 'calendar-event') {\n      // Moving existing calendar event\n\n      taskStore.updateTask(task.id, {\n        scheduledDate: target.date,\n        scheduledTime: timeStr\n      })\n\n      // Update instance if it exists\n      if (task.instances && task.instances.length > 0) {\n        const instance = task.instances[0] // Use first instance for simplicity\n        if (instance.id) {\n          taskStore.updateTaskInstance(task.id, instance.id, {\n            scheduledDate: target.date,\n            scheduledTime: timeStr\n          })\n        }\n      }\n    } else if (dragData.source && dragData.source.includes('unified-inbox')) {\n      // Drag from inbox - CRITICAL FIX: Handle inbox drag sources properly\n\n      // Create task instance to schedule the task\n      const instance = taskStore.createTaskInstance(task.id, {\n        scheduledDate: target.date,\n        scheduledTime: timeStr\n      })\n\n      if (instance) {\n        // Only remove from inbox if instance creation succeeded\n        taskStore.updateTask(task.id, {\n          isInInbox: false\n        })\n      } else {\n      }\n    } else {\n      // Drag from other sources\n      const instance = taskStore.createTaskInstance(task.id, {\n        scheduledDate: target.date,\n        scheduledTime: timeStr\n      })\n\n      if (instance) {\n        taskStore.updateTask(task.id, {\n          isInInbox: false\n        })\n      } else {\n      }\n    }\n  }\n\n  /**\n   * Handle drop on day cell (month view)\n   */\n  const handleDayDrop = async (task: Task, target: DropTarget, _dragData: DragData) => {\n    // Keep existing time or default to 9 AM\n    const scheduledTime = task.scheduledTime || '09:00'\n\n    if (dragState.value.dragMode === 'duplicate') {\n      // Create duplicate task\n      taskStore.createTask({\n        title: task.title,\n        description: task.description,\n        scheduledDate: target.date,\n        scheduledTime,\n        estimatedDuration: task.estimatedDuration,\n        projectId: task.projectId,\n        priority: task.priority,\n        status: task.status,\n        isInInbox: false\n      })\n    } else {\n      // Move existing task\n      taskStore.updateTask(task.id, {\n        scheduledDate: target.date,\n        scheduledTime,\n        isInInbox: false\n      })\n    }\n  }\n\n  /**\n   * Handle drop on week grid (complex positioning)\n   */\n  const handleWeekGridDrop = async (task: Task, target: DropTarget, _dragData: DragData) => {\n    if (target.dayIndex === undefined || target.slotIndex === undefined) return\n\n    const WORKING_HOURS_OFFSET = 6\n    const newHour = Math.floor(target.slotIndex / 2) + WORKING_HOURS_OFFSET\n    const newMinute = (target.slotIndex % 2) * 30\n    const timeStr = `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`\n\n    // Calculate the actual date based on dayIndex\n    const weekStart = core.getWeekStart(new Date())\n    const targetDate = new Date(weekStart)\n    targetDate.setDate(weekStart.getDate() + target.dayIndex)\n    const dateString = core.getDateString(targetDate)\n\n    if (dragState.value.dragMode === 'duplicate') {\n      // Create duplicate task\n      taskStore.createTask({\n        title: task.title,\n        description: task.description,\n        scheduledDate: dateString,\n        scheduledTime: timeStr,\n        estimatedDuration: task.estimatedDuration,\n        projectId: task.projectId,\n        priority: task.priority,\n        status: task.status,\n        isInInbox: false\n      })\n    } else {\n      // Move existing task\n      taskStore.updateTask(task.id, {\n        scheduledDate: dateString,\n        scheduledTime: timeStr\n      })\n    }\n  }\n\n  // === UTILITY FUNCTIONS ===\n\n  /**\n   * Clear all drag state\n   */\n  const clearDragState = () => {\n    // Ensure tracking is stopped\n    stopDocumentDragTracking()\n\n    dragState.value = {\n      isDragging: false,\n      draggedTaskId: null,\n      draggedInstanceId: null,\n      source: null,\n      dragMode: null\n    }\n    dragGhost.value = {\n      visible: false,\n      title: '',\n      duration: 30,\n      slotIndex: 0\n    }\n    activeDropTarget.value = null\n    delete (window as Window & typeof globalThis).__draggingTaskId\n  }\n\n  /**\n   * Check if currently dragging\n   */\n  const isDragging = () => dragState.value.isDragging\n\n  /**\n   * Get ghost style for time slot rendering\n   */\n  const getGhostStyle = (slotHeight: number = 30) => {\n    if (!dragGhost.value.visible) return {}\n\n    const slotSpan = Math.ceil(dragGhost.value.duration / 30)\n\n    return {\n      position: 'absolute' as const,\n      top: `${dragGhost.value.slotIndex * slotHeight}px`,\n      height: `${slotSpan * slotHeight}px`,\n      left: '0',\n      width: '100%',\n      opacity: 0.5,\n      pointerEvents: 'none' as const\n    }\n  }\n\n  return {\n    // State\n    dragState,\n    dragGhost,\n    activeDropTarget,\n\n    // Common handlers\n    startDrag,\n    handleDragEnter,\n    handleDragOver,\n    handleDragLeave,\n    handleDrop,\n    handleDragEnd,\n\n    // Utilities\n    clearDragState,\n    isDragging,\n    getGhostStyle\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarInteractionHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Task' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, type Ref } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { Task } from '@/stores/tasks'\nimport type { CalendarEvent } from '@/types/tasks'\n\n/**\n * Calendar interaction handlers composable\n * Manages context menus, clicks, double clicks, hover, and selection logic\n */\nexport function useCalendarInteractionHandlers(\n    isDragging: Ref<boolean>,\n    viewMode: Ref<'day' | 'week' | 'month'>,\n    handleEditTask: (taskId: string) => void,\n    handleConfirmDelete: (taskId: string) => void,\n    monthDayClickHandler: (dateString: string, viewMode: Ref<'day' | 'week' | 'month'>) => void\n) {\n    const taskStore = useTaskStore()\n\n    // State\n    const selectedCalendarEvents = ref<CalendarEvent[]>([])\n    const hoveredEventId = ref<string | null>(null)\n\n    /**\n     * Tracker for hover events on slot tasks\n     */\n    const handleSlotTaskMouseEnter = (eventId: string) => {\n        hoveredEventId.value = eventId\n    }\n\n    const handleSlotTaskMouseLeave = () => {\n        hoveredEventId.value = null\n    }\n\n    /**\n     * Handle double click on calendar event (Edit)\n     */\n    const handleEventDblClick = (calendarEvent: CalendarEvent) => {\n        handleEditTask(calendarEvent.taskId)\n    }\n\n    /**\n     * Handle context menu trigger on calendar event\n     */\n    const handleEventContextMenu = (mouseEvent: MouseEvent, calendarEvent: CalendarEvent) => {\n        mouseEvent.preventDefault()\n        mouseEvent.stopPropagation()\n\n        const task = taskStore.tasks.find(t => t.id === calendarEvent.taskId)\n        if (!task) return\n\n        // Dispatch global event for ModalManager to handle\n        window.dispatchEvent(new CustomEvent('task-context-menu', {\n            detail: {\n                event: mouseEvent,\n                task,\n                instanceId: calendarEvent.instanceId,\n                isCalendarEvent: true\n            }\n        }))\n    }\n\n    /**\n     * Unschedule a task (remove from calendar)\n     */\n    const handleRemoveFromCalendar = (calendarEvent: CalendarEvent) => {\n        taskStore.unscheduleTask(calendarEvent.taskId)\n    }\n\n    /**\n     * Handle single click on calendar event (Selection)\n     */\n    const handleEventClick = (mouseEvent: MouseEvent, calendarEvent: CalendarEvent) => {\n        const eventElement = mouseEvent.currentTarget as HTMLElement\n        const isCtrlOrCmd = mouseEvent.ctrlKey || mouseEvent.metaKey\n\n        // Don't handle clicks if dragging\n        if (isDragging.value) return\n\n        if (isCtrlOrCmd) {\n            // Toggle selection\n            const index = selectedCalendarEvents.value.findIndex(e => e.id === calendarEvent.id)\n            if (index > -1) {\n                selectedCalendarEvents.value.splice(index, 1)\n                eventElement.classList.remove('selected')\n            } else {\n                selectedCalendarEvents.value.push(calendarEvent)\n                eventElement.classList.add('selected')\n            }\n        } else {\n            // Reset or toggle single selection\n            if (selectedCalendarEvents.value.length === 1 && selectedCalendarEvents.value[0].id === calendarEvent.id) {\n                selectedCalendarEvents.value = []\n                eventElement.classList.remove('selected')\n            } else {\n                // Clear all previous selections\n                document.querySelectorAll('.calendar-event.selected, .week-event.selected').forEach(el => {\n                    el.classList.remove('selected')\n                })\n                selectedCalendarEvents.value = [calendarEvent]\n                eventElement.classList.add('selected')\n            }\n        }\n    }\n\n    /**\n     * Handle keyboard delete for selected events\n     */\n    const handleKeyDown = (event: KeyboardEvent) => {\n        const isDeleteKey = event.key === 'Delete' || event.key === 'Backspace'\n        if (!isDeleteKey) return\n        if (selectedCalendarEvents.value.length === 0) return\n\n        event.preventDefault()\n        event.stopPropagation()\n\n        selectedCalendarEvents.value.forEach(calendarEvent => {\n            taskStore.unscheduleTaskWithUndo(calendarEvent.taskId)\n        })\n\n        // Clear selection state and DOM classes\n        selectedCalendarEvents.value = []\n        document.querySelectorAll('.calendar-event.selected, .week-event.selected').forEach(el => {\n            el.classList.remove('selected')\n        })\n    }\n\n    /**\n     * Switch to day view when clicking a day in month view\n     */\n    const handleMonthDayClick = (dateString: string) => {\n        monthDayClickHandler(dateString, viewMode)\n    }\n\n    return {\n        selectedCalendarEvents,\n        hoveredEventId,\n        handleSlotTaskMouseEnter,\n        handleSlotTaskMouseLeave,\n        handleEventDblClick,\n        handleEventContextMenu,\n        handleRemoveFromCalendar,\n        handleEventClick,\n        handleKeyDown,\n        handleMonthDayClick\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarModals.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":55,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":27},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":55,"column":29,"nodeType":"BlockStatement","messageId":"unexpected","endLine":56,"endColumn":14,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1461,1474],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { useTaskStore } from '@/stores/tasks'\n\n/**\n * Calendar modals composable\n * Manages TaskEditModal and ConfirmationModal (deletion) states\n */\nexport function useCalendarModals() {\n    const taskStore = useTaskStore()\n\n    // Task Edit Modal state\n    const isEditModalOpen = ref(false)\n    const selectedTask = ref<Task | null>(null)\n\n    // Delete confirmation modal state\n    const showConfirmModal = ref(false)\n    const taskToDelete = ref<string | null>(null)\n\n    /**\n     * Open edit modal for a specific task\n     */\n    const handleEditTask = (taskId: string) => {\n        const task = taskStore.tasks.find(t => t.id === taskId)\n        if (task) {\n            selectedTask.value = task\n            isEditModalOpen.value = true\n        }\n    }\n\n    /**\n     * Close the edit modal\n     */\n    const closeEditModal = () => {\n        isEditModalOpen.value = false\n        selectedTask.value = null\n    }\n\n    /**\n     * Open delete confirmation modal\n     */\n    const handleConfirmDelete = (taskId: string) => {\n        taskToDelete.value = taskId\n        showConfirmModal.value = true\n    }\n\n    /**\n     * Finalize task deletion\n     */\n    const confirmDeleteTask = async () => {\n        if (taskToDelete.value) {\n            try {\n                await taskStore.deleteTaskWithUndo(taskToDelete.value)\n                taskToDelete.value = null\n            } catch (error) {\n            }\n        }\n        showConfirmModal.value = false\n    }\n\n    /**\n     * Cancel task deletion\n     */\n    const cancelDeleteTask = () => {\n        taskToDelete.value = null\n        showConfirmModal.value = false\n    }\n\n    return {\n        isEditModalOpen,\n        selectedTask,\n        showConfirmModal,\n        taskToDelete,\n        handleEditTask,\n        closeEditModal,\n        handleConfirmDelete,\n        confirmDeleteTask,\n        cancelDeleteTask\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarMonthView.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1723,1726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1723,1726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1802,1805],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1802,1805],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, type Ref } from 'vue'\nimport { useTaskStore, getTaskInstances } from '@/stores/tasks'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport type { CalendarEvent } from '@/types/tasks'\n\nexport interface MonthDay {\n  dateString: string\n  dayNumber: number\n  isCurrentMonth: boolean\n  isToday: boolean\n  events: CalendarEvent[]\n}\n\n/**\n * Month view specific logic for calendar\n * Handles month grid, day cells, and event aggregation\n */\nexport function useCalendarMonthView(currentDate: Ref<Date>, statusFilter: Ref<string | null>) {\n  const taskStore = useTaskStore()\n  const { getPriorityColor, getDateString } = useCalendarCore()\n\n  // Month days computation\n  const monthDays = computed<MonthDay[]>(() => {\n    const year = currentDate.value.getFullYear()\n    const month = currentDate.value.getMonth()\n\n    const firstDay = new Date(year, month, 1)\n    const startDate = new Date(firstDay)\n\n    // Adjust to start on Monday\n    const dayOfWeek = firstDay.getDay()\n    startDate.setDate(startDate.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1))\n\n    const days: MonthDay[] = []\n    const today = getDateString(new Date())\n\n    for (let i = 0; i < 42; i++) { // 6 weeks × 7 days\n      const date = new Date(startDate)\n      date.setDate(date.getDate() + i)\n\n      const dateString = getDateString(date)\n\n      // Get events for this day\n      const dayEvents: CalendarEvent[] = []\n      taskStore.filteredTasks\n        .filter(task => {\n          if (statusFilter.value === null) return true\n          return task.status === statusFilter.value\n        })\n        .forEach(task => {\n          const instances = getTaskInstances(task)\n          instances\n            .filter((instance: any) => instance.scheduledDate === dateString)\n            .forEach((instance: any) => {\n              const [_hour, _minute] = (instance.scheduledTime || '12:00').split(':').map(Number)\n              const duration = instance.duration || task.estimatedDuration || 30\n\n              dayEvents.push({\n                id: instance.id,\n                taskId: task.id,\n                instanceId: instance.id,\n                title: task.title,\n                startTime: new Date(`${instance.scheduledDate}T${instance.scheduledTime}`),\n                endTime: new Date(new Date(`${instance.scheduledDate}T${instance.scheduledTime}`).getTime() + duration * 60000),\n                duration,\n                startSlot: 0,\n                slotSpan: 0,\n                color: getPriorityColor(task.priority),\n                column: 0,\n                totalColumns: 1,\n                isDueDate: false\n              })\n            })\n        })\n\n      days.push({\n        dateString,\n        dayNumber: date.getDate(),\n        isCurrentMonth: date.getMonth() === month,\n        isToday: dateString === today,\n        events: dayEvents\n      })\n    }\n\n    return days\n  })\n\n  // Month drag handlers\n  const handleMonthDragStart = (event: DragEvent, calendarEvent: CalendarEvent) => {\n    event.dataTransfer?.setData('application/json', JSON.stringify({\n      taskId: calendarEvent.taskId,\n      instanceId: calendarEvent.instanceId\n    }))\n  }\n\n  const handleMonthDrop = (event: DragEvent, targetDate: string) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (!data) return\n\n    const { taskId, instanceId: _instanceId } = JSON.parse(data)\n\n    // Simple update: modify task's scheduledDate directly\n    // Keep existing time if task has one, otherwise set to 9 AM\n    const existingTask = taskStore.getTask(taskId)\n    const scheduledTime = existingTask?.scheduledTime || '09:00'\n\n    taskStore.updateTask(taskId, {\n      scheduledDate: targetDate,\n      scheduledTime: scheduledTime,\n      isInInbox: false // Task is now scheduled, no longer in inbox\n    })\n  }\n\n  const handleMonthDragEnd = (_event: DragEvent) => {\n    // Cleanup any drag states\n    // Currently no specific cleanup needed for month view\n  }\n\n  const handleMonthDayClick = (dateString: string, viewMode: Ref<'day' | 'week' | 'month'>) => {\n    // Switch to Day view for the clicked date\n    const [year, month, day] = dateString.split('-').map(Number)\n    currentDate.value = new Date(year, month - 1, day)\n    viewMode.value = 'day'\n  }\n\n  return {\n    monthDays,\n\n    // Drag handlers\n    handleMonthDragStart,\n    handleMonthDrop,\n    handleMonthDragEnd,\n    handleMonthDayClick\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarScroll.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarWeekView.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2350,2353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2350,2353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2625,2628],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2625,2628],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":110,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, ref, type Ref } from 'vue'\nimport { useTaskStore, getTaskInstances } from '@/stores/tasks'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport type { WeekEvent } from '@/types/tasks'\nimport { calculateOverlappingPositions } from '@/utils/calendar/overlapCalculation'\n\nexport interface WeekDay {\n  dayName: string\n  date: number\n  dateString: string\n  fullDate: Date\n}\n\n// Re-export for consumers\nexport type { WeekEvent } from '@/types/tasks'\n\n/**\n * Week view specific logic for calendar\n * Handles 7-day grid, events positioning, drag-and-drop, and resizing\n */\nexport function useCalendarWeekView(currentDate: Ref<Date>, _statusFilter: Ref<string | null>) {\n  const taskStore = useTaskStore()\n  const { getPriorityColor, getDateString } = useCalendarCore()\n\n  const workingHours = Array.from({ length: 17 }, (_, i) => i + 6) // 6 AM to 10 PM\n  const dragMode = ref<string | null>(null)\n\n  // Get week start (Monday)\n  const getWeekStart = (date: Date): Date => {\n    const d = new Date(date)\n    const day = d.getDay()\n    const diff = d.getDate() - day + (day === 0 ? -6 : 1)\n    d.setDate(diff)\n    d.setHours(0, 0, 0, 0)\n    return d\n  }\n\n  // Week days computation\n  const weekDays = computed<WeekDay[]>(() => {\n    const weekStart = getWeekStart(currentDate.value)\n    const days: WeekDay[] = []\n\n    for (let i = 0; i < 7; i++) {\n      const date = new Date(weekStart)\n      date.setDate(weekStart.getDate() + i)\n\n      days.push({\n        dayName: date.toLocaleDateString('en-US', { weekday: 'short' }),\n        date: date.getDate(),\n        dateString: getDateString(date),\n        fullDate: date\n      })\n    }\n\n    return days\n  })\n\n  // Week events computation with day positioning\n  const weekEvents = computed<WeekEvent[]>(() => {\n    const eventsByDay: WeekEvent[][] = Array.from({ length: 7 }, () => [])\n\n    weekDays.value.forEach((day, dayIndex) => {\n      const dayEvents: WeekEvent[] = []\n\n      // Use filtered tasks to respect active status filter\n      taskStore.filteredTasks.forEach(task => {\n        if (!task) return\n\n        try {\n          const instances = getTaskInstances(task)\n\n          // GUARD: Limit processed instances per task to prevent OOM\n          const MAX_INSTANCES_PER_TASK = 50\n          let processedCount = 0\n\n          instances\n            .filter((instance: any) => {\n              if (processedCount >= MAX_INSTANCES_PER_TASK) return false\n              const matches = instance.scheduledDate === day.dateString\n              if (matches) processedCount++\n              return matches\n            })\n            .forEach((instance: any) => {\n              const [hour, minute] = (instance.scheduledTime || '12:00').split(':').map(Number)\n              const duration = instance.duration || task.estimatedDuration || 30\n\n              // Only show if within working hours\n              if (hour >= 6 && hour < 23) {\n                const startTime = new Date(`${instance.scheduledDate}T${instance.scheduledTime}`)\n                const endTime = new Date(startTime.getTime() + duration * 60000)\n\n                dayEvents.push({\n                  id: instance.id,\n                  taskId: task.id,\n                  instanceId: instance.id,\n                  title: task.title,\n                  startTime,\n                  endTime,\n                  duration,\n                  startSlot: (hour - 6) * 2 + (minute === 30 ? 1 : 0),\n                  slotSpan: Math.ceil(duration / 30),\n                  color: getPriorityColor(task.priority),\n                  column: 0,\n                  totalColumns: 1,\n                  dayIndex,\n                  isDueDate: false\n                })\n              }\n            })\n        } catch (err) {\n          // Task processing error\n        }\n      })\n\n      // Calculate overlapping positions for this day\n      eventsByDay[dayIndex] = calculateOverlappingPositions(dayEvents) as WeekEvent[]\n    })\n\n    // Flatten all events into a single array\n    return eventsByDay.flat()\n  })\n\n  // use overlapCalculation utility\n\n  // Event styling for week grid\n  const getWeekEventStyle = (event: WeekEvent): Record<string, string | number> => {\n    const HALF_HOUR_HEIGHT = 30\n    const dayColumnWidth = 100 / 7\n\n    // Calculate column positioning within the day\n    const eventWidthWithinDay = dayColumnWidth / event.totalColumns\n    const eventLeftOffset = (dayColumnWidth * event.dayIndex) + (eventWidthWithinDay * event.column)\n\n    return {\n      position: 'absolute',\n      top: `${event.startSlot * HALF_HOUR_HEIGHT}px`,\n      height: `${event.slotSpan * HALF_HOUR_HEIGHT}px`,\n      left: `${eventLeftOffset}%`,\n      width: `${eventWidthWithinDay}%`\n    }\n  }\n\n  // Week drag-and-drop handlers\n  const _startWeekDrag = (event: MouseEvent, calendarEvent: WeekEvent) => {\n    event.preventDefault()\n    event.stopPropagation()\n\n    const weekDaysGrid = document.querySelector('.week-days-grid') as HTMLElement\n    if (!weekDaysGrid) return\n\n    const gridRect = weekDaysGrid.getBoundingClientRect()\n    const dayColumnWidth = gridRect.width / 7\n    const HALF_HOUR_HEIGHT = 30\n    const WORKING_HOURS_OFFSET = 6\n\n    const eventRect = (event.target as HTMLElement).closest('.week-event')?.getBoundingClientRect()\n    if (!eventRect) return\n\n    const clickOffsetY = event.clientY - eventRect.top\n\n    const isDuplicateMode = event.altKey\n    const _duplicateInstanceId: string | null = null\n\n    let lastUpdatedDayIndex = calendarEvent.dayIndex\n    let lastUpdatedSlot = calendarEvent.startSlot\n\n    const handleMouseMove = (e: MouseEvent) => {\n      requestAnimationFrame(() => {\n        const scrollTop = weekDaysGrid.scrollTop || 0\n\n        // Calculate day column\n        const relativeX = e.clientX - gridRect.left\n        const newDayIndex = Math.max(0, Math.min(6, Math.floor(relativeX / dayColumnWidth)))\n\n        // Calculate time slot\n        const mouseYInGrid = e.clientY - gridRect.top + scrollTop\n        const eventTopInGrid = mouseYInGrid - clickOffsetY\n        const slotFromTop = Math.max(0, Math.min(33, Math.round(eventTopInGrid / HALF_HOUR_HEIGHT)))\n\n        if (slotFromTop !== lastUpdatedSlot || newDayIndex !== lastUpdatedDayIndex) {\n          lastUpdatedSlot = slotFromTop\n          lastUpdatedDayIndex = newDayIndex\n\n          const newHour = Math.floor(slotFromTop / 2) + WORKING_HOURS_OFFSET\n          const newMinute = (slotFromTop % 2) * 30\n          const newDate = weekDays.value[newDayIndex].dateString\n          const newTime = `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`\n\n          if (isDuplicateMode) {\n            // In duplicate mode, create a copy of the task with new schedule\n            const originalTask = taskStore.getTask(calendarEvent.taskId)\n            if (originalTask) {\n              taskStore.createTask({\n                title: originalTask.title,\n                description: originalTask.description,\n                scheduledDate: newDate,\n                scheduledTime: newTime,\n                estimatedDuration: calendarEvent.duration,\n                projectId: originalTask.projectId,\n                priority: originalTask.priority,\n                status: originalTask.status,\n                isInInbox: false\n              })\n            }\n          } else {\n            // Simple update: modify task's scheduledDate and scheduledTime directly\n            taskStore.updateTask(calendarEvent.taskId, {\n              scheduledDate: newDate,\n              scheduledTime: newTime\n            })\n          }\n        }\n      })\n    }\n\n    const handleMouseUp = () => {\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n  }\n\n  const handleWeekEventMouseDown = (event: MouseEvent, _calendarEvent: WeekEvent) => {\n    // Only handle mouse down for resize handles, let HTML5 drag handle dragging\n    // Don't interfere with dragstart events\n    if (event.shiftKey) {\n      dragMode.value = 'shift'\n      return\n    }\n    // Let HTML5 drag events handle the dragging - don't block them\n    // Remove preventDefault and stopPropagation to allow drag events\n  }\n\n  // Week resize handlers\n  const startWeekResize = (event: MouseEvent, calendarEvent: WeekEvent, direction: 'top' | 'bottom') => {\n    event.preventDefault()\n\n    const startY = event.clientY\n    const HALF_HOUR_HEIGHT = 30\n    const WORKING_HOURS_OFFSET = 6\n    const originalStartSlot = calendarEvent.startSlot\n    const originalDuration = calendarEvent.duration\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const deltaY = e.clientY - startY\n      const deltaSlots = Math.round(deltaY / HALF_HOUR_HEIGHT)\n\n      let newDuration = originalDuration\n      let newStartSlot = originalStartSlot\n\n      if (direction === 'bottom') {\n        newDuration = Math.max(30, originalDuration + (deltaSlots * 30))\n      } else {\n        const endSlot = originalStartSlot + Math.ceil(originalDuration / 30)\n        newStartSlot = Math.max(0, Math.min(33, originalStartSlot + deltaSlots))\n        newDuration = Math.max(30, (endSlot - newStartSlot) * 30)\n      }\n\n      if (direction === 'bottom') {\n        taskStore.updateTask(calendarEvent.taskId, {\n          estimatedDuration: newDuration\n        })\n      } else {\n        const newHour = Math.floor(newStartSlot / 2) + WORKING_HOURS_OFFSET\n        const newMinute = (newStartSlot % 2) * 30\n\n        if (newHour >= WORKING_HOURS_OFFSET && newHour < 23) {\n          taskStore.updateTask(calendarEvent.taskId, {\n            scheduledTime: `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`,\n            estimatedDuration: newDuration\n          })\n        }\n      }\n    }\n\n    const handleMouseUp = () => {\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n  }\n\n  // Week drop handlers\n  const handleWeekDragOver = (event: DragEvent) => {\n    event.preventDefault()\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = 'move'\n    }\n  }\n\n  const handleWeekDrop = (event: DragEvent, dateString: string, hour: number) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (!data) return\n\n    const { taskId } = JSON.parse(data)\n    const timeStr = `${hour.toString().padStart(2, '0')}:00`\n\n    // Simple update: modify task's scheduledDate and scheduledTime directly\n    taskStore.updateTask(taskId, {\n      scheduledDate: dateString,\n      scheduledTime: timeStr,\n      isInInbox: false // Task is now scheduled, no longer in inbox\n    })\n  }\n\n  // Current time detection for week view\n  const isCurrentWeekTimeCell = (dateString: string, hour: number) => {\n    const now = new Date()\n    const currentHour = now.getHours()\n    const todayString = getDateString(now)\n\n    return dateString === todayString && hour === currentHour\n  }\n\n  return {\n    workingHours,\n    weekDays,\n    weekEvents,\n\n    // Styling\n    getWeekEventStyle,\n\n    // Drag handlers\n    handleWeekEventMouseDown,\n    handleWeekDragOver,\n    handleWeekDrop,\n\n    // Resize handlers\n    startWeekResize,\n\n    // Utilities\n    isCurrentWeekTimeCell\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/__tests__/useCanvasOperationState.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/node/useTaskNodeActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/node/useTaskNodeState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/state-machine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'previousState' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":105,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":28},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":208,"column":16,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":208,"endColumn":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Node State Machine\n * \n * Replaces 7+ boolean flags with a single state machine\n * Prevents impossible states like isDragging + isSync + isConverting\n */\n\nimport { ref, computed, type Ref } from 'vue';\n\n/**\n * Valid states for a canvas node\n */\nexport enum NodeState {\n    IDLE = 'idle',\n    DRAGGING_LOCAL = 'dragging_local',\n    SYNCING = 'syncing',\n    CONFLICT = 'conflict',\n    RESIZING = 'resizing',\n    LOADING = 'loading',\n    ERROR = 'error'\n}\n\n/**\n * Define valid state transitions\n * Prevents impossible states like DRAGGING → ERROR → DRAGGING\n */\nconst STATE_TRANSITIONS: Record<NodeState, NodeState[]> = {\n    [NodeState.IDLE]: [\n        NodeState.DRAGGING_LOCAL,\n        NodeState.RESIZING,\n        NodeState.LOADING,\n        NodeState.SYNCING\n    ],\n    [NodeState.DRAGGING_LOCAL]: [\n        NodeState.SYNCING,\n        NodeState.IDLE\n    ],\n    [NodeState.SYNCING]: [\n        NodeState.IDLE,\n        NodeState.CONFLICT,\n        NodeState.ERROR\n    ],\n    [NodeState.CONFLICT]: [\n        NodeState.DRAGGING_LOCAL,\n        NodeState.IDLE,\n        NodeState.SYNCING\n    ],\n    [NodeState.RESIZING]: [\n        NodeState.SYNCING,\n        NodeState.IDLE,\n        NodeState.ERROR\n    ],\n    [NodeState.LOADING]: [\n        NodeState.IDLE,\n        NodeState.ERROR\n    ],\n    [NodeState.ERROR]: [\n        NodeState.IDLE,\n        NodeState.SYNCING,\n        NodeState.DRAGGING_LOCAL\n    ]\n};\n\n/**\n * Composable for managing node state machine\n * Usage:\n *   const state = useNodeStateMachine();\n *   state.setState(NodeState.DRAGGING_LOCAL);\n *   if (state.canTransitionTo(NodeState.SYNCING)) { ... }\n */\nexport function useNodeStateMachine(initialState: NodeState = NodeState.IDLE) {\n    const currentState: Ref<NodeState> = ref(initialState);\n    const lastError: Ref<string | null> = ref(null);\n    const stateHistory: Ref<{ state: NodeState; timestamp: number }[]> = ref([]);\n\n    /**\n     * Check if transition is valid\n     */\n    function canTransitionTo(targetState: NodeState): boolean {\n        return STATE_TRANSITIONS[currentState.value].includes(targetState);\n    }\n\n    /**\n     * Attempt state transition\n     * Returns true if successful (or already in target state), false if invalid\n     *\n     * IDEMPOTENT: If already in targetState, returns true without logging warning.\n     * This prevents spurious \"Invalid state transition: X → X\" messages when\n     * Vue Flow fires duplicate drag events or multi-select triggers multiple handlers.\n     */\n    function setState(targetState: NodeState, reason?: string): boolean {\n        // IDEMPOTENT: Already in target state = success (no-op)\n        if (currentState.value === targetState) {\n            return true;\n        }\n\n        if (!canTransitionTo(targetState)) {\n            console.warn(\n                `Invalid state transition: ${currentState.value} → ${targetState}` +\n                (reason ? ` (${reason})` : '')\n            );\n            return false;\n        }\n\n        const previousState = currentState.value;\n        currentState.value = targetState;\n\n        // Track state history for debugging\n        stateHistory.value.push({\n            state: targetState,\n            timestamp: Date.now()\n        });\n\n        // Keep only last 50 state changes\n        if (stateHistory.value.length > 50) {\n            stateHistory.value = stateHistory.value.slice(-50);\n        }\n\n        // console.debug(\n        //   `State transition: ${previousState} → ${targetState}` +\n        //   (reason ? ` (${reason})` : '')\n        // );\n\n        return true;\n    }\n\n    /**\n     * Move to error state with message\n     */\n    function setError(message: string): boolean {\n        lastError.value = message;\n        return setState(NodeState.ERROR, message);\n    }\n\n    /**\n     * Get human-readable state label\n     */\n    function getStateLabel(state: NodeState = currentState.value): string {\n        const labels: Record<NodeState, string> = {\n            [NodeState.IDLE]: 'Idle',\n            [NodeState.DRAGGING_LOCAL]: 'Dragging',\n            [NodeState.SYNCING]: 'Syncing with server',\n            [NodeState.CONFLICT]: 'Conflict detected',\n            [NodeState.RESIZING]: 'Resizing',\n            [NodeState.LOADING]: 'Loading',\n            [NodeState.ERROR]: 'Error'\n        };\n        return labels[state] || 'Unknown';\n    }\n\n    /**\n     * Reset to idle (useful for cleanup)\n     */\n    function reset(): void {\n        currentState.value = NodeState.IDLE;\n        lastError.value = null;\n    }\n\n    /**\n     * Get debug info\n     */\n    function getDebugInfo(): object {\n        return {\n            currentState: currentState.value,\n            lastError: lastError.value,\n            recentStateChanges: stateHistory.value.slice(-10).map(entry => ({\n                state: entry.state,\n                secondsAgo: Math.round((Date.now() - entry.timestamp) / 1000)\n            })),\n            validNextStates: STATE_TRANSITIONS[currentState.value]\n        };\n    }\n\n    return {\n        // State\n        currentState: computed(() => currentState.value),\n        lastError: computed(() => lastError.value),\n        stateHistory: computed(() => stateHistory.value),\n\n        // Methods\n        setState,\n        setError,\n        canTransitionTo,\n        reset,\n\n        // UI Helpers\n        getStateLabel,\n\n        // Debug\n        getDebugInfo\n    };\n}\n\n/**\n * Global state machine for managing multiple nodes\n * Usage:\n *   const nodeStates = useNodeStateManager();\n *   nodeStates.setNodeState('node-123', NodeState.DRAGGING_LOCAL);\n */\nconst nodeStates = new Map<string, ReturnType<typeof useNodeStateMachine>>();\n\nexport function useNodeStateManager() {\n\n    function getOrCreateNodeState(nodeId: string): ReturnType<typeof useNodeStateMachine> {\n        if (!nodeStates.has(nodeId)) {\n            nodeStates.set(nodeId, useNodeStateMachine());\n        }\n        return nodeStates.get(nodeId)!;\n    }\n\n    function setNodeState(nodeId: string, state: NodeState, reason?: string): boolean {\n        return getOrCreateNodeState(nodeId).setState(state, reason);\n    }\n\n    function getNodeState(nodeId: string): NodeState {\n        return getOrCreateNodeState(nodeId).currentState.value;\n    }\n\n    function canNodeTransitionTo(nodeId: string, state: NodeState): boolean {\n        return getOrCreateNodeState(nodeId).canTransitionTo(state);\n    }\n\n    function resetNodeState(nodeId: string): void {\n        getOrCreateNodeState(nodeId).reset();\n    }\n\n    /**\n     * Get all nodes in specific state\n     */\n    function getNodesInState(state: NodeState): string[] {\n        const result: string[] = [];\n        nodeStates.forEach((machine, nodeId) => {\n            if (machine.currentState.value === state) {\n                result.push(nodeId);\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Cleanup state for node (e.g., after deletion)\n     */\n    function deleteNodeState(nodeId: string): void {\n        nodeStates.delete(nodeId);\n    }\n\n    return {\n        setNodeState,\n        getNodeState,\n        canNodeTransitionTo,\n        resetNodeState,\n        getNodesInState,\n        deleteNodeState\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nextTick' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'markGroupDeleted' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'confirmGroupDeleted' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":47},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1510,1513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1510,1513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1532,1535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1532,1535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getSelectedNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":43,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'removeNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":43,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5390,5393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5390,5393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref, ref, nextTick } from 'vue'\nimport { useVueFlow, type Node } from '@vue-flow/core'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useCanvasContextMenuStore } from '@/stores/canvas/contextMenus'\nimport { markGroupDeleted, confirmGroupDeleted } from '@/utils/deletedGroupsTracker'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\n// Imported Composables\nimport { useCanvasGroupActions } from './useCanvasGroupActions'\nimport { useCanvasTaskActions } from './useCanvasTaskActions'\n\ninterface ActionsDeps {\n    viewport: Ref<{ x: number; y: number; zoom: number }>\n    batchedSyncNodes: (priority?: 'high' | 'normal' | 'low') => void\n    syncNodes: () => void\n    closeCanvasContextMenu: () => void\n    closeEdgeContextMenu: () => void\n    closeNodeContextMenu: () => void\n    // TASK-149: Pass recentlyDeletedGroups to prevent zombie groups\n    recentlyDeletedGroups?: Ref<Set<string>>\n}\n\n// NOTE: State is now decomposed into sub-composables but we keep this interface \n// if we need to aggregate it for the view, but the ReturnType of this composable\n// will naturally expose everything.\n// \n// For backward compatibility with the View, we'll destructure and re-return everything.\n/*\ninterface ActionsState {\n    // ... moved to sub-composables\n}\n*/\n\n// Note: arguments changed slightly - state is now internal/distributed\nexport function useCanvasActions(\n    deps: ActionsDeps,\n    // state argument removed or ignored as we build it up\n    ignoredState: any,\n    undoHistory: any\n) {\n    const canvasStore = useCanvasStore()\n    const contextMenuStore = useCanvasContextMenuStore()\n    const { getSelectedNodes, screenToFlowCoordinate, removeNodes } = useVueFlow()\n\n    // --- Instantiate Sub-Composables ---\n\n    // Groups\n    const groupActions = useCanvasGroupActions({\n        viewport: deps.viewport,\n        syncNodes: deps.syncNodes,\n        batchSyncNodes: deps.batchedSyncNodes,\n        closeCanvasContextMenu: deps.closeCanvasContextMenu,\n        screenToFlowCoordinate: (pos) => screenToFlowCoordinate(pos),\n        recentlyDeletedGroups: deps.recentlyDeletedGroups,\n        state: ignoredState // Pass the potentially injected state (modals)\n    })\n\n    // Tasks\n    const taskActions = useCanvasTaskActions({\n        syncNodes: deps.syncNodes,\n        batchSyncNodes: deps.batchedSyncNodes,\n        closeCanvasContextMenu: deps.closeCanvasContextMenu,\n        screenToFlowCoordinate: (pos) => screenToFlowCoordinate(pos),\n        recentlyDeletedGroups: deps.recentlyDeletedGroups,\n        undoHistory\n    })\n\n    // --- Orchestrator Logic (things that don't fit cleanly or bridge both) ---\n\n    // Node Context Menu (Orchestrates between Groups and Tasks)\n    const selectedNode = ref<Node | null>(null)\n    const showNodeContextMenu = ref(false)\n    const nodeContextMenuX = ref(0)\n    const nodeContextMenuY = ref(0)\n\n    // BUG-208 FIX: Use Pinia store for context menu state\n    // Previously local refs were used but CanvasContextMenus.vue reads from the store\n    const handleNodeContextMenu = (event: { node: Node; event: MouseEvent | TouchEvent }) => {\n        console.debug('[BUG-251] handleNodeContextMenu called', {\n            nodeId: event.node.id,\n            eventType: event.event.type,\n            isGroupNode: CanvasIds.isGroupNode(event.node.id)\n        })\n        event.event.preventDefault()\n        event.event.stopPropagation()\n\n        if (!CanvasIds.isGroupNode(event.node.id)) return\n\n        const mouseEvent = event.event as MouseEvent\n        const { id: sectionId } = CanvasIds.parseNodeId(event.node.id)\n        const section = canvasStore.sections.find(s => s.id === sectionId)\n\n        if (section) {\n            // Show the canvas context menu with group actions (TASK-070)\n            contextMenuStore.openCanvasContextMenu(mouseEvent.clientX || 0, mouseEvent.clientY || 0, section)\n        } else {\n            // Ghost handling\n            const ghostSection: CanvasSection = {\n                id: sectionId,\n                name: (event.node.data?.name as string) || 'Unknown Group (Ghost)',\n                color: (event.node.data?.color as string) || '#6366f1',\n                position: { x: 0, y: 0, width: 300, height: 200 },\n                isCollapsed: false,\n                type: 'custom',\n                layout: 'freeform',\n                isVisible: true\n            }\n            contextMenuStore.openCanvasContextMenu(mouseEvent.clientX || 0, mouseEvent.clientY || 0, ghostSection)\n        }\n\n        deps.closeEdgeContextMenu()\n    }\n\n    const closeNodeContextMenu = () => {\n        showNodeContextMenu.value = false\n        selectedNode.value = null\n    }\n\n    const deleteNode = async () => {\n        if (!selectedNode.value) return\n\n        if (CanvasIds.isGroupNode(selectedNode.value.id)) {\n            const { id: sectionId } = CanvasIds.parseNodeId(selectedNode.value.id)\n            // Check existence\n            const section = canvasStore.sections.find(s => s.id === sectionId)\n\n            // Delegate to group actions\n            if (section) {\n                groupActions.deleteGroup(section)\n            } else {\n                // Ghost?\n                const ghost: CanvasSection = {\n                    id: sectionId,\n                    name: 'Ghost',\n                    color: '#000',\n                    position: { x: 0, y: 0, w: 0, h: 0 } as any,\n                    type: 'custom',\n                    layout: 'freeform',\n                    isVisible: true,\n                    isCollapsed: false\n                }\n                groupActions.deleteGroup(ghost)\n            }\n        }\n        closeNodeContextMenu()\n    }\n\n    // --- Re-Export Everything ---\n    return {\n        // Group Actions & State\n        createGroup: groupActions.createGroup,\n        closeGroupModal: groupActions.closeGroupModal,\n        handleGroupCreated: groupActions.handleGroupCreated,\n        handleGroupUpdated: groupActions.handleGroupUpdated,\n        editGroup: groupActions.editGroup,\n        closeGroupEditModal: groupActions.closeGroupEditModal,\n        handleGroupEditSave: groupActions.handleGroupEditSave,\n        deleteGroup: groupActions.deleteGroup,\n        confirmDeleteGroup: groupActions.confirmDeleteGroup,\n        cancelDeleteGroup: groupActions.cancelDeleteGroup,\n\n        isGroupModalOpen: groupActions.isGroupModalOpen,\n        selectedGroup: groupActions.selectedGroup,\n        groupModalPosition: groupActions.groupModalPosition,\n        isGroupEditModalOpen: groupActions.isGroupEditModalOpen,\n        selectedSectionForEdit: groupActions.selectedSectionForEdit,\n        isDeleteGroupModalOpen: groupActions.isDeleteGroupModalOpen,\n        groupPendingDelete: groupActions.groupPendingDelete,\n\n        // Task Actions & State\n        createTaskHere: taskActions.createTaskHere,\n        createTaskInGroup: taskActions.createTaskInGroup,\n        handleQuickTaskCreate: taskActions.handleQuickTaskCreate,\n        closeQuickTaskCreate: taskActions.closeQuickTaskCreate,\n        moveSelectedTasksToInbox: taskActions.moveSelectedTasksToInbox,\n        deleteSelectedTasks: taskActions.deleteSelectedTasks,\n        confirmBulkDelete: taskActions.confirmBulkDelete,\n        cancelBulkDelete: taskActions.cancelBulkDelete,\n\n        isQuickTaskCreateOpen: taskActions.isQuickTaskCreateOpen,\n        quickTaskPosition: taskActions.quickTaskPosition,\n        isBulkDeleteModalOpen: taskActions.isBulkDeleteModalOpen,\n        bulkDeleteItems: taskActions.bulkDeleteItems,\n        bulkDeleteIsPermanent: taskActions.bulkDeleteIsPermanent,\n\n        // Orchestrator State & Actions\n        handleNodeContextMenu,\n        closeNodeContextMenu,\n        deleteNode,\n\n        selectedNode,\n        showNodeContextMenu,\n        nodeContextMenuX,\n        nodeContextMenuY\n        // BUG-208: Canvas context menu state removed - now managed by useCanvasContextMenuStore\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasAlignment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasConnections.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Task' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[427,430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[427,430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[437,440],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[437,440],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[452,455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[452,455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[471,474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[471,474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":114,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":117,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[481,484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[481,484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":30,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":38,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":36}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { type Ref } from 'vue'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport type { EdgeMouseEvent, Edge } from '@vue-flow/core'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\ninterface ConnectionDeps {\n    syncEdges: () => void\n    closeCanvasContextMenu: () => void\n    closeEdgeContextMenu: () => void\n    closeNodeContextMenu: () => void\n    withVueFlowErrorBoundary: (name: string, fn: (...args: any[]) => any, options?: any) => ((...args: any[]) => any)\n}\n\ninterface ConnectionState {\n    isConnecting: Ref<boolean>\n    recentlyRemovedEdges: Ref<Set<string>>\n    showEdgeContextMenu: Ref<boolean>\n    edgeContextMenuX: Ref<number>\n    edgeContextMenuY: Ref<number>\n    selectedEdge: Ref<Edge | null>\n}\n\nexport function useCanvasConnections(\n    deps: ConnectionDeps,\n    state: ConnectionState\n) {\n    const taskStore = useTaskStore()\n\n    const handleConnectStart = (event: { nodeId?: string; handleId?: string | null; handleType?: string }) => {\n        state.isConnecting.value = true\n\n        deps.closeCanvasContextMenu()\n        deps.closeEdgeContextMenu()\n        deps.closeNodeContextMenu()\n    }\n\n    const handleConnectEnd = (event?: MouseEvent | { nodeId?: string; handleId?: string; handleType?: string }) => {\n        setTimeout(() => {\n            state.isConnecting.value = false\n        }, 100)\n    }\n\n    const handleConnect = deps.withVueFlowErrorBoundary('handleConnect', (connection: { source: string; target: string; sourceHandle?: string; targetHandle?: string }) => {\n        const { source, target } = connection\n\n        deps.closeCanvasContextMenu()\n        deps.closeEdgeContextMenu()\n        deps.closeNodeContextMenu()\n\n        // Allow immediate re-creation of recently deleted edges\n        // If the user manually connects A->B, we must unblock it from the \"zombie edge\" protection list\n        const potentialEdgeId = CanvasIds.edgeId(source, target)\n        if (state.recentlyRemovedEdges.value.has(potentialEdgeId)) {\n            state.recentlyRemovedEdges.value.delete(potentialEdgeId)\n        }\n\n        if (CanvasIds.isGroupNode(source) || CanvasIds.isGroupNode(target)) return\n        if (source === target) return\n\n        const sourceTask = taskStore.tasks.find(t => t.id === source)\n        const targetTask = taskStore.tasks.find(t => t.id === target)\n\n        if (sourceTask && targetTask && sourceTask.canvasPosition && targetTask.canvasPosition) {\n            const dependsOn = targetTask.dependsOn || []\n            if (!dependsOn.includes(source)) {\n                taskStore.updateTaskWithUndo(target, { dependsOn: [...dependsOn, source] })\n                deps.syncEdges()\n            }\n        }\n    })\n\n    const disconnectEdge = () => {\n        if (!state.selectedEdge.value) return\n\n        const { source, target, id: edgeId } = state.selectedEdge.value\n        const targetTask = taskStore.tasks.find(t => t.id === target)\n\n        state.recentlyRemovedEdges.value.add(edgeId)\n\n        setTimeout(() => {\n            state.recentlyRemovedEdges.value.delete(edgeId)\n        }, 2000)\n\n        // Update task dependencies\n        if (targetTask && targetTask.dependsOn) {\n            const updatedDependsOn = targetTask.dependsOn.filter(id => id !== source)\n            taskStore.updateTaskWithUndo(targetTask.id, { dependsOn: updatedDependsOn })\n            deps.syncEdges()\n        }\n\n        deps.closeEdgeContextMenu()\n    }\n\n    const handleEdgeContextMenu = (event: EdgeMouseEvent) => {\n        const mouseEvent = event.event as MouseEvent\n        event.event.preventDefault()\n        event.event.stopPropagation()\n\n        state.edgeContextMenuX.value = mouseEvent.clientX\n        state.edgeContextMenuY.value = mouseEvent.clientY\n        state.selectedEdge.value = event.edge\n        state.showEdgeContextMenu.value = true\n\n        deps.closeCanvasContextMenu()\n        deps.closeNodeContextMenu()\n    }\n\n    const closeEdgeContextMenu = () => {\n        state.showEdgeContextMenu.value = false\n        state.selectedEdge.value = null\n    }\n\n    return {\n        handleConnectStart,\n        handleConnectEnd,\n        handleConnect,\n        disconnectEdge,\n        handleEdgeContextMenu,\n        closeEdgeContextMenu\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasContextMenus.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CanvasSection' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { storeToRefs } from 'pinia'\nimport { useCanvasContextMenuStore } from '@/stores/canvas/contextMenus'\nimport type { CanvasSection } from '@/stores/canvas'\n\nexport function useCanvasContextMenus() {\n    const store = useCanvasContextMenuStore()\n    const {\n        showCanvasContextMenu,\n        canvasContextMenuX,\n        canvasContextMenuY,\n        canvasContextSection,\n        showNodeContextMenu,\n        nodeContextMenuX,\n        nodeContextMenuY,\n        selectedNodeId,\n        showEdgeContextMenu,\n        edgeContextMenuX,\n        edgeContextMenuY,\n        selectedEdgeId\n    } = storeToRefs(store)\n\n    const {\n        openCanvasContextMenu,\n        closeCanvasContextMenu,\n        openNodeContextMenu,\n        closeNodeContextMenu,\n        openEdgeContextMenu,\n        closeEdgeContextMenu\n    } = store\n\n    const closeAllContextMenus = () => {\n        store.closeCanvasContextMenu()\n        store.closeNodeContextMenu()\n        store.closeEdgeContextMenu()\n    }\n\n    return {\n        // State (mapped to legacy names where needed)\n        showCanvasContextMenu,\n        canvasContextMenuX,\n        canvasContextMenuY,\n        canvasContextSection,\n\n        showNodeContextMenu,\n        nodeContextMenuX,\n        nodeContextMenuY,\n        nodeContextMenuNodeId: selectedNodeId, // Alias for legacy compatibility\n\n        showEdgeContextMenu,\n        edgeContextMenuX,\n        edgeContextMenuY,\n        edgeContextMenuEdgeId: selectedEdgeId, // Alias for legacy compatibility\n\n        // Actions\n        openCanvasContextMenu,\n        closeCanvasContextMenu,\n        openNodeContextMenu,\n        closeNodeContextMenu,\n        openEdgeContextMenu,\n        closeEdgeContextMenu,\n        closeAllContextMenus\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasCore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ref' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Node' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Edge' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ViewportTransform' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":66}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, ref, onBeforeUnmount } from 'vue'\nimport { useVueFlow, type Node, type Edge, type ViewportTransform } from '@vue-flow/core'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { storeToRefs } from 'pinia'\n\n/**\n * useCanvasCore\n *\n * The foundational composable for the Canvas system.\n * consolidates:\n * - Vue Flow instance access\n * - Viewport management (zoom, pan, fit view)\n * - Basic Node/Edge state access\n * - Core lifecycle hooks\n */\nexport function useCanvasCore() {\n    const {\n        nodes,\n        edges,\n        addNodes,\n        removeNodes,\n        addEdges,\n        removeEdges,\n        setNodes,\n        setEdges,\n        findNode,\n        getNodes,\n        toObject,\n        setViewport,\n        getViewport,\n        fitView: vueFlowFitView,\n        zoomIn: vueFlowZoomIn,\n        zoomTo: vueFlowZoomTo,\n        onInit,\n        onPaneReady,\n        onNodeDragStart,\n        onNodeDrag,\n        onNodeDragStop,\n        updateNode,\n        screenToFlowCoordinate,\n        project,\n        getIntersectingNodes,\n        isNodeIntersecting,\n        onMoveEnd,\n        onConnect,\n        onEdgesChange,\n        onNodesChange,\n        applyNodeChanges,\n        applyEdgeChanges,\n        panOnDrag\n    } = useVueFlow()\n\n    const canvasStore = useCanvasStore()\n    const { zoomConfig, viewport: storeViewport } = storeToRefs(canvasStore)\n\n    // --- Viewport & Zoom Logic (Consolidated from useCanvasZoom/Navigation) ---\n\n    // Performance throttling for zoom operations\n    const zoomPerformanceManager = {\n        animationFrameId: null as number | null,\n        pendingOperations: [] as Array<() => void>,\n        lastZoomTime: 0,\n        zoomThrottleMs: 16, // ~60fps\n\n        shouldThrottleZoom(): boolean {\n            const now = performance.now()\n            if (now - this.lastZoomTime < this.zoomThrottleMs) {\n                return true\n            }\n            this.lastZoomTime = now\n            return false\n        },\n\n        scheduleOperation(operation: () => void) {\n            this.pendingOperations.push(operation)\n\n            if (!this.animationFrameId) {\n                this.animationFrameId = requestAnimationFrame(() => {\n                    this.flushOperations()\n                })\n            }\n        },\n\n        flushOperations() {\n            this.pendingOperations.forEach(operation => operation())\n            this.pendingOperations.length = 0\n            this.animationFrameId = null\n        },\n\n        cleanup() {\n            if (this.animationFrameId) {\n                cancelAnimationFrame(this.animationFrameId)\n                this.animationFrameId = null\n            }\n            this.pendingOperations.length = 0\n        }\n    }\n\n    const fitView = (options: { padding?: number, duration?: number, nodes?: string[] } = {}) => {\n        vueFlowFitView({ padding: options.padding ?? 0.2, duration: options.duration ?? 300, nodes: options.nodes })\n    }\n\n    const zoomIn = () => {\n        if (zoomPerformanceManager.shouldThrottleZoom()) return\n        zoomPerformanceManager.scheduleOperation(() => {\n            vueFlowZoomIn({ duration: 200 })\n        })\n    }\n\n    const zoomOut = () => {\n        if (zoomPerformanceManager.shouldThrottleZoom()) return\n        zoomPerformanceManager.scheduleOperation(() => {\n            // Respect min zoom\n            const currentZoom = getViewport().zoom\n            const newZoom = Math.max(zoomConfig.value.minZoom, currentZoom - 0.1)\n            vueFlowZoomTo(newZoom, { duration: 200 })\n        })\n    }\n\n    const zoomToSelection = () => {\n        const selectedIds = canvasStore.selectedNodeIds\n        if (!selectedIds || selectedIds.length === 0) return\n\n        const currentNodes = getNodes.value\n        // Filter nodes that are actually on canvas\n        const selectedNodes = currentNodes.filter(n => selectedIds.includes(n.id))\n\n        if (selectedNodes.length === 0) return\n\n        fitView({ nodes: selectedIds, padding: 0.3 })\n    }\n\n    // Cleanup on unmount\n    onBeforeUnmount(() => {\n        zoomPerformanceManager.cleanup()\n    })\n\n    return {\n        // Vue Flow State\n        nodes,\n        edges,\n\n        // Basic Operations\n        addNodes,\n        removeNodes,\n        setNodes,\n        addEdges,\n        removeEdges,\n        setEdges,\n        findNode,\n        getNodes,\n        updateNode,\n        toObject,\n\n        // Coordinate Helpers\n        screenToFlowCoordinate,\n        project,\n        getIntersectingNodes,\n        isNodeIntersecting,\n\n        // Viewport & Zoom\n        viewport: storeViewport,\n        setViewport,\n        getViewport,\n        fitView,\n        zoomIn,\n        zoomOut,\n        zoomTo: vueFlowZoomTo,\n        zoomToSelection,\n        panOnDrag,\n\n        // Lifecycle\n        onInit,\n        onPaneReady,\n\n        // Events\n        onMoveEnd,\n        onConnect,\n        onEdgesChange,\n        onNodesChange,\n        applyNodeChanges,\n        applyEdgeChanges,\n\n        // Drag Events (Exposed for useCanvasDrag)\n        onNodeDragStart,\n        onNodeDrag,\n        onNodeDragStop\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasEdgeSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'deps' is defined but never used. Allowed unused args must match /^_/u.","line":10,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport { type Node, type Edge } from '@vue-flow/core'\n\ninterface EdgeSyncDeps {\n    nodes: Ref<Node[]>\n    edges: Ref<Edge[]>\n    recentlyRemovedEdges: Ref<Set<string>>\n}\n\nexport function useCanvasEdgeSync(deps: EdgeSyncDeps) {\n    const syncEdges = () => {\n        // Edge sync is handled by Vue Flow automatically\n        // This is a placeholder for any custom edge logic\n    }\n\n    return {\n        syncEdges\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasEvents.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CanvasSection' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'viewport' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":12,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'updateNode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":12,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":77}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, nextTick, computed } from 'vue'\nimport { useVueFlow, type Node, type Edge } from '@vue-flow/core'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { errorHandler, ErrorCategory } from '@/utils/errorHandler'\nimport { useCanvasContextMenus } from './useCanvasContextMenus'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\nexport function useCanvasEvents(syncNodes?: () => void) {\n    const canvasStore = useCanvasStore()\n    const taskStore = useTaskStore()\n    const { viewport, screenToFlowCoordinate, setNodes, getNodes, updateNode, findNode, removeSelectedNodes, getSelectedNodes } = useVueFlow()\n\n    // --- Interaction State ---\n    const isConnecting = ref(false)\n\n    // --- Context Menu State (Singleton) ---\n    const {\n        showCanvasContextMenu,\n        canvasContextMenuX,\n        canvasContextMenuY,\n        canvasContextSection,\n        showNodeContextMenu,\n        nodeContextMenuX,\n        nodeContextMenuY,\n        nodeContextMenuNodeId, // Singleton ID\n        showEdgeContextMenu,\n        edgeContextMenuX,\n        edgeContextMenuY,\n        edgeContextMenuEdgeId, // Singleton ID\n        openNodeContextMenu,\n        openEdgeContextMenu,\n        closeCanvasContextMenu,\n        closeNodeContextMenu,\n        closeEdgeContextMenu,\n        closeAllContextMenus\n    } = useCanvasContextMenus()\n\n    // Compatibility: Map IDs to Objects for legacy consumers\n    const selectedNode = computed(() => {\n        if (!nodeContextMenuNodeId.value) return null\n        return findNode(nodeContextMenuNodeId.value) || null\n    })\n\n    const selectedEdgeId = computed(() => edgeContextMenuEdgeId.value)\n\n    /* Actions are now provided by singleton */\n\n    // --- Event Handlers ---\n\n    const handlePaneClick = (event: MouseEvent) => {\n        // Only Ctrl/Cmd+click toggles group selection\n        // Shift is reserved for rubber-band drag selection (handled in useCanvasSelection)\n        const isMultiSelectClick = event.ctrlKey || event.metaKey\n\n        if (isMultiSelectClick) {\n            const { x, y } = screenToFlowCoordinate({\n                x: event.clientX,\n                y: event.clientY\n            })\n\n            // Find all groups that contain this point\n            const hitGroups = canvasStore.groups.filter(group => {\n                const gx = group.position.x\n                const gy = group.position.y\n                const gw = group.position.width\n                const gh = group.position.height\n                return x >= gx && x <= gx + gw && y >= gy && y <= gy + gh\n            })\n\n            if (hitGroups.length > 0) {\n                // If multiple groups (nested), pick the smallest one (likely the child)\n                hitGroups.sort((a, b) => (a.position.width * a.position.height) - (b.position.width * b.position.height))\n\n                const targetGroup = hitGroups[0]\n                canvasStore.toggleNodeSelection(targetGroup.id)\n\n                // Don't clear selection or close menus if we hit a group\n                return\n            }\n\n            // If we clicked empty space with modifier, preserve selection\n            closeAllContextMenus()\n            return\n        }\n\n        // Regular click on empty pane - clear selection (TASK-262)\n        // TASK-262: Set flag to allow deselection changes through the filter\n        // This flag is checked in handleNodesChange to permit bulk deselection\n        canvasStore.allowBulkDeselect = true\n\n        // Clear both Vue Flow's internal selection AND the store\n        const selectedNodes = getSelectedNodes.value\n        if (selectedNodes.length > 0) {\n            removeSelectedNodes(selectedNodes)\n        }\n        canvasStore.setSelectedNodes([])\n        closeAllContextMenus()\n    }\n\n    const handleCanvasRightClick = (event: MouseEvent) => {\n        if (isConnecting.value) {\n            event.preventDefault()\n            event.stopPropagation()\n            return\n        }\n\n        const target = event.target as HTMLElement\n        // Don't show menu if clicking on a task or section node\n        if (target.closest('.task-node') || target.closest('[data-id^=\"section-\"]')) {\n            return\n        }\n\n        canvasContextMenuX.value = event.clientX\n        canvasContextMenuY.value = event.clientY\n        showCanvasContextMenu.value = true\n    }\n\n    const handlePaneContextMenu = (event: MouseEvent) => {\n        if (isConnecting.value) {\n            event.preventDefault()\n            event.stopPropagation()\n            return\n        }\n        event.preventDefault()\n\n        // BUG-228 FIX: Explicitly clear any stale section context\n        // so we don't accidentally open a group menu\n        canvasContextSection.value = null\n\n        canvasContextMenuX.value = event.clientX\n        canvasContextMenuY.value = event.clientY\n        showCanvasContextMenu.value = true\n    }\n\n    // Drag and Drop (Task -> Canvas)\n    const handleDrop = async (event: DragEvent) => {\n        event.preventDefault()\n        const data = event.dataTransfer?.getData('application/json')\n        if (!data) return\n\n        try {\n            const { taskId } = JSON.parse(data)\n            if (!taskId) return\n\n            const vueFlowElement = document.querySelector('.vue-flow') as HTMLElement\n            if (!vueFlowElement) return\n\n            const flowCoords = screenToFlowCoordinate({\n                x: event.clientX,\n                y: event.clientY\n            })\n            const { x, y } = flowCoords\n\n\n            // AWAIT the task update before calling syncNodes\n            // Otherwise syncNodes runs with stale task data\n            await taskStore.updateTask(taskId, {\n                canvasPosition: { x, y },\n                isInInbox: false\n            })\n\n            if (syncNodes) syncNodes()\n\n            // Wait for Vue reactivity to propagate before syncing\n            // filteredTasks is a computed that needs time to recalculate\n            await nextTick()\n\n            // Call syncNodes to build the node array with parent-child relationships\n            if (syncNodes) {\n                syncNodes()\n            }\n\n            // Wait for v-model to sync nodes.value to Vue Flow's internal state\n            // BEFORE reading getNodes.value. Without this tick, getNodes returns STALE state.\n            await nextTick()\n\n            // CRITICAL - Use setNodes() to force Vue Flow to reinitialize\n            // Direct array mutation doesn't trigger Vue Flow's complete initialization sequence\n            // setNodes() ensures parent-child relationships are properly discovered\n            const currentNodes = getNodes.value\n            setNodes(currentNodes)\n\n            // Double nextTick() for Vue Flow parent-child discovery\n            await nextTick()\n            await nextTick()\n\n        } catch (error) {\n            errorHandler.report({\n                error: error as Error,\n                category: ErrorCategory.CANVAS,\n                message: 'Error in handleDrop',\n                userMessage: 'Failed to drop task on canvas'\n            })\n        }\n    }\n\n    const handleNodeContextMenu = (event: { event: MouseEvent | TouchEvent; node: Node } | MouseEvent | TouchEvent) => {\n        let mouseEvent: MouseEvent | TouchEvent\n        let node: Node | undefined\n\n        if (event && 'event' in event && 'node' in event) {\n            mouseEvent = event.event\n            node = event.node\n        } else {\n            mouseEvent = event as MouseEvent | TouchEvent\n        }\n\n        if (!node) return\n\n        // Use clientX/Y from MouseEvent or TouchEvent (first touch)\n        const clientX = 'clientX' in mouseEvent ? mouseEvent.clientX : (mouseEvent as TouchEvent).touches[0].clientX\n        const clientY = 'clientY' in mouseEvent ? mouseEvent.clientY : (mouseEvent as TouchEvent).touches[0].clientY\n\n        mouseEvent.preventDefault()\n\n        // --- ROUTE TO CORRECT MENU ---\n        if (node.type === 'taskNode') {\n            // Bridge to TaskContextMenu (managed by ModalManager)\n            window.dispatchEvent(new CustomEvent('task-context-menu', {\n                detail: {\n                    event: mouseEvent,\n                    task: node.data?.task || { id: node.id }\n                }\n            }))\n            closeAllContextMenus()\n        } else if (node.type === 'sectionNode') {\n            // Bridge to CanvasContextMenu with Section context\n            const { id: sectionId } = CanvasIds.parseNodeId(node.id)\n            const section = canvasStore.groups.find(s => s.id === sectionId)\n\n            canvasContextMenuX.value = clientX\n            canvasContextMenuY.value = clientY\n            canvasContextSection.value = section || null\n            showCanvasContextMenu.value = true\n\n            // Close other internal menus\n            showNodeContextMenu.value = false\n            showEdgeContextMenu.value = false\n        } else {\n            // Default generic node menu (for any other custom types)\n            openNodeContextMenu(clientX, clientY, node.id)\n        }\n    }\n\n    const handleEdgeContextMenu = (event: { event: MouseEvent | TouchEvent; edge: Edge } | MouseEvent | TouchEvent) => {\n        let mouseEvent: MouseEvent | TouchEvent\n        let edgeId: string | undefined\n\n        if ('event' in event && 'edge' in event) {\n            mouseEvent = event.event\n            edgeId = event.edge.id\n        } else {\n            mouseEvent = event as MouseEvent | TouchEvent\n        }\n\n        const clientX = 'clientX' in mouseEvent ? mouseEvent.clientX : (mouseEvent as TouchEvent).touches[0].clientX\n        const clientY = 'clientY' in mouseEvent ? mouseEvent.clientY : (mouseEvent as TouchEvent).touches[0].clientY\n\n        mouseEvent.preventDefault()\n        if (edgeId) {\n            openEdgeContextMenu(clientX, clientY, edgeId)\n        }\n    }\n\n    return {\n        // State\n        isConnecting,\n        showCanvasContextMenu,\n        canvasContextMenuX,\n        canvasContextMenuY,\n        canvasContextSection,\n        showNodeContextMenu,\n        nodeContextMenuX,\n        nodeContextMenuY,\n        selectedNode,\n        showEdgeContextMenu,\n        edgeContextMenuX,\n        edgeContextMenuY,\n        selectedEdgeId,\n\n        // Actions\n        closeCanvasContextMenu,\n        closeNodeContextMenu,\n        closeEdgeContextMenu,\n        closeAllContextMenus,\n\n        // Handlers\n        handlePaneClick,\n        handleCanvasRightClick,\n        handlePaneContextMenu,\n        handleNodeContextMenu,\n        handleEdgeContextMenu,\n        handleDrop\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasFilteredState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ref' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'width' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":17,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, ref, type Ref } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { useWindowSize } from '@vueuse/core'\nimport { assertNoDuplicateIds } from '@/utils/canvas/invariants'\n\ninterface TaskStoreSettings {\n    hideCanvasDoneTasks?: boolean\n    hideCanvasOverdueTasks?: boolean\n}\n\ninterface CanvasStore {\n    calculateContentBounds: (tasks: Task[]) => { x: number; y: number; width: number; height: number }\n    taskStore?: TaskStoreSettings\n}\n\nexport function useCanvasFilteredState(filteredTasks: Ref<Task[]>, canvasStore: CanvasStore) {\n    const { width } = useWindowSize()\n\n    // --- Caching Variables ---\n    let lastCanvasTasks: Task[] = []\n    let lastCanvasTasksHash = ''\n\n    let lastHasNoTasks = false\n    let lastHasNoTasksLength = -1\n\n    let lastHasInboxTasks = false\n    let lastHasInboxTasksHash = ''\n\n    let lastDynamicNodeExtent: [[number, number], [number, number]] | null = null\n    let lastDynamicNodeExtentHash = ''\n\n    // --- Computed State ---\n\n    /**\n     * Optimized filtering for tasks that have valid canvas positions.\n     * Consolidates filteredTasksWithCanvasPosition and tasksWithCanvasPositions.\n     * Also handles view-specific filtering (Hide Done, Hide Overdue).\n     */\n    const tasksWithCanvasPosition = computed(() => {\n        let tasks = filteredTasks.value\n        if (!Array.isArray(tasks)) return []\n\n        // 1. Filter out Done tasks if enabled in store\n        if (canvasStore.taskStore?.hideCanvasDoneTasks) {\n            tasks = tasks.filter(t => t.status !== 'done')\n        }\n\n        // 2. Filter out Overdue tasks if enabled\n        if (canvasStore.taskStore?.hideCanvasOverdueTasks) {\n            const today = new Date()\n            today.setHours(0, 0, 0, 0)\n            tasks = tasks.filter(t => {\n                if (!t.dueDate) return true\n                const due = new Date(t.dueDate)\n                return due >= today\n            })\n        }\n\n        // Robust hashing for cache invalidation\n        const currentHash = tasks.map(t => `${t.id}:${t.title}:${t.description || ''}:${t.canvasPosition?.x || ''}:${t.canvasPosition?.y || ''}:${t.updatedAt ? new Date(t.updatedAt).getTime() : ''}`).join('|')\n\n        if (currentHash === lastCanvasTasksHash && lastCanvasTasks.length > 0) {\n            return lastCanvasTasks\n        }\n\n        const result = tasks.filter(task => {\n            const pos = task.canvasPosition\n            return pos && typeof pos.x === 'number' && typeof pos.y === 'number'\n        })\n\n        // ================================================================\n        // DUPLICATE DETECTION - Canvas Selector Layer (AUTHORITATIVE)\n        // ================================================================\n        // This detects if the store/filtering layer is returning duplicates\n        // A duplicate here means the bug is upstream (in task store or filtering)\n        // Uses assertNoDuplicateIds for consistent detection across layers\n        if (import.meta.env.DEV) {\n            const checkResult = assertNoDuplicateIds(result, 'tasksWithCanvasPosition')\n\n            if (checkResult.hasDuplicates) {\n                console.error('[TASK-ID-HISTOGRAM] DUPLICATES in tasksWithCanvasPosition', {\n                    duplicates: checkResult.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                    totalCount: checkResult.totalCount,\n                    uniqueIdCount: checkResult.uniqueIdCount\n                })\n            } else if (result.length > 0) {\n                console.debug('[TASK-ID-HISTOGRAM] tasksWithCanvasPosition', {\n                    uniqueIdCount: checkResult.uniqueIdCount,\n                    totalCount: checkResult.totalCount\n                })\n            }\n        }\n\n        lastCanvasTasksHash = currentHash\n        lastCanvasTasks = result\n        return result\n    })\n\n    const hasNoTasks = computed(() => {\n        const currentLength = filteredTasks.value?.length || 0\n        if (currentLength === lastHasNoTasksLength) return lastHasNoTasks\n\n        lastHasNoTasksLength = currentLength\n        lastHasNoTasks = currentLength === 0\n        return lastHasNoTasks\n    })\n\n    const hasInboxTasks = computed(() => {\n        const tasks = filteredTasks.value\n        if (!Array.isArray(tasks)) return false\n\n        const currentHash = tasks.map(t => `${t.id}:${!!t.canvasPosition}:${t.status}`).join('|')\n        if (currentHash === lastHasInboxTasksHash) return lastHasInboxTasks\n\n        // Logic: Task is in \"inbox\" if it has no canvas position and is not done\n        const result = tasks.some(task => !task.canvasPosition && task.status !== 'done')\n\n        lastHasInboxTasksHash = currentHash\n        lastHasInboxTasks = result\n        return result\n    })\n\n    const dynamicNodeExtent = computed(() => {\n        const tasks = tasksWithCanvasPosition.value\n        if (!tasks.length) {\n            return [[-2000, -2000], [5000, 5000]] as [[number, number], [number, number]]\n        }\n\n        const currentHash = tasks.map(t => `${t.id}:${t.canvasPosition?.x || 0}:${t.canvasPosition?.y || 0}`).join('|')\n        if (currentHash === lastDynamicNodeExtentHash && lastDynamicNodeExtent) {\n            return lastDynamicNodeExtent\n        }\n\n        try {\n            const bounds = canvasStore.calculateContentBounds(tasks)\n            const padding = 1000\n\n            // Convert {x,y,w,h} to extent [[minX, minY], [maxX, maxY]]\n            const minX = bounds.x\n            const minY = bounds.y\n            const maxX = bounds.x + bounds.width\n            const maxY = bounds.y + bounds.height\n\n            const result = [\n                [minX - padding * 10, minY - padding * 10],\n                [maxX + padding * 10, maxY + padding * 10]\n            ] as [[number, number], [number, number]]\n\n            lastDynamicNodeExtent = result\n            lastDynamicNodeExtentHash = currentHash\n            return result\n        } catch (error) {\n            console.warn('⚠️ [COMPUTED] Error calculating dynamic node extent:', error)\n            return [[-2000, -2000], [5000, 5000]] as [[number, number], [number, number]]\n        }\n    })\n\n    // --- Helper Logic ---\n\n    return {\n        tasksWithCanvasPosition,\n        hasNoTasks,\n        hasInboxTasks,\n        dynamicNodeExtent\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasGroupActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useTaskStore' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'vueFlowElement' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":58,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'group' is defined but never used. Allowed unused args must match /^_/u.","line":89,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'group' is defined but never used. Allowed unused args must match /^_/u.","line":93,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sectionNodeId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":129,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":32},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":163,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":163,"endColumn":52,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6706,6707],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, type Ref, nextTick } from 'vue'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\n// TASK-158: Persistent deleted groups tracking\nimport { markGroupDeleted, confirmGroupDeleted } from '@/utils/deletedGroupsTracker'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\nexport interface GroupActionsDeps {\n    viewport?: Ref<{ x: number; y: number; zoom: number }>\n    syncNodes: () => void\n    batchSyncNodes?: (priority?: 'high' | 'normal' | 'low') => void // Optional for now\n    closeCanvasContextMenu: () => void\n    screenToFlowCoordinate: (position: { x: number; y: number }) => { x: number; y: number }\n    recentlyDeletedGroups?: Ref<Set<string>>\n    state?: {\n        isGroupModalOpen: Ref<boolean>\n        selectedGroup: Ref<CanvasSection | null>\n        groupModalPosition: Ref<{ x: number; y: number }>\n        isGroupEditModalOpen: Ref<boolean>\n        selectedSectionForEdit: Ref<CanvasSection | null>\n        isDeleteGroupModalOpen: Ref<boolean>\n        groupPendingDelete: Ref<CanvasSection | null>\n    }\n}\n\nexport function useCanvasGroupActions(deps: GroupActionsDeps) {\n    const canvasStore = useCanvasStore()\n\n    // --- State (Use injected state or fallback to local) ---\n    const isGroupModalOpen = deps.state?.isGroupModalOpen ?? ref(false)\n    const selectedGroup = deps.state?.selectedGroup ?? ref<CanvasSection | null>(null)\n    const groupModalPosition = deps.state?.groupModalPosition ?? ref({ x: 100, y: 100 })\n\n    const isGroupEditModalOpen = deps.state?.isGroupEditModalOpen ?? ref(false)\n    const selectedSectionForEdit = deps.state?.selectedSectionForEdit ?? ref<CanvasSection | null>(null)\n\n    const isDeleteGroupModalOpen = deps.state?.isDeleteGroupModalOpen ?? ref(false)\n    const groupPendingDelete = deps.state?.groupPendingDelete ?? ref<CanvasSection | null>(null)\n\n    // --- Helper for Ghost Removal ---\n    // Note: duplicated small helper to avoid complex sharing, or could be passed in.\n    // Given its simplicity, I'll keep it here, but ideally it should be a shared util.\n    // For this refactor, I'll access the store directly to avoid circular dependency with orchestrator.\n    const removeGhostNodeRef = (id: string) => {\n        // We can't easily access VueFlow's removeNodes here without passing it in.\n        // But the main orchestrator handles the view dependencies.\n        // For pure data operations, we can modify the store.\n        if (canvasStore.nodes) {\n            const nodeId = CanvasIds.groupNodeId(id)\n            canvasStore.nodes = canvasStore.nodes.filter(n => n.id !== nodeId)\n        }\n    }\n\n    // --- Actions ---\n\n    const createGroup = async (screenPos?: { x: number; y: number }) => {\n\n        const vueFlowElement = document.querySelector('.vue-flow') as HTMLElement\n        // Relaxed check: Logic doesn't strict depend on this being present for state update\n\n        // If no position provided, use viewport center\n        let flowCoords: { x: number; y: number }\n        if (!screenPos) {\n            const viewport = deps.viewport?.value || { x: 0, y: 0, zoom: 1 }\n            // Note: Simplistic viewport center calculation if screenPos is missing\n            flowCoords = {\n                x: -viewport.x / viewport.zoom + (window.innerWidth / 2) / viewport.zoom,\n                y: -viewport.y / viewport.zoom + (window.innerHeight / 2) / viewport.zoom\n            }\n        } else {\n            flowCoords = deps.screenToFlowCoordinate(screenPos)\n        }\n\n        groupModalPosition.value = flowCoords\n        selectedGroup.value = null // Ensure create mode\n\n        deps.closeCanvasContextMenu()\n        isGroupModalOpen.value = true\n\n        return undefined // Matches Promise<string | undefined> expectation of hotkeys\n    }\n\n    const closeGroupModal = () => {\n        isGroupModalOpen.value = false\n        selectedGroup.value = null\n        groupModalPosition.value = { x: 100, y: 100 }\n    }\n\n    const handleGroupCreated = (group: CanvasSection) => {\n        deps.syncNodes()\n    }\n\n    const handleGroupUpdated = (group: CanvasSection) => {\n        deps.syncNodes()\n    }\n\n    const editGroup = (section: CanvasSection) => {\n        selectedSectionForEdit.value = section\n        isGroupEditModalOpen.value = true\n        deps.closeCanvasContextMenu()\n    }\n\n    const closeGroupEditModal = () => {\n        isGroupEditModalOpen.value = false\n        selectedSectionForEdit.value = null\n    }\n\n    const handleGroupEditSave = (updatedSection: Partial<CanvasSection> & { id: string }) => {\n        if (!updatedSection) return\n        canvasStore.updateSectionWithUndo(updatedSection.id, updatedSection)\n        deps.syncNodes()\n        closeGroupEditModal()\n    }\n\n    const deleteGroup = (section: CanvasSection) => {\n        if (!section) return\n\n        // Show designed confirmation modal instead of native confirm()\n        groupPendingDelete.value = section\n        isDeleteGroupModalOpen.value = true\n        deps.closeCanvasContextMenu()\n    }\n\n    const confirmDeleteGroup = async () => {\n        const section = groupPendingDelete.value\n        if (!section) return\n\n        try {\n            const sectionNodeId = CanvasIds.groupNodeId(section.id)\n\n            // TASK-158 FIX: Use persistent deleted groups tracker\n            markGroupDeleted(section.id)\n            if (deps.recentlyDeletedGroups) {\n                deps.recentlyDeletedGroups.value.add(section.id)\n            }\n\n            // BUG-091 FIX: Check if section exists in store (might be a ghost)\n            const existsInStore = canvasStore.sections.some(s => s.id === section.id)\n\n            if (!existsInStore) {\n                removeGhostNodeRef(section.id)\n\n                // Confirm deletion since there's nothing in Supabase to delete\n                confirmGroupDeleted(section.id)\n                if (deps.recentlyDeletedGroups) {\n                    deps.recentlyDeletedGroups.value.delete(section.id)\n                }\n            } else {\n                try {\n                    await canvasStore.deleteSection(section.id)\n                    confirmGroupDeleted(section.id)\n                    if (deps.recentlyDeletedGroups) {\n                        deps.recentlyDeletedGroups.value.delete(section.id)\n                    }\n                } catch (e) {\n                    console.error('[ASYNC-ERROR] confirmDeleteGroup deleteSection failed', e)\n                    // Don't clear from tracker on failure - let TTL handle cleanup\n                }\n            }\n\n            // Force high priority sync which cleans up/re-verifies\n            if (deps.batchSyncNodes) {\n                nextTick(() => deps.batchSyncNodes!('high'))\n            } else {\n                nextTick(() => deps.syncNodes())\n            }\n\n            // Close the modal\n            cancelDeleteGroup()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] confirmDeleteGroup failed', error)\n        }\n    }\n\n    const cancelDeleteGroup = () => {\n        isDeleteGroupModalOpen.value = false\n        groupPendingDelete.value = null\n    }\n\n    return {\n        // State\n        isGroupModalOpen,\n        selectedGroup,\n        groupModalPosition,\n        isGroupEditModalOpen,\n        selectedSectionForEdit,\n        isDeleteGroupModalOpen,\n        groupPendingDelete,\n\n        // Actions\n        createGroup,\n        closeGroupModal,\n        handleGroupCreated,\n        handleGroupUpdated,\n        editGroup,\n        closeGroupEditModal,\n        handleGroupEditSave,\n        deleteGroup,\n        confirmDeleteGroup,\n        cancelDeleteGroup\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasGroupMembership.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Rect' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":47}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useCanvasGroupMembership\n *\n * TASK-106: Provides helpers for determining which canvas group a task belongs to.\n * Used by CalendarInboxPanel to filter tasks by canvas group.\n *\n * Note: Tasks are associated with groups through visual containment (position-based),\n * not through explicit groupId fields.\n *\n * TASK-144: Now uses shared geometry utilities from @/utils/geometry.ts\n */\n\nimport { computed } from 'vue'\nimport { useCanvasStore, type CanvasGroup } from '@/stores/canvas'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { findSmallestContainingRect, type Rect } from '@/utils/canvas/positionCalculator'\n\nexport function useCanvasGroupMembership() {\n  const canvasStore = useCanvasStore()\n  const taskStore = useTaskStore()\n\n  // Local helper to replace the removed utility\n  const getGroupAbsolutePosition = (groupId: string, groups: CanvasGroup[]) => {\n    let x = 0\n    let y = 0\n    let currentId: string | null = groupId\n\n    // Safety break to prevent infinite loops\n    let depth = 0\n    while (currentId && depth < 50) {\n      const group = groups.find(g => g.id === currentId)\n      if (!group) break\n\n      x += group.position.x\n      y += group.position.y\n      currentId = group.parentGroupId || null\n      depth++\n    }\n    return { x, y }\n  }\n\n  /**\n   * Get the canvas group ID that contains a task.\n   * Returns the smallest (most specific) containing group if nested.\n   * Returns null if task has no canvas position or isn't in any group.\n   */\n  const getTaskGroupId = (task: Task): string | null => {\n    if (!task.canvasPosition) return null\n\n    const { x, y } = task.canvasPosition\n\n    // Convert groups to Rect format using ABSOLUTE positions (fixing nested group detection)\n    const groupsRaw = canvasStore.groups\n    const groupRects = groupsRaw.map(group => {\n      const absPos = getGroupAbsolutePosition(group.id, groupsRaw)\n      return {\n        ...group,\n        x: absPos.x,\n        y: absPos.y,\n        width: group.position.width,\n        height: group.position.height\n      }\n    })\n\n    const containingGroup = findSmallestContainingRect(x, y, groupRects)\n    return containingGroup?.id || null\n  }\n\n  /**\n   * Get all tasks that belong to a specific canvas group\n   */\n  const getTasksInGroup = (groupId: string): Task[] => {\n    return taskStore.filteredTasks.filter(task => getTaskGroupId(task) === groupId)\n  }\n\n  /**\n   * Get count of tasks in a specific group\n   */\n  const getGroupTaskCount = (groupId: string): number => {\n    return getTasksInGroup(groupId).length\n  }\n\n  /**\n   * Computed list of groups with their task counts, sorted by name\n   * Used for dropdown options in CalendarInboxPanel\n   */\n  const groupsWithCounts = computed(() => {\n    return canvasStore.groups\n      .map(group => ({\n        id: group.id,\n        name: group.name,\n        color: group.color,\n        type: group.type,\n        taskCount: getGroupTaskCount(group.id)\n      }))\n      .sort((a, b) => a.name.localeCompare(b.name))\n  })\n\n  /**\n   * Filter tasks to only those in a specific group (or all if groupId is null)\n   */\n  const filterTasksByGroup = (tasks: Task[], groupId: string | null): Task[] => {\n    if (!groupId) return tasks\n    return tasks.filter(task => getTaskGroupId(task) === groupId)\n  }\n\n  return {\n    getTaskGroupId,\n    getTasksInGroup,\n    getGroupTaskCount,\n    groupsWithCounts,\n    filterTasksByGroup\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasGroups.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'unref' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":20,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":18},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":62,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":62,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nodeRect' is defined but never used. Allowed unused args must match /^_/u.","line":73,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":48}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, nextTick, unref } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useCanvasCore } from './useCanvasCore'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\n/**\n * useCanvasGroups\n *\n * Consolidates all group-related logic:\n * - Task counting (Single Source of Truth: parentId)\n * - Containment checks (using Vue Flow computed positions)\n * - Group Actions (Create, Delete, Update)\n * - Hierarchy management\n */\nexport function useCanvasGroups() {\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const { nodes, getNodes } = useCanvasCore()\n\n    // --- Helpers ---\n\n    const isPointInRect = (x: number, y: number, rect: { x: number, y: number, width: number, height: number }) => {\n        return x >= rect.x && x <= rect.x + rect.width &&\n            y >= rect.y && y <= rect.y + rect.height\n    }\n\n    // --- Containment Logic ---\n\n    // Find the deep-most section that contains the center of a task\n    const findSectionForTask = (taskCenter: { x: number, y: number }, excludeId?: string): CanvasSection | null => {\n        const sections = getNodes.value.filter(n => CanvasIds.isGroupNode(n.id) && !n.hidden)\n\n        const validContainers = sections.filter(node => {\n            const { id: sectionId } = CanvasIds.parseNodeId(node.id)\n            if (sectionId === excludeId) return false\n\n            // Use computed position (absolute) from Vue Flow\n            const absX = node.computedPosition?.x ?? node.position.x\n            const absY = node.computedPosition?.y ?? node.position.y\n            const width = node.data?.width ?? 300\n            const height = node.data?.height ?? 200\n\n            return isPointInRect(taskCenter.x, taskCenter.y, {\n                x: absX,\n                y: absY,\n                width,\n                height\n            })\n        })\n\n        if (validContainers.length === 0) return null\n\n        // Sort by area (ascending: smallest first) - we want the most specific (deepest) group\n        return validContainers.sort((a, b) => {\n            const areaA = (a.data?.width ?? 300) * (a.data?.height ?? 200)\n            const areaB = (b.data?.width ?? 300) * (b.data?.height ?? 200)\n            return areaA - areaB\n        }).map(n => {\n            const { id } = CanvasIds.parseNodeId(n.id)\n            return canvasStore.groups.find(g => g.id === id)!\n        }).filter(Boolean)[0] || null\n    }\n\n    // Used during drag to find where a task is hovering\n    const getContainingGroupForTask = (x: number, y: number, w: number = 220, h: number = 100) => {\n        const centerX = x + w / 2\n        const centerY = y + h / 2\n        return findSectionForTask({ x: centerX, y: centerY })\n    }\n\n    const findAllContainingSections = (nodeRect: { x: number, y: number, width: number, height: number }) => {\n        // Implementation for group-in-group drag could go here if needed.\n        // For now, focusing on Task->Group drop.\n        return []\n    }\n\n    const getSectionAbsolutePosition = (sectionId: string) => {\n        const node = getNodes.value.find(n => n.id === CanvasIds.groupNodeId(sectionId))\n        return node?.computedPosition || { x: 0, y: 0 }\n    }\n\n    // --- Task Counting Logic ---\n\n    // Optimized Recursive Count (CYCLE-SAFE)\n    // Relies STRICTLY on parentId relationship, avoiding expensive spatial checks for counting.\n    // Uses visited set to prevent infinite recursion if cycles exist in data.\n    // FIX: Uses _rawGroups to include hidden groups in hierarchy traversal\n    const getTaskCountInGroupRecursive = (\n        groupId: string,\n        tasks: Task[],\n        visited: Set<string> = new Set()\n    ): number => {\n        // Cycle protection: don't revisit groups we've already counted\n        if (visited.has(groupId)) {\n            console.warn('[GROUPS] Detected cycle while counting tasks', { groupId })\n            return 0\n        }\n        visited.add(groupId)\n\n        // 1. Direct Children\n        let count = tasks.filter(t => t.parentId === groupId && !t._soft_deleted).length\n\n        // 2. Recursive Children (in subgroups)\n        // FIX: Use _rawGroups instead of canvasStore.groups to include hidden groups\n        // canvasStore.groups is filtered to visible only, which breaks hierarchy traversal\n        const allGroups = canvasStore._rawGroups\n        const childGroups = allGroups.filter(g => g.parentGroupId === groupId)\n        for (const child of childGroups) {\n            count += getTaskCountInGroupRecursive(child.id, tasks, visited)\n        }\n\n        return count\n    }\n\n    // Update a single section's task count node data\n    // FIX: Update BOTH directTaskCount and aggregatedTaskCount (not just taskCount)\n    // GroupNodeSimple.vue reads directTaskCount/aggregatedTaskCount from props.data\n    const updateSingleSectionCount = (sectionId: string, _tasks: Task[]) => {\n        const sectionNodeId = CanvasIds.groupNodeId(sectionId)\n\n        // Read from store's reactive computeds (source of truth)\n        const directCount = canvasStore.taskCountByGroupId.get(sectionId) ?? 0\n        const aggregatedCount = canvasStore.aggregatedTaskCountByGroupId.get(sectionId) ?? directCount\n\n        // Direct reactivity update on Vue Flow node data\n        const node = getNodes.value.find(n => n.id === sectionNodeId)\n        if (node && node.data) {\n            const oldDirect = node.data.directTaskCount\n            const oldAggregated = node.data.aggregatedTaskCount\n\n            // Update ALL count properties to ensure UI consistency\n            node.data.directTaskCount = directCount\n            node.data.aggregatedTaskCount = aggregatedCount\n            node.data.taskCount = aggregatedCount // Legacy compat\n\n            // Log when counts actually change for debugging\n            if (oldDirect !== directCount || oldAggregated !== aggregatedCount) {\n                console.log(`📊 [COUNT-UPDATE] ${sectionId.slice(0, 8)}: direct ${oldDirect}→${directCount}, aggregated ${oldAggregated}→${aggregatedCount}`)\n            }\n        }\n    }\n\n    // Helper to get ancestor chain for bubbling updates\n    // FIX: Uses _rawGroups to include hidden groups in hierarchy traversal\n    const getAncestorGroupIds = (groupId: string, visited = new Set<string>()): string[] => {\n        if (visited.has(groupId)) return []\n        visited.add(groupId)\n\n        const allGroups = canvasStore._rawGroups\n        const group = allGroups.find(g => g.id === groupId)\n        if (!group || !group.parentGroupId) return []\n\n        const ancestors: string[] = [group.parentGroupId]\n        ancestors.push(...getAncestorGroupIds(group.parentGroupId, visited))\n        return ancestors\n    }\n\n    // Main entry point for updating counts\n    const updateSectionTaskCounts = async (oldSectionId?: string, newSectionId?: string) => {\n        // Ensure store is fresh\n        await nextTick()\n\n        const tasks = taskStore.tasks.filter(t => !t._soft_deleted)\n        const sectionsToUpdate = new Set<string>()\n\n        if (oldSectionId) {\n            sectionsToUpdate.add(oldSectionId)\n            getAncestorGroupIds(oldSectionId).forEach(id => sectionsToUpdate.add(id))\n        }\n\n        if (newSectionId) {\n            sectionsToUpdate.add(newSectionId)\n            getAncestorGroupIds(newSectionId).forEach(id => sectionsToUpdate.add(id))\n        }\n\n        sectionsToUpdate.forEach(sectionId => {\n            updateSingleSectionCount(sectionId, tasks)\n        })\n    }\n\n    return {\n        // Counting\n        getTaskCountInGroupRecursive,\n        updateSectionTaskCounts,\n        updateSingleSectionCount,\n        getAncestorGroupIds,\n\n        // Containment / Hierarchy\n        getContainingGroupForTask,\n        getSectionAbsolutePosition,\n        findAllContainingSections\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasHotkeys.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'viewport' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":27,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Ref } from 'vue'\nimport { useVueFlow } from '@vue-flow/core'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\ninterface BulkDeleteState {\n    isBulkDeleteModalOpen: Ref<boolean>\n    bulkDeleteItems: Ref<{ id: string; name: string; type: 'task' | 'section' }[]>\n    bulkDeleteIsPermanent: Ref<boolean>\n    createGroup: (position?: { x: number; y: number }) => Promise<string | undefined>\n}\n\nexport function useCanvasHotkeys(\n    deps: BulkDeleteState\n) {\n    const canvasStore = useCanvasStore()\n    const taskStore = useTaskStore()\n    const { getSelectedNodes, toObject } = useVueFlow()\n\n    // Handle Delete Key\n    const handleKeyDown = async (event: KeyboardEvent) => {\n        // Handle Creation Hotkeys\n        if (event.shiftKey && (event.key === 'G' || event.key === 'g')) {\n            event.preventDefault()\n            // Create group at center of viewport\n            const viewport = toObject().viewport\n            // Calculate center: -x/zoom + width/2/zoom\n            // Simple approximation or just let createGroup handle default (center)\n            await deps.createGroup()\n            return\n        }\n\n        const isDeleteKey = event.key === 'Delete' || event.key === 'Backspace'\n\n        if (!isDeleteKey) return\n\n        // Input protection\n        const target = event.target as HTMLElement | null\n        if (target) {\n            const tagName = target.tagName\n            const isEditable = tagName === 'INPUT' || tagName === 'TEXTAREA' || target.isContentEditable\n            if (isEditable && !event.shiftKey) return\n        }\n\n        // Check for selected nodes\n        // Use canvasStore source of truth if possible, or VueFlow\n        const selectedNodes = getSelectedNodes.value\n        if (!selectedNodes || selectedNodes.length === 0) return\n\n        event.preventDefault()\n        const permanentDelete = event.shiftKey\n\n        // Collect all items to delete - show ONE confirmation for all\n        const itemsToDelete: { id: string; name: string; type: 'task' | 'section' }[] = []\n\n        for (const node of selectedNodes) {\n            if (CanvasIds.isGroupNode(node.id)) {\n                const { id: sectionId } = CanvasIds.parseNodeId(node.id)\n                const section = canvasStore.sections.find(s => s.id === sectionId)\n\n                itemsToDelete.push({\n                    id: sectionId,\n                    name: section?.name || 'Unknown Section',\n                    type: 'section'\n                })\n            } else {\n                const task = taskStore.getTask(node.id)\n                itemsToDelete.push({\n                    id: node.id,\n                    name: task?.title || 'Unknown Task',\n                    type: 'task'\n                })\n            }\n        }\n\n        if (itemsToDelete.length === 0) return\n\n        if (itemsToDelete.length === 0) return\n\n        // Show bulk delete confirmation modal\n        deps.bulkDeleteItems.value = itemsToDelete\n        deps.bulkDeleteIsPermanent.value = permanentDelete\n        deps.isBulkDeleteModalOpen.value = true\n    }\n\n    // Register listener\n    // We can attach to window or let Vue Flow handle usage via @keydown\n    // The original implementation was passed to @keydown on VueFlow component\n    // so we should just return the handler.\n\n    return {\n        handleKeyDown\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasInteractions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nextTick' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4593,4596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4593,4596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":253,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10558,10561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10558,10561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":312,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12574,12577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12574,12577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12613,12616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12613,12616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":314,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12641,12644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12641,12644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":320,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":320,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":327,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13172,13175],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13172,13175],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'x' is defined but never used. Allowed unused args must match /^_/u.","line":339,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":339,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'y' is defined but never used. Allowed unused args must match /^_/u.","line":339,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":339,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'w' is defined but never used. Allowed unused args must match /^_/u.","line":339,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":339,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'h' is defined but never used. Allowed unused args must match /^_/u.","line":339,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":339,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":525,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":525,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22285,22288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22285,22288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":526,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":526,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22356,22359],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22356,22359],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":589,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":589,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25397,25400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25397,25400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":624,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":624,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26715,26718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26715,26718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sectionId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":625,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":625,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":662,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":662,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28482,28485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28482,28485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, reactive, computed, nextTick, type Ref } from 'vue'\nimport { type Node, type NodeDragEvent, useVueFlow } from '@vue-flow/core'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { Task } from '@/types/tasks'\nimport type { CanvasGroup } from '@/stores/canvas/types'\nimport { useCanvasGroups } from './useCanvasGroups'\nimport { useCanvasCore } from './useCanvasCore'\nimport { useCanvasOperationState } from './useCanvasOperationState'\nimport { useCanvasResizeState } from './useCanvasResizeState'\nimport { useCanvasResizeCalculation } from './useCanvasResizeCalculation'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport { getDeepestContainingGroup, DEFAULT_TASK_WIDTH, DEFAULT_TASK_HEIGHT } from '@/utils/canvas/spatialContainment'\nimport { useNodeSync } from './useNodeSync'\nimport { useNodeStateManager, NodeState } from './state-machine'\nimport { storeToRefs } from 'pinia'\nimport { getGroupAbsolutePosition, toAbsolutePosition } from '@/utils/canvas/coordinates'\nimport { useCanvasSectionProperties } from './useCanvasSectionProperties'\n\n// =============================================================================\n// DESCENDANT COLLECTION HELPERS (BUG #1 FIX)\n// =============================================================================\n// These helpers recursively collect ALL descendants (not just direct children)\n// so that when a parent group moves, all nested items are synced to DB.\n\n/**\n * Collect all descendant groups recursively (CYCLE-SAFE)\n * For hierarchy A → B → C, calling with A returns [B, C]\n *\n * Uses visited set to prevent infinite recursion if cycles exist in data.\n */\nfunction collectDescendantGroups(\n    rootId: string,\n    groups: CanvasGroup[],\n    visited: Set<string> = new Set()\n): CanvasGroup[] {\n    // Cycle protection: don't revisit nodes we've already processed\n    if (visited.has(rootId)) return []\n    visited.add(rootId)\n\n    const directChildren = groups.filter(g => g.parentGroupId === rootId)\n\n    return directChildren.flatMap(child => [\n        child,\n        ...collectDescendantGroups(child.id, groups, visited)\n    ])\n}\n\n/**\n * Collect all descendant tasks (tasks in the group AND all descendant groups)\n * For hierarchy A → B → C with tasks in each, returns all tasks\n */\nfunction collectDescendantTasks(rootId: string, tasks: Task[], groups: CanvasGroup[]): Task[] {\n    const descendants: Task[] = []\n\n    // Direct tasks in this group\n    const directTasks = tasks.filter(t => t.parentId === rootId)\n    descendants.push(...directTasks)\n\n    // Tasks in ALL descendant groups (recursive)\n    const descendantGroups = collectDescendantGroups(rootId, groups)\n    for (const group of descendantGroups) {\n        const groupTasks = tasks.filter(t => t.parentId === group.id)\n        descendants.push(...groupTasks)\n    }\n\n    return descendants\n}\n\n// =============================================================================\n// GROUP PARENT UPDATE HELPER\n// =============================================================================\n// This helper encapsulates ALL parent transition logic for groups:\n// - Center-based containment detection\n// - Cycle prevention\n// - Vue Flow node updates (parentNode, position)\n// - Store updates (parentGroupId)\n//\n// CRITICAL INVARIANT: Groups must NOT have extent: 'parent' set!\n// This allows them to escape their parent via drag.\n\ninterface GroupParentUpdateResult {\n    oldParentId: string | null\n    newParentId: string | null\n    transitionType: 'root-to-child' | 'child-to-root' | 'child-to-child' | 'no-change'\n    cyclePreventedAttemptedParent?: string\n}\n\n/**\n * Update a group's parent after drag, using center-based containment.\n *\n * BEHAVIOR:\n * 1. Computes targetParentId using center of group's bounding box\n * 2. If center is inside a group → becomes child of that group\n * 3. If center is outside all groups → becomes root (parentGroupId = null)\n * 4. Prevents cycles (can't make a descendant the parent)\n * 5. Updates Vue Flow node.parentNode (but NOT extent!)\n * 6. Returns detailed transition info for logging\n *\n * @param args.groupId - The group being moved\n * @param args.absoluteRect - The group's absolute bounding box {x, y, width, height}\n * @param args.node - The Vue Flow node to update\n * @param args.allGroups - All groups for containment lookup\n * @returns Result with old/new parent and transition type\n */\nfunction updateGroupParentAfterDrag(args: {\n    groupId: string\n    absoluteRect: { x: number; y: number; width: number; height: number }\n    node: any\n    allGroups: CanvasGroup[]\n}): GroupParentUpdateResult {\n    const { groupId, absoluteRect, node, allGroups } = args\n\n    // Find current group in store\n    const group = allGroups.find(g => g.id === groupId)\n    const oldParentId = group?.parentGroupId ?? null\n\n    // Build spatial representation for containment check\n    const spatialGroup = {\n        position: { x: absoluteRect.x, y: absoluteRect.y },\n        width: absoluteRect.width,\n        height: absoluteRect.height,\n    }\n\n    // Find containing group by CENTER (not overlap)\n    const targetParent = getDeepestContainingGroup(spatialGroup, allGroups, groupId)\n    let newParentId: string | null = targetParent?.id ?? null\n\n    // Log center position for debugging\n    const centerX = absoluteRect.x + absoluteRect.width / 2\n    const centerY = absoluteRect.y + absoluteRect.height / 2\n\n    console.log(`[GROUP-PARENT] Checking containment for \"${group?.name || groupId}\"`, {\n        center: { x: Math.round(centerX), y: Math.round(centerY) },\n        oldParent: oldParentId ?? '(root)',\n        detectedParent: newParentId ?? '(root)',\n    })\n\n    // ================================================================\n    // CYCLE PREVENTION\n    // ================================================================\n    let cyclePreventedAttemptedParent: string | undefined\n\n    // 1) Don't allow self-parenting\n    if (newParentId === groupId) {\n        console.warn(`[GROUP-PARENT] Prevented self-parenting for ${groupId}`)\n        newParentId = null\n    }\n\n    // 2) Don't allow making a descendant the parent (creates A→B→A cycle)\n    if (newParentId) {\n        const descendants = collectDescendantGroups(groupId, allGroups)\n        const descendantIds = new Set(descendants.map(d => d.id))\n        if (descendantIds.has(newParentId)) {\n            console.warn(`[GROUP-PARENT] Prevented cycle: \"${group?.name}\" cannot have descendant \"${targetParent?.name}\" as parent`)\n            cyclePreventedAttemptedParent = newParentId\n            // BUG FIX: When cycle prevented, DON'T keep old parent!\n            // The user dragged outside, they want to escape. Set to root.\n            // Only exception: if they tried to drop INTO their own child.\n            // In that case, we keep position but become root.\n            newParentId = null\n        }\n    }\n\n    // ================================================================\n    // POSITION ADJUSTMENT (before parentNode change)\n    // ================================================================\n    // When parent changes, Vue Flow interprets node.position relative to new parent.\n    // Adjust position so visual location stays the same.\n    if (oldParentId !== newParentId) {\n        if (newParentId) {\n            // Going INTO a parent: convert absolute → relative\n            const newParentAbsolute = getGroupAbsolutePosition(newParentId, allGroups)\n            const newRelativePos = {\n                x: absoluteRect.x - newParentAbsolute.x,\n                y: absoluteRect.y - newParentAbsolute.y\n            }\n            if (isFinite(newRelativePos.x) && isFinite(newRelativePos.y)) {\n                node.position = newRelativePos\n            }\n        } else {\n            // Going to ROOT: use absolute position directly\n            node.position = { x: absoluteRect.x, y: absoluteRect.y }\n        }\n    }\n\n    // ================================================================\n    // VUE FLOW NODE UPDATE\n    // ================================================================\n    // CRITICAL: Do NOT set extent: 'parent'!\n    // This would lock the group inside and prevent future escape.\n    if (newParentId) {\n        node.parentNode = CanvasIds.groupNodeId(newParentId)\n        // NOTE: Intentionally NOT setting node.extent = 'parent'\n    } else {\n        node.parentNode = undefined\n        node.extent = undefined\n    }\n\n    // Determine transition type for logging\n    let transitionType: GroupParentUpdateResult['transitionType'] = 'no-change'\n    if (oldParentId !== newParentId) {\n        if (!oldParentId && newParentId) {\n            transitionType = 'root-to-child'\n        } else if (oldParentId && !newParentId) {\n            transitionType = 'child-to-root'\n        } else {\n            transitionType = 'child-to-child'\n        }\n\n        const oldName = oldParentId ? allGroups.find(g => g.id === oldParentId)?.name : '(root)'\n        const newName = newParentId ? allGroups.find(g => g.id === newParentId)?.name : '(root)'\n        console.log(`[GROUP-PARENT] ✓ Transition: ${transitionType}`, {\n            group: group?.name || groupId,\n            from: oldName,\n            to: newName,\n        })\n    }\n\n    return {\n        oldParentId,\n        newParentId,\n        transitionType,\n        cyclePreventedAttemptedParent,\n    }\n}\n\n// =============================================================================\n// ABSOLUTE POSITION COMPUTATION HELPER\n// =============================================================================\n// This helper reliably computes the absolute world position of a Vue Flow node,\n// even when computedPosition is not available or stale.\n//\n// KEY INSIGHT: When expandParent is false, Vue Flow may not always populate\n// computedPosition correctly. We need to manually compute it when necessary.\n\n/**\n * Compute absolute world position for a Vue Flow node\n *\n * CONTAINMENT FIX: Instead of trusting computedPosition (which may be stale\n * or unavailable after setting expandParent: false), we manually compute\n * the absolute position using the store's absolute group positions.\n *\n * @param node - The Vue Flow node\n * @param allGroups - All groups from the canvas store (have absolute positions)\n * @returns Absolute world position {x, y}\n */\nfunction computeNodeAbsolutePosition(\n    node: Node,\n    allGroups: CanvasGroup[]\n): { x: number; y: number } {\n    // First try computedPosition - this is the most reliable if available\n    const vfNode = node as any\n    if (vfNode.computedPosition &&\n        typeof vfNode.computedPosition.x === 'number' &&\n        typeof vfNode.computedPosition.y === 'number' &&\n        isFinite(vfNode.computedPosition.x) &&\n        isFinite(vfNode.computedPosition.y)) {\n        return {\n            x: vfNode.computedPosition.x,\n            y: vfNode.computedPosition.y\n        }\n    }\n\n    // If no parentNode, position is already absolute\n    if (!node.parentNode) {\n        return { x: node.position.x, y: node.position.y }\n    }\n\n    // Has parentNode - position is RELATIVE to parent\n    // We need to compute absolute by adding parent's absolute position\n    const parentId = node.parentNode.startsWith('section-')\n        ? node.parentNode.replace('section-', '')\n        : node.parentNode\n\n    const parentAbsolute = getGroupAbsolutePosition(parentId, allGroups)\n    const absolute = toAbsolutePosition(node.position, parentAbsolute)\n\n    return { x: absolute.x, y: absolute.y }\n}\n\nexport interface SelectionBox {\n    x: number\n    y: number\n    width: number\n    height: number\n    startX: number\n    startY: number\n    isVisible: boolean\n}\n\n/**\n * useCanvasInteractions\n *\n * ============================================================================\n * DRAG/RESIZE HANDLERS - WRITE PATH\n * ============================================================================\n *\n * This composable handles user interactions that trigger the WRITE PATH:\n * - Drag end: saves new absolute positions to DB\n * - Resize end: saves new absolute positions and dimensions to DB\n *\n * FULLY ABSOLUTE ARCHITECTURE:\n * - Uses Vue Flow's computedPosition for absolute world coordinates\n * - Saves ABSOLUTE positions to DB for ALL nodes (tasks AND groups)\n * - When parent group moves, syncs both child tasks AND child groups\n *\n * KEY: Parent-drag triggers child sync because Vue Flow moves children\n * visually, but DB doesn't auto-update. We must explicitly sync.\n */\nexport function useCanvasInteractions(deps?: {\n    findNode: (id: string) => any\n    updateNode: (id: string, node: any) => void\n    nodes: Ref<any[]>\n}) {\n    // Vue Flow context hooks with fallback\n    let vueFlow: ReturnType<typeof useVueFlow> | null = null\n    try {\n        if (!deps) vueFlow = useVueFlow()\n    } catch (e) {\n        console.warn('⚠️ [CANVAS-INTERACTIONS] useVueFlow context fallback')\n    }\n\n    const { getNodes } = useCanvasCore()\n    const findNode = deps?.findNode || vueFlow?.findNode || (() => null)\n    const updateNode = deps?.updateNode || vueFlow?.updateNode || (() => { })\n    const nodes = (deps?.nodes || vueFlow?.nodes || ref([])) as Ref<any[]>\n\n    const canvasStore = useCanvasStore()\n    const taskStore = useTaskStore()\n    const { nodeVersionMap } = storeToRefs(canvasStore)\n    const { updateSectionTaskCounts } = useCanvasGroups()\n    const { startDrag, endDrag, startResize, endResize } = useCanvasOperationState()\n    const { setNodeState } = useNodeStateManager()\n\n    // Smart Section Properties\n    const { getSectionProperties } = useCanvasSectionProperties({\n        taskStore,\n        getAllContainingSections: (x, y, w, h) => {\n            // This is used for nesting, but onNodeDragStop handles its own containment\n            return []\n        }\n    })\n\n    // Interaction sub-states\n    const { resizeState, isResizeSettling, resizeLineStyle, edgeHandleStyle } = useCanvasResizeState()\n    const { validateDimensions, calculateChildInverseDelta } = useCanvasResizeCalculation()\n\n    // Selection state\n    const selectionBox = reactive<SelectionBox>({\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        startX: 0,\n        startY: 0,\n        isVisible: false\n    })\n\n    const selectedTask = ref<Task | null>(null)\n    const isEditModalOpen = ref(false)\n\n    // --- DRAG HANDLERS ---\n\n    /**\n     * Handle drag start - SINGLE SOURCE OF TRUTH for initiating drag state\n     *\n     * GUARDS:\n     * 1. `startDrag()` checks if global operation state is idle (prevents duplicate drags)\n     * 2. `setNodeState()` is idempotent (no warning if node already in DRAGGING_LOCAL)\n     * 3. `canvasStore.isDragging` is only set TRUE once per drag session\n     *\n     * If Vue Flow fires duplicate events, the guards prevent duplicate state transitions.\n     */\n    const onNodeDragStart = (event: NodeDragEvent) => {\n        const { nodes: involvedNodes } = event\n        const positions = new Map(involvedNodes.map(n => [n.id, { x: n.position.x, y: n.position.y }]))\n\n        // Guard: Only proceed if we can start a new drag (operation state is idle)\n        // This is the AUTHORITATIVE guard that prevents duplicate drag starts\n        if (startDrag(involvedNodes.map(n => n.id), positions)) {\n            // Set per-node state (idempotent - safe to call even if already DRAGGING_LOCAL)\n            involvedNodes.forEach(node => setNodeState(node.id, NodeState.DRAGGING_LOCAL))\n            // Set store-level drag flag ONCE per drag session\n            canvasStore.isDragging = true\n        }\n        // If startDrag() returned false, we are already dragging - ignore duplicate event\n    }\n\n    const onNodeDrag = (_event: NodeDragEvent) => {\n        // Vue Flow updates node.position automatically\n    }\n\n    // useNodeSync expects Ref<Map> from storeToRefs for proper reactivity\n    const { syncNodePosition } = useNodeSync(nodeVersionMap)\n\n    /**\n     * Handle drag stop - save new absolute positions to DB\n     *\n     * =========================================================================\n     * GEOMETRY WRITE POLICY (TASK-240 Phase 2.5)\n     * =========================================================================\n     * This function (onNodeDragStop) is the ONLY place where user-initiated\n     * geometry changes are allowed:\n     *   - task.parentId\n     *   - task.canvasPosition\n     *   - group.parentGroupId\n     *   - group.position\n     *\n     * All other code paths (Smart Groups, sync, orchestrator, overdue collectors)\n     * must be READ-ONLY for geometry fields. They may change metadata (dueDate,\n     * priority, status, tags) but NEVER parent or position fields.\n     *\n     * This policy prevents sync loops and position drift.\n     * =========================================================================\n     *\n     * FULLY ABSOLUTE ARCHITECTURE:\n     * 1. Use computedPosition for absolute world coordinates\n     * 2. Detect new parent using spatial containment\n     * 3. Update store with absolute position\n     * 4. Sync to DB with optimistic locking\n     * 5. For groups: also sync child tasks AND child groups\n     */\n    const onNodeDragStop = async (event: NodeDragEvent) => {\n        const { nodes: involvedNodes } = event\n        canvasStore.isDragging = false\n\n        for (const node of involvedNodes) {\n            if (CanvasIds.isGroupNode(node.id)) {\n                // ============================================================\n                // GROUP DRAG END\n                // ============================================================\n                const { id: groupId } = CanvasIds.parseNodeId(node.id)\n                const allGroups = canvasStore._rawGroups || canvasStore.groups || []\n                const group = allGroups.find(g => g.id === groupId)\n                if (!group) continue\n\n                // Compute absolute position for the group\n                const absolutePos = computeNodeAbsolutePosition(node, allGroups)\n                const groupWidth = group.position.width\n                const groupHeight = group.position.height\n\n                // Use the unified helper for parent update logic\n                // This handles: containment detection, cycle prevention, position adjustment,\n                // Vue Flow node updates (parentNode but NOT extent)\n                const parentResult = updateGroupParentAfterDrag({\n                    groupId,\n                    absoluteRect: {\n                        x: absolutePos.x,\n                        y: absolutePos.y,\n                        width: groupWidth,\n                        height: groupHeight,\n                    },\n                    node,\n                    allGroups,\n                })\n\n                // Update store with ABSOLUTE position AND parentGroupId\n                canvasStore.updateSection(groupId, {\n                    position: {\n                        x: absolutePos.x,\n                        y: absolutePos.y,\n                        width: groupWidth,\n                        height: groupHeight,\n                    },\n                    parentGroupId: parentResult.newParentId,\n                    positionFormat: 'absolute',\n                })\n\n                // Sync group to DB (persists parent_group_id)\n                // Re-fetch allGroups after store update to ensure we have latest data\n                const updatedAllGroups = canvasStore._rawGroups || canvasStore.groups || []\n                setNodeState(groupId, NodeState.SYNCING)\n                await syncNodePosition(groupId, node, updatedAllGroups, 'groups')\n                setNodeState(groupId, NodeState.IDLE)\n\n                // ================================================================\n                // SYNC DESCENDANTS: Tasks and Groups\n                // ================================================================\n                // When parent moves, Vue Flow moves all children visually.\n                // We must sync their NEW absolute positions to DB.\n\n                const descendantTasks = collectDescendantTasks(groupId, taskStore.tasks, updatedAllGroups)\n                const descendantGroups = collectDescendantGroups(groupId, updatedAllGroups)\n\n                // Sync descendant GROUPS first (parents before their children)\n                for (const descendantGroup of descendantGroups) {\n                    const childNodeId = CanvasIds.groupNodeId(descendantGroup.id)\n                    const childNode = findNode(childNodeId)\n                    if (!childNode) continue\n\n                    setNodeState(descendantGroup.id, NodeState.SYNCING)\n                    await syncNodePosition(descendantGroup.id, childNode, updatedAllGroups, 'groups')\n                    setNodeState(descendantGroup.id, NodeState.IDLE)\n                }\n\n                // Sync descendant TASKS\n                for (const descendantTask of descendantTasks) {\n                    const childNode = findNode(descendantTask.id)\n                    if (!childNode) continue\n\n                    setNodeState(descendantTask.id, NodeState.SYNCING)\n                    await syncNodePosition(descendantTask.id, childNode, updatedAllGroups, 'tasks')\n                    setNodeState(descendantTask.id, NodeState.IDLE)\n                }\n\n            } else {\n                // ============================================================\n                // TASK DRAG END\n                // ============================================================\n                const task = taskStore.getTask(node.id)\n                if (!task) continue\n\n                // Use _rawGroups to include hidden groups in lookups\n                const taskAllGroups = canvasStore._rawGroups || canvasStore.groups || []\n\n                // 1. Compute ABSOLUTE position for containment check\n                // When node has parentNode, node.position is RELATIVE, not absolute\n                // computedPosition is preferred; fallback calculates from parent's absolute\n                const absolutePos = computeNodeAbsolutePosition(node, taskAllGroups)\n\n                // 2. Build spatial task with explicit dimensions for center-based containment\n                const spatialTask = {\n                    position: absolutePos,\n                    width: (node as any).width ?? DEFAULT_TASK_WIDTH,\n                    height: (node as any).height ?? DEFAULT_TASK_HEIGHT\n                }\n\n                // 3. Detect new parent using spatial containment (center inside group bounds)\n                const targetGroup = getDeepestContainingGroup(spatialTask, taskAllGroups)\n                const oldParentId = task.parentId\n                const newParentId = targetGroup?.id ?? null\n\n                // Skip if position didn't change meaningfully\n                // (prevents drift when task just followed parent group)\n                if (oldParentId === newParentId && oldParentId !== null) {\n                    const oldPos = task.canvasPosition || { x: 0, y: 0 }\n                    const posDelta = Math.abs(absolutePos.x - oldPos.x) + Math.abs(absolutePos.y - oldPos.y)\n                    if (posDelta < 1) {\n                        continue\n                    }\n                }\n\n                // 4. Optimistic Store Update (Absolute position + parentId)\n                // GEOMETRY WRITER: Primary drag handler (TASK-255)\n                taskStore.updateTask(task.id, {\n                    parentId: newParentId ?? undefined,\n                    canvasPosition: absolutePos,\n                    positionFormat: 'absolute'\n                }, 'DRAG')\n\n                if (oldParentId !== newParentId) {\n                    // REACTIVITY FIX: Bump version FIRST to trigger count recomputation\n                    // Then updateSectionTaskCounts can read the fresh values from computeds\n                    canvasStore.bumpTaskParentVersion()\n                    updateSectionTaskCounts(oldParentId || undefined, newParentId || undefined)\n                }\n\n                // 5. Update Vue Flow parentNode to match new containment\n                if (newParentId) {\n                    node.parentNode = CanvasIds.groupNodeId(newParentId)\n                } else {\n                    node.parentNode = undefined\n                }\n\n                // 6. Apply Smart Section Properties (Today, Tomorrow, Priorities, etc.)\n                // METADATA ONLY: Smart groups update dueDate/priority/status, never geometry (TASK-255)\n                if (targetGroup) {\n                    const smartUpdates = getSectionProperties(targetGroup as CanvasSection)\n                    if (Object.keys(smartUpdates).length > 0) {\n                        console.log(`✨ [SMART-GROUP] Applying properties from \"${targetGroup.name}\" to task \"${task.title}\":`, smartUpdates)\n                        taskStore.updateTask(task.id, smartUpdates, 'SMART-GROUP')\n                    }\n                }\n\n                // 7. Sync task to DB with optimistic locking\n                setNodeState(task.id, NodeState.SYNCING)\n                await syncNodePosition(task.id, node, taskAllGroups, 'tasks')\n                setNodeState(task.id, NodeState.IDLE)\n            }\n        }\n        endDrag(involvedNodes.map(n => n.id))\n    }\n\n    // --- RESIZE HANDLERS ---\n\n    // --- RESIZE HANDLERS ---\n\n    const onSectionResizeStart = ({ sectionId: rawSectionId }: { sectionId: string; event: any }) => {\n        const { id: sectionId } = CanvasIds.parseNodeId(rawSectionId)\n        const section = canvasStore.groups.find(s => s.id === sectionId)\n        if (!section) return\n\n        const vueFlowNode = findNode(CanvasIds.groupNodeId(sectionId))\n        const startX = vueFlowNode?.position.x ?? section.position.x\n        const startY = vueFlowNode?.position.y ?? section.position.y\n\n        setNodeState(sectionId, NodeState.RESIZING)\n        startResize(sectionId, 'se')\n\n        resizeState.value = {\n            ...resizeState.value,\n            isResizing: true,\n            sectionId,\n            startX,\n            startY,\n            startWidth: section.position.width,\n            startHeight: section.position.height,\n            currentX: startX,\n            currentY: startY,\n            currentWidth: section.position.width,\n            currentHeight: section.position.height,\n            childStartPositions: {}\n        }\n\n        const vueFlowParentId = CanvasIds.groupNodeId(sectionId)\n        nodes.value.forEach(node => {\n            if (node.parentNode === vueFlowParentId) {\n                resizeState.value.childStartPositions[node.id] = { ...node.position }\n            }\n        })\n    }\n\n    const onSectionResize = ({ sectionId: rawSectionId, event }: { sectionId: string; event: any }) => {\n        const { id: sectionId } = CanvasIds.parseNodeId(rawSectionId)\n        const typedEvent = event as { params?: { width?: number; height?: number; x?: number; y?: number } }\n        const width = typedEvent?.params?.width\n        const height = typedEvent?.params?.height\n\n        // STRICT GUARD: Ignore resize events if not in an active resize session\n        // This prevents spurious events from NodeResizer on mount or layout shift\n        if (!resizeState.value.isResizing) return\n\n        // TOLERANCE CHECK: Ignore sub-pixel jitter to prevent ResizeObserver loops\n        if (!width || !height) return\n\n        // Must change by at least 1px to matter\n        if (Math.abs(width - resizeState.value.currentWidth) < 1 &&\n            Math.abs(height - resizeState.value.currentHeight) < 1) {\n            return\n        }\n\n        resizeState.value.currentWidth = width\n        resizeState.value.currentHeight = height\n\n        const xParam = typedEvent?.params?.x\n        const yParam = typedEvent?.params?.y\n        if (typeof xParam === 'number') resizeState.value.currentX = xParam\n        if (typeof yParam === 'number') resizeState.value.currentY = yParam\n\n        const deltaX = resizeState.value.currentX - resizeState.value.startX\n        const deltaY = resizeState.value.currentY - resizeState.value.startY\n\n        if (deltaX !== 0 || deltaY !== 0) {\n            Object.entries(resizeState.value.childStartPositions).forEach(([childId, startPos]) => {\n                const newRelPos = calculateChildInverseDelta(startPos, deltaX, deltaY)\n                updateNode(childId, { position: newRelPos })\n            })\n        }\n    }\n\n    const onSectionResizeEnd = async ({ sectionId: rawSectionId, event }: { sectionId: string; event: any }) => {\n        const { id: sectionId } = CanvasIds.parseNodeId(rawSectionId)\n        const vueFlowNode = findNode(CanvasIds.groupNodeId(sectionId))\n        if (!vueFlowNode) return\n\n        const typedEvent = event as { params?: { width?: number; height?: number } }\n        const width = typedEvent?.params?.width\n        const height = typedEvent?.params?.height\n        if (!width || !height) return\n\n        const section = canvasStore.groups.find(s => s.id === sectionId)\n        if (!section) return\n\n        isResizeSettling.value = true\n        resizeState.value.isResizing = false\n        endResize(sectionId)\n\n        const { width: validatedWidth, height: validatedHeight } = validateDimensions(width, height)\n        const newX = vueFlowNode.position.x\n        const newY = vueFlowNode.position.y\n        const deltaX = newX - resizeState.value.startX\n        const deltaY = newY - resizeState.value.startY\n\n        const absPos = { x: newX, y: newY }\n\n        // 1. Optimistic Store Update (Absolute)\n        canvasStore.updateGroup(sectionId, {\n            position: {\n                ...absPos,\n                width: validatedWidth,\n                height: validatedHeight\n            },\n            positionFormat: 'absolute'\n        })\n\n        // 2. Optimistic DB Sync\n        // We find the Vue Flow node to pass to key logic\n        if (vueFlowNode) {\n            // Ensure width/height are set for sync\n            vueFlowNode.data = { ...vueFlowNode.data, width: validatedWidth, height: validatedHeight }\n\n            setNodeState(sectionId, NodeState.SYNCING)\n            await syncNodePosition(sectionId, vueFlowNode, canvasStore.groups, 'groups')\n            setNodeState(sectionId, NodeState.IDLE)\n        }\n\n        // ================================================================\n        // BUG #4 FIX: Sync descendants when resize changes origin\n        // ================================================================\n        // If resize changed the group's origin (e.g., resizing from top-left),\n        // we must sync all descendant positions to DB. When resizing from\n        // bottom-right only, deltaX/deltaY will be 0 and no sync is needed.\n        if (deltaX !== 0 || deltaY !== 0) {\n            console.log(`📐 [RESIZE] Origin changed by (${deltaX}, ${deltaY}), syncing descendants...`)\n\n            // Sync ALL Descendant Tasks (reuse helpers from BUG #1 fix)\n            const descendantTasks = collectDescendantTasks(sectionId, taskStore.tasks, canvasStore.groups)\n            for (const descendantTask of descendantTasks) {\n                const childNode = findNode(descendantTask.id)\n                if (childNode) {\n                    setNodeState(descendantTask.id, NodeState.SYNCING)\n                    syncNodePosition(descendantTask.id, childNode, canvasStore.groups, 'tasks')\n                        .finally(() => setNodeState(descendantTask.id, NodeState.IDLE))\n                }\n            }\n\n            // Sync ALL Descendant Groups\n            const descendantGroups = collectDescendantGroups(sectionId, canvasStore.groups)\n            for (const descendantGroup of descendantGroups) {\n                const childNodeId = CanvasIds.groupNodeId(descendantGroup.id)\n                const childNode = findNode(childNodeId)\n                if (childNode) {\n                    setNodeState(descendantGroup.id, NodeState.SYNCING)\n                    syncNodePosition(descendantGroup.id, childNode, canvasStore.groups, 'groups')\n                        .finally(() => setNodeState(descendantGroup.id, NodeState.IDLE))\n                }\n            }\n        }\n        // NOTE: When deltaX === 0 && deltaY === 0 (bottom-right resize only),\n        // no child sync is needed because child absolute positions don't change.\n\n        setTimeout(() => isResizeSettling.value = false, 1000)\n    }\n\n    // --- SELECTION HANDLERS ---\n\n    const handleTaskSelect = (task: Task, multiSelect: boolean) => {\n        if (!task.id) return\n        if (multiSelect) {\n            canvasStore.toggleNodeSelection(task.id)\n        } else {\n            canvasStore.setSelectedNodes([task.id])\n        }\n    }\n\n    const clearSelection = () => {\n        canvasStore.setSelectedNodes([])\n        selectedTask.value = null\n    }\n\n    const updateSelection = (event: MouseEvent) => {\n        if (!selectionBox.isVisible) return\n        const currentX = event.clientX\n        const currentY = event.clientY\n        selectionBox.width = Math.abs(currentX - selectionBox.startX)\n        selectionBox.height = Math.abs(currentY - selectionBox.startY)\n        selectionBox.x = Math.min(currentX, selectionBox.startX)\n        selectionBox.y = Math.min(currentY, selectionBox.startY)\n    }\n\n    const startSelection = (event: MouseEvent) => {\n        if (!event.shiftKey) return\n        const { clientX, clientY } = event\n        selectionBox.startX = clientX\n        selectionBox.startY = clientY\n        selectionBox.x = clientX\n        selectionBox.y = clientY\n        selectionBox.width = 0\n        selectionBox.height = 0\n        selectionBox.isVisible = true\n        window.addEventListener('mousemove', updateSelection)\n        window.addEventListener('mouseup', endSelection)\n        event.preventDefault()\n        event.stopPropagation()\n    }\n\n    const endSelection = (_event: MouseEvent) => {\n        window.removeEventListener('mousemove', updateSelection)\n        window.removeEventListener('mouseup', endSelection)\n        if (!selectionBox.isVisible) return\n\n        const viewport = getViewportFromDOM()\n        const flowContainer = document.querySelector('.vue-flow__container') || document.querySelector('.canvas-container')\n        if (!flowContainer) return\n        const rect = flowContainer.getBoundingClientRect()\n\n        const involvedNodes = getNodes.value\n        const selectedIds: string[] = []\n        const boxLeft = selectionBox.x\n        const boxTop = selectionBox.y\n        const boxRight = selectionBox.x + selectionBox.width\n        const boxBottom = selectionBox.y + selectionBox.height\n\n        involvedNodes.forEach(node => {\n            const { x: graphX, y: graphY } = getAbsolutePositionRecursive(node, involvedNodes)\n            const graphW = Number(node.dimensions?.width ?? node.width ?? 200)\n            const graphH = Number(node.dimensions?.height ?? node.height ?? 100)\n            const screenX = (graphX * viewport.zoom) + viewport.x + rect.left\n            const screenY = (graphY * viewport.zoom) + viewport.y + rect.top\n            const screenW = graphW * viewport.zoom\n            const screenH = graphH * viewport.zoom\n\n            if (node.type === 'sectionNode') {\n                const isFullyContained = (\n                    screenX >= boxLeft && (screenX + screenW) <= boxRight &&\n                    screenY >= boxTop && (screenY + screenH) <= boxBottom\n                )\n                if (isFullyContained) selectedIds.push(node.id)\n                return\n            }\n\n            const intersects = (\n                screenX < boxRight && (screenX + screenW) > boxLeft &&\n                screenY < boxBottom && (screenY + screenH) > boxTop\n            )\n            if (intersects) selectedIds.push(node.id)\n        })\n\n        if (selectedIds.length > 0) canvasStore.setSelectedNodes(selectedIds)\n        selectionBox.isVisible = false\n    }\n\n    // --- RECURSIVE HELPERS ---\n\n    const getAbsolutePositionRecursive = (node: Node, allNodes: Node[]): { x: number, y: number } => {\n        let x = node.position.x\n        let y = node.position.y\n        let parentId = node.parentNode\n        while (parentId) {\n            const parent = allNodes.find(n => n.id === parentId)\n            if (parent) {\n                x += parent.position.x\n                y += parent.position.y\n                parentId = parent.parentNode\n            } else break\n        }\n        return { x, y }\n    }\n\n    const getViewportFromDOM = (): { x: number, y: number, zoom: number } => {\n        const transformPane = document.querySelector('.vue-flow__transformationpane') as HTMLElement\n        if (!transformPane) return { x: 0, y: 0, zoom: 1 }\n        const transform = transformPane.style.transform\n        const match = transform.match(/translate\\(([-\\d.]+)px,\\s*([-\\d.]+)px\\)\\s*scale\\(([-\\d.]+)\\)/)\n        return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]), zoom: parseFloat(match[3]) } : { x: 0, y: 0, zoom: 1 }\n    }\n\n    return {\n        onNodeDragStart, onNodeDrag, onNodeDragStop,\n        onSectionResizeStart, onSectionResize, onSectionResizeEnd,\n        selectionBox, selectedTask, isEditModalOpen, handleTaskSelect, clearSelection, startSelection, updateSelection, endSelection,\n        resizeState, isResizeSettling, resizeLineStyle, edgeHandleStyle\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasLifecycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasModals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasNavigation.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'minX' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'minY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'maxX' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'maxY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":36,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":19}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed } from 'vue'\nimport { useVueFlow } from '@vue-flow/core'\nimport type { useCanvasStore } from '@/stores/canvas'\n\nexport function useCanvasNavigation(canvasStore: ReturnType<typeof useCanvasStore>) {\n    const { fitView: vueFlowFitView, getNodes } = useVueFlow()\n\n    // Safety check - use computed to access viewport properties to avoid crash if store is not ready\n    const initialViewport = computed(() => {\n        const vp = canvasStore?.viewport || { x: 0, y: 0, zoom: 1 }\n        return {\n            x: Number.isFinite(vp.x) ? vp.x : 0,\n            y: Number.isFinite(vp.y) ? vp.y : 0,\n            zoom: (Number.isFinite(vp.zoom) && vp.zoom > 0) ? vp.zoom : 1\n        }\n    })\n\n    const zoomToSelection = () => {\n        // Get selected nodes from store/VueFlow\n        const selectedIds = canvasStore.selectedNodeIds\n        if (!selectedIds || selectedIds.length === 0) return\n\n        const nodes = getNodes.value\n        const selectedNodes = nodes.filter(n => selectedIds.includes(n.id))\n\n        if (selectedNodes.length === 0) return\n\n        // Calculate bounding box\n        const xs = selectedNodes.map(n => n.position.x)\n        const ys = selectedNodes.map(n => n.position.y)\n        const minX = Math.min(...xs)\n        const minY = Math.min(...ys)\n        // Approximate dimensions since actual dimensions might vary\n        // Ideally we'd use node.dimensions if measured, but position is improved\n        const maxX = Math.max(...xs) + 220\n        const maxY = Math.max(...ys) + 100\n\n        vueFlowFitView({\n            nodes: selectedIds,\n            padding: 0.3,\n            duration: 300\n        })\n    }\n\n    const fitCanvas = () => {\n        vueFlowFitView({ padding: 0.2, duration: 300 })\n    }\n\n    return {\n        initialViewport,\n        zoomToSelection,\n        fitCanvas\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasOperationState.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1488,1491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1488,1491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2937,2940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2937,2940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue'\n\nexport type CanvasOperationType =\n    | 'idle'\n    | 'dragging'\n    | 'drag-settling'\n    | 'resizing'\n    | 'resize-settling'\n    | 'syncing'\n    | 'editing'\n\nexport interface Position {\n    x: number\n    y: number\n}\n\nexport type CanvasOperationState =\n    | { type: 'idle' }\n    | { type: 'dragging'; nodeIds: string[]; startPositions: Map<string, Position> }\n    | { type: 'drag-settling'; nodeIds: string[]; settleTimeout: number }\n    | { type: 'resizing'; groupId: string; handle: string }\n    | { type: 'resize-settling'; groupId: string; settleTimeout: number }\n    | { type: 'syncing'; source: 'local' | 'remote' }\n    | { type: 'editing'; nodeId: string }\n\n// Singleton state to be shared across all canvas composables\nconst state = ref<CanvasOperationState>({ type: 'idle' })\n\n/**\n * State machine for canvas operations.\n * Replaces ad-hoc lock flags with formal transitions.\n */\nexport function useCanvasOperationState() {\n\n    // --- Transitions ---\n\n    const startDrag = (nodeIds: string[], positions: Map<string, Position>) => {\n        if (state.value.type !== 'idle') return false\n        state.value = { type: 'dragging', nodeIds, startPositions: positions }\n        return true\n    }\n\n    const endDrag = (nodeIds: string[]) => {\n        if (state.value.type !== 'dragging') return\n\n        // Clear previous timeout if any\n        if ('settleTimeout' in state.value) {\n            window.clearTimeout(state.value.settleTimeout as any)\n        }\n\n        const settleTimeout = window.setTimeout(() => {\n            if (state.value.type === 'drag-settling') {\n                state.value = { type: 'idle' }\n            }\n        }, 800)\n\n        state.value = { type: 'drag-settling', nodeIds, settleTimeout }\n    }\n\n    const startResize = (groupId: string, handle: string) => {\n        if (state.value.type !== 'idle') return false\n        state.value = { type: 'resizing', groupId, handle }\n        return true\n    }\n\n    const endResize = (groupId: string) => {\n        if (state.value.type !== 'resizing') return\n\n        const settleTimeout = window.setTimeout(() => {\n            if (state.value.type === 'resize-settling') {\n                state.value = { type: 'idle' }\n            }\n        }, 800)\n\n        state.value = { type: 'resize-settling', groupId, settleTimeout }\n    }\n\n    const setSyncing = (source: 'local' | 'remote') => {\n        // Can only sync if idle or already syncing\n        if (state.value.type !== 'idle' && state.value.type !== 'syncing') return false\n        state.value = { type: 'syncing', source }\n        return true\n    }\n\n    const setEditing = (nodeId: string) => {\n        if (state.value.type !== 'idle') return false\n        state.value = { type: 'editing', nodeId }\n        return true\n    }\n\n    const resetToIdle = () => {\n        if ('settleTimeout' in state.value) {\n            window.clearTimeout(state.value.settleTimeout as any)\n        }\n        state.value = { type: 'idle' }\n    }\n\n    // --- Guards/Selectors ---\n\n    const currentType = computed(() => state.value.type)\n\n    const isIdle = computed(() => state.value.type === 'idle')\n    const isDragging = computed(() => state.value.type === 'dragging')\n    const isResizing = computed(() => state.value.type === 'resizing')\n    const isSyncing = computed(() => state.value.type === 'syncing')\n\n    /**\n     * Whether remote updates should be blocked due to ongoing local interaction.\n     */\n    const isLocked = computed(() => {\n        return state.value.type !== 'idle' && state.value.type !== 'syncing'\n    })\n\n    /**\n     * Specific guard for sync updates.\n     */\n    const canAcceptRemoteUpdate = computed(() => {\n        return state.value.type === 'idle' || state.value.type === 'syncing'\n    })\n\n    const canStartOperation = computed(() => state.value.type === 'idle')\n\n    /**\n     * Is canvas in a settling state? (just finished interaction)\n     */\n    const isSettling = computed(() => {\n        return state.value.type === 'drag-settling' || state.value.type === 'resize-settling'\n    })\n\n    /**\n     * Should we block ALL updates? (interacting or settling)\n     */\n    const shouldBlockUpdates = computed(() => {\n        return isLocked.value || isSettling.value\n    })\n\n    /**\n     * Get debug info for troubleshooting\n     */\n    const getDebugInfo = () => ({\n        type: state.value.type,\n        canAcceptRemoteUpdate: canAcceptRemoteUpdate.value,\n        isLocked: isLocked.value,\n        isSettling: isSettling.value,\n        fullState: state.value\n    })\n\n    return {\n        state,\n        currentType,\n        isIdle,\n        isDragging,\n        isResizing,\n        isSyncing,\n        isLocked,\n        canAcceptRemoteUpdate,\n        canStartOperation,\n        startDrag,\n        endDrag,\n        startResize,\n        endResize,\n        setSyncing,\n        setEditing,\n        resetToIdle,\n        isSettling,\n        shouldBlockUpdates,\n        getDebugInfo\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Ref' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Node' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Edge' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'args' is defined but never used. Allowed unused args must match /^_/u.","line":42,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setViewport' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":77,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":78,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":79,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":79,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'screenToFlowCoordinate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":82,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isNodeIntersecting' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":83,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":83,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getIntersectingNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":84,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":84,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'addEdges' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":86,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'removeEdges' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":87,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":87,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onConnect' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":88,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onEdgesChange' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":89,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onNodesChange' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":90,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'toObject' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":93,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fitView' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":94,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'zoomTo' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":95,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":95,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'project' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":96,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'panOnDrag' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":97,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'width' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":102,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'height' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":102,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'groups' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":140,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":140,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5421,5424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5421,5424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'priority' is defined but never used. Allowed unused args must match /^_/u.","line":167,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":167,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":476,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":476,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17249,17252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17249,17252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":490,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":490,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17839,17842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17839,17842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":491,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":491,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17911,17914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17911,17914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, watch, nextTick, onMounted, type Ref } from 'vue'\nimport { type Node, type Edge } from '@vue-flow/core'\nimport { storeToRefs } from 'pinia'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasUiStore } from '@/stores/canvas/canvasUi'\nimport { useUIStore } from '@/stores/ui'\nimport { useMagicKeys, useWindowSize } from '@vueuse/core'\n\nimport resourceManager from '../../utils/canvas/resourceManager'\nimport { getUndoSystem } from '@/composables/undoSingleton'\nimport { reconcileTaskParentsByContainment } from '@/utils/canvas/spatialContainment'\nimport { logHierarchySummary } from '@/utils/canvas/invariants'\n\n// --- NEW COMPOSABLES (Phase 3) ---\nimport { useCanvasCore } from './useCanvasCore'\nimport { useCanvasSync } from './useCanvasSync'\nimport { useCanvasInteractions } from './useCanvasInteractions'\n\n// ...\n// Persistence (Sync)\n// Moved inside useCanvasOrchestrator to ensure correct Vue context\n\nimport { useCanvasGroups } from './useCanvasGroups'\n\n\n// Legacy/Auxiliary Composables (Still used)\nimport { useCanvasEvents } from './useCanvasEvents'\nimport { useCanvasHotkeys } from './useCanvasHotkeys'\nimport { useCanvasActions } from './useCanvasActions'\nimport { useCanvasOverdueCollector } from './useCanvasOverdueCollector'\nimport { useCanvasModals } from './useCanvasModals'\nimport { useCanvasFilteredState } from './useCanvasFilteredState'\nimport { useCanvasLifecycle } from './useCanvasLifecycle'\nimport { useCanvasNavigation } from './useCanvasNavigation' // Keeping for specialized nav if needed\nimport { useCanvasZoom } from './useCanvasZoom' // Keeping for cleanup hooks\nimport { useCanvasAlignment } from './useCanvasAlignment'\nimport { useCanvasConnections } from './useCanvasConnections'\n\n// Helper for error boundaries\nconst mockErrorBoundary = (_name: string, fn: (...args: unknown[]) => unknown) => {\n    if (typeof fn !== 'function') return (...args: unknown[]) => {\n        return null\n    }\n    return (...args: unknown[]) => {\n        try {\n            return fn(...args)\n        } catch (e) {\n            console.error(`[CanvasError] Error in ${_name}:`, e)\n            return null\n        }\n    }\n}\n\n// =============================================================================\n// DRIFT FIX: Module-level flag to ensure reconciliation runs only ONCE per browser session\n// =============================================================================\n// This prevents parent drift when:\n// - Tab visibility changes (focus/unfocus)\n// - Auth token refreshes (TOKEN_REFRESHED event)\n// - CanvasView remounts for any reason\n// Reconciliation should only happen on FIRST load, not repeatedly.\nlet hasReconciledThisSession = false\n\nexport function useCanvasOrchestrator() {\n    const canvasStore = useCanvasStore()\n    const taskStore = useTaskStore()\n    const canvasUiStore = useCanvasUiStore()\n    const uiStore = useUIStore()\n\n    // --- 1. Core State & Vue Flow (Via useCanvasCore) ---\n    const {\n        nodes,\n        edges,\n        onPaneReady,\n        viewport,\n        setViewport,\n        getNodes,\n        setNodes,\n        updateNode,\n        findNode,\n        screenToFlowCoordinate, // Proxy\n        isNodeIntersecting,\n        getIntersectingNodes,\n        onMoveEnd,\n        addEdges,\n        removeEdges,\n        onConnect,\n        onEdgesChange,\n        onNodesChange,\n        applyNodeChanges,\n        applyEdgeChanges,\n        toObject,\n        fitView, // Core now exposes fitView\n        zoomTo, // Core now exposes zoomTo\n        project,\n        panOnDrag\n    } = useCanvasCore()\n\n    const { hasInitialFit, operationLoading, operationError } = storeToRefs(canvasUiStore)\n    const { setOperationLoading, setOperationError, clearOperationError } = canvasUiStore\n    const { width, height } = useWindowSize()\n    const { shift, control, meta } = useMagicKeys()\n\n    // --- 2. Computed Data ---\n    const filteredTasks = computed(() => taskStore.filteredTasks)\n\n    // Pass taskStore reference so filtering can access hideCanvasDoneTasks etc.\n    const canvasStoreWithTaskStore = {\n        ...canvasStore,\n        taskStore: {\n            get hideCanvasDoneTasks() { return taskStore.hideCanvasDoneTasks },\n            get hideCanvasOverdueTasks() { return taskStore.hideCanvasOverdueTasks }\n        }\n    }\n\n    const {\n        tasksWithCanvasPosition,\n        dynamicNodeExtent,\n        hasNoTasks,\n        hasInboxTasks\n    } = useCanvasFilteredState(filteredTasks, canvasStoreWithTaskStore)\n\n    // --- 3. Feature Initialization ---\n\n    // Persistence (Sync)\n    // const persistence = useCanvasPersistence()\n\n    // Persistence (Sync)\n    const persistence = useCanvasSync()\n\n    // Unified Interactions (Drag & Resize)\n    const interactions = useCanvasInteractions({\n        nodes,\n        findNode,\n        updateNode\n    })\n\n    // Groups (Unified)\n    const groups = useCanvasGroups()\n\n    // Navigation & Zoom (Legacy cleanup support, transitioning to Core)\n    const { initialViewport, fitCanvas: legacyFitCanvas, zoomToSelection: legacyZoomToSelection } = useCanvasNavigation(canvasStore)\n    const fitCanvas = legacyFitCanvas\n    const zoomToSelection = legacyZoomToSelection\n    const { cleanupZoom } = useCanvasZoom(resourceManager)\n\n    // Modals\n    const modals = useCanvasModals()\n\n    // Sync Helpers (Adapter for legacy calls)\n    const syncNodes = (tasks?: any[]) => {\n        // Prevent sync if explicitly unwanted (e.g. during specific interactions)\n        if (canvasUiStore.operationLoading.syncing) return\n\n        console.debug('👉 [ORCHESTRATOR] Calling syncNodes', { hasTasks: !!tasks })\n        try {\n            const tasksToSync = tasks || tasksWithCanvasPosition.value\n            persistence.syncStoreToCanvas(tasksToSync)\n        } catch (e) {\n            console.error('💥 [ORCHESTRATOR] syncNodes failed:', e)\n        }\n    }\n\n    // OPTIMIZATION: True batching (only runs once per tick)\n    let isSyncScheduled = false\n    const batchedSyncNodes = (priority?: string) => {\n        if (isSyncScheduled) return\n        isSyncScheduled = true\n        nextTick(() => {\n            syncNodes()\n            isSyncScheduled = false\n        })\n    }\n\n    const syncEdges = () => { /* Edges sync implemented in Persistence later if needed, mostly static for now */ }\n\n    // Events (Selection, Connection)\n    const isVueFlowReady = ref(false)\n    const isVueFlowMounted = ref(false)\n\n    const events = useCanvasEvents(syncNodes)\n\n    // Actions\n    const recentlyDeletedGroups = ref(new Set<string>())\n    const actions = useCanvasActions({\n        viewport,\n        batchedSyncNodes: batchedSyncNodes,\n        syncNodes: syncNodes,\n        closeCanvasContextMenu: events.closeCanvasContextMenu,\n        closeEdgeContextMenu: events.closeEdgeContextMenu,\n        closeNodeContextMenu: events.closeNodeContextMenu,\n        recentlyDeletedGroups\n    }, modals, getUndoSystem())\n\n    // Hotkeys\n    const { handleKeyDown } = useCanvasHotkeys({\n        isBulkDeleteModalOpen: modals.isBulkDeleteModalOpen,\n        bulkDeleteItems: modals.bulkDeleteItems,\n        bulkDeleteIsPermanent: modals.bulkDeleteIsPermanent,\n        createGroup: actions.createGroup\n    })\n\n    // Lifecycle\n    const lifecycle = useCanvasLifecycle(\n        taskStore,\n        canvasStore,\n        uiStore,\n        fitCanvas,\n        cleanupZoom\n    )\n\n\n    const isCanvasReady = computed(() => {\n        return !operationLoading.value.loading && !operationLoading.value.syncing\n    })\n\n    // Alignment\n    const alignment = useCanvasAlignment(nodes, {\n        isVueFlowMounted,\n        isVueFlowReady,\n        isCanvasReady\n    }, {\n        closeCanvasContextMenu: events.closeCanvasContextMenu\n    })\n\n    // Smart Groups\n    const smartGroups = useCanvasOverdueCollector()\n\n    // Events Wrapper\n    const handleCanvasContainerClick = (_e: MouseEvent) => {\n        interactions.clearSelection()\n        events.closeCanvasContextMenu()\n        events.closeEdgeContextMenu()\n        events.closeNodeContextMenu()\n    }\n\n    const collectTasksForSection = (_sectionId: string) => {\n        smartGroups.autoCollectOverdueTasks()\n    }\n\n    // Connections\n    const connections = useCanvasConnections({\n        syncEdges: syncEdges,\n        closeCanvasContextMenu: events.closeCanvasContextMenu,\n        closeEdgeContextMenu: events.closeEdgeContextMenu,\n        closeNodeContextMenu: events.closeNodeContextMenu,\n        withVueFlowErrorBoundary: mockErrorBoundary\n    }, {\n        isConnecting: ref(false),\n        recentlyRemovedEdges: ref(new Set()), // Persistence handles this internally now?\n        showEdgeContextMenu: ref(false),\n        edgeContextMenuX: ref(0),\n        edgeContextMenuY: ref(0),\n        selectedEdge: ref(null)\n    })\n\n    // --- 4. Initialization & Reactivity ---\n\n    // CRITICAL: Initialization guard to prevent watchers from calling syncNodes during startup\n    // Without this, watchers fire as data loads, causing multiple syncNodes() calls with different task counts\n    const isInitialized = ref(false)\n\n    // Initial sync\n    onMounted(async () => {\n        console.log('🚀 [ORCHESTRATOR] onMounted starting...')\n\n        await canvasStore.loadSavedViewport()\n        await nextTick()\n\n        // Initialize Realtime\n        persistence.initRealtimeSubscription()\n\n        // CONTAINMENT RECONCILIATION: Fix legacy tasks with incorrect parentId\n        // DRIFT FIX: Only run ONCE per browser session to prevent repeated parent changes\n        // This guards against remounts from: tab focus, auth refresh, route changes\n        if (!hasReconciledThisSession) {\n            hasReconciledThisSession = true\n            console.log('🔧 [ORCHESTRATOR] Starting ONE-TIME reconciliation with', taskStore.tasks.length, 'tasks')\n            await reconcileTaskParentsByContainment(\n                taskStore.tasks,\n                canvasStore.groups,\n                async (taskId, updates) => {\n                    // Update store (will auto-sync to Supabase via existing persistence)\n                    // GEOMETRY WRITER: One-time reconciliation only (TASK-255)\n                    console.log(`🔧 [RECONCILE-WRITE] Task ${taskId.slice(0, 8)}... parentId → ${updates.parentId ?? 'none'}`)\n                    taskStore.updateTask(taskId, updates, 'RECONCILE')\n                },\n                { writeToDb: true, silent: false }\n            )\n        } else {\n            console.log('⏭️ [ORCHESTRATOR] Skipping reconciliation - already ran this session')\n        }\n\n        // Calculate initial task counts AFTER reconciliation (fixes 0 counters on load)\n        canvasStore.recalculateAllTaskCounts(taskStore.tasks)\n\n        // Log hierarchy summary once on load (dev only)\n        if (import.meta.env.DEV) {\n            logHierarchySummary(canvasStore._rawGroups || [])\n        }\n\n        // SINGLE initial sync respecting current filters\n        console.log('🚀 [ORCHESTRATOR] Initial syncNodes...')\n        syncNodes()\n\n        // Mark initialization complete - watchers can now fire\n        isInitialized.value = true\n        console.log('✅ [ORCHESTRATOR] Initialization complete')\n    })\n\n    // Persist Viewport on Change\n    onMoveEnd((flow) => {\n        if (flow && flow.flowTransform) {\n            // Debounce viewport saves slightly to strictly avoid slamming store\n            // (VueFlow handles throttling internal events, but good to be safe)\n            canvasStore.setViewport(flow.flowTransform.x, flow.flowTransform.y, flow.flowTransform.zoom)\n        }\n    })\n\n    // Watchers are now largely handled by persistence.initRealtimeSubscription which watches Stores\n    // But we still need to watch Filter changes here as they affect WHICH tasks we show\n    // CRITICAL: All watchers check isInitialized to prevent firing during startup\n    // OPTIMIZATION: Use batchedSyncNodes to coalesce multiple updates\n    watch(() => taskStore.activeStatusFilter, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n    })\n    watch(() => taskStore.hideCanvasDoneTasks, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n    })\n    watch(() => taskStore.hideCanvasOverdueTasks, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n    })\n\n    // REACTIVITY FIX: Watch for manual sync requests from context menus\n    watch(() => canvasStore.syncTrigger, () => {\n        if (!isInitialized.value) return\n        console.log('🔔 [ORCHESTRATOR] canvasStore.syncTrigger changed - forcing sync')\n        batchedSyncNodes()\n    })\n\n    watch(() => canvasUiStore.syncTrigger, () => {\n        if (!isInitialized.value) return\n        console.log('🔔 [ORCHESTRATOR] canvasUiStore.syncTrigger changed - forcing sync')\n        batchedSyncNodes()\n    })\n\n    // Global guard to prevent recursive watcher triggers\n    let isSyncingFromWatcher = false\n\n    // CRITICAL FIX: Watch for task data changes (e.g. after async load)\n    // Only watch task count changes, not deep property changes\n    watch(() => tasksWithCanvasPosition.value.length, () => {\n        // Skip during initialization - onMounted handles initial sync\n        if (!isInitialized.value) return\n        if (isSyncingFromWatcher) return\n        isSyncingFromWatcher = true\n        try {\n            if (persistence.isSyncing.value) return\n            canvasStore.recalculateAllTaskCounts(taskStore.tasks)\n            batchedSyncNodes()\n        } finally {\n            isSyncingFromWatcher = false\n        }\n    })\n\n    // CRITICAL FIX: Watch for group changes (e.g. creation/deletion/remote sync)\n    watch(() => canvasStore.groups.length, () => {\n        // Skip during initialization - onMounted handles initial sync\n        if (!isInitialized.value) return\n        if (isSyncingFromWatcher) return\n        isSyncingFromWatcher = true\n        try {\n            if (persistence.isSyncing.value) return\n            console.log('👀 [ORCHESTRATOR] canvasStore.groups changed', { count: canvasStore.groups.length })\n            canvasStore.recalculateAllTaskCounts(taskStore.tasks)\n            batchedSyncNodes()\n        } finally {\n            isSyncingFromWatcher = false\n        }\n    })\n\n    // DRIFT FIX: REMOVED watcher on taskCountByGroupId\n    // This watcher was causing sync loops and is now redundant because:\n    // 1. updateSingleSectionCount() directly updates Vue Flow node.data with fresh counts\n    // 2. The drag handler calls bumpTaskParentVersion() + updateSectionTaskCounts()\n    // 3. No need to rebuild all nodes just because counts changed\n    // Keeping this comment to document why it was removed.\n    // watch(() => canvasStore.taskCountByGroupId, () => { ... }, { deep: true })\n\n    // Retry Logic\n    const retryFailedOperation = async () => {\n        if (!operationError.value?.retryable) return\n        const { type } = operationError.value\n        clearOperationError()\n\n        if (type === 'System Restart') {\n            // persistence.performSystemRestart() // Todo: implement if needed\n            window.location.reload()\n        } else {\n            setOperationLoading('syncing', true)\n            try {\n                await nextTick()\n                syncNodes()\n                setOperationLoading('syncing', false)\n            } catch (_error) {\n                setOperationError('Sync Operation', 'Retry failed', true)\n                setOperationLoading('syncing', false)\n            }\n        }\n    }\n\n    // --- Expose Public Interface ---\n    return {\n        // State\n        nodes,\n        edges,\n        isCanvasReady,\n        operationLoading,\n        operationError,\n\n        // UI\n        viewport,\n        initialViewport,\n        hasInitialFit,\n        shift,\n        control,\n        meta,\n        vueFlowRef: ref(null), // TODO: Do we need this ref if we use Core? CanvasView binds it.\n\n        // Computed\n        filteredTasks,\n        tasksWithCanvasPosition,\n        dynamicNodeExtent,\n        hasNoTasks,\n        hasInboxTasks,\n\n        // Actions & Handlers\n        ...actions,\n        ...modals,\n        closeSectionSettingsModal: actions.closeGroupEditModal,\n        handleSectionSettingsSave: actions.handleGroupEditSave,\n\n        ...events,\n\n        // Selection Handlers\n        handleMouseDown: interactions.startSelection,\n        handleMouseMove: interactions.updateSelection,\n        handleMouseUp: interactions.endSelection,\n        handleCanvasContainerClick,\n\n        // New feature re-exports\n        ...interactions,\n        ...alignment,\n        ...smartGroups,\n        collectTasksForSection,\n        ...connections,\n\n        // Interaction Handlers\n        handleNodeDragStart: interactions.onNodeDragStart,\n        handleNodeDrag: interactions.onNodeDrag,\n        handleNodeDragStop: interactions.onNodeDragStop,\n\n        handleSectionResizeStart: interactions.onSectionResizeStart,\n        handleSectionResize: interactions.onSectionResize,\n        handleSectionResizeEnd: interactions.onSectionResizeEnd,\n\n        resizeState: interactions.resizeState,\n        isResizeSettling: interactions.isResizeSettling,\n        resizeLineStyle: interactions.resizeLineStyle,\n        edgeHandleStyle: interactions.edgeHandleStyle,\n\n        onPaneReady: (instance: any) => {\n            onPaneReady(instance) // Core handler\n            isVueFlowReady.value = true\n            isVueFlowMounted.value = true\n            setOperationLoading('loading', false)\n            setOperationLoading('syncing', false)\n        },\n        fitCanvas,\n        zoomToSelection,\n        retryFailedOperation,\n\n        // Vue Flow Handlers\n        // TASK-262: Filter selection changes to prevent unwanted deselection on node click\n        // Vue Flow default: clicking a node deselects all others. We only want pane click to deselect.\n        handleNodesChange: (changes: any[]) => {\n            const filteredChanges = changes.filter((change: any) => {\n                // Allow all non-selection changes (position, dimensions, add, remove, etc.)\n                if (change.type !== 'select') return true\n\n                // Allow selection (selected: true)\n                if (change.selected === true) return true\n\n                // Block deselection (selected: false) unless explicitly allowed via pane click\n                if (change.selected === false) {\n                    return canvasStore.allowBulkDeselect\n                }\n\n                return true\n            })\n\n            // Reset flag after filtering\n            if (canvasStore.allowBulkDeselect) {\n                canvasStore.allowBulkDeselect = false\n            }\n\n            applyNodeChanges(filteredChanges)\n        },\n        handleEdgesChange: applyEdgeChanges,\n        handleConnect: (params: import('@vue-flow/core').Connection) => {\n            connections.handleConnect(params)\n        },\n\n        // Debug\n        syncNodes,\n        performSystemRestart: () => window.location.reload(), // Simple fallback\n        storeHealth: lifecycle.storeHealth,\n\n        // Hotkeys\n        handleKeyDown\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasOverdueCollector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasResizeCalculation.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Bounds' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Pure mathematical calculations for canvas resizing logic.\n * Segregated for testability and clarity.\n */\n\ninterface Bounds {\n    x: number\n    y: number\n    width: number\n    height: number\n}\n\ninterface Constraints {\n    minWidth: number\n    maxWidth: number\n    minHeight: number\n    maxHeight: number\n}\n\nexport function useCanvasResizeCalculation() {\n\n    /**\n     * Validates and constrains resize dimensions\n     */\n    const validateDimensions = (width: number, height: number, constraints: Constraints = { minWidth: 200, maxWidth: 50000, minHeight: 80, maxHeight: 50000 }) => {\n        return {\n            width: Math.max(constraints.minWidth, Math.min(constraints.maxWidth, Math.abs(width))),\n            height: Math.max(constraints.minHeight, Math.min(constraints.maxHeight, Math.abs(height)))\n        }\n    }\n\n    /**\n     * Calculates the relative position of a child node during a parent resize operation.\n     * Implements \"Inverse Delta Compensation\" which keeps the child visually stationary\n     * by moving it in the opposite direction of the parent's top-left origin shift.\n     */\n    const calculateChildInverseDelta = (\n        childStartPos: { x: number; y: number },\n        deltaX: number,\n        deltaY: number\n    ) => {\n        return {\n            x: childStartPos.x - deltaX,\n            y: childStartPos.y - deltaY\n        }\n    }\n\n    /**\n     * Calculates the absolute position of a child when its parent moves to a new absolute position.\n     * Used when persisting changes to the backend.\n     */\n    const calculateChildAbsolutePosition = (\n        parentNewAbsPos: { x: number; y: number },\n        childNewRelPos: { x: number; y: number }\n    ) => {\n        return {\n            x: parentNewAbsPos.x + childNewRelPos.x,\n            y: parentNewAbsPos.y + childNewRelPos.y\n        }\n    }\n\n    return {\n        validateDimensions,\n        calculateChildInverseDelta,\n        calculateChildAbsolutePosition\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasResizeState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasSectionProperties.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getSmartGroupType' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":53}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { useTaskStore } from '@/stores/tasks'\nimport { type Task } from '@/stores/tasks'\nimport { type CanvasSection } from '@/stores/canvas'\nimport { shouldUseSmartGroupLogic, getSmartGroupType, detectPowerKeyword } from '../useTaskSmartGroups'\nimport { resolveDueDate } from '../useGroupSettings'\nimport { formatDateKey } from '@/utils/dateUtils'\nimport { DURATION_DEFAULTS, type DurationCategory } from '@/utils/durationCategories'\n\ninterface SectionPropertiesDeps {\n    taskStore: ReturnType<typeof useTaskStore>\n    getAllContainingSections: (x: number, y: number, width?: number, height?: number) => CanvasSection[]\n}\n\nexport function useCanvasSectionProperties(deps: SectionPropertiesDeps) {\n    const { taskStore, getAllContainingSections } = deps\n\n    // Helper: Get properties from a single section based on its name/settings\n    const getSectionProperties = (section: CanvasSection): Partial<Task> => {\n        const updates: Partial<Task> = {}\n\n        // 0. DAY-OF-WEEK GROUPS (Monday-Sunday)\n        const dayOfWeekMap: Record<string, number> = {\n            'sunday': 0, 'monday': 1, 'tuesday': 2, 'wednesday': 3,\n            'thursday': 4, 'friday': 5, 'saturday': 6\n        }\n        const lowerName = section.name.toLowerCase().trim()\n        if (dayOfWeekMap[lowerName] !== undefined) {\n            const today = new Date()\n            const targetDay = dayOfWeekMap[lowerName]\n            // Calculate next occurrence: ((7 + target - current) % 7) || 7\n            const daysUntilTarget = ((7 + targetDay - today.getDay()) % 7) || 7\n            const resultDate = new Date(today)\n            resultDate.setDate(today.getDate() + daysUntilTarget)\n            updates.dueDate = formatDateKey(resultDate)\n            return updates\n        }\n\n        // 1. Check explicit assignOnDrop settings first\n        if (section.assignOnDrop) {\n            const settings = section.assignOnDrop\n            if (settings.priority) updates.priority = settings.priority\n            if (settings.status) updates.status = settings.status\n            if (settings.projectId) updates.projectId = settings.projectId\n            if (settings.dueDate) {\n                const resolvedDate = resolveDueDate(settings.dueDate)\n                if (resolvedDate !== null) updates.dueDate = resolvedDate\n            }\n            return updates\n        }\n\n        // 2. Auto-detect from section name (Power Keywords)\n        const keyword = detectPowerKeyword(section.name)\n        if (keyword) {\n            const today = new Date()\n            switch (keyword.category) {\n                case 'date':\n                    switch (keyword.value) {\n                        case 'today':\n                            updates.dueDate = formatDateKey(today)\n                            break\n                        case 'tomorrow': {\n                            const tom = new Date(today)\n                            tom.setDate(today.getDate() + 1)\n                            updates.dueDate = formatDateKey(tom)\n                            break\n                        }\n                        case 'this weekend': {\n                            const sat = new Date(today)\n                            sat.setDate(today.getDate() + ((6 - today.getDay() + 7) % 7 || 7))\n                            updates.dueDate = formatDateKey(sat)\n                            break\n                        }\n                        case 'this week': {\n                            const sun = new Date(today)\n                            sun.setDate(today.getDate() + ((7 - today.getDay()) % 7 || 7))\n                            updates.dueDate = formatDateKey(sun)\n                            break\n                        }\n                        case 'later':\n                            updates.dueDate = ''\n                            break\n                    }\n                    break\n                case 'priority':\n                    updates.priority = keyword.value as 'high' | 'medium' | 'low'\n                    break\n                case 'status':\n                    updates.status = keyword.value as Task['status']\n                    break\n                case 'duration':\n                    updates.estimatedDuration = DURATION_DEFAULTS[keyword.value as DurationCategory] ?? 0\n                    break\n            }\n            return updates\n        }\n\n        // 3. Legacy fallback - check section type\n        if (section.type === 'priority' && section.propertyValue) {\n            updates.priority = section.propertyValue as 'high' | 'medium' | 'low'\n        } else if (section.type === 'status' && section.propertyValue) {\n            updates.status = section.propertyValue as Task['status']\n        } else if (section.type === 'project' && section.propertyValue) {\n            updates.projectId = section.propertyValue\n        } else if (section.type === 'custom' || section.type === 'timeline') {\n            if (shouldUseSmartGroupLogic(section.name)) {\n                // For smart group logic, we'd ideally call moveTaskToSmartGroup\n                // but since this is a pure \"get properties\" function, we'll let\n                // the keyword detection above handle it, or return the propertyValue as dueDate.\n                if (section.propertyValue) updates.dueDate = section.propertyValue\n            } else if (section.propertyValue) {\n                updates.dueDate = section.propertyValue\n            }\n        }\n\n        return updates\n    }\n\n    // Helper: Apply properties from ALL containing sections (nested group inheritance)\n    const applyAllNestedSectionProperties = (taskId: string, taskX: number, taskY: number) => {\n        const containingSections = getAllContainingSections(taskX, taskY)\n        if (containingSections.length === 0) return\n\n        const mergedUpdates: Partial<Task> = {}\n\n        for (const section of containingSections) {\n            const sectionProps = getSectionProperties(section)\n            if (Object.keys(sectionProps).length > 0) {\n                Object.assign(mergedUpdates, sectionProps)\n            }\n        }\n\n        if (Object.keys(mergedUpdates).length > 0) {\n            taskStore.updateTaskWithUndo(taskId, mergedUpdates)\n        }\n    }\n\n    // Helper: Apply section properties to task (single section - legacy/manual)\n    const applySectionPropertiesToTask = (taskId: string, section: CanvasSection) => {\n        const updates = getSectionProperties(section)\n\n        if (Object.keys(updates).length > 0) {\n            taskStore.updateTaskWithUndo(taskId, updates)\n        }\n    }\n\n\n    return {\n        getSectionProperties,\n        applyAllNestedSectionProperties,\n        applySectionPropertiesToTask\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CanvasGroup' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logHierarchySummary' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'addNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":86,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'removeNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":86,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":54},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3775,3778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3775,3778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6886,6889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6886,6889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":235,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10619,10622],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10619,10622],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'parentWasVisible' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":320,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":320,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":352,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16803,16806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16803,16806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":352,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16813,16816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16813,16816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":355,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16977,16980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16977,16980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":400,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":400,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19154,19157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19154,19157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":403,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":403,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19298,19301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19298,19301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":430,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":430,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21050,21053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21050,21053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":431,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":431,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21143,21146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21143,21146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":453,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":453,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22253,22256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22253,22256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":454,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":454,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22351,22354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22351,22354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":511,"column":97,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":511,"endColumn":100,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25622,25625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25622,25625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, watch, nextTick } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useVueFlow } from '@vue-flow/core'\nimport {\n    sanitizePosition,\n    groupPositionToVueFlow,\n    taskPositionToVueFlow\n} from '@/utils/canvas/coordinates'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport type { CanvasGroup } from '@/stores/canvas/types'\nimport { validateAllInvariants, logHierarchySummary, assertNoDuplicateIds } from '@/utils/canvas/invariants'\n\n// =============================================================================\n// MODULE-LEVEL HELPERS (defined before composable to ensure availability)\n// =============================================================================\n\n/**\n * Interface for groups that can be sorted by hierarchy\n */\ninterface HierarchicalGroup {\n    id: string\n    parentGroupId?: string | null\n}\n\n/**\n * Sort groups by hierarchy depth (parents before children)\n * Ensures Vue Flow can resolve parentNode references correctly.\n *\n * Uses topological sort: root groups (no parent) first, then their children, etc.\n * This guarantees that when a child group is added, its parent already exists.\n *\n * @param groups - Array of groups with id and optional parentGroupId\n * @returns Sorted array with root groups first, then depth 1, depth 2, etc.\n */\nfunction sortGroupsByHierarchy<T extends HierarchicalGroup>(groups: T[]): Array<T & { _depth: number }> {\n    // Helper to get depth (0 = root, 1 = direct child of root, etc.)\n    const getDepth = (groupId: string, visited: Set<string> = new Set()): number => {\n        const group = groups.find(g => g.id === groupId)\n        if (!group) return 0\n        if (!group.parentGroupId || group.parentGroupId === 'NONE') return 0\n        if (visited.has(groupId)) return 0 // Cycle protection\n\n        visited.add(groupId)\n        return 1 + getDepth(group.parentGroupId, visited)\n    }\n\n    // Calculate depth for each group\n    const groupsWithDepth = groups.map(g => ({\n        ...g,\n        _depth: getDepth(g.id)\n    }))\n\n    // Sort by depth: root groups (depth 0) first, then children (depth 1), etc.\n    groupsWithDepth.sort((a, b) => a._depth - b._depth)\n\n    return groupsWithDepth\n}\n\n// =============================================================================\n// COMPOSABLE\n// =============================================================================\n\n/**\n * Canvas Sync Composable\n *\n * ============================================================================\n * READ PATH: DB/Store → Vue Flow\n * ============================================================================\n *\n * This composable handles the READ PATH of the Fully Absolute Architecture:\n * - Reads absolute positions from store (which mirrors DB)\n * - Converts to relative positions for nested nodes (Vue Flow requirement)\n * - Creates Vue Flow nodes with correct position and parentNode\n *\n * KEY PRINCIPLE:\n * - DB/Store stores ABSOLUTE world coordinates for ALL nodes\n * - Vue Flow displays nested nodes with RELATIVE positions\n * - Conversion happens HERE using groupPositionToVueFlow/taskPositionToVueFlow\n */\nexport function useCanvasSync() {\n    const canvasStore = useCanvasStore()\n    const { nodeVersionMap, aggregatedTaskCountByGroupId, taskCountByGroupId } = storeToRefs(canvasStore)\n    const taskStore = useTaskStore()\n    const { getNodes, setNodes, addNodes, removeNodes } = useVueFlow()\n\n    const isSyncing = ref(false)\n\n    /**\n     * Helper to detect if assigning a parent would create a cycle\n     * Traces up the parent chain to ensure we don't point back to ourselves\n     */\n    const hasParentCycle = (nodeId: string, potentialParentId: string | null, groups: any[]): boolean => {\n        if (!potentialParentId) return false\n        if (nodeId === potentialParentId) return true // Self-reference\n\n        let currentId = potentialParentId\n        const visited = new Set<string>()\n\n        // Safety Break: max depth\n        let depth = 0\n        const MAX_DEPTH = 50\n\n        while (currentId && currentId !== 'NONE' && depth < MAX_DEPTH) {\n            if (currentId === nodeId) return true // Cycle detected!\n            if (visited.has(currentId)) return true // Circular chain found upstream\n\n            visited.add(currentId)\n\n            const parentGroup = groups.find(g => g.id === currentId)\n            if (!parentGroup) break // End of known chain\n\n            currentId = parentGroup.parentGroupId\n            depth++\n        }\n\n        return false\n    }\n\n    /**\n     * Sync store data to canvas nodes (READ PATH)\n     *\n     * =========================================================================\n     * GEOMETRY WRITE POLICY (TASK-240 Phase 2.5)\n     * =========================================================================\n     * Sync is a READ-ONLY projection from store → Vue Flow display.\n     *\n     * This function MUST NEVER write to:\n     *   - taskStore (task positions, parentId, any task data)\n     *   - canvasStore.groups (group positions, parentGroupId, any group data)\n     *\n     * ALLOWED writes:\n     *   - nodeVersionMap (optimistic locking metadata, not user data)\n     *   - Vue Flow nodes via setNodes() (display layer, not persistence)\n     *\n     * RATIONALE:\n     * Writing to stores from sync would create feedback loops:\n     *   Store changes → sync runs → sync writes to store → sync runs → ...\n     * This causes position drift and groups \"merging back together\".\n     *\n     * Only useCanvasInteractions.onNodeDragStop() may write geometry.\n     * =========================================================================\n     *\n     * READ PATH FLOW:\n     * 1. Read groups/tasks from store (absolute positions)\n     * 2. For each item, compute Vue Flow position:\n     *    - Root items: use absolute directly\n     *    - Nested items: convert absolute → relative using parent's absolute\n     * 3. Create Vue Flow nodes with correct position and parentNode\n     *\n     * BUG #3 FIX: Always use fresh store positions instead of preserving\n     * stale Vue Flow positions. This ensures cross-tab sync works correctly.\n     */\n    const syncStoreToCanvas = (tasks?: Task[]) => {\n        if (isSyncing.value) return\n        isSyncing.value = true\n\n        try {\n            const tasksToSync = tasks || taskStore.tasks.filter(t => t.canvasPosition)\n            const groups = canvasStore.groups || []\n            const currentNodes = getNodes.value\n\n            // BUG #3 FIX: Removed existingPositions preservation\n            // Previously we preserved existing Vue Flow positions to \"avoid visual jumps\",\n            // but this caused stale positions to win over fresh store data on cross-tab sync.\n            // Now we ALWAYS use the fresh position from the store (source of truth).\n\n            const newNodes: any[] = []\n\n            // ================================================================\n            // PROCESS GROUPS\n            // ================================================================\n            // CRITICAL: Sort groups so that parent groups are processed before children.\n            // Vue Flow needs parent nodes to exist before children reference them via parentNode.\n            // This ensures correct parent-child relationships on initial render after reload.\n\n            // === ASSERT: No duplicate group IDs before node creation (AUTHORITATIVE) ===\n            // Uses assertNoDuplicateIds for consistent detection across layers\n            if (import.meta.env.DEV) {\n                const groupCheck = assertNoDuplicateIds(groups, 'groups input to syncStoreToCanvas')\n                if (groupCheck.hasDuplicates) {\n                    console.error('[ASSERT-FAILED] Duplicate groupIds in groups before node creation', {\n                        duplicates: groupCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                        totalCount: groupCheck.totalCount,\n                        uniqueIdCount: groupCheck.uniqueIdCount\n                    })\n                }\n            }\n\n            const sortedGroups = sortGroupsByHierarchy(groups)\n\n            // Create a Set of visible group IDs for fast lookup\n            const visibleGroupIds = new Set(groups.map(g => g.id))\n\n            for (const group of sortedGroups) {\n                const nodeId = CanvasIds.groupNodeId(group.id)\n\n                // FULLY ABSOLUTE ARCHITECTURE:\n                // group.position in store is ABSOLUTE (world coordinates)\n                // Convert to Vue Flow position (relative for nested, absolute for root)\n                // BUG #3 FIX: Always use fresh vueFlowPos from store\n                const vueFlowPos = groupPositionToVueFlow(group, groups)\n                const displayPos = sanitizePosition(vueFlowPos, { x: 100, y: 100 })\n\n                // Determine parent node for Vue Flow\n                let parentId = group.parentGroupId && group.parentGroupId !== 'NONE'\n                    ? group.parentGroupId\n                    : null\n\n                // SAFETY: Cycle Detection\n                if (parentId && hasParentCycle(group.id, parentId, groups)) {\n                    console.error(`🔄 [CYCLE DETECTED] Creating group ${group.id} would create cycle with parent ${parentId}. Breaking link.`)\n                    parentId = null\n                }\n\n                // FIX: Only set parentNode if parent is VISIBLE (will be rendered in Vue Flow)\n                // If parent exists but is hidden, treat as root node to avoid \"Only child nodes can use a parent extent\" warning\n                if (parentId && !visibleGroupIds.has(parentId)) {\n                    console.warn(`[SYNC] Parent group ${parentId} is hidden, treating ${group.id} as root node`)\n                    parentId = null\n                }\n\n                // Get BOTH direct and aggregated task counts\n                // Direct = tasks where task.parentId === group.id (only this group)\n                // Aggregated = direct + all tasks in descendant groups\n                const directTaskCount = taskCountByGroupId.value.get(group.id) ?? 0\n                const aggregatedTaskCount = aggregatedTaskCountByGroupId.value.get(group.id) ?? directTaskCount\n\n                // Compute parentNode for hierarchy\n                const parentNodeId = parentId ? CanvasIds.groupNodeId(parentId) : undefined\n\n                // BUG-226 FIX: Apply depth-based zIndex bonus\n                // ensures child groups (higher depth) are always on top of parent groups\n                const depth = (group as any)._depth || 0\n                const zIndex = 11 + (depth * 10) // Base group Z is 10 (CANVAS.Z_INDEX_GROUP)\n\n                newNodes.push({\n                    id: nodeId,\n                    type: 'sectionNode',\n                    position: displayPos,\n                    parentNode: parentNodeId,\n                    zIndex, // Explicit zIndex bonus\n                    // FIX: Removed extent: 'parent' so groups can be dragged OUT of their parent.\n                    // With extent: 'parent', Vue Flow constrains movement to parent bounds,\n                    // preventing groups from being detached via drag. Without it, groups can be\n                    // freely dragged, and onNodeDragStop handles re-parenting via spatial containment.\n                    // (Same approach as tasks - see line ~284)\n                    expandParent: false,\n                    data: {\n                        id: group.id,\n                        label: group.name || 'Group',\n                        name: group.name || 'Group',\n                        color: group.color || '#3b82f6',\n                        width: group.position?.width || 300,\n                        height: group.position?.height || 200,\n                        collapsed: group.isCollapsed || false,\n                        // Pass BOTH counts - component decides which to show\n                        directTaskCount,\n                        aggregatedTaskCount,\n                        // Pass STORE's parentGroupId (not Vue Flow's parentId) so component\n                        // correctly determines if it's a root or child group for count logic\n                        parentGroupId: group.parentGroupId,\n                        // Legacy: keep taskCount for backwards compat (use aggregated)\n                        taskCount: aggregatedTaskCount\n                    },\n                    style: {\n                        width: `${group.position?.width || 300}px`,\n                        height: `${group.position?.height || 200}px`\n                    }\n                })\n            }\n\n            // ================================================================\n            // PROCESS TASKS\n            // ================================================================\n            // Initialize task position versions in nodeVersionMap for optimistic locking\n            // This ensures syncNodePosition has version info when saving positions\n\n            // Defensive: ensure nodeVersionMap.value is a valid Map\n            if (!nodeVersionMap.value || !(nodeVersionMap.value instanceof Map)) {\n                nodeVersionMap.value = new Map()\n            }\n            const versionMap = nodeVersionMap.value\n\n            for (const task of tasksToSync) {\n                if (!task.canvasPosition) continue\n\n                // Initialize version if not already tracked\n                if (!versionMap.has(task.id)) {\n                    versionMap.set(task.id, task.positionVersion ?? 0)\n                }\n\n                const nodeId = task.id\n\n                // FULLY ABSOLUTE ARCHITECTURE:\n                // task.canvasPosition in store is ABSOLUTE (world coordinates)\n                // Convert to Vue Flow position (relative for nested, absolute for root)\n                // BUG #3 FIX: Always use fresh vueFlowPos from store\n                const vueFlowPos = taskPositionToVueFlow(task, groups)\n                if (!vueFlowPos) continue\n\n                const displayPos = sanitizePosition(vueFlowPos, { x: 200, y: 200 })\n\n                // Determine parent node for Vue Flow\n                // DRIFT LOGGING: Track original parentId before any modifications\n                const originalParentId = task.parentId\n                let parentId = task.parentId && task.parentId !== 'NONE'\n                    ? task.parentId\n                    : null\n\n                // SAFETY: Cycle Detection\n                if (parentId && hasParentCycle(task.id, parentId, groups)) {\n                    console.error(`🔄 [CYCLE DETECTED] Creating task ${task.id} would create cycle with parent ${parentId}. Breaking link.`)\n                    parentId = null\n                }\n\n                // FIX: Only set parentNode if parent group is VISIBLE (will be rendered in Vue Flow)\n                // If parent group is hidden, treat task as root node\n                const parentWasVisible = parentId ? visibleGroupIds.has(parentId) : true\n                if (parentId && !visibleGroupIds.has(parentId)) {\n                    console.warn(`⚠️ [SYNC-PARENT-CLEARED] Task ${task.id.slice(0, 8)}... (${task.title?.slice(0, 20)}) parent ${parentId?.slice(0, 8)} is NOT visible - treating as root`, {\n                        originalParentId,\n                        visibleGroupCount: visibleGroupIds.size,\n                        visibleGroupIds: Array.from(visibleGroupIds).map(id => id.slice(0, 8))\n                    })\n                    parentId = null\n                }\n\n                newNodes.push({\n                    id: nodeId,\n                    type: 'taskNode',\n                    position: displayPos,\n                    parentNode: parentId ? CanvasIds.groupNodeId(parentId) : undefined,\n                    // FIX: Removed extent: 'parent' so tasks can be dragged OUT of groups.\n                    // With extent: 'parent', Vue Flow constrains movement to parent bounds,\n                    // preventing tasks from being dragged outside. Without it, tasks can be\n                    // freely dragged, and onNodeDragStop handles re-parenting via spatial containment.\n                    expandParent: false,\n                    data: {\n                        task,\n                        label: task.title\n                    }\n                })\n            }\n\n            // ================================================================\n            // IDEMPOTENCE CHECK\n            // ================================================================\n            // Prevent recursive updates if generated nodes match existing nodes\n            // We compare essential properties: id, position, parentNode, data (height/width)\n            const isDifferent = (a: any[], b: any[]) => {\n                if (a.length !== b.length) return true\n                // Create a map for faster lookup\n                const bMap = new Map(b.map((n: any) => [n.id, n]))\n\n                for (const nodeA of a) {\n                    const nodeB = bMap.get(nodeA.id)\n                    if (!nodeB) return true\n\n                    // Check Position\n                    if (Math.abs(nodeA.position.x - nodeB.position.x) > 0.1 ||\n                        Math.abs(nodeA.position.y - nodeB.position.y) > 0.1) return true\n\n                    // Check Parent\n                    if (nodeA.parentNode !== nodeB.parentNode) return true\n\n                    // Check Dimensions (for groups)\n                    if (nodeA.data?.width !== nodeB.data?.width ||\n                        nodeA.data?.height !== nodeB.data?.height) return true\n\n                    // TASK-DATA REACTION: Check critical task properties\n                    // If these change, we MUST update the node even if position is same\n                    if (nodeA.type === 'taskNode' && nodeB.type === 'taskNode') {\n                        const taskA = nodeA.data?.task\n                        const taskB = nodeB.data?.task\n\n                        if (taskA && taskB) {\n                            if (taskA.status !== taskB.status) return true\n                            if (taskA.priority !== taskB.priority) return true\n                            if (taskA.dueDate !== taskB.dueDate) return true\n                            if (taskA.title !== taskB.title) return true\n                        }\n                    }\n\n                    // GROUP-DATA REACTION: Check group labels/colors\n                    if (nodeA.type === 'sectionNode' && nodeB.type === 'sectionNode') {\n                        if (nodeA.data?.label !== nodeB.data?.label ||\n                            nodeA.data?.color !== nodeB.data?.color ||\n                            nodeA.data?.collapsed !== nodeB.data?.collapsed) return true\n                    }\n                }\n\n                return false\n            }\n\n            if (isDifferent(newNodes, currentNodes)) {\n                // DRIFT LOGGING: Track when nodes change parent status\n                const taskNodesOld = currentNodes.filter(n => n.type === 'taskNode')\n                const taskNodesNew = newNodes.filter((n: any) => n.type === 'taskNode')\n\n                for (const newNode of taskNodesNew) {\n                    const oldNode = taskNodesOld.find((o: any) => o.id === newNode.id)\n                    if (oldNode && oldNode.parentNode !== newNode.parentNode) {\n                        console.warn(`🔀 [SYNC-PARENT-CHANGE] Task ${newNode.id.slice(0, 8)}... parentNode: \"${oldNode.parentNode ?? 'root'}\" → \"${newNode.parentNode ?? 'root'}\"`, {\n                            taskTitle: newNode.data?.label?.slice(0, 20),\n                            oldPosition: oldNode.position,\n                            newPosition: newNode.position\n                        })\n                    }\n                }\n\n                // ================================================================\n                // DUPLICATE DETECTION - Node Builder Layer (AUTHORITATIVE)\n                // ================================================================\n                // Uses assertNoDuplicateIds for consistent detection across layers\n                // This is the final checkpoint before nodes are rendered\n                if (import.meta.env.DEV) {\n                    // 1. Check tasksToSync for duplicates (upstream issue)\n                    const taskSyncCheck = assertNoDuplicateIds(tasksToSync, 'tasksToSync')\n                    if (taskSyncCheck.hasDuplicates) {\n                        console.error('[ASSERT-FAILED] Duplicate taskIds in tasksToSync before node creation', {\n                            duplicates: taskSyncCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                            totalCount: taskSyncCheck.totalCount,\n                            uniqueIdCount: taskSyncCheck.uniqueIdCount\n                        })\n                    }\n\n                    // 2. Check task nodes for duplicates\n                    const taskNodes = newNodes.filter((n: any) => n.type === 'taskNode')\n                    const taskNodeObjects = taskNodes.map((n: any) => ({\n                        id: n.data?.task?.id || n.id\n                    }))\n                    const taskNodeCheck = assertNoDuplicateIds(taskNodeObjects, 'taskNodes')\n\n                    if (taskNodeCheck.hasDuplicates) {\n                        console.error('[DUPLICATE-NODES]', {\n                            duplicates: taskNodeCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                            totalTaskNodes: taskNodeCheck.totalCount,\n                            uniqueTaskIds: taskNodeCheck.uniqueIdCount,\n                            source: 'syncStoreToCanvas'\n                        })\n                    }\n\n                    console.debug('[NODE-BUILDER]', {\n                        totalNodes: newNodes.length,\n                        taskNodes: taskNodeCheck.totalCount,\n                        uniqueTaskIds: taskNodeCheck.uniqueIdCount,\n                        hasDuplicates: taskNodeCheck.hasDuplicates\n                    })\n\n                    // 3. Check group nodes for duplicates\n                    const groupNodes = newNodes.filter((n: any) => n.type === 'sectionNode')\n                    const groupNodeObjects = groupNodes.map((n: any) => ({\n                        id: n.data?.id || n.id\n                    }))\n                    const groupNodeCheck = assertNoDuplicateIds(groupNodeObjects, 'groupNodes')\n\n                    if (groupNodeCheck.hasDuplicates) {\n                        console.error('[DUPLICATE-GROUP-NODES]', {\n                            duplicates: groupNodeCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                            totalGroupNodes: groupNodeCheck.totalCount,\n                            uniqueGroupIds: groupNodeCheck.uniqueIdCount,\n                            source: 'syncStoreToCanvas'\n                        })\n                    }\n\n                    console.debug('[GROUP-NODE-BUILDER]', {\n                        totalNodes: newNodes.length,\n                        groupNodes: groupNodeCheck.totalCount,\n                        uniqueGroupIds: groupNodeCheck.uniqueIdCount\n                    })\n\n                    // ================================================================\n                    // GEOMETRY DRIFT DETECTION - Compare store positions vs node positions\n                    // ================================================================\n                    // This catches drift at the moment nodes are about to be rendered.\n                    // For root nodes (no parent), store position should equal node position.\n                    // Any mismatch indicates position drift from an unexpected source.\n                    const DRIFT_EPSILON = 0.5\n\n                    // Check task nodes for drift\n                    for (const taskNode of taskNodes) {\n                        const task = taskNode.data?.task\n                        if (!task?.canvasPosition) continue\n\n                        const storeAbsolute = task.canvasPosition\n                        const nodePosition = taskNode.position\n                        const hasParent = task.parentId && task.parentId !== 'NONE'\n\n                        // For root tasks, store position should match node position directly\n                        if (!hasParent) {\n                            const dx = Math.abs((storeAbsolute.x ?? 0) - (nodePosition?.x ?? 0))\n                            const dy = Math.abs((storeAbsolute.y ?? 0) - (nodePosition?.y ?? 0))\n                            if (dx > DRIFT_EPSILON || dy > DRIFT_EPSILON) {\n                                console.warn('[GEOMETRY-DRIFT]', {\n                                    type: 'task',\n                                    id: task.id?.slice(0, 8),\n                                    title: task.title?.slice(0, 20),\n                                    parentId: task.parentId,\n                                    storePosition: { x: storeAbsolute.x, y: storeAbsolute.y },\n                                    nodePosition: { x: nodePosition?.x, y: nodePosition?.y },\n                                    delta: { x: dx.toFixed(1), y: dy.toFixed(1) }\n                                })\n                            }\n                        }\n                    }\n\n                    // Check group nodes for drift\n                    for (const groupNode of groupNodes) {\n                        const group = groupNode.data?.group || canvasStore._rawGroups?.find((g: any) => g.id === groupNode.data?.id)\n                        if (!group?.position) continue\n\n                        const storeAbsolute = group.position\n                        const nodePosition = groupNode.position\n                        const hasParent = group.parentGroupId && group.parentGroupId !== 'NONE'\n\n                        // For root groups, store position should match node position directly\n                        if (!hasParent) {\n                            const dx = Math.abs((storeAbsolute.x ?? 0) - (nodePosition?.x ?? 0))\n                            const dy = Math.abs((storeAbsolute.y ?? 0) - (nodePosition?.y ?? 0))\n                            if (dx > DRIFT_EPSILON || dy > DRIFT_EPSILON) {\n                                console.warn('[GEOMETRY-DRIFT]', {\n                                    type: 'group',\n                                    id: group.id?.slice(0, 8),\n                                    name: group.name?.slice(0, 20),\n                                    parentGroupId: group.parentGroupId,\n                                    storePosition: { x: storeAbsolute.x, y: storeAbsolute.y },\n                                    nodePosition: { x: nodePosition?.x, y: nodePosition?.y },\n                                    delta: { x: dx.toFixed(1), y: dy.toFixed(1) }\n                                })\n                            }\n                        }\n                    }\n                }\n\n                setNodes(newNodes)\n\n                // ================================================================\n                // INVARIANT VALIDATION (Dev Only)\n                // ================================================================\n                // Run invariant checks after sync to catch any violations early\n                // This helps identify bugs before they cause visual issues\n                if (import.meta.env.DEV) {\n                    // Use nextTick to ensure Vue Flow has processed the nodes\n                    nextTick(() => {\n                        const vueFlowNodes = getNodes.value\n                        const storeGroups = canvasStore._rawGroups || []\n                        const storeTasks = taskStore.tasks || []\n\n                        validateAllInvariants(\n                            vueFlowNodes,\n                            storeGroups,\n                            storeTasks,\n                            'syncStoreToCanvas'\n                        )\n\n                        // ================================================================\n                        // CHILD→ROOT INVARIANT CHECK\n                        // ================================================================\n                        // Verify: If a group has no parentGroupId in store,\n                        // its Vue Flow node must NOT have parentNode set.\n                        // This catches bugs where detach logic fails to clear parentNode.\n                        const nodeMap = new Map(vueFlowNodes.map(n => [n.id, n]))\n                        for (const group of storeGroups) {\n                            const nodeId = CanvasIds.groupNodeId(group.id)\n                            const node = nodeMap.get(nodeId)\n                            const hasStoreParent = group.parentGroupId && group.parentGroupId !== 'NONE'\n\n                            if (!hasStoreParent && node?.parentNode) {\n                                console.error('[INVARIANT A-child-root] Group has no parentGroupId but node.parentNode is set', {\n                                    groupId: group.id,\n                                    groupName: group.name,\n                                    storeParentGroupId: group.parentGroupId,\n                                    nodeParentNode: node.parentNode,\n                                })\n                            }\n                        }\n                    })\n                }\n            }\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    /**\n     * Initialize realtime subscription for store changes\n     * Note: Watchers are handled by useCanvasOrchestrator to avoid duplicate triggers\n     */\n    const initRealtimeSubscription = () => {\n        // No-op: Orchestrator handles watching to avoid infinite loops\n        // The orchestrator calls syncStoreToCanvas directly when stores change\n    }\n\n    return {\n        syncStoreToCanvas,\n        initRealtimeSubscription,\n        isSyncing\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasTaskActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CANVAS' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[766,769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[766,769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":72,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2819,2822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2819,2822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref, nextTick } from 'vue'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useCanvasModalsStore } from '@/stores/canvas/modals'\nimport { markGroupDeleted, confirmGroupDeleted } from '@/utils/deletedGroupsTracker'\nimport { storeToRefs } from 'pinia'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\nimport { CANVAS } from '@/constants/canvas'\n\nexport interface TaskActionsDeps {\n    syncNodes: (tasks?: Task[]) => void\n    batchSyncNodes?: (priority?: 'high' | 'normal' | 'low') => void\n    closeCanvasContextMenu: () => void\n    screenToFlowCoordinate: (position: { x: number; y: number }) => { x: number; y: number }\n    recentlyDeletedGroups?: Ref<Set<string>>\n    undoHistory: any\n}\n\nexport function useCanvasTaskActions(deps: TaskActionsDeps) {\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const modalsStore = useCanvasModalsStore()\n    const { undoHistory } = deps\n\n    const {\n        isBulkDeleteModalOpen,\n        bulkDeleteItems,\n        bulkDeleteIsPermanent,\n        isQuickTaskCreateOpen,\n        quickTaskPosition\n    } = storeToRefs(modalsStore)\n\n    const removeGhostNodeRef = (id: string) => {\n        if (canvasStore.nodes) {\n            const nodeId = CanvasIds.groupNodeId(id)\n            canvasStore.nodes = canvasStore.nodes.filter(n => n.id !== nodeId)\n        }\n    }\n\n    const createTaskHere = (screenPos?: { x: number; y: number }) => {\n        try {\n            const vueFlowElement = document.querySelector('.vue-flow')\n            if (!vueFlowElement) {\n                quickTaskPosition.value = { x: 0, y: 0 }\n                deps.closeCanvasContextMenu()\n                isQuickTaskCreateOpen.value = true\n                return\n            }\n\n            let finalPos = screenPos\n            if (!finalPos) {\n                const rect = vueFlowElement.getBoundingClientRect()\n                finalPos = {\n                    x: rect.left + rect.width / 2,\n                    y: rect.top + rect.height / 2\n                }\n            }\n\n            const flowCoords = deps.screenToFlowCoordinate(finalPos)\n            if (!Number.isFinite(flowCoords.x) || !Number.isFinite(flowCoords.y)) {\n                quickTaskPosition.value = { x: 200, y: 200 }\n                deps.closeCanvasContextMenu()\n                isQuickTaskCreateOpen.value = true\n                return\n            }\n\n            quickTaskPosition.value = flowCoords\n            deps.closeCanvasContextMenu()\n            isQuickTaskCreateOpen.value = true\n\n        } catch (error) {\n            quickTaskPosition.value = { x: 0, y: 0 }\n            deps.closeCanvasContextMenu()\n            isQuickTaskCreateOpen.value = true\n        }\n    }\n\n    const createTaskInGroup = (groupOrId: string | any) => {\n        const groupId = typeof groupOrId === 'string' ? groupOrId : groupOrId.id\n        const group = canvasStore._rawGroups.find(g => g.id === groupId)\n\n        if (!group) return\n\n        // Position is relative to the group since we set parentId\n        const groupWidth = group.position?.width || 300\n        const groupHeight = group.position?.height || 200\n\n        const groupCenter = {\n            x: (groupWidth / 2) - 110, // Center - half task width approx\n            y: (groupHeight / 2) - 50, // Center - half task height approx\n            parentId: group.id\n        }\n\n        quickTaskPosition.value = groupCenter\n        deps.closeCanvasContextMenu()\n        isQuickTaskCreateOpen.value = true\n    }\n\n    /**\n     * GEOMETRY WRITER: Creates task with initial canvas position (TASK-255)\n     * This is an ALLOWED geometry write as it's an explicit user action (creating a task).\n     */\n    const handleQuickTaskCreate = async (title: string, description: string) => {\n        try {\n            if (!title?.trim()) return\n\n            const isDefaultPosition = quickTaskPosition.value.x === 0 && quickTaskPosition.value.y === 0\n            const shouldCreateInInbox = isDefaultPosition\n\n            const { x, y, parentId } = quickTaskPosition.value\n\n            await taskStore.createTaskWithUndo({\n                title,\n                description,\n                canvasPosition: shouldCreateInInbox ? undefined : { x, y },\n                parentId: shouldCreateInInbox ? undefined : parentId,\n                status: 'planned',\n                isInInbox: shouldCreateInInbox\n            })\n\n            if (deps.batchSyncNodes) {\n                deps.batchSyncNodes('high')\n            } else {\n                deps.syncNodes()\n            }\n\n            isQuickTaskCreateOpen.value = false\n            quickTaskPosition.value = { x: 0, y: 0 }\n\n        } catch (error) {\n            console.error('Failed to create task', error)\n        }\n    }\n\n    const closeQuickTaskCreate = () => {\n        isQuickTaskCreateOpen.value = false\n        quickTaskPosition.value = { x: 0, y: 0 }\n    }\n\n    /**\n     * GEOMETRY WRITER: Removes tasks from canvas by clearing canvasPosition (TASK-255)\n     * This is an ALLOWED geometry write as it's an explicit user action (move to inbox).\n     */\n    const moveSelectedTasksToInbox = async () => {\n        const selectedNodeIds = canvasStore.selectedNodeIds.filter(id => !CanvasIds.isGroupNode(id))\n        if (selectedNodeIds.length === 0) return\n\n        try {\n            for (const nodeId of selectedNodeIds) {\n                await undoHistory.updateTaskWithUndo(nodeId, {\n                    isInInbox: true,\n                    canvasPosition: undefined\n                })\n            }\n            canvasStore.setSelectedNodes([])\n            if (deps.batchSyncNodes) deps.batchSyncNodes('high')\n            deps.closeCanvasContextMenu()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] moveSelectedTasksToInbox failed', error)\n        }\n    }\n\n    const deleteSelectedTasks = async () => {\n        const selectedNodeIds = canvasStore.selectedNodeIds.filter(id => !CanvasIds.isGroupNode(id))\n        if (selectedNodeIds.length === 0) return\n\n        if (!confirm('Delete selected tasks permanently?')) return\n\n        try {\n            for (const nodeId of selectedNodeIds) {\n                await undoHistory.deleteTaskWithUndo(nodeId)\n            }\n\n            canvasStore.setSelectedNodes([])\n            if (deps.batchSyncNodes) deps.batchSyncNodes('high')\n            deps.closeCanvasContextMenu()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] deleteSelectedTasks failed', error)\n        }\n    }\n\n    const confirmBulkDelete = async () => {\n        const items = bulkDeleteItems.value\n        const isPermanent = bulkDeleteIsPermanent.value\n\n        try {\n            for (const item of items) {\n                if (item.type === 'section') {\n                    markGroupDeleted(item.id)\n                    if (deps.recentlyDeletedGroups) deps.recentlyDeletedGroups.value.add(item.id)\n\n                    if (!canvasStore.sections.some(s => s.id === item.id)) {\n                        removeGhostNodeRef(item.id)\n                        confirmGroupDeleted(item.id)\n                        deps.recentlyDeletedGroups?.value.delete(item.id)\n                    } else {\n                        await canvasStore.deleteSection(item.id)\n                        confirmGroupDeleted(item.id)\n                        deps.recentlyDeletedGroups?.value.delete(item.id)\n                    }\n                } else if (isPermanent) {\n                    await taskStore.permanentlyDeleteTask(item.id)\n                } else {\n                    await undoHistory.updateTaskWithUndo(item.id, {\n                        canvasPosition: undefined,\n                        isInInbox: true,\n                        instances: [],\n                        scheduledDate: undefined,\n                        scheduledTime: undefined\n                    })\n                }\n            }\n\n            canvasStore.setSelectedNodes([])\n            bulkDeleteItems.value = []\n            isBulkDeleteModalOpen.value = false\n            await nextTick()\n            deps.syncNodes()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] confirmBulkDelete failed', error)\n        }\n    }\n\n    const cancelBulkDelete = () => {\n        bulkDeleteItems.value = []\n        isBulkDeleteModalOpen.value = false\n    }\n\n    return {\n        isQuickTaskCreateOpen,\n        quickTaskPosition,\n        isBulkDeleteModalOpen,\n        bulkDeleteItems,\n        bulkDeleteIsPermanent,\n        createTaskHere,\n        createTaskInGroup,\n        handleQuickTaskCreate,\n        closeQuickTaskCreate,\n        moveSelectedTasksToInbox,\n        deleteSelectedTasks,\n        confirmBulkDelete,\n        cancelBulkDelete\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasZoom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useMidnightTaskMover.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useNodeSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4480,4483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4480,4483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6199,6202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6199,6202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7004,7007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7004,7007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7095,7098],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7095,7098],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11891,11894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11891,11894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, type Ref } from 'vue'\nimport { supabase } from '@/services/auth/supabase'\nimport type { Node } from '@vue-flow/core'\nimport type { CanvasGroup } from '@/stores/canvas/types'\nimport {\n    getGroupAbsolutePosition,\n    toAbsolutePosition,\n    sanitizePosition\n} from '@/utils/canvas/coordinates'\n\n/**\n * Composable for managing node sync with optimistic locking\n *\n * ============================================================================\n * WRITE PATH: Vue Flow → DB\n * ============================================================================\n *\n * This composable handles the WRITE PATH of the Fully Absolute Architecture:\n * - Takes Vue Flow node positions (relative for nested nodes)\n * - Converts to absolute world coordinates\n * - Saves to DB with optimistic locking for conflict detection\n *\n * KEY PRINCIPLE:\n * - Vue Flow stores RELATIVE positions for nested nodes\n * - DB must store ABSOLUTE world coordinates for ALL nodes\n * - Conversion happens HERE using computedPosition or manual calculation\n *\n * NOTE: nodeVersionMap is passed as Ref<Map> from Pinia store via storeToRefs.\n * We access .value to get the underlying Map.\n */\nexport function useNodeSync(\n    nodeVersionMapRef: Ref<Map<string, number>>\n) {\n    const isSyncing = ref(false)\n    const syncError = ref<string | null>(null)\n\n    /**\n     * Sync a single node position with conflict detection\n     *\n     * WRITE PATH FLOW:\n     * 1. Get Vue Flow node position (relative if nested)\n     * 2. Convert to absolute world coordinates\n     * 3. Save to DB with optimistic lock\n     *\n     * @param nodeId The node/group ID (not Vue Flow node ID)\n     * @param vueFlowNode The Vue Flow node with current position\n     * @param allGroups All groups for parent lookup\n     * @param tableName 'tasks' or 'groups'\n     */\n    async function syncNodePosition(\n        nodeId: string,\n        vueFlowNode: Node,\n        allGroups: CanvasGroup[],\n        tableName: 'tasks' | 'groups'\n    ): Promise<boolean> {\n        // Defensive initialization: ensure nodeVersionMapRef.value is always a Map\n        // This handles cases where the ref might not be properly initialized yet\n        // (e.g., during HMR, store re-initialization, or timing issues)\n        if (!nodeVersionMapRef?.value || !(nodeVersionMapRef.value instanceof Map)) {\n            // Auto-fix: reinitialize as an empty Map instead of bailing out\n            if (nodeVersionMapRef) {\n                nodeVersionMapRef.value = new Map<string, number>()\n            } else {\n                // Truly exceptional case: ref itself is missing\n                console.error('[NODE-SYNC] nodeVersionMapRef is null/undefined - cannot sync')\n                return false\n            }\n        }\n\n        // CRITICAL: Capture the Map reference in a local variable\n        // This ensures we use the same Map instance throughout the async function,\n        // even if nodeVersionMapRef.value gets reassigned during await calls\n        const versionMap = nodeVersionMapRef.value as Map<string, number>\n\n        // Validate nodeId is provided\n        if (!nodeId) {\n            console.error('[NODE-SYNC] nodeId is required for sync')\n            return false\n        }\n\n        if (isSyncing.value) return false\n\n        isSyncing.value = true\n        syncError.value = null\n\n        try {\n            // ================================================================\n            // 1. EXTRACT PARENT ID FROM VUE FLOW NODE\n            // ================================================================\n            // Vue Flow stores parentNode as \"section-{groupId}\" format\n            const rawParentId = vueFlowNode.parentNode\n            const currentParentId = rawParentId\n                ? (rawParentId.startsWith('section-')\n                    ? rawParentId.replace('section-', '')\n                    : rawParentId)\n                : null\n\n            // ================================================================\n            // 2. CALCULATE ABSOLUTE POSITION\n            // ================================================================\n            // FULLY ABSOLUTE ARCHITECTURE: Always save absolute coordinates\n            //\n            // Priority order:\n            // 1. computedPosition (Vue Flow already computed world position)\n            // 2. Manual conversion using parent's absolute position\n            let absolutePosition: { x: number; y: number }\n\n            const vfNode = vueFlowNode as any\n            if (vfNode.computedPosition) {\n                // Vue Flow provides computed world position - use directly\n                absolutePosition = {\n                    x: vfNode.computedPosition.x,\n                    y: vfNode.computedPosition.y\n                }\n            } else {\n                // Fallback: manually convert relative → absolute\n                const relativePos = sanitizePosition(vueFlowNode.position)\n\n                if (currentParentId && currentParentId !== 'NONE') {\n                    const parentAbsolute = getGroupAbsolutePosition(currentParentId, allGroups)\n                    absolutePosition = toAbsolutePosition(relativePos, parentAbsolute)\n                } else {\n                    // Root node - position is already absolute\n                    absolutePosition = relativePos\n                }\n            }\n\n            // ================================================================\n            // 3. GET CURRENT VERSION FOR OPTIMISTIC LOCK\n            // ================================================================\n            // Use local versionMap (captured above) for all Map operations\n            const currentVersion = versionMap.get(nodeId) ?? 0\n\n            // ================================================================\n            // 4. PREPARE DB PAYLOAD\n            // ================================================================\n            // FULLY ABSOLUTE: All nodes save absolute coordinates\n            // No special case for nested groups - consistent architecture\n            const positionToSave = absolutePosition\n\n            // Build update payload based on table type\n            const updatePayload: Record<string, any> = {\n                position_version: currentVersion + 1,\n                updated_at: new Date().toISOString()\n            }\n\n            if (tableName === 'tasks') {\n                // Tasks: position is JSONB with x, y, parentId, format\n                updatePayload.position = {\n                    x: positionToSave.x,\n                    y: positionToSave.y,\n                    parentId: currentParentId === 'NONE' ? null : currentParentId,\n                    format: 'absolute'\n                }\n            } else {\n                // Groups: position_json is JSONB with x, y, width, height\n                updatePayload.position_json = {\n                    x: positionToSave.x,\n                    y: positionToSave.y,\n                    width: vueFlowNode.data?.width || (vueFlowNode as any).width || 300,\n                    height: vueFlowNode.data?.height || (vueFlowNode as any).height || 200\n                }\n                // Also update parent_group_id column for groups\n                updatePayload.parent_group_id = currentParentId === 'NONE' ? null : currentParentId\n            }\n\n            // ================================================================\n            // 5. EXECUTE OPTIMISTIC LOCK UPDATE\n            // ================================================================\n            const { data, error } = await supabase\n                .from(tableName)\n                .update(updatePayload)\n                .eq('id', nodeId)\n                .eq('position_version', currentVersion) // ← The Key: Optimistic Lock\n                .select('position_version')\n\n            if (error) {\n                throw error;\n            }\n\n            // Fix 406: Manually check array instead of using maybeSingle()\n            // PostgREST can return 406 if maybeSingle finds 0 rows with return=representation\n            if (!data || data.length === 0) {\n                // ================================================================\n                // BUG #2 FIX: RETRY ONCE ON CONFLICT\n                // ================================================================\n                // Update failed - version mismatch (someone else updated)\n                // Instead of just returning false and losing the user's changes,\n                // we fetch the latest version and retry ONCE.\n                console.warn(`⚠️ [NODE-SYNC] Conflict detected for ${tableName} ${nodeId}, retrying with fresh version...`)\n\n                // Fetch latest version to recover\n                const { data: latest, error: fetchError } = await supabase\n                    .from(tableName)\n                    .select('position_version')\n                    .eq('id', nodeId)\n                    .single()\n\n                if (fetchError || !latest) {\n                    syncError.value = `Sync Conflict: Could not fetch latest version for ${tableName} ${nodeId}`\n                    return false\n                }\n\n                const newVersion = latest.position_version\n                // Use local versionMap for all Map operations\n                versionMap.set(nodeId, newVersion)\n\n                // Retry the update with the new version\n                updatePayload.position_version = newVersion + 1\n\n                const { data: retryData, error: retryError } = await supabase\n                    .from(tableName)\n                    .update(updatePayload)\n                    .eq('id', nodeId)\n                    .eq('position_version', newVersion)\n                    .select('position_version')\n\n                if (retryError) {\n                    throw retryError\n                }\n\n                if (!retryData || retryData.length === 0) {\n                    // ================================================================\n                    // RETRY FAILED - LOG ONLY, NO STORE MUTATION\n                    // ================================================================\n                    // CRITICAL CONTRACT: On retry failure, we ONLY log the error.\n                    // We do NOT:\n                    //   - Fire syncTrigger to cause another sync attempt\n                    //   - Modify task.canvasPosition or task.parentId\n                    //   - Modify group.position or group.parentGroupId\n                    //   - Call any store mutation methods\n                    //\n                    // This prevents feedback loops where failed syncs cascade into\n                    // more sync attempts that also fail.\n                    // ================================================================\n                    const expectedPayload = tableName === 'tasks'\n                        ? updatePayload.position\n                        : updatePayload.position_json\n                    console.error(`❌ [NODE-SYNC] Retry failed for ${tableName} ${nodeId}`, {\n                        expectedPosition: expectedPayload,\n                        lastKnownVersion: newVersion,\n                        advice: 'Position may be stale until next user drag. No automatic retry.'\n                    })\n                    syncError.value = `Sync Conflict: Retry failed for ${tableName} ${nodeId}. Position may be stale.`\n                    return false\n                }\n\n                // Retry succeeded - use local versionMap\n                console.log(`✅ [NODE-SYNC] Retry succeeded for ${tableName} ${nodeId}`)\n                versionMap.set(nodeId, retryData[0].position_version)\n                return true\n            }\n\n            // Success: update local version tracker using versionMap\n            versionMap.set(nodeId, data[0].position_version)\n            return true\n\n        } catch (err: any) {\n            console.error('Optimistic Sync Failed:', err)\n            syncError.value = err.message || 'Sync failed'\n            return false\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    return {\n        isSyncing: computed(() => isSyncing.value),\n        syncError: computed(() => syncError.value),\n        syncNodePosition\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/inbox/useCalendarInboxState.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":113,"column":65,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":113,"endColumn":88}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useCanvasGroupMembership } from '@/composables/canvas/useCanvasGroupMembership'\nimport { type DurationCategory, matchesDurationCategory } from '@/utils/durationCategories'\n\nexport function useCalendarInboxState() {\n    const taskStore = useTaskStore()\n    const { groupsWithCounts, filterTasksByGroup } = useCanvasGroupMembership()\n\n    // --- State ---\n    const isCollapsed = ref(false)\n    const showTodayOnly = ref(false)\n\n    // Advanced Filters\n    const showAdvancedFilters = ref(false)\n    const unscheduledOnly = ref(false)\n    const selectedPriority = ref<'high' | 'medium' | 'low' | null>(null)\n    const selectedProject = ref<string | null>(null)\n    const selectedDuration = ref<DurationCategory | null>(null)\n    const selectedCanvasGroups = ref<Set<string>>(new Set())\n\n    // --- Computed ---\n\n    // TASK-076: Get calendar-specific hide done filter from store\n    const hideCalendarDoneTasks = computed(() => taskStore.hideCalendarDoneTasks)\n\n    // Canvas group options for dropdown\n    const canvasGroupOptions = computed(() => {\n        const options = [\n            { label: 'All Tasks', value: '' }\n        ]\n\n        groupsWithCounts.value.forEach(group => {\n            options.push({\n                label: `${group.name} (${group.taskCount})`,\n                value: group.id\n            })\n        })\n\n        return options\n    })\n\n    // Helper: Get today's date string\n    const getTodayStr = () => new Date().toISOString().split('T')[0]\n\n    // Helper: Check if task is scheduled\n    const isScheduledOnCalendar = (task: Task): boolean => {\n        if (!task.instances || task.instances.length === 0) return false\n        return task.instances.some(inst => inst.scheduledDate)\n    }\n\n    // Base Inbox Tasks (Respects store filters + calendar specific logic)\n    const baseInboxTasks = computed(() => {\n        return taskStore.filteredTasks.filter(task => {\n            if (hideCalendarDoneTasks.value && task.status === 'done') return false\n            return !isScheduledOnCalendar(task)\n        })\n    })\n\n    // Count tasks due today\n    const todayCount = computed(() => {\n        const todayStr = getTodayStr()\n        return baseInboxTasks.value.filter(task => task.dueDate === todayStr).length\n    })\n\n    // Active filters check\n    const hasActiveFilters = computed(() => {\n        return showTodayOnly.value ||\n            unscheduledOnly.value ||\n            selectedPriority.value !== null ||\n            selectedProject.value !== null ||\n            selectedDuration.value !== null ||\n            (selectedCanvasGroups.value.size > 0)\n    })\n\n    // Final Filtered Inbox Tasks\n    const inboxTasks = computed(() => {\n        let tasks = baseInboxTasks.value\n\n        // 1. Canvas Group Filter (Primary)\n        if (selectedCanvasGroups.value.size > 0) {\n            const groupIds = Array.from(selectedCanvasGroups.value)\n            tasks = tasks.filter(task =>\n                groupIds.some(groupId => filterTasksByGroup([task], groupId).length > 0)\n            )\n        }\n\n        // 2. Today Filter\n        if (showTodayOnly.value) {\n            const todayStr = getTodayStr()\n            tasks = tasks.filter(task => task.dueDate === todayStr)\n        }\n\n        // 3. Advanced Filters\n        if (unscheduledOnly.value) {\n            tasks = tasks.filter(task => !isScheduledOnCalendar(task))\n        }\n\n        if (selectedPriority.value !== null) {\n            tasks = tasks.filter(task => task.priority === selectedPriority.value)\n        }\n\n        if (selectedProject.value !== null) {\n            if (selectedProject.value === 'none') {\n                tasks = tasks.filter(task => !task.projectId)\n            } else {\n                tasks = tasks.filter(task => task.projectId === selectedProject.value)\n            }\n        }\n\n        if (selectedDuration.value !== null) {\n            tasks = tasks.filter(task =>\n                matchesDurationCategory(task.estimatedDuration, selectedDuration.value!)\n            )\n        }\n\n        return tasks\n    })\n\n    // --- Actions ---\n\n    const toggleHideDoneTasks = () => {\n        taskStore.toggleCalendarDoneTasks()\n    }\n\n    const clearAllFilters = () => {\n        unscheduledOnly.value = false\n        selectedPriority.value = null\n        selectedProject.value = null\n        selectedDuration.value = null\n        selectedCanvasGroups.value = new Set()\n    }\n\n    return {\n        // State\n        isCollapsed,\n        showTodayOnly,\n        showAdvancedFilters,\n        unscheduledOnly,\n        selectedPriority,\n        selectedProject,\n        selectedDuration,\n        selectedCanvasGroups,\n\n        // Computed\n        hideCalendarDoneTasks,\n        canvasGroupOptions,\n        baseInboxTasks,\n        inboxTasks,\n        todayCount,\n        hasActiveFilters,\n\n        // Methods\n        toggleHideDoneTasks,\n        clearAllFilters\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/inbox/useUnifiedInboxActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/inbox/useUnifiedInboxState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onMounted' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":34},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":144,"column":65,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":144,"endColumn":88}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, onMounted, watch } from 'vue'\nimport type { Task } from '@/types/tasks'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useSmartViews } from '@/composables/useSmartViews'\nimport { useCanvasGroupMembership } from '@/composables/canvas/useCanvasGroupMembership'\n// TASK-144: Use centralized duration categories\nimport { type DurationCategory, matchesDurationCategory } from '@/utils/durationCategories'\n\nexport interface InboxContextProps {\n    context: 'calendar' | 'canvas' | 'standalone'\n    hideDoneTasks?: boolean\n}\n\nexport function useUnifiedInboxState(props: InboxContextProps) {\n    const taskStore = useTaskStore()\n    const { isTodayTask } = useSmartViews()\n    const { groupsWithCounts, filterTasksByGroup } = useCanvasGroupMembership()\n\n    // --- Core Filter State ---\n    const isCollapsed = ref(false)\n    const activeTimeFilter = ref<'all' | 'today'>('all')\n\n    // --- Advanced Filter State ---\n    const showAdvancedFilters = ref(false)\n    const unscheduledOnly = ref(false)\n    const selectedPriority = ref<'high' | 'medium' | 'low' | null>(null)\n    const selectedProject = ref<string | null>(null)\n    const selectedDuration = ref<DurationCategory | null>(null)\n\n    // TASK-106: Canvas group filter (primary filter)\n    const selectedCanvasGroups = ref<Set<string>>(new Set())\n\n    // --- Local Done Filter ---\n    // Default to hiding done tasks in Calendar context\n    const hideInboxDoneTasks = ref(props.context === 'calendar')\n    const currentHideDoneTasks = computed(() => hideInboxDoneTasks.value)\n    const toggleHideDoneTasks = () => {\n        hideInboxDoneTasks.value = !hideInboxDoneTasks.value\n    }\n\n    interface GroupOption {\n        label: string\n        value: string\n        color?: string\n        count?: number\n    }\n\n    // --- Canvas Group Options ---\n    const canvasGroupOptions = computed((): GroupOption[] => {\n        const options: GroupOption[] = [\n            { label: 'All', value: '', color: undefined }\n        ]\n\n        groupsWithCounts.value.forEach(group => {\n            options.push({\n                label: group.name,\n                value: group.id,\n                color: group.color || '#4ecdc4',\n                count: group.taskCount\n            })\n        })\n\n        return options\n    })\n\n    // --- Filter Logic ---\n\n    // Base Inbox Tasks (Filtered by global rules + context rules)\n    const baseInboxTasks = computed(() => {\n        return taskStore.filteredTasks.filter(task => {\n            // 1. Hide Done tasks (Local View Filter)\n            if (currentHideDoneTasks.value && task.status === 'done') {\n                return false\n            }\n\n            // 2. Soft Deleted check (Safety)\n            if (task._soft_deleted) {\n                return false\n            }\n\n            // 3. Context Specific Rules\n            if (props.context === 'calendar') {\n                // CALENDAR INBOX: Show tasks NOT on the calendar grid\n                const hasInstances = task.instances && task.instances.length > 0\n                const hasLegacySchedule = (task.scheduledDate && task.scheduledDate.trim() !== '') &&\n                    (task.scheduledTime && task.scheduledTime.trim() !== '')\n                return !hasInstances && !hasLegacySchedule\n            } else {\n                // CANVAS INBOX: Show tasks NOT on the canvas\n                // (Dec 16, 2025 FIX: ONLY check canvasPosition)\n                return !task.canvasPosition\n            }\n        })\n    })\n\n    const todayCount = computed(() => {\n        return baseInboxTasks.value.filter(task => isTodayTask(task)).length\n    })\n\n    const isScheduledOnCalendar = (task: Task): boolean => {\n        if (!task.instances || task.instances.length === 0) return false\n        return task.instances.some(inst => inst.scheduledDate)\n    }\n\n    // Final Inbox Tasks (Apply all local filters)\n    const inboxTasks = computed(() => {\n        let tasks = baseInboxTasks.value\n\n        // 1. Canvas Group Filter (Multi-select)\n        if (selectedCanvasGroups.value.size > 0) {\n            const groupIds = Array.from(selectedCanvasGroups.value)\n            tasks = tasks.filter(task =>\n                groupIds.some(groupId => filterTasksByGroup([task], groupId).length > 0)\n            )\n        }\n\n        // 2. Today Filter\n        if (activeTimeFilter.value === 'today') {\n            tasks = tasks.filter(task => isTodayTask(task))\n        }\n\n        // 3. Unscheduled Filter\n        if (unscheduledOnly.value) {\n            tasks = tasks.filter(task => !isScheduledOnCalendar(task))\n        }\n\n        // 4. Priority Filter\n        if (selectedPriority.value !== null) {\n            tasks = tasks.filter(task => task.priority === selectedPriority.value)\n        }\n\n        // 5. Project Filter\n        if (selectedProject.value !== null) {\n            if (selectedProject.value === 'none') {\n                tasks = tasks.filter(task => !task.projectId)\n            } else {\n                tasks = tasks.filter(task => task.projectId === selectedProject.value)\n            }\n        }\n\n        // 6. Duration Filter\n        if (selectedDuration.value !== null) {\n            tasks = tasks.filter(task =>\n                matchesDurationCategory(task.estimatedDuration, selectedDuration.value!)\n            )\n        }\n\n        return tasks\n    })\n\n    const clearAllFilters = () => {\n        unscheduledOnly.value = false\n        selectedPriority.value = null\n        selectedProject.value = null\n        selectedDuration.value = null\n        activeTimeFilter.value = 'all'\n        selectedCanvasGroups.value = new Set()\n    }\n\n    // FEATURE-254: Canvas inbox starts minimized always unless it has tasks inside\n    // Reactive behavior: auto-collapse when empty, auto-expand when tasks appear (on start)\n    watch(() => inboxTasks.value.length, (count) => {\n        if (props.context === 'canvas') {\n            if (count === 0) {\n                isCollapsed.value = true\n            } else {\n                isCollapsed.value = false\n            }\n        }\n    }, { immediate: true })\n\n    return {\n        // State\n        isCollapsed,\n        activeTimeFilter,\n        showAdvancedFilters,\n        unscheduledOnly,\n        selectedPriority,\n        selectedProject,\n        selectedDuration,\n        selectedCanvasGroups,\n        currentHideDoneTasks,\n\n        // Computed (State)\n        canvasGroupOptions,\n        baseInboxTasks,\n        inboxTasks,\n        todayCount,\n\n        // Actions (State Mutators)\n        toggleHideDoneTasks,\n        clearAllFilters\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/suggestions/useDayGroupSuggestions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DAY_OF_WEEK_KEYWORDS' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getDayName' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentDate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":248,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":248,"endColumn":24}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Day-Group Suggestions\n *\n * Detects when a day-based canvas group (e.g., \"Friday\") matches today's date\n * and creates a suggestion to move tasks to the \"Today\" group.\n *\n * This is a user-triggered approach that respects TASK-255 geometry invariants:\n * - User clicks \"Move Tasks\" to initiate the move\n * - Tasks are moved via proper drag-handler code path\n * - No automatic geometry changes\n *\n * @see TASK-266 in MASTER_PLAN.md\n */\n\nimport { ref, computed, watch, onMounted, onUnmounted } from 'vue'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useSmartSuggestionsSingleton } from './useSmartSuggestions'\nimport { detectPowerKeyword, DAY_OF_WEEK_KEYWORDS, SMART_GROUPS } from '@/composables/usePowerKeywords'\nimport { useDateTransition } from '@/composables/useDateTransition'\nimport type { DayGroupTransitionSuggestion, DayGroupTransitionMetadata } from '@/types/suggestions'\nimport type { CanvasGroup } from '@/stores/canvas/types'\nimport type { Task } from '@/types/tasks'\n\n/**\n * Get the current day of week index (0=Sunday, 6=Saturday)\n */\nconst getTodayDayIndex = (): number => {\n  return new Date().getDay()\n}\n\n/**\n * Get the day name from index\n */\nconst getDayName = (dayIndex: number): string => {\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n  return days[dayIndex] || 'Unknown'\n}\n\n/**\n * Check if a group is a day-of-week group and matches today\n */\nconst isDayGroupMatchingToday = (group: CanvasGroup): { matches: boolean; dayName: string } => {\n  const powerKeyword = group.powerKeyword || detectPowerKeyword(group.name)\n\n  if (!powerKeyword || powerKeyword.category !== 'day_of_week') {\n    return { matches: false, dayName: '' }\n  }\n\n  const groupDayIndex = parseInt(powerKeyword.value, 10)\n  const todayIndex = getTodayDayIndex()\n\n  return {\n    matches: groupDayIndex === todayIndex,\n    dayName: powerKeyword.displayName\n  }\n}\n\n/**\n * Find the \"Today\" group on the canvas\n */\nconst findTodayGroup = (groups: CanvasGroup[]): CanvasGroup | null => {\n  return groups.find(group => {\n    const powerKeyword = group.powerKeyword || detectPowerKeyword(group.name)\n    return powerKeyword?.category === 'date' && powerKeyword.value === SMART_GROUPS.TODAY\n  }) || null\n}\n\n/**\n * Get tasks that belong to a specific group\n * Uses spatial containment to determine membership\n */\nconst getTasksInGroup = (\n  groupId: string,\n  tasks: Task[],\n  groups: CanvasGroup[]\n): Task[] => {\n  const group = groups.find(g => g.id === groupId)\n  if (!group) return []\n\n  return tasks.filter(task => {\n    // Check if task is spatially within the group\n    if (!task.canvasPosition) return false\n\n    const pos = task.canvasPosition\n    return (\n      pos.x >= group.position.x &&\n      pos.x <= group.position.x + group.position.width &&\n      pos.y >= group.position.y &&\n      pos.y <= group.position.y + group.position.height\n    )\n  })\n}\n\n/**\n * Day-group suggestions composable.\n * Detects day-based groups matching today and creates move suggestions.\n */\nexport function useDayGroupSuggestions() {\n  const canvasStore = useCanvasStore()\n  const taskStore = useTaskStore()\n  const suggestionSystem = useSmartSuggestionsSingleton()\n\n  // Track if we've already shown suggestions for today\n  const checkedToday = ref(false)\n  const lastCheckedDate = ref<string>('')\n\n  /**\n   * Generate a unique suggestion ID for a day-group transition\n   */\n  const generateSuggestionId = (sourceGroupId: string, date: string): string => {\n    return `day-group-transition-${sourceGroupId}-${date}`\n  }\n\n  /**\n   * Move tasks from source group to target group.\n   * This uses the task store's update method with 'DRAG' source\n   * to respect geometry invariants.\n   */\n  const moveTasksToGroup = async (\n    taskIds: string[],\n    targetGroup: CanvasGroup\n  ): Promise<void> => {\n    // Calculate positions within the target group\n    const startX = targetGroup.position.x + 20\n    const startY = targetGroup.position.y + 60 // Below header\n    const spacing = 80\n\n    for (let i = 0; i < taskIds.length; i++) {\n      const taskId = taskIds[i]\n\n      // Update task position to be inside target group\n      // Use 'DRAG' source to respect geometry invariants\n      await taskStore.updateTask(\n        taskId,\n        {\n          canvasPosition: {\n            x: startX,\n            y: startY + (i * spacing)\n          },\n          parentId: targetGroup.id\n        },\n        'DRAG' // Critical: Use DRAG source for geometry changes\n      )\n    }\n  }\n\n  /**\n   * Check for day-group matches and create suggestions\n   */\n  const checkForDayGroupMatches = () => {\n    // Don't check if feature is disabled\n    if (!suggestionSystem.isDayGroupSuggestionsEnabled.value) {\n      return\n    }\n\n    // Get current date string for deduplication\n    const today = new Date()\n    const dateKey = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`\n\n    // Don't check multiple times for the same day\n    if (lastCheckedDate.value === dateKey && checkedToday.value) {\n      return\n    }\n\n    lastCheckedDate.value = dateKey\n\n    const groups = canvasStore.groups\n    const tasks = taskStore.filteredTasks\n\n    // Find the Today group (target for moves)\n    const todayGroup = findTodayGroup(groups)\n\n    // Check each group for day-of-week match\n    for (const group of groups) {\n      const { matches, dayName } = isDayGroupMatchingToday(group)\n\n      if (!matches) continue\n\n      // Get tasks in this day group\n      const tasksInGroup = getTasksInGroup(group.id, tasks, groups)\n\n      if (tasksInGroup.length === 0) continue\n\n      // Create suggestion\n      const suggestionId = generateSuggestionId(group.id, dateKey)\n\n      const metadata: DayGroupTransitionMetadata = {\n        sourceGroupId: group.id,\n        sourceGroupName: group.name,\n        targetGroupId: todayGroup?.id,\n        targetGroupName: todayGroup?.name || 'Today',\n        taskIds: tasksInGroup.map(t => t.id),\n        taskCount: tasksInGroup.length,\n        dayName\n      }\n\n      const suggestion: DayGroupTransitionSuggestion = {\n        id: suggestionId,\n        type: 'day_group_transition',\n        title: `${dayName} is today!`,\n        description: `You have ${tasksInGroup.length} task${tasksInGroup.length === 1 ? '' : 's'} in your ${group.name} group. Move them to Today?`,\n        source: 'rule',\n        confidence: 1.0,\n        priority: 100, // High priority\n        createdAt: new Date(),\n        dismissed: false,\n        metadata,\n        actions: [\n          {\n            id: 'move',\n            label: 'Move Tasks',\n            icon: 'ArrowRight',\n            primary: true,\n            handler: async () => {\n              if (todayGroup) {\n                await moveTasksToGroup(metadata.taskIds, todayGroup)\n              } else {\n                // If no Today group exists, just update the due date\n                for (const taskId of metadata.taskIds) {\n                  const todayDate = new Date().toISOString().split('T')[0]\n                  await taskStore.updateTask(taskId, { dueDate: todayDate }, 'SMART-GROUP')\n                }\n              }\n            }\n          },\n          {\n            id: 'dismiss',\n            label: 'Not Now',\n            icon: 'X',\n            handler: () => {\n              suggestionSystem.dismissSuggestion(suggestionId)\n            }\n          }\n        ]\n      }\n\n      suggestionSystem.addSuggestion(suggestion)\n    }\n\n    checkedToday.value = true\n  }\n\n  /**\n   * Set up date transition watcher to re-check at midnight\n   */\n  const setupDateTransitionWatcher = () => {\n    const { currentDate } = useDateTransition({\n      onDayChange: () => {\n        // Reset check flag and re-check\n        checkedToday.value = false\n        checkForDayGroupMatches()\n      }\n    })\n\n    // Also watch for visibility changes (user returns to app)\n    if (typeof document !== 'undefined') {\n      const handleVisibility = () => {\n        if (document.visibilityState === 'visible') {\n          checkForDayGroupMatches()\n        }\n      }\n\n      onMounted(() => {\n        document.addEventListener('visibilitychange', handleVisibility)\n      })\n\n      onUnmounted(() => {\n        document.removeEventListener('visibilitychange', handleVisibility)\n      })\n    }\n  }\n\n  /**\n   * Initialize the day-group suggestion system\n   */\n  const initialize = () => {\n    setupDateTransitionWatcher()\n\n    // Initial check after a short delay (wait for stores to load)\n    setTimeout(() => {\n      checkForDayGroupMatches()\n    }, 1000)\n  }\n\n  return {\n    checkForDayGroupMatches,\n    initialize\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/suggestions/useSmartSuggestions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SuggestionState' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SuggestionSettings' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DEFAULT_SUGGESTION_SETTINGS' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":30}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Smart Suggestions Core System\n *\n * AI-Ready infrastructure for intelligent suggestions.\n * Manages suggestion state, dismissal, and settings.\n *\n * @see TASK-266 in MASTER_PLAN.md\n */\n\nimport { ref, computed, watch } from 'vue'\nimport { useSettingsStore } from '@/stores/settings'\nimport type {\n  SmartSuggestion,\n  SuggestionState,\n  SuggestionSettings,\n  DEFAULT_SUGGESTION_SETTINGS\n} from '@/types/suggestions'\n\n// Session storage key for dismissed suggestions\nconst DISMISSED_KEY = 'flow-state-dismissed-suggestions'\n\n/**\n * Core suggestion system composable.\n * Manages all active suggestions and provides methods to add, dismiss, and act on them.\n */\nexport function useSmartSuggestions() {\n  const settingsStore = useSettingsStore()\n\n  // State\n  const suggestions = ref<SmartSuggestion[]>([])\n  const sessionDismissed = ref<Set<string>>(new Set())\n  const initialized = ref(false)\n\n  // Load dismissed suggestions from session storage\n  const loadDismissed = () => {\n    try {\n      const stored = sessionStorage.getItem(DISMISSED_KEY)\n      if (stored) {\n        const parsed = JSON.parse(stored) as string[]\n        sessionDismissed.value = new Set(parsed)\n      }\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  // Save dismissed suggestions to session storage\n  const saveDismissed = () => {\n    try {\n      const arr = Array.from(sessionDismissed.value)\n      sessionStorage.setItem(DISMISSED_KEY, JSON.stringify(arr))\n    } catch {\n      // Ignore storage errors\n    }\n  }\n\n  // Computed: Active (non-dismissed) suggestions sorted by priority\n  const activeSuggestions = computed(() => {\n    return suggestions.value\n      .filter(s => !s.dismissed && !sessionDismissed.value.has(s.id))\n      .sort((a, b) => b.priority - a.priority)\n  })\n\n  // Computed: The highest priority suggestion to show\n  const currentSuggestion = computed(() => {\n    return activeSuggestions.value[0] || null\n  })\n\n  // Computed: Whether there are any active suggestions\n  const hasSuggestions = computed(() => activeSuggestions.value.length > 0)\n\n  /**\n   * Add a new suggestion to the system.\n   * Deduplicates by ID.\n   */\n  const addSuggestion = (suggestion: SmartSuggestion) => {\n    // Check if already exists\n    const existing = suggestions.value.find(s => s.id === suggestion.id)\n    if (existing) {\n      // Update existing suggestion\n      Object.assign(existing, suggestion)\n    } else {\n      suggestions.value.push(suggestion)\n    }\n  }\n\n  /**\n   * Remove a suggestion by ID.\n   */\n  const removeSuggestion = (suggestionId: string) => {\n    const index = suggestions.value.findIndex(s => s.id === suggestionId)\n    if (index !== -1) {\n      suggestions.value.splice(index, 1)\n    }\n  }\n\n  /**\n   * Dismiss a suggestion for this session.\n   * The suggestion won't be shown again until the session ends.\n   */\n  const dismissSuggestion = (suggestionId: string) => {\n    sessionDismissed.value.add(suggestionId)\n    saveDismissed()\n\n    // Mark as dismissed in the suggestion itself\n    const suggestion = suggestions.value.find(s => s.id === suggestionId)\n    if (suggestion) {\n      suggestion.dismissed = true\n    }\n  }\n\n  /**\n   * Execute an action from a suggestion.\n   * Handles errors and removes the suggestion on success.\n   */\n  const executeAction = async (suggestionId: string, actionId: string) => {\n    const suggestion = suggestions.value.find(s => s.id === suggestionId)\n    if (!suggestion) return\n\n    const action = suggestion.actions.find(a => a.id === actionId)\n    if (!action) return\n\n    try {\n      await action.handler()\n      // Remove suggestion after successful action\n      removeSuggestion(suggestionId)\n    } catch (error) {\n      console.error('[SmartSuggestions] Action failed:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Clear all suggestions.\n   */\n  const clearSuggestions = () => {\n    suggestions.value = []\n  }\n\n  /**\n   * Clear session dismissed list.\n   */\n  const clearDismissed = () => {\n    sessionDismissed.value.clear()\n    saveDismissed()\n  }\n\n  /**\n   * Initialize the suggestion system.\n   */\n  const initialize = () => {\n    if (initialized.value) return\n\n    loadDismissed()\n    initialized.value = true\n  }\n\n  /**\n   * Check if day-group suggestions are enabled.\n   */\n  const isDayGroupSuggestionsEnabled = computed(() => {\n    return settingsStore.enableDayGroupSuggestions\n  })\n\n  /**\n   * Disable day-group suggestions (user clicked \"don't show again\").\n   */\n  const disableDayGroupSuggestions = () => {\n    settingsStore.updateSetting('enableDayGroupSuggestions', false)\n  }\n\n  // Auto-initialize\n  initialize()\n\n  return {\n    // State\n    suggestions,\n    activeSuggestions,\n    currentSuggestion,\n    hasSuggestions,\n    initialized,\n\n    // Settings\n    isDayGroupSuggestionsEnabled,\n    disableDayGroupSuggestions,\n\n    // Actions\n    addSuggestion,\n    removeSuggestion,\n    dismissSuggestion,\n    executeAction,\n    clearSuggestions,\n    clearDismissed,\n    initialize\n  }\n}\n\n// Singleton instance for global state\nlet _instance: ReturnType<typeof useSmartSuggestions> | null = null\n\n/**\n * Get the singleton instance of the suggestion system.\n * Use this when you need to access suggestions from multiple components.\n */\nexport function useSmartSuggestionsSingleton() {\n  if (!_instance) {\n    _instance = useSmartSuggestions()\n  }\n  return _instance\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/sync/useBroadcastChannelSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[139,142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[139,142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[441,444],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[441,444],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1125,1128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1125,1128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1421,1424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1421,1424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onUnmounted } from 'vue'\n\ninterface BroadcastMessage {\n    type: string\n    senderId: string\n    timestamp: number\n    data: any\n}\n\nexport function useBroadcastChannelSync(channelName = 'flow-state-sync') {\n    const tabId = ref(`tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`)\n    const isConnected = ref(false)\n\n    let channel: BroadcastChannel | null = null\n    const messageHandlers = new Map<string, (data: any) => void>()\n\n    const connect = () => {\n        if (channel) return\n\n        channel = new BroadcastChannel(channelName)\n        channel.onmessage = (event: MessageEvent<BroadcastMessage>) => {\n            if (event.data.senderId === tabId.value) return // Ignore own messages\n\n            const handler = messageHandlers.get(event.data.type)\n            if (handler) {\n                handler(event.data.data)\n            }\n        }\n\n        isConnected.value = true\n    }\n\n    const disconnect = () => {\n        if (channel) {\n            channel.close()\n            channel = null\n        }\n        isConnected.value = false\n    }\n\n    const broadcast = (type: string, data: any) => {\n        if (!channel) return\n\n        const message: BroadcastMessage = {\n            type,\n            senderId: tabId.value,\n            timestamp: Date.now(),\n            data\n        }\n        channel.postMessage(message)\n    }\n\n    const onMessage = (type: string, handler: (data: any) => void) => {\n        messageHandlers.set(type, handler)\n    }\n\n    const offMessage = (type: string) => {\n        messageHandlers.delete(type)\n    }\n\n    onUnmounted(() => {\n        disconnect()\n    })\n\n    return {\n        tabId,\n        isConnected,\n        connect,\n        disconnect,\n        broadcast,\n        onMessage,\n        offMessage\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/sync/useSupabaseRealtimeSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[451,454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[451,454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onUnmounted } from 'vue'\nimport { supabase } from '@/services/auth/supabase'\nimport type { RealtimeChannel } from '@supabase/supabase-js'\n\ninterface RealtimeSyncDeps {\n    userId: string | undefined\n}\n\nexport function useSupabaseRealtimeSync(deps: RealtimeSyncDeps) {\n    const { userId } = deps\n\n    const isSubscribed = ref(false)\n    let channel: RealtimeChannel | null = null\n\n    const subscribe = (\n        onTaskChange: (payload: any) => void,\n        onTimerChange: (payload: any) => void\n    ) => {\n        if (!userId || channel) return\n\n        channel = supabase\n            .channel(`user-${userId}`)\n            .on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'tasks',\n                filter: `user_id=eq.${userId}`\n            }, onTaskChange)\n            .on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'timer_sessions',\n                filter: `user_id=eq.${userId}`\n            }, onTimerChange)\n            .subscribe()\n\n        isSubscribed.value = true\n    }\n\n    const unsubscribe = () => {\n        if (channel) {\n            supabase.removeChannel(channel)\n            channel = null\n        }\n        isSubscribed.value = false\n    }\n\n    onUnmounted(() => {\n        unsubscribe()\n    })\n\n    return {\n        isSubscribed,\n        subscribe,\n        unsubscribe\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/sync/useTimerLeaderElection.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[209,212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[209,212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2316,2319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2316,2319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\n\ninterface TimerLeaderState {\n    leaderId: string\n    lastHeartbeat: number\n    sessionState: unknown\n}\n\ninterface LeaderElectionDeps {\n    tabId: string\n    broadcastMessage: (msg: any) => void\n    onBecomeLeader?: () => void\n    onLoseLeadership?: () => void\n    onSessionUpdate?: (session: unknown) => void\n}\n\nexport function useTimerLeaderElection(deps: LeaderElectionDeps) {\n    const { tabId, broadcastMessage, onBecomeLeader, onLoseLeadership, onSessionUpdate } = deps\n\n    const leaderState = ref<TimerLeaderState | null>(null)\n    const isLeader = ref(false)\n\n    const HEARTBEAT_INTERVAL = 2000\n    const LEADER_TIMEOUT = 5000\n\n    let heartbeatTimer: ReturnType<typeof setInterval> | null = null\n\n    const isLeaderAlive = (): boolean => {\n        if (!leaderState.value) return false\n        return Date.now() - leaderState.value.lastHeartbeat < LEADER_TIMEOUT\n    }\n\n    const claimLeadership = (): boolean => {\n        if (leaderState.value && isLeaderAlive() && leaderState.value.leaderId !== tabId) {\n            return false\n        }\n\n        leaderState.value = {\n            leaderId: tabId,\n            lastHeartbeat: Date.now(),\n            sessionState: leaderState.value?.sessionState || null\n        }\n        isLeader.value = true\n\n        broadcastMessage({\n            action: 'claim_leadership',\n            leaderId: tabId,\n            sessionState: leaderState.value.sessionState,\n            timestamp: Date.now()\n        })\n\n        startHeartbeat()\n\n        if (onBecomeLeader) {\n            onBecomeLeader()\n        }\n\n        return true\n    }\n\n    const startHeartbeat = () => {\n        stopHeartbeat()\n        heartbeatTimer = setInterval(() => {\n            if (isLeader.value && leaderState.value) {\n                leaderState.value.lastHeartbeat = Date.now()\n                broadcastMessage({\n                    action: 'heartbeat',\n                    leaderId: tabId,\n                    sessionState: leaderState.value.sessionState,\n                    timestamp: Date.now()\n                })\n            }\n        }, HEARTBEAT_INTERVAL)\n    }\n\n    const stopHeartbeat = () => {\n        if (heartbeatTimer) {\n            clearInterval(heartbeatTimer)\n            heartbeatTimer = null\n        }\n    }\n\n    const handleLeaderMessage = (sync: any) => {\n        switch (sync.action) {\n            case 'claim_leadership':\n                if (sync.leaderId !== tabId) {\n                    if (isLeader.value) {\n                        isLeader.value = false\n                        stopHeartbeat()\n                        if (onLoseLeadership) {\n                            onLoseLeadership()\n                        }\n                    }\n\n                    leaderState.value = {\n                        leaderId: sync.leaderId,\n                        lastHeartbeat: sync.timestamp,\n                        sessionState: sync.sessionState\n                    }\n\n                    if (sync.sessionState && onSessionUpdate) {\n                        onSessionUpdate(sync.sessionState)\n                    }\n                }\n                break\n\n            case 'heartbeat':\n                if (leaderState.value && sync.leaderId === leaderState.value.leaderId) {\n                    leaderState.value.lastHeartbeat = sync.timestamp\n                    leaderState.value.sessionState = sync.sessionState\n\n                    if (!isLeader.value && sync.sessionState && onSessionUpdate) {\n                        onSessionUpdate(sync.sessionState)\n                    }\n                }\n                break\n\n            case 'session_update':\n                if (leaderState.value) {\n                    leaderState.value.sessionState = sync.sessionState\n                    leaderState.value.lastHeartbeat = sync.timestamp\n                }\n\n                if (!isLeader.value && onSessionUpdate) {\n                    onSessionUpdate(sync.sessionState)\n                }\n                break\n\n            case 'session_stop':\n                if (leaderState.value) {\n                    leaderState.value.sessionState = null\n                }\n\n                if (!isLeader.value && onSessionUpdate) {\n                    onSessionUpdate(null)\n                }\n                break\n        }\n    }\n\n    const cleanup = () => {\n        stopHeartbeat()\n        isLeader.value = false\n    }\n\n    return {\n        isLeader,\n        leaderState,\n        claimLeadership,\n        handleLeaderMessage,\n        cleanup\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/card/useTaskCardActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[239,242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[239,242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport { type Task } from '@/stores/tasks'\nimport { useTaskStore } from '@/stores/tasks'\n\nexport function useTaskCardActions(\n    props: { task: Task; disabled?: boolean },\n    emit: (event: string, ...args: any[]) => void,\n    state: {\n        isExpanded: Ref<boolean>\n        isFocused: Ref<boolean>\n        isPressed: Ref<boolean>\n        isSelected: Ref<boolean>\n        cardRef: Ref<HTMLElement | null>\n        progressiveDisclosureEnabled: Ref<boolean>\n    }\n) {\n    const taskStore = useTaskStore()\n\n    // --- Handlers ---\n\n    const handleCardClick = (event: MouseEvent) => {\n        if (props.disabled) return\n        event.preventDefault()\n\n        if (state.progressiveDisclosureEnabled.value) {\n            state.isExpanded.value = !state.isExpanded.value\n        } else {\n            handleSelectionClick(event)\n        }\n    }\n\n    const handleSelectionClick = (event: MouseEvent) => {\n        if (event.ctrlKey || event.metaKey) {\n            // Multi-select toggle\n            if (state.isSelected.value) {\n                taskStore.deselectTask(props.task.id)\n            } else {\n                taskStore.selectTask(props.task.id)\n            }\n        } else {\n            // Single select\n            taskStore.clearSelection()\n            emit('select', props.task.id)\n        }\n    }\n\n    const handleKeydown = (event: KeyboardEvent) => {\n        if (props.disabled) return\n\n        switch (event.key) {\n            case 'Enter':\n            case ' ': {\n                event.preventDefault()\n                state.isPressed.value = true\n\n                // Synthetic click for consistent behavior\n                const syntheticEvent = new MouseEvent('click', {\n                    bubbles: true,\n                    cancelable: true,\n                    view: window\n                })\n                handleCardClick(syntheticEvent)\n\n                setTimeout(() => {\n                    state.isPressed.value = false\n                }, 150)\n                break\n            }\n\n            case 'ArrowRight':\n            case 'ArrowDown': {\n                event.preventDefault()\n                // Try to focus the status button\n                const statusButton = state.cardRef.value?.querySelector('.status-icon-button') as HTMLElement\n                statusButton?.focus()\n                break\n            }\n\n            case 'e':\n            case 'E':\n                if (!event.ctrlKey && !event.metaKey) {\n                    event.preventDefault()\n                    emit('edit', props.task.id)\n                }\n                break\n\n            case 't':\n            case 'T':\n                if (!event.ctrlKey && !event.metaKey) {\n                    event.preventDefault()\n                    emit('startTimer', props.task.id)\n                }\n                break\n\n            case 'Delete':\n            case 'Backspace':\n                event.preventDefault()\n                emit('delete', props.task.id)\n                break\n        }\n    }\n\n    const handleFocus = (event: FocusEvent) => {\n        state.isFocused.value = true\n        emit('focus', event)\n    }\n\n    const handleBlur = (event: FocusEvent) => {\n        state.isFocused.value = false\n        emit('blur', event)\n    }\n\n    const handleRightClick = (event: MouseEvent) => {\n        emit('contextMenu', event, props.task)\n    }\n\n    // --- Status Logic ---\n\n    const cycleStatus = () => {\n        const statusCycle: Task['status'][] = ['planned', 'in_progress', 'done', 'backlog', 'on_hold']\n        const currentStatus = props.task.status || 'backlog'\n        const currentIndex = statusCycle.indexOf(currentStatus)\n        const nextStatus = statusCycle[(currentIndex + 1) % statusCycle.length]\n\n        emit('select', props.task.id)\n        taskStore.updateTask(props.task.id, { status: nextStatus })\n    }\n\n    return {\n        handleCardClick,\n        handleKeydown,\n        handleFocus,\n        handleBlur,\n        handleRightClick,\n        cycleStatus\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/card/useTaskCardState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/row/useTaskRowActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[288,291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[288,291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[512,515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[512,515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":166,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":166,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { useDragAndDrop, type DragData } from '@/composables/useDragAndDrop'\n\nexport function useTaskRowActions(\n    props: { task: Task; indentLevel: number; hasSubtasks: boolean; isExpanded: boolean },\n    emit: any,\n    state: {\n        isDragging: Ref<boolean>\n        isDropTarget: Ref<boolean>\n        isFocused: Ref<boolean>\n        isHovered: Ref<boolean>\n        showTouchFeedback?: Ref<boolean>\n        touchFeedbackStyle?: Ref<any>\n    }\n) {\n    const { startDrag, endDrag } = useDragAndDrop()\n\n    // --- Drag and Drop ---\n\n    const handleDragStart = (event: DragEvent) => {\n        if (!event.dataTransfer) return\n\n        state.isDragging.value = true\n\n        const dragData: DragData = {\n            type: 'task',\n            taskId: props.task.id,\n            title: props.task.title,\n            source: 'kanban' // Using kanban/list as generic source\n        }\n\n        startDrag(dragData)\n        event.dataTransfer.setData('application/json', JSON.stringify(dragData))\n        event.dataTransfer.effectAllowed = 'move'\n    }\n\n    const handleDragEnd = () => {\n        state.isDragging.value = false\n        state.isDropTarget.value = false\n        endDrag()\n    }\n\n    const handleDragOver = (event: DragEvent) => {\n        event.preventDefault()\n        state.isDropTarget.value = true\n        if (event.dataTransfer) {\n            event.dataTransfer.dropEffect = 'move'\n        }\n    }\n\n    const handleDragLeave = () => {\n        state.isDropTarget.value = false\n    }\n\n    const handleDrop = (event: DragEvent) => {\n        event.preventDefault()\n        state.isDropTarget.value = false\n\n        const dataString = event.dataTransfer?.getData('application/json')\n        if (!dataString) return\n\n        try {\n            const dragData = JSON.parse(dataString) as DragData\n            if (dragData.type === 'task' && dragData.taskId && dragData.taskId !== props.task.id) {\n                // Dropped task becomes a subtask of this task\n                emit('moveTask', dragData.taskId, props.task.projectId || null, props.task.id)\n            }\n        } catch (error) {\n            console.error('Failed to parse drag data:', error)\n        }\n    }\n\n    // --- User Interactions ---\n\n    const handleRowClick = () => {\n        emit('select', props.task.id)\n    }\n\n    const handleToggleComplete = () => {\n        emit('toggleComplete', props.task.id)\n    }\n\n    const toggleExpanded = () => {\n        if (props.hasSubtasks) {\n            emit('toggleExpand', props.task.id)\n        }\n    }\n\n    // --- Keyboard & Focus ---\n\n    const handleFocusIn = () => {\n        state.isFocused.value = true\n    }\n\n    const handleFocusOut = () => {\n        state.isFocused.value = false\n    }\n\n    const handleMouseEnter = () => {\n        state.isHovered.value = true\n    }\n\n    const handleMouseLeave = () => {\n        state.isHovered.value = false\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n        switch (event.key) {\n            case 'Enter':\n            case ' ':\n                event.preventDefault()\n                handleRowClick()\n                break\n            case 'ArrowRight':\n                if (props.hasSubtasks && !props.isExpanded) {\n                    event.preventDefault()\n                    toggleExpanded()\n                }\n                break\n            case 'ArrowLeft':\n                if (props.hasSubtasks && props.isExpanded) {\n                    event.preventDefault()\n                    toggleExpanded()\n                }\n                break\n            case 'd':\n                if (event.ctrlKey || event.metaKey) {\n                    event.preventDefault()\n                    emit('toggleComplete', props.task.id)\n                }\n                break\n            case 'e':\n                if (event.ctrlKey || event.metaKey) {\n                    event.preventDefault()\n                    emit('edit', props.task.id)\n                }\n                break\n        }\n    }\n\n    // --- Touch Support ---\n\n    const handleTouchStart = (event: TouchEvent) => {\n        // Only applied if checkMobile was true in state (logic handled there or by consumer)\n        // We'll leave the conditional check to the template or strict mobile mode\n        // but here we just provide the handler logic\n\n        // Simple feedback logic reuse if provided\n        if (state.showTouchFeedback && state.touchFeedbackStyle) {\n            const touch = event.touches[0]\n            const rect = (event.currentTarget as HTMLElement)?.getBoundingClientRect()\n            if (rect) {\n                state.touchFeedbackStyle.value = {\n                    left: `${touch.clientX - rect.left}px`,\n                    top: `${touch.clientY - rect.top}px`\n                }\n                state.showTouchFeedback.value = true\n            }\n        }\n    }\n\n    const handleTouchEnd = () => {\n        if (state.showTouchFeedback) {\n            setTimeout(() => {\n                state.showTouchFeedback!.value = false\n            }, 200)\n        }\n    }\n\n    // --- Action Wrapper Helpers ---\n\n    const updateTaskStatus = (taskId: string, status: string) => {\n        emit('updateTask', taskId, { status })\n    }\n\n    const cyclePriority = (taskId: string, currentPriority?: string | null) => {\n        const priorities = ['low', 'medium', 'high'] as const\n        const currentIndex = priorities.indexOf((currentPriority || 'medium') as typeof priorities[number])\n        const nextIndex = (currentIndex + 1) % priorities.length\n        emit('updateTask', taskId, { priority: priorities[nextIndex] })\n    }\n\n    return {\n        handleDragStart,\n        handleDragEnd,\n        handleDragOver,\n        handleDragLeave,\n        handleDrop,\n        handleRowClick,\n        handleToggleComplete,\n        toggleExpanded,\n        handleFocusIn,\n        handleFocusOut,\n        handleMouseEnter,\n        handleMouseLeave,\n        handleKeyDown,\n        handleTouchStart,\n        handleTouchEnd,\n        updateTaskStatus,\n        cyclePriority\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/row/useTaskRowState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskEditActions.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":127,"column":52,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":127,"endColumn":69}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[314,317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[314,317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[412,415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[412,415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6729,6732],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6729,6732],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7429,7432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7429,7432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8534,8537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8534,8537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport { type Task, type Subtask, useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\n\n\n// Helper for cleaning task instances (from existing code)\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst getTaskInstances = (task: Task): any[] => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (task as any).instances || []\n}\n\nexport function useTaskEditActions(\n    props: { task: Task | null },\n    emit: (event: 'close') => void,\n    editedTask: Ref<Task>,\n    isSaving: Ref<boolean>\n) {\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n\n\n    // --- Subtask Management ---\n\n    const addSubtask = () => {\n        const newSubtask: Subtask = {\n            id: Date.now().toString(),\n            parentTaskId: editedTask.value.id,\n            title: '',\n            description: '',\n            completedPomodoros: 0,\n            isCompleted: false,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        }\n        editedTask.value.subtasks.push(newSubtask)\n    }\n\n    const deleteSubtask = (subtaskId: string) => {\n        const index = editedTask.value.subtasks.findIndex(st => st.id === subtaskId)\n        if (index !== -1) {\n            editedTask.value.subtasks.splice(index, 1)\n        }\n    }\n\n    const updateSubtaskCompletion = (subtask: Subtask) => {\n        if (!props.task) return\n\n        // TASK-089 FIX: Lock position BEFORE any store updates\n        const canvasPosition = editedTask.value.canvasPosition ?? props.task?.canvasPosition\n        if (canvasPosition) {\n            // Optimistic sync removed\n        }\n\n        // Update subtask in store\n        taskStore.updateSubtaskWithUndo(editedTask.value.id, subtask.id, {\n            isCompleted: subtask.isCompleted,\n            updatedAt: new Date()\n        })\n\n        // Recalculate parent progress\n        const completedCount = editedTask.value.subtasks.filter(st => st.isCompleted).length\n        const totalSubtasks = editedTask.value.subtasks.length\n        const newProgress = totalSubtasks > 0 ? Math.round((completedCount / totalSubtasks) * 100) : 0\n\n        taskStore.updateTaskWithUndo(editedTask.value.id, {\n            progress: newProgress,\n            updatedAt: new Date()\n        })\n    }\n\n    const resetPomodoros = () => {\n        editedTask.value.completedPomodoros = 0\n        editedTask.value.subtasks.forEach(subtask => {\n            subtask.completedPomodoros = 0\n        })\n    }\n\n    // --- Core Scheduling & Parsing Logic ---\n\n    const handleScheduledDateChange = () => {\n        if (editedTask.value.scheduledDate && !editedTask.value.scheduledTime) {\n            editedTask.value.scheduledTime = '09:00'\n        }\n    }\n\n    // --- Canvas Interaction ---\n\n    const handleSectionChange = (sectionId: string | null) => {\n        if (!sectionId) {\n            // Move to Inbox\n            editedTask.value.isInInbox = true\n            editedTask.value.canvasPosition = undefined\n            return\n        }\n\n        const section = canvasStore.sections.find(s => s.id === sectionId)\n        if (!section) return\n\n        // Update position if not already in this section\n        const currentPos = editedTask.value.canvasPosition\n        const isCurrentlyInSection = currentPos &&\n            currentPos.x >= section.position.x &&\n            currentPos.x <= section.position.x + section.position.width &&\n            currentPos.y >= section.position.y &&\n            currentPos.y <= section.position.y + section.position.height\n\n        if (!isCurrentlyInSection) {\n            // Place in center of section with small offset\n            editedTask.value.canvasPosition = {\n                x: section.position.x + (section.position.width / 2) - 100,\n                y: section.position.y + (section.position.height / 2) - 40\n            }\n        }\n\n        editedTask.value.isInInbox = false\n\n        // Apply \"Assign on Drop\" settings\n        if (section.assignOnDrop) {\n            const settings = section.assignOnDrop\n            if (settings.priority) editedTask.value.priority = settings.priority\n            if (settings.status) editedTask.value.status = settings.status\n            if (settings.projectId) editedTask.value.projectId = settings.projectId\n\n            if (settings.dueDate) {\n                import('@/composables/useGroupSettings').then(({ resolveDueDate }) => {\n                    const dateStr = resolveDueDate(settings.dueDate!)\n                    if (dateStr) editedTask.value.dueDate = dateStr\n                })\n            }\n        }\n    }\n\n    // --- Main Save Action ---\n\n    const saveTask = () => {\n        // Guard: Prevent double-save\n        if (isSaving.value || !props.task) return\n        isSaving.value = true\n\n        try {\n            // Debug logging omitted for brevity in refactor, but logic preserved\n\n            const originalTask = taskStore.tasks.find(t => t.id === editedTask.value.id)\n            const originalInstances = originalTask ? getTaskInstances(originalTask) : []\n\n            const hadOriginalSchedule = originalInstances.length > 0 ||\n                (originalTask?.scheduledDate && originalTask?.scheduledTime) ||\n                (originalTask?.instances && originalTask.instances.length > 0)\n            const hasNewSchedule = editedTask.value.scheduledDate && editedTask.value.scheduledTime\n            const scheduleExplicitlyRemoved = hadOriginalSchedule && !hasNewSchedule\n\n            const originalCanvasPosition = editedTask.value.canvasPosition ?? props.task?.canvasPosition\n            const originalIsInInbox = editedTask.value.isInInbox ?? props.task?.isInInbox\n\n            const updates: Record<string, unknown> = {\n                title: editedTask.value.title,\n                description: editedTask.value.description,\n                status: editedTask.value.status,\n                priority: editedTask.value.priority,\n                dueDate: editedTask.value.dueDate,\n                scheduledDate: editedTask.value.scheduledDate,\n                scheduledTime: editedTask.value.scheduledTime,\n                estimatedDuration: editedTask.value.estimatedDuration\n            }\n\n            if (originalCanvasPosition !== undefined) {\n                updates.canvasPosition = originalCanvasPosition\n                updates.isInInbox = false\n            } else if (originalIsInInbox !== undefined) {\n                updates.isInInbox = originalIsInInbox\n            }\n\n            // Preserve existing instances\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (editedTask.value.instances && (editedTask.value.instances as unknown as any[]).length > 0) {\n                updates.instances = editedTask.value.instances\n            }\n\n            // Lock position before update\n            if (originalCanvasPosition) {\n                // Optimistic sync removed\n            }\n\n            // Update main task\n            taskStore.updateTaskWithUndo(editedTask.value.id, updates)\n\n            // Handle instances\n            if (editedTask.value.scheduledDate && editedTask.value.scheduledTime) {\n                const existingInstances = props.task ? getTaskInstances(props.task) : []\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const sameDayInstance = existingInstances.find((inst: any) =>\n                    inst.scheduledDate === editedTask.value.scheduledDate\n                )\n\n                if (sameDayInstance) {\n                    taskStore.updateTaskInstanceWithUndo(editedTask.value.id, sameDayInstance.id, {\n                        scheduledTime: editedTask.value.scheduledTime,\n                        duration: editedTask.value.estimatedDuration || 60\n                    })\n                } else {\n                    taskStore.createTaskInstanceWithUndo(editedTask.value.id, {\n                        scheduledDate: editedTask.value.scheduledDate,\n                        scheduledTime: editedTask.value.scheduledTime,\n                        duration: editedTask.value.estimatedDuration || 60\n                    })\n                }\n            } else if (scheduleExplicitlyRemoved) {\n                const existingInstances = props.task ? getTaskInstances(props.task) : []\n                if (existingInstances.length > 0) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    existingInstances.forEach((instance: any) => {\n                        taskStore.deleteTaskInstanceWithUndo(editedTask.value.id, instance.id)\n                    })\n\n                    // Check if should return to inbox\n                    const currentTask = taskStore.tasks.find(t => t.id === editedTask.value.id)\n                    if (currentTask) {\n                        const hasRemainingInstances = getTaskInstances(currentTask).length > 0\n                        if (!hasRemainingInstances && currentTask.isInInbox === false) {\n                            taskStore.updateTask(currentTask.id, {\n                                instances: [],\n                                isInInbox: true\n                            })\n                        }\n                    }\n                }\n            }\n\n            // Sync Subtasks\n            const originalSubtasks = props.task.subtasks || []\n\n            originalSubtasks.forEach(originalSt => {\n                const exists = editedTask.value.subtasks.find(st => st.id === originalSt.id)\n                if (!exists) {\n                    taskStore.deleteSubtaskWithUndo(editedTask.value.id, originalSt.id)\n                }\n            })\n\n            editedTask.value.subtasks.forEach(subtask => {\n                if (originalSubtasks.find(st => st.id === subtask.id)) {\n                    taskStore.updateSubtaskWithUndo(editedTask.value.id, subtask.id, subtask)\n                } else {\n                    taskStore.createSubtaskWithUndo(editedTask.value.id, subtask)\n                }\n            })\n\n            emit('close')\n        } finally {\n            isSaving.value = false\n        }\n    }\n\n    return {\n        addSubtask,\n        deleteSubtask,\n        updateSubtaskCompletion,\n        resetPomodoros,\n        handleScheduledDateChange,\n        handleSectionChange,\n        saveTask\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskEditState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskFiltering.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":158,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":158,"endColumn":42,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6313,6314],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":295,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12153,12156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12153,12156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, type Ref } from 'vue'\nimport type { Task, Project } from '@/types/tasks'\nimport { useSmartViews } from '@/composables/useSmartViews'\nimport { formatDateKey } from '@/utils/dateUtils'\n\n\nexport type SmartView = 'today' | 'week' | 'uncategorized' | 'unscheduled' | 'in_progress' | 'all_active' | null\n\nexport const useTaskFiltering = (\n    tasks: Ref<Task[]>,\n    projects: Ref<Project[]>,\n    activeProjectId: Ref<string | null>,\n    activeSmartView: Ref<SmartView>,\n    activeStatusFilter: Ref<string | null>,\n    activeDurationFilter: Ref<string | null>,\n    hideDoneTasks: Ref<boolean>,\n    hideCalendarDoneTasks?: Ref<boolean>,\n    selectedProjectIds?: Ref<Set<string>> // TASK-084: Multi-select support\n) => {\n    const {\n        applySmartViewFilter,\n        isUncategorizedTask,\n        isQuickTask,\n        isShortTask,\n        isMediumTask,\n        isLongTask,\n        isUnestimatedTask,\n        isTodayTask,\n        isWeekTask,\n        isUnscheduledTask,\n        isInProgressTask\n    } = useSmartViews()\n\n\n    // Helper to recursively collect nested tasks - Optimized to O(N) using Map\n    const collectNestedTasks = (taskIds: string[], allTasks: Task[]): string[] => {\n        const allNestedIds: string[] = []\n        const visited = new Set<string>(taskIds) // Pre-fill with starting IDs to prevent duplicates\n\n        // 1. Build Parent-Child Map (O(N))\n        const parentMap = new Map<string, string[]>()\n        allTasks.forEach(task => {\n            if (task.parentTaskId && !task._soft_deleted) {\n                if (!parentMap.has(task.parentTaskId)) {\n                    parentMap.set(task.parentTaskId, [])\n                }\n                parentMap.get(task.parentTaskId)?.push(task.id)\n            }\n        })\n\n        // 2. Traverse (O(N) in worst case of full tree)\n        const traverse = (parentId: string) => {\n            const children = parentMap.get(parentId)\n            if (children) {\n                children.forEach(childId => {\n                    if (!visited.has(childId)) {\n                        visited.add(childId)\n                        allNestedIds.push(childId)\n                        traverse(childId)\n                    }\n                })\n            }\n        }\n\n        taskIds.forEach(parentId => traverse(parentId))\n        return allNestedIds\n    }\n\n    // Recursive project ID helper with cycle detection\n    const getChildProjectIds = (projectId: string, visited = new Set<string>()): string[] => {\n        if (visited.has(projectId)) {\n            return [] // Already visited, break recursion to prevent cycles\n        }\n        visited.add(projectId)\n\n        const ids = [projectId] // Include the current project ID\n        const childProjects = projects.value.filter(p => p.parentId === projectId)\n        childProjects.forEach(child => {\n            ids.push(...getChildProjectIds(child.id, visited))\n        })\n        return ids\n    }\n\n    const filteredTasks = computed(() => {\n        if (!tasks.value || !Array.isArray(tasks.value)) {\n            // console.debug('⚠️ [FILTER-DEBUG] No tasks to filter')\n            return []\n        }\n\n        let filtered = tasks.value.filter(task => !task._soft_deleted)\n        // console.debug(`🔍 [FILTER-DEBUG] Starting filter with ${filtered.length} tasks (excluding deleted)`)\n\n        // 1. Smart View\n        if (activeSmartView.value) {\n            filtered = applySmartViewFilter(filtered, activeSmartView.value)\n            // console.debug(`🔍 [FILTER-DEBUG] After SmartView (${activeSmartView.value}): ${filtered.length}`)\n        }\n\n        // 2. Project (Single or Multi-select)\n        if (selectedProjectIds?.value && selectedProjectIds.value.size > 0) {\n            // TASK-084: Multi-select mode\n            const allTargetProjectIds = new Set<string>()\n            selectedProjectIds.value.forEach(pid => {\n                const childIds = getChildProjectIds(pid)\n                childIds.forEach(cid => allTargetProjectIds.add(cid))\n            })\n            filtered = filtered.filter(task => allTargetProjectIds.has(task.projectId))\n        } else if (activeProjectId.value) {\n            // Standard single project mode\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            filtered = filtered.filter(task => projectIds.includes(task.projectId))\n            // console.debug(`🔍 [FILTER-DEBUG] After Project (${activeProjectId.value}): ${filtered.length}`)\n        }\n\n        // 3. Status\n        if (activeStatusFilter.value) {\n            filtered = filtered.filter(task => task.status === activeStatusFilter.value)\n        }\n\n        // 4. Duration\n        if (activeDurationFilter.value) {\n            filtered = filtered.filter(t => {\n                switch (activeDurationFilter.value) {\n                    case 'quick': return isQuickTask(t)\n                    case 'short': return isShortTask(t)\n                    case 'medium': return isMediumTask(t)\n                    case 'long': return isLongTask(t)\n                    case 'unestimated': return isUnestimatedTask(t)\n                    default: return true\n                }\n            })\n        }\n\n        // 5. Hide Done - REMOVED (TASK-076)\n        // Each view (Canvas, Calendar, Inbox) handles done filtering locally\n        // Canvas: CanvasView.vue filteredTasks computed\n        // Calendar: CalendarView.vue local filter\n        // Inbox: UnifiedInboxPanel.vue hideInboxDoneTasks ref\n        // This ensures canvas toggle doesn't affect inbox and vice versa\n\n        // Include nested tasks\n        const filteredTaskIds = filtered.map(task => task.id)\n        const nestedTaskIds = collectNestedTasks(filteredTaskIds, tasks.value)\n\n        let nestedTasks: Task[] = []\n        try {\n            // Optimization: Get project IDs once instead of inside filter loop\n            let activeProjectTreeIds: string[] | null = null\n\n            if (activeProjectId.value) {\n                activeProjectTreeIds = getChildProjectIds(activeProjectId.value)\n            }\n\n            // TASK-084: Handle nesting for multi-select\n            if (selectedProjectIds?.value && selectedProjectIds.value.size > 0) {\n                activeProjectTreeIds = []\n                selectedProjectIds.value.forEach(pid => {\n                    activeProjectTreeIds!.push(...getChildProjectIds(pid))\n                })\n            }\n\n            nestedTasks = tasks.value\n                .filter(task => nestedTaskIds.includes(task.id) && !task._soft_deleted)\n                .filter(task => {\n                    if (activeProjectTreeIds) {\n                        if (!activeProjectTreeIds.includes(task.projectId)) return false\n                    }\n                    // TASK-076: Only filter done tasks for Today smart view here\n                    // View-specific done filtering handled locally by each view\n                    if (task.status === 'done' && activeSmartView.value === 'today') return false\n                    return true\n                })\n        } catch {\n            nestedTasks = []\n        }\n\n        const allTasks = [...filtered, ...nestedTasks]\n        const finalResult = allTasks.filter((task, index, self) =>\n            index === self.findIndex(t => t.id === task.id)\n        )\n\n        console.debug(`✅ [FILTER-DEBUG] Final filtered tasks: ${finalResult.length} (ActiveProject: ${activeProjectId.value || 'None'})`)\n        return finalResult\n    })\n\n    const tasksByStatus = computed(() => {\n        const tasksToGroup = filteredTasks.value\n        return {\n            planned: tasksToGroup.filter(task => task.status === 'planned'),\n            in_progress: tasksToGroup.filter(task => task.status === 'in_progress'),\n            done: tasksToGroup.filter(task => task.status === 'done'),\n            backlog: tasksToGroup.filter(task => task.status === 'backlog'),\n            on_hold: tasksToGroup.filter(task => task.status === 'on_hold')\n        }\n    })\n\n    const filteredTasksWithCanvasPosition = computed(() => {\n        return filteredTasks.value.filter(task => task.canvasPosition &&\n            typeof task.canvasPosition.x === 'number' &&\n            typeof task.canvasPosition.y === 'number')\n    })\n\n    const tasksWithCanvasPosition = computed(() => {\n        return tasks.value.filter(task => task.canvasPosition &&\n            typeof task.canvasPosition.x === 'number' &&\n            typeof task.canvasPosition.y === 'number')\n    })\n\n    const calendarFilteredTasks = computed(() => {\n        let filtered = tasks.value.filter(task => !task._soft_deleted)\n\n        // 1. Project\n        if (activeProjectId.value) {\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            filtered = filtered.filter(task => projectIds.includes(task.projectId))\n        }\n\n        // 2. Hide Done (Calendar specific)\n        if (hideCalendarDoneTasks?.value) {\n            filtered = filtered.filter(task => task.status !== 'done')\n        }\n\n        return filtered\n    })\n\n    const totalTasks = computed(() => tasks.value.filter(task => task.status !== 'done' && !task._soft_deleted).length)\n    const completedTasks = computed(() => tasks.value.filter(task => task.status === 'done' && !task._soft_deleted).length)\n\n    const totalPomodoros = computed(() =>\n        tasks.value.reduce((sum, task) => sum + (task.completedPomodoros || 0), 0)\n    )\n\n    const doneTasksForColumn = computed(() => {\n        let doneTasks = tasks.value.filter(task => task.status === 'done')\n\n        if (activeProjectId.value) {\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            doneTasks = doneTasks.filter(task => projectIds.includes(task.projectId))\n        }\n\n        if (activeSmartView.value === 'today') {\n            const todayStr = new Date().toISOString().split('T')[0]\n            const today = new Date()\n            today.setHours(0, 0, 0, 0)\n\n            doneTasks = doneTasks.filter(task => {\n                const taskCreatedDate = new Date(task.createdAt)\n                taskCreatedDate.setHours(0, 0, 0, 0)\n                if (taskCreatedDate.getTime() === today.getTime()) return true\n\n                if (task.dueDate) {\n                    const taskDueDate = new Date(task.dueDate)\n                    if (!isNaN(taskDueDate.getTime()) && formatDateKey(taskDueDate) === todayStr) return true\n                }\n                return false\n            })\n        }\n\n        return doneTasks\n    })\n\n    const smartViewTaskCounts = computed(() => {\n        let baseTasks = tasks.value.filter(task => !task._soft_deleted)\n\n        if (activeProjectId.value) {\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            baseTasks = baseTasks.filter(task => projectIds.includes(task.projectId))\n        }\n\n        if (hideDoneTasks.value) {\n            baseTasks = baseTasks.filter(task => task.status !== 'done')\n        }\n\n        return {\n            today: baseTasks.filter(task => isTodayTask(task)).length,\n            week: baseTasks.filter(task => isWeekTask(task)).length,\n            uncategorized: baseTasks.filter(task => isUncategorizedTask(task)).length,\n            unscheduled: baseTasks.filter(task => isUnscheduledTask(task)).length,\n            inProgress: baseTasks.filter(task => isInProgressTask(task)).length,\n            allActive: baseTasks.filter(task => task.status !== 'done').length,\n            all: baseTasks.length,\n            quick: baseTasks.filter(task => isQuickTask(task)).length,\n            short: baseTasks.filter(task => isShortTask(task)).length,\n            medium: baseTasks.filter(task => isMediumTask(task)).length,\n            long: baseTasks.filter(task => isLongTask(task)).length,\n            unestimated: baseTasks.filter(task => isUnestimatedTask(task)).length\n        }\n    })\n\n    const getProjectTaskCount = (projectId: string): number => {\n        const projectIds = getChildProjectIds(projectId)\n        let projectTasks = tasks.value.filter(task => projectIds.includes(task.projectId))\n\n        if (activeSmartView.value) {\n            projectTasks = applySmartViewFilter(projectTasks, activeSmartView.value as any)\n        }\n\n        if (activeStatusFilter.value) {\n            projectTasks = projectTasks.filter(task => task.status === activeStatusFilter.value)\n        }\n\n        if (hideDoneTasks.value) {\n            projectTasks = projectTasks.filter(task => task.status !== 'done')\n        }\n\n        return projectTasks.length\n    }\n\n    return {\n        filteredTasks,\n        tasksByStatus,\n        filteredTasksWithCanvasPosition,\n        smartViewTaskCounts,\n        getProjectTaskCount,\n        totalTasks,\n        nonDoneTaskCount: totalTasks,\n        completedTasks,\n        totalPomodoros,\n        doneTasksForColumn,\n        tasksWithCanvasPosition,\n        calendarFilteredTasks\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskMigrations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/ui/done-toggle/useDoneToggleInteraction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/ui/drag-handle/useDragHandleInteraction.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nextTick' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":43}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onUnmounted, nextTick, watch } from 'vue'\n\nexport interface DragHandleProps {\n    disabled: boolean\n    showKeyboardNavigation: boolean\n}\n\nexport interface DragHandleState {\n    isDragging: { value: boolean }\n    isHovered: { value: boolean }\n    isFocused: { value: boolean }\n    showTouchFeedback: { value: boolean }\n    dragGhost: { value: boolean }\n    dragStartPosition: { value: { x: number, y: number } }\n    currentPosition: { value: { x: number, y: number } }\n}\n\nexport interface DragHandleEmits {\n    (e: 'dragStart', event: MouseEvent | TouchEvent): void\n    (e: 'dragEnd', event: MouseEvent | TouchEvent): void\n    (e: 'dragMove', event: MouseEvent | TouchEvent, deltaX: number, deltaY: number): void\n    (e: 'keyboardMove', direction: 'up' | 'down' | 'left' | 'right'): void\n    (e: 'hoverStart'): void\n    (e: 'hoverEnd'): void\n}\n\nexport function useDragHandleInteraction(\n    props: DragHandleProps,\n    state: DragHandleState,\n    emit: DragHandleEmits\n) {\n    const animationFrame = ref<number | null>(null)\n\n    // --- Core Lifecycle ---\n\n    const cleanup = () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n        document.removeEventListener('mouseup', handleMouseUp)\n        document.removeEventListener('touchmove', handleTouchMove)\n        document.removeEventListener('touchend', handleTouchEnd)\n\n        if (animationFrame.value) {\n            cancelAnimationFrame(animationFrame.value)\n            animationFrame.value = null\n        }\n    }\n\n    onUnmounted(() => {\n        cleanup()\n    })\n\n    // --- Drag Operations ---\n\n    const startDragOperation = (event: MouseEvent | TouchEvent) => {\n        state.isDragging.value = true\n        state.dragGhost.value = true\n\n        // Calculate initial position\n        const clientX = 'touches' in event ? event.touches[0]?.clientX || 0 : (event as MouseEvent).clientX\n        const clientY = 'touches' in event ? event.touches[0]?.clientY || 0 : (event as MouseEvent).clientY\n\n        state.dragStartPosition.value = { x: clientX, y: clientY }\n        state.currentPosition.value = { x: clientX, y: clientY }\n\n        emit('dragStart', event)\n        startPositionTracking()\n    }\n\n    const endDragOperation = (event: MouseEvent | TouchEvent) => {\n        if (state.isDragging.value) {\n            state.isDragging.value = false\n            state.dragGhost.value = false\n\n            if (animationFrame.value) {\n                cancelAnimationFrame(animationFrame.value)\n                animationFrame.value = null\n            }\n\n            emit('dragEnd', event)\n        }\n    }\n\n    const startPositionTracking = () => {\n        const trackPosition = () => {\n            if (!state.isDragging.value) return\n            // Request next frame for smooth ghost updates (though DOM updates happen reactively)\n            animationFrame.value = requestAnimationFrame(trackPosition)\n        }\n        animationFrame.value = requestAnimationFrame(trackPosition)\n    }\n\n    // --- Specific Event Handlers ---\n\n    const handleMouseDown = (event: MouseEvent) => {\n        if (props.disabled) return\n        event.preventDefault()\n        startDragOperation(event)\n        document.addEventListener('mousemove', handleMouseMove)\n        document.addEventListener('mouseup', handleMouseUp)\n    }\n\n    const handleMouseMove = (event: MouseEvent) => {\n        if (!state.isDragging.value) return\n\n        // Update State\n        const deltaX = event.clientX - state.dragStartPosition.value.x\n        const deltaY = event.clientY - state.dragStartPosition.value.y\n        state.currentPosition.value = { x: event.clientX, y: event.clientY }\n\n        emit('dragMove', event, deltaX, deltaY)\n    }\n\n    const handleMouseUp = (event: MouseEvent) => {\n        endDragOperation(event)\n        document.removeEventListener('mousemove', handleMouseMove)\n        document.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    // --- Touch Handlers ---\n\n    const handleTouchStart = (event: TouchEvent) => {\n        if (props.disabled) return\n        event.preventDefault()\n        state.showTouchFeedback.value = true\n        startDragOperation(event)\n        document.addEventListener('touchmove', handleTouchMove)\n        document.addEventListener('touchend', handleTouchEnd)\n    }\n\n    const handleTouchMove = (event: TouchEvent) => {\n        if (!state.isDragging.value) return\n        const touch = event.touches[0]\n        if (!touch) return\n\n        const deltaX = touch.clientX - state.dragStartPosition.value.x\n        const deltaY = touch.clientY - state.dragStartPosition.value.y\n        state.currentPosition.value = { x: touch.clientX, y: touch.clientY }\n\n        event.preventDefault() // Block scrolling\n        emit('dragMove', event, deltaX, deltaY)\n    }\n\n    const handleTouchEnd = (event: TouchEvent) => {\n        state.showTouchFeedback.value = false\n        endDragOperation(event)\n        document.removeEventListener('touchmove', handleTouchMove)\n        document.removeEventListener('touchend', handleTouchEnd)\n    }\n\n    // --- Keyboard Handlers ---\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n        if (props.disabled) return\n\n        switch (event.key) {\n            case 'Enter':\n            case ' ':\n                event.preventDefault()\n                if (!state.isDragging.value) {\n                    // Simulate drag start via keyboard\n                    const syntheticEvent = new MouseEvent('mousedown', {\n                        clientX: 0, clientY: 0, bubbles: true, cancelable: true\n                    })\n                    startDragOperation(syntheticEvent)\n                }\n                break\n            case 'Escape':\n                if (state.isDragging.value) {\n                    event.preventDefault()\n                    endDragOperation(event as unknown as MouseEvent)\n                }\n                break\n        }\n    }\n\n    const handleArrowKey = (direction: 'up' | 'down' | 'left' | 'right') => {\n        if (props.disabled || !props.showKeyboardNavigation) return\n        emit('keyboardMove', direction)\n    }\n\n    return {\n        handleMouseDown,\n        handleMouseMove,\n        handleMouseUp,\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n        handleKeyDown,\n        handleArrowKey,\n        // Expose start/end for public API if needed\n        startDragOperation,\n        endDragOperation\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/ui/drag-handle/useDragHandleState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue'\n\nexport function useDragHandleState() {\n    const isDragging = ref(false)\n    const isHovered = ref(false)\n    const isFocused = ref(false)\n    const showTouchFeedback = ref(false)\n    const dragGhost = ref(false)\n\n    // Position tracking\n    const dragStartPosition = ref({ x: 0, y: 0 })\n    const currentPosition = ref({ x: 0, y: 0 })\n\n    return {\n        isDragging,\n        isHovered,\n        isFocused,\n        showTouchFeedback,\n        dragGhost,\n        dragStartPosition,\n        currentPosition\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/undoSingleton.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[685,688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[685,688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":64,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":64,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2430,2431],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":67,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":67,"endColumn":22,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2564,2565],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5819,5822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5819,5822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7237,7240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7237,7240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'description' is defined but never used. Allowed unused args must match /^_/u.","line":204,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":204,"endColumn":37},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":230,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":230,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Undo System Singleton - Ensures shared instance across the entire application\n// This solves initialization order issues between App.vue and globalKeyboardHandlerSimple.ts\n// UPDATED: Now tracks both tasks AND canvas groups for unified undo/redo (ISSUE-008 fix)\n\nimport { ref, computed, nextTick } from 'vue'\nimport type { Ref, ComputedRef } from 'vue'\nimport { useManualRefHistory } from '@vueuse/core'\nimport type { Task } from '../stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport type { CanvasGroup } from '@/stores/canvas/types'\nimport { guardTaskCreation } from '../utils/demoContentGuard'\n\ndeclare global {\n  interface Window {\n    __pomoFlowUndoSystem?: any\n  }\n}\n\n// Combined state interface for tracking both tasks and groups\ninterface UnifiedUndoState {\n  tasks: Task[]\n  groups: CanvasGroup[]\n}\n\n// Global singleton refHistory instance - created only ONCE\nlet refHistoryInstance: ReturnType<typeof useManualRefHistory<UnifiedUndoState>> | null = null\nlet unifiedState: Ref<UnifiedUndoState> | null = null\nlet canUndo: ComputedRef<boolean> | null = null\nlet canRedo: ComputedRef<boolean> | null = null\nlet undoCount: ComputedRef<number> | null = null\nlet redoCount: ComputedRef<number> | null = null\nlet history: ComputedRef<unknown[]> | null = null\nlet undo: (() => void) | null = null\nlet redo: (() => void) | null = null\nlet commit: (() => void) | null = null\nlet clear: (() => void) | null = null\n\n/**\n * Initialize the single refHistory instance\n */\nfunction initializeRefHistory() {\n  if (refHistoryInstance) {\n    return\n  }\n\n  // CRITICAL FIX: Start with empty state to avoid circular dependency during store setup\n  // The state will be populated after stores are fully initialized\n  // This is called during useTaskStore() setup, so we can't access taskStore.tasks yet\n  unifiedState = ref<UnifiedUndoState>({\n    tasks: [],\n    groups: []\n  })\n\n  // Schedule state population after stores are ready (next tick ensures store setup is complete)\n  nextTick(async () => {\n    try {\n      // Dynamic import to break circular dependency (tasks -> taskHistory -> undoSingleton -> tasks)\n      const { useTaskStore } = await import('../stores/tasks')\n      const taskStore = useTaskStore()\n      const canvasStore = useCanvasStore()\n\n      // Now safely populate the state - stores should be fully initialized\n      if (taskStore.tasks && Array.isArray(taskStore.tasks)) {\n        unifiedState!.value.tasks = [...taskStore.tasks]\n      }\n      if (canvasStore.groups && Array.isArray(canvasStore.groups)) {\n        unifiedState!.value.groups = [...canvasStore.groups]\n      }\n    } catch (error) {\n      console.warn('⚠️ [UNDO] Could not populate initial state (stores may not be ready):', error)\n    }\n  })\n\n  // Create the SINGLE useManualRefHistory instance with proper VueUse configuration\n  // NOTE: deep: true was intentionally removed for performance reasons (deep watchers issue)\n  refHistoryInstance = useManualRefHistory(unifiedState, {\n    capacity: 50,\n    clone: true\n  })\n\n  // Extract all the reactive properties\n  canUndo = computed(() => refHistoryInstance?.canUndo.value ?? false)\n  canRedo = computed(() => refHistoryInstance?.canRedo.value ?? false)\n  // useManualRefHistory provides history tracking\n  undoCount = computed(() => {\n    if (!refHistoryInstance) return 0\n    return refHistoryInstance.undoStack.value.length\n  })\n  redoCount = computed(() => {\n    if (!refHistoryInstance) return 0\n    return refHistoryInstance.redoStack.value.length\n  })\n  history = computed(() => refHistoryInstance?.history.value ?? [])\n\n  // Bind the methods\n  undo = refHistoryInstance.undo.bind(refHistoryInstance)\n  redo = refHistoryInstance.redo.bind(refHistoryInstance)\n  commit = refHistoryInstance.commit.bind(refHistoryInstance)\n  clear = refHistoryInstance.clear.bind(refHistoryInstance)\n\n  // Also store on window for direct access\n  if (typeof window !== 'undefined') {\n    (window as Window & typeof globalThis).__pomoFlowUndoSystem = {\n      canUndo,\n      canRedo,\n      undoCount,\n      redoCount,\n      history,\n      undo,\n      redo,\n      commit,\n      clear,\n      collectFilter: {\n        matchDueDate: null, // Was false, fixed to match CollectFilterSettings\n        matchPriority: undefined,\n        matchStatus: undefined,\n        matchDuration: 'quick'\n      }\n    }\n  }\n}\n\n// ✅ FIXED - Functions defined at module level (outside return object)\n// FIX: Made async to properly await restoreState which is an async function\n// UPDATED: Now restores both tasks AND groups (ISSUE-008 fix)\nconst performUndo = async () => {\n  if (!refHistoryInstance || !unifiedState) return false\n  refHistoryInstance.undo()\n\n  // After undo, unifiedState.value now contains the previous state\n  // Restore both tasks and groups\n  const previousState = unifiedState.value\n  if (previousState && typeof previousState === 'object' && 'tasks' in previousState) {\n    // Dynamic import\n    const { useTaskStore } = await import('../stores/tasks')\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const { useCanvasUiStore } = await import('../stores/canvas/canvasUi')\n    const canvasUiStore = useCanvasUiStore()\n\n    // BUG-008 FIX: Restore groups FIRST (synchronous, no DB dependency)\n    // This ensures groups are restored immediately even if task DB save hangs\n    canvasStore.setGroups([...previousState.groups])\n\n    // Request canvas sync IMMEDIATELY after group restore\n    try {\n      canvasUiStore.requestSync('user:undo')\n    } catch (error) {\n      console.warn('⚠️ [UNDO] Could not request canvas sync:', error)\n    }\n\n    // Restore tasks (async - may take time for DB operations)\n    // Don't await - let it run in background to avoid blocking UI\n    taskStore.restoreState(previousState.tasks).then(() => {\n    }).catch((err: any) => {\n      console.error('❌ [UNDO] Task store restore failed:', err)\n    })\n\n    return true\n  }\n  return false\n}\n\n// FIX: Made async to properly await restoreState which is an async function\n// UPDATED: Now restores both tasks AND groups (ISSUE-008 fix)\nconst performRedo = async () => {\n  if (!refHistoryInstance || !unifiedState) return false\n  refHistoryInstance.redo()\n\n  // After redo, unifiedState.value now contains the next state\n  // Restore both tasks and groups\n  const nextState = unifiedState.value\n  if (nextState && typeof nextState === 'object' && 'tasks' in nextState) {\n    // Dynamic import\n    const { useTaskStore } = await import('../stores/tasks')\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const { useCanvasUiStore } = await import('../stores/canvas/canvasUi')\n    const canvasUiStore = useCanvasUiStore()\n\n    // BUG-008 FIX: Restore groups FIRST (synchronous, no DB dependency)\n    canvasStore.setGroups([...nextState.groups])\n\n    // Request canvas sync IMMEDIATELY after group restore\n    try {\n      canvasUiStore.requestSync('user:redo')\n    } catch (error) {\n      console.warn('⚠️ [REDO] Could not request canvas sync:', error)\n    }\n\n    // Restore tasks (async - may take time for DB operations)\n    // Don't await - let it run in background to avoid blocking UI\n    taskStore.restoreState(nextState.tasks).then(() => {\n    }).catch((err: any) => {\n      console.error('❌ [REDO] Task store restore failed:', err)\n    })\n\n    return true\n  }\n  return false\n}\n\n// UPDATED: Now saves both tasks AND groups (ISSUE-008 fix)\nconst saveState = async (description?: string) => {\n  // BUG-008 DEBUG: Log when refHistoryInstance is null\n  if (!refHistoryInstance) {\n    console.error('❌ [UNDO-CRITICAL] saveState() called but refHistoryInstance is NULL! Calling initializeRefHistory()...')\n    initializeRefHistory()\n    if (!refHistoryInstance) {\n      console.error('❌ [UNDO-CRITICAL] Still null after init retry!')\n      return false\n    }\n  }\n  // FIX: Add null check for commit function to prevent silent failures\n  if (!commit) {\n    console.error('❌ [UNDO] commit function not initialized - calling initializeRefHistory()')\n    initializeRefHistory()\n    if (!commit) {\n      console.error('❌ [UNDO] commit function still not initialized after retry')\n      return false\n    }\n  }\n  try {\n    // Dynamic import\n    const { useTaskStore } = await import('../stores/tasks')\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n\n    // Save combined state (tasks + groups)\n    unifiedState!.value = {\n      tasks: [...taskStore.tasks],\n      groups: [...canvasStore.groups]\n    }\n\n    commit()\n    return true\n  } catch (error) {\n    console.error('❌ Failed to save state:', error)\n    return false\n  }\n}\n\nconst deleteTaskWithUndo = async (taskId: string) => {\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n\n  const taskToDelete = taskStore.tasks.find(t => t.id === taskId)\n  if (!taskToDelete) {\n    console.warn('⚠️ Task not found for deletion:', taskId)\n    return\n  }\n\n  // FIXED: Use proper VueUse pattern - save state before operation\n  await saveState('Before task deletion')\n\n  try {\n    // Perform the deletion\n    await taskStore.deleteTask(taskId)\n\n    // FIXED: Save state after operation\n    await nextTick()\n    await saveState('After task deletion')\n  } catch (error) {\n    console.error('❌ deleteTaskWithUndo failed:', error)\n    throw error\n  }\n}\n\nconst updateTaskWithUndo = async (taskId: string, updates: Partial<Task>) => {\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n\n  const taskToUpdate = taskStore.tasks.find(t => t.id === taskId)\n  if (!taskToUpdate) {\n    console.warn('⚠️ Task not found for update:', taskId)\n    return\n  }\n\n  // FIXED: Use proper VueUse pattern - save state before operation\n  await saveState('Before task update')\n\n  // Perform the update\n  taskStore.updateTask(taskId, updates)\n\n  // FIXED: Save state after operation\n  await nextTick()\n  await saveState('After task update')\n}\n\nconst createTaskWithUndo = async (taskData: Partial<Task>) => {\n  // TASK-061: Demo content guard - defense in depth (also checked in taskStore.createTask)\n  if (taskData.title) {\n    guardTaskCreation(taskData.title)\n  }\n\n  // FIXED: Use proper VueUse pattern - save state before operation\n  await saveState('Before task creation')\n\n  // Create the task\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n  const newTask = await taskStore.createTask(taskData)\n\n  // FIXED: Save state after operation\n  await nextTick()\n  await saveState('After task creation')\n  return newTask\n}\n\n// NEW: Create group with undo support (BUG-008 fix)\nconst createGroupWithUndo = async (groupData: Omit<CanvasGroup, 'id'>) => {\n  const canvasStore = useCanvasStore()\n\n  // Save state before operation\n  await saveState('Before group creation')\n\n  try {\n    // Perform the creation\n    const newGroup = await canvasStore.createGroup(groupData)\n\n    // Save state after operation\n    await nextTick()\n    await saveState('After group creation')\n    return newGroup\n  } catch (error) {\n    console.error('❌ createGroupWithUndo failed:', error)\n    throw error\n  }\n}\n\n// NEW: Update group with undo support (BUG-008 fix)\nconst updateGroupWithUndo = async (groupId: string, updates: Partial<CanvasGroup>) => {\n  const canvasStore = useCanvasStore()\n\n  const groupToUpdate = canvasStore.groups.find(g => g.id === groupId)\n  if (!groupToUpdate) {\n    console.warn('⚠️ Group not found for update:', groupId)\n    return\n  }\n\n  // Save state before operation\n  await saveState('Before group update')\n\n  try {\n    // Perform the update\n    await canvasStore.updateGroup(groupId, updates)\n\n    // Save state after operation\n    await nextTick()\n    await saveState('After group update')\n  } catch (error) {\n    console.error('❌ updateGroupWithUndo failed:', error)\n    throw error\n  }\n}\n\n// NEW: Delete group with undo support (ISSUE-008 fix)\nconst deleteGroupWithUndo = async (groupId: string) => {\n  const canvasStore = useCanvasStore()\n\n  const groupToDelete = canvasStore.groups.find(g => g.id === groupId)\n  if (!groupToDelete) {\n    console.warn('⚠️ Group not found for deletion:', groupId)\n    return\n  }\n\n  // Save state before operation\n  await saveState('Before group deletion')\n\n  try {\n    // Perform the deletion\n    await canvasStore.deleteGroup(groupId)\n\n    // Save state after operation\n    await nextTick()\n    await saveState('After group deletion')\n  } catch (error) {\n    console.error('❌ deleteGroupWithUndo failed:', error)\n    throw error\n  }\n}\n\n// BUG-036 FIX: Batch delete support in singleton\nconst bulkDeleteTasksWithUndo = async (taskIds: string[]) => {\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n\n  await saveState(`Before bulk delete of ${taskIds.length} tasks`)\n\n  try {\n    if (taskStore.bulkDeleteTasks) {\n      await taskStore.bulkDeleteTasks(taskIds)\n    } else {\n      console.warn('⚠️ taskStore.bulkDeleteTasks not found, falling back to individual')\n      // Fallback for safety (though store should have it now)\n      for (const id of taskIds) {\n        await taskStore.deleteTask(id)\n      }\n    }\n\n    await nextTick()\n    await saveState('After bulk delete')\n  } catch (error) {\n    console.error('❌ bulkDeleteTasksWithUndo failed:', error)\n    throw error\n  }\n}\n\n/**\n * Get the global undo system functions that use the shared refHistory instance\n */\nexport function getUndoSystem() {\n  if (!refHistoryInstance) {\n    initializeRefHistory()\n  }\n\n  return {\n    canUndo,\n    canRedo,\n    undoCount,\n    redoCount,\n    history,\n\n    // Standard undo/redo operations\n    undo: performUndo,\n    redo: performRedo,\n\n    // FIXED: Unified state management using VueUse pattern\n    saveState,               // Use unified saveState function instead of before/after\n\n    // Task operations that use the shared refHistory\n    deleteTaskWithUndo,\n    bulkDeleteTasksWithUndo,\n    updateTaskWithUndo,\n    createTaskWithUndo,\n\n    // Group operations with undo (ISSUE-008 fix / BUG-008 fix)\n    createGroupWithUndo,\n    updateGroupWithUndo,\n    deleteGroupWithUndo\n  }\n}\n\n/**\n * Check if the undo system is initialized\n */\nexport function isUndoSystemInitialized(): boolean {\n  return refHistoryInstance !== null\n}\n\n/**\n * Reset the undo system (useful for testing)\n */\nexport function resetUndoSystem() {\n  refHistoryInstance = null\n  unifiedState = null\n  canUndo = null\n  canRedo = null\n  undoCount = null\n  redoCount = null\n  history = null\n  undo = null\n  redo = null\n  commit = null\n  clear = null\n  if (typeof window !== 'undefined') {\n    delete (window as Window & typeof globalThis).__pomoFlowUndoSystem\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useBackupSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":958,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":958,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29855,29858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29855,29858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import IntegrityService from '@/utils/integrity'\n\n/**\n * Unified Backup System\n *\n * Consolidates 4 competing backup implementations into a single, cohesive system.\n * Replaces: useBackupManager, useSimpleBackup, useAutoBackup, useBackupRestoration\n *\n * @version 1.0.0\n * @since 2025-12-03\n */\n\nimport { ref, computed, onMounted, onUnmounted, getCurrentInstance } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useProjectStore } from '@/stores/projects'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { filterMockTasks } from '@/utils/mockTaskDetector'\nimport type { Task, Project } from '@/types/tasks'\nimport type { CanvasGroup } from '@/stores/canvas'\n\n// ============================================================================\n// Types & Interfaces\n// ============================================================================\n\nexport interface BackupData {\n  id: string\n  tasks: Task[]\n  projects: Project[]\n  groups: CanvasGroup[]\n  timestamp: number\n  version: string\n  checksum: string\n  type: 'auto' | 'manual' | 'emergency'\n  metadata?: {\n    taskCount: number\n    projectCount: number\n    groupCount: number\n    size?: number\n    exportedAt?: string\n  }\n}\n\nexport interface BackupConfig {\n  enabled: boolean\n  autoSaveInterval: number // milliseconds (default: 5 min)\n  maxHistorySize: number   // max backups to keep (default: 10)\n  filterMockTasks: boolean // remove mock/test tasks (default: true)\n}\n\nexport interface BackupStats {\n  lastBackupTime: number | null\n  totalBackups: number\n  isBackupInProgress: boolean\n  historyCount: number\n}\n\nexport interface BackupSystemState {\n  isReady: boolean\n  isRestoring: boolean\n  restoreProgress: number\n  error: string | null\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst STORAGE_KEYS = {\n  HISTORY: 'flow-state-backup-history',\n  LATEST: 'flow-state-latest-backup',\n  STATS: 'flow-state-backup-stats',\n  // BUG-059 FIX: Golden backup that can NEVER be overwritten by auto-backups\n  // Only updated when manually triggered OR when task count reaches new maximum\n  GOLDEN: 'flow-state-golden-backup',\n  // Tracks the maximum task count ever seen - used to detect data loss\n  MAX_TASK_COUNT: 'flow-state-max-task-count'\n} as const\n\n// BUG-059 FIX: Threshold for detecting suspicious data loss\n// If new backup has less than this % of previous max tasks, block auto-backup\nconst DATA_LOSS_THRESHOLD = 0.5 // 50%\n\n// TASK-153: Maximum age for golden backup before warning (7 days in ms)\nconst GOLDEN_BACKUP_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000\n\n// TASK-156: Maximum age for backup history entries (30 days in ms)\nconst BACKUP_HISTORY_TTL_MS = 30 * 24 * 60 * 60 * 1000\n\n// TASK-156: Current backup schema version\nconst BACKUP_SCHEMA_VERSION = '3.1.0'\n\n// TASK-153: Types for golden backup validation\nexport interface GoldenBackupValidation {\n  isValid: boolean\n  ageMs: number\n  ageWarning: string | null\n  preview: {\n    tasks: { total: number; filtered: number; toRestore: number }\n    projects: { total: number; filtered: number; toRestore: number }\n    groups: { total: number; filtered: number; toRestore: number }\n  }\n  warnings: string[]\n}\n\nconst DEFAULT_CONFIG: BackupConfig = {\n  enabled: true,\n  autoSaveInterval: 5 * 60 * 1000, // 5 minutes\n  maxHistorySize: 10,\n  filterMockTasks: true\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Calculate simple checksum for data integrity verification\n */\nfunction calculateChecksum(data: unknown): string {\n  return IntegrityService.calculateChecksum(data)\n}\n\n/**\n * Generate unique backup ID\n */\nfunction generateBackupId(): string {\n  return `backup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n}\n\n/**\n * Format timestamp to human-readable string\n */\nfunction formatTimestamp(timestamp: number): string {\n  const date = new Date(timestamp)\n  return date.toLocaleString()\n}\n\n// ============================================================================\n// Main Composable\n// ============================================================================\n\nexport function useBackupSystem(userConfig: Partial<BackupConfig> = {}) {\n  // Merge user config with defaults\n  const config = ref<BackupConfig>({ ...DEFAULT_CONFIG, ...userConfig })\n\n  // Dependencies\n  const taskStore = useTaskStore()\n  const projectStore = useProjectStore()\n  const canvasStore = useCanvasStore()\n  const db = useSupabaseDatabase()\n\n  // State\n  const state = ref<BackupSystemState>({\n    isReady: false,\n    isRestoring: false,\n    restoreProgress: 0,\n    error: null\n  })\n\n  const stats = ref<BackupStats>({\n    lastBackupTime: null,\n    totalBackups: 0,\n    isBackupInProgress: false,\n    historyCount: 0\n  })\n\n  const backupHistory = ref<BackupData[]>([])\n\n  // Timers\n  let autoBackupInterval: NodeJS.Timeout | null = null\n\n  // ============================================================================\n  // Core Backup Operations\n  // ============================================================================\n\n  /**\n   * BUG-059 FIX: Get the maximum task count ever recorded\n   */\n  function getMaxTaskCount(): number {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEYS.MAX_TASK_COUNT)\n      return stored ? parseInt(stored, 10) : 0\n    } catch {\n      return 0\n    }\n  }\n\n  /**\n   * BUG-059 FIX: Update the maximum task count if current is higher\n   */\n  function updateMaxTaskCount(currentCount: number): void {\n    const maxCount = getMaxTaskCount()\n    if (currentCount > maxCount) {\n      localStorage.setItem(STORAGE_KEYS.MAX_TASK_COUNT, currentCount.toString())\n      console.log(`[Backup] 🏆 New maximum task count: ${currentCount} (was ${maxCount})`)\n    }\n  }\n\n  /**\n   * BUG-059 FIX: Get golden backup (immutable high-water mark backup)\n   */\n  function getGoldenBackup(): BackupData | null {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEYS.GOLDEN)\n      return stored ? JSON.parse(stored) : null\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * BUG-059 FIX: Save golden backup (only if task count is higher than previous)\n   */\n  function saveGoldenBackup(backup: BackupData, force: boolean = false): boolean {\n    const golden = getGoldenBackup()\n    const goldenTaskCount = golden?.metadata?.taskCount || 0\n    const newTaskCount = backup.metadata?.taskCount || 0\n\n    if (force || newTaskCount > goldenTaskCount) {\n      localStorage.setItem(STORAGE_KEYS.GOLDEN, JSON.stringify(backup))\n      console.log(`[Backup] 💛 Golden backup updated: ${newTaskCount} tasks (was ${goldenTaskCount})`)\n      return true\n    }\n    return false\n  }\n\n  /**\n   * TASK-153: Validate golden backup before restore\n   * - Checks age and warns if > 7 days old\n   * - Cross-references with current Supabase data to filter deleted items\n   * - Returns preview of what will be restored\n   */\n  async function validateGoldenBackup(): Promise<GoldenBackupValidation | null> {\n    const golden = getGoldenBackup()\n    if (!golden) {\n      console.warn('[Backup] No golden backup to validate')\n      return null\n    }\n\n    const warnings: string[] = []\n    const now = Date.now()\n    const ageMs = now - golden.timestamp\n\n    // Check age warning\n    let ageWarning: string | null = null\n    if (ageMs > GOLDEN_BACKUP_MAX_AGE_MS) {\n      const ageDays = Math.floor(ageMs / (24 * 60 * 60 * 1000))\n      ageWarning = `Golden backup is ${ageDays} days old (created ${new Date(golden.timestamp).toLocaleDateString()})`\n      warnings.push(ageWarning)\n    }\n\n    // Get current deleted item IDs from Supabase\n    let deletedTaskIds: Set<string> = new Set()\n    let deletedProjectIds: Set<string> = new Set()\n    let deletedGroupIds: Set<string> = new Set()\n\n    try {\n      // Fetch deleted items from Supabase to filter them out\n      if (db.fetchDeletedTaskIds) {\n        deletedTaskIds = new Set(await db.fetchDeletedTaskIds())\n      }\n      if (db.fetchDeletedProjectIds) {\n        deletedProjectIds = new Set(await db.fetchDeletedProjectIds())\n      }\n      if (db.fetchDeletedGroupIds) {\n        deletedGroupIds = new Set(await db.fetchDeletedGroupIds())\n      }\n    } catch (error) {\n      console.warn('[Backup] Could not fetch deleted item IDs from Supabase:', error)\n      warnings.push('Could not verify deleted items against Supabase - some deleted items may be restored')\n    }\n\n    // Calculate what would be restored after filtering\n    const tasksToRestore = golden.tasks.filter(t => !deletedTaskIds.has(t.id))\n    const projectsToRestore = (golden.projects || []).filter(p => !deletedProjectIds.has(p.id))\n    const groupsToRestore = (golden.groups || []).filter(g => !deletedGroupIds.has(g.id))\n\n    const filteredTasks = golden.tasks.length - tasksToRestore.length\n    const filteredProjects = (golden.projects?.length || 0) - projectsToRestore.length\n    const filteredGroups = (golden.groups?.length || 0) - groupsToRestore.length\n\n    if (filteredTasks > 0) {\n      warnings.push(`${filteredTasks} tasks will be skipped (deleted in Supabase)`)\n    }\n    if (filteredProjects > 0) {\n      warnings.push(`${filteredProjects} projects will be skipped (deleted in Supabase)`)\n    }\n    if (filteredGroups > 0) {\n      warnings.push(`${filteredGroups} groups will be skipped (deleted in Supabase)`)\n    }\n\n    return {\n      isValid: true,\n      ageMs,\n      ageWarning,\n      preview: {\n        tasks: {\n          total: golden.tasks.length,\n          filtered: filteredTasks,\n          toRestore: tasksToRestore.length\n        },\n        projects: {\n          total: golden.projects?.length || 0,\n          filtered: filteredProjects,\n          toRestore: projectsToRestore.length\n        },\n        groups: {\n          total: golden.groups?.length || 0,\n          filtered: filteredGroups,\n          toRestore: groupsToRestore.length\n        }\n      },\n      warnings\n    }\n  }\n\n  /**\n   * TASK-153: Filter golden backup data to exclude items deleted in Supabase\n   */\n  async function filterGoldenBackupData(golden: BackupData): Promise<BackupData> {\n    let deletedTaskIds: Set<string> = new Set()\n    let deletedProjectIds: Set<string> = new Set()\n    let deletedGroupIds: Set<string> = new Set()\n\n    try {\n      if (db.fetchDeletedTaskIds) {\n        deletedTaskIds = new Set(await db.fetchDeletedTaskIds())\n      }\n      if (db.fetchDeletedProjectIds) {\n        deletedProjectIds = new Set(await db.fetchDeletedProjectIds())\n      }\n      if (db.fetchDeletedGroupIds) {\n        deletedGroupIds = new Set(await db.fetchDeletedGroupIds())\n      }\n    } catch (error) {\n      console.warn('[Backup] Could not fetch deleted IDs, restoring all items:', error)\n    }\n\n    return {\n      ...golden,\n      tasks: golden.tasks.filter(t => !deletedTaskIds.has(t.id)),\n      projects: (golden.projects || []).filter(p => !deletedProjectIds.has(p.id)),\n      groups: (golden.groups || []).filter(g => !deletedGroupIds.has(g.id)),\n      metadata: {\n        ...golden.metadata,\n        taskCount: golden.tasks.filter(t => !deletedTaskIds.has(t.id)).length,\n        projectCount: (golden.projects || []).filter(p => !deletedProjectIds.has(p.id)).length,\n        groupCount: (golden.groups || []).filter(g => !deletedGroupIds.has(g.id)).length\n      }\n    }\n  }\n\n  /**\n   * BUG-059 FIX: Check if backup looks suspicious (potential data loss)\n   */\n  function isBackupSuspicious(taskCount: number, type: 'auto' | 'manual' | 'emergency'): { suspicious: boolean; reason: string } {\n    const maxCount = getMaxTaskCount()\n    const golden = getGoldenBackup()\n    const goldenCount = golden?.metadata?.taskCount || 0\n\n    // For manual/emergency backups, allow any state (user explicitly requested)\n    if (type !== 'auto') {\n      return { suspicious: false, reason: '' }\n    }\n\n    // If we've never seen tasks before, can't detect data loss\n    if (maxCount === 0 && goldenCount === 0) {\n      return { suspicious: false, reason: '' }\n    }\n\n    const referenceCount = Math.max(maxCount, goldenCount)\n\n    // CRITICAL: Block auto-backup if task count dropped by more than threshold\n    if (referenceCount > 5 && taskCount < referenceCount * DATA_LOSS_THRESHOLD) {\n      return {\n        suspicious: true,\n        reason: `Task count dropped from ${referenceCount} to ${taskCount} (>${(1 - DATA_LOSS_THRESHOLD) * 100}% loss)`\n      }\n    }\n\n    // CRITICAL: Block auto-backup if tasks went to 0 when we had tasks before\n    if (taskCount === 0 && referenceCount > 0) {\n      return {\n        suspicious: true,\n        reason: `All ${referenceCount} tasks disappeared - blocking auto-backup`\n      }\n    }\n\n    return { suspicious: false, reason: '' }\n  }\n\n  /**\n   * Create a new backup\n   */\n  async function createBackup(type: 'auto' | 'manual' | 'emergency' = 'manual'): Promise<BackupData | null> {\n    if (stats.value.isBackupInProgress) {\n      console.log('[Backup] Skipping - backup already in progress')\n      return null\n    }\n\n    stats.value.isBackupInProgress = true\n    state.value.error = null\n\n    try {\n      console.log(`[Backup] Creating ${type} backup...`)\n\n      // Get tasks from store\n      let tasks = [...(taskStore.tasks || [])]\n\n      // Filter mock tasks if enabled\n      if (config.value.filterMockTasks && tasks.length > 0) {\n        const filterResult = filterMockTasks(tasks as unknown as Record<string, unknown>[], { confidence: 'medium', logResults: false })\n        if (filterResult.mockTasks.length > 0) {\n          console.log(`[Backup] Filtered ${filterResult.mockTasks.length} mock tasks`)\n        }\n        tasks = filterResult.cleanTasks as unknown as Task[]\n      }\n\n      // BUG-059 FIX: Check if this backup looks suspicious before saving\n      const suspiciousCheck = isBackupSuspicious(tasks.length, type)\n      if (suspiciousCheck.suspicious) {\n        state.value.error = suspiciousCheck.reason\n        return null\n      }\n\n      // Get projects and groups from stores\n      const projects = [...(projectStore.projects || [])]\n      const groups = [...(canvasStore.groups || [])]\n\n      // Create backup object\n      const backupData: BackupData = {\n        id: generateBackupId(),\n        tasks,\n        projects,\n        groups,\n        timestamp: Date.now(),\n        version: BACKUP_SCHEMA_VERSION, // TASK-156: Use constant for schema version\n        checksum: '',\n        type,\n        metadata: {\n          taskCount: tasks.length,\n          projectCount: projects.length,\n          groupCount: groups.length\n        }\n      }\n\n      // Calculate checksum\n      backupData.checksum = calculateChecksum({\n        tasks: backupData.tasks,\n        projects: backupData.projects,\n        groups: backupData.groups\n      })\n\n      // Calculate approximate size\n      const size = new TextEncoder().encode(JSON.stringify(backupData)).length\n      if (backupData.metadata) {\n        backupData.metadata.size = size\n      }\n\n      // Save to localStorage\n      saveToHistory(backupData)\n\n      // BUG-059 FIX: Update max task count and golden backup\n      const taskCount = backupData.metadata?.taskCount || 0\n      updateMaxTaskCount(taskCount)\n      saveGoldenBackup(backupData)\n\n      // Update stats\n      stats.value.lastBackupTime = backupData.timestamp\n      stats.value.totalBackups++\n\n      console.log(`[Backup] Created successfully: ${backupData.metadata?.taskCount} tasks, ${backupData.metadata?.projectCount} projects, ${backupData.metadata?.groupCount} groups`)\n\n      return backupData\n\n    } catch (error) {\n      console.error('[Backup] Failed to create backup:', error)\n      state.value.error = error instanceof Error ? error.message : 'Backup failed'\n      return null\n\n    } finally {\n      stats.value.isBackupInProgress = false\n    }\n  }\n\n  /**\n   * Restore from a backup\n   */\n  async function restoreBackup(backup: BackupData | string): Promise<boolean> {\n    state.value.isRestoring = true\n    state.value.restoreProgress = 0\n    state.value.error = null\n\n    try {\n      console.log('[Backup] Starting restore...')\n\n      // Parse if string\n      const backupData: BackupData = typeof backup === 'string'\n        ? JSON.parse(backup)\n        : backup\n\n      // Validate backup\n      if (!backupData.tasks || !Array.isArray(backupData.tasks)) {\n        throw new Error('Invalid backup: missing tasks array')\n      }\n\n      // Verify checksum if present\n      if (backupData.checksum) {\n        const currentChecksum = calculateChecksum({\n          tasks: backupData.tasks,\n          projects: backupData.projects,\n          groups: backupData.groups\n        })\n        if (currentChecksum !== backupData.checksum) {\n          console.warn('[Backup] Checksum mismatch - backup may be corrupted')\n        }\n      }\n\n      state.value.restoreProgress = 20\n\n      // Create emergency backup before restore\n      await createBackup('emergency')\n      state.value.restoreProgress = 40\n\n      // Restore to Supabase\n      // Note: We're doing serial saves for stability, but could be Promise.all\n      // Restore Tasks\n      await db.saveTasks(backupData.tasks)\n      state.value.restoreProgress = 60\n\n      // Restore Projects\n      await db.saveProjects(backupData.projects || [])\n      state.value.restoreProgress = 70\n\n      // Restore Groups\n      if (backupData.groups && Array.isArray(backupData.groups)) {\n        for (const group of backupData.groups) {\n          await db.saveGroup(group)\n        }\n      }\n      state.value.restoreProgress = 80\n\n      // Reload stores from database\n      if (taskStore.loadFromDatabase) await taskStore.loadFromDatabase()\n      if (projectStore.loadProjectsFromDatabase) await projectStore.loadProjectsFromDatabase()\n      if (canvasStore.loadFromDatabase) await canvasStore.loadFromDatabase()\n\n      state.value.restoreProgress = 100\n\n      console.log(`[Backup] Restored successfully: ${backupData.tasks.length} tasks`)\n      return true\n\n    } catch (error) {\n      console.error('[Backup] Restore failed:', error)\n      state.value.error = error instanceof Error ? error.message : 'Restore failed'\n      return false\n\n    } finally {\n      state.value.isRestoring = false\n      state.value.restoreProgress = 0\n    }\n  }\n\n  // ============================================================================\n  // History Management\n  // ============================================================================\n\n  /**\n   * Save backup to history (localStorage)\n   */\n  function saveToHistory(backup: BackupData): void {\n    try {\n      // Add to beginning of history\n      backupHistory.value.unshift(backup)\n\n      // Trim to max size\n      if (backupHistory.value.length > config.value.maxHistorySize) {\n        backupHistory.value = backupHistory.value.slice(0, config.value.maxHistorySize)\n      }\n\n      // Save to localStorage\n      localStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(backupHistory.value))\n      localStorage.setItem(STORAGE_KEYS.LATEST, JSON.stringify(backup))\n\n      stats.value.historyCount = backupHistory.value.length\n\n    } catch (error) {\n      console.error('[Backup] Failed to save to history:', error)\n    }\n  }\n\n  /**\n   * Load backup history from localStorage\n   * TASK-156: Added TTL pruning for old backups\n   */\n  function loadHistory(): void {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEYS.HISTORY)\n      if (stored) {\n        const rawHistory: BackupData[] = JSON.parse(stored)\n        const now = Date.now()\n\n        // TASK-156: Filter out backups older than TTL (30 days)\n        const validBackups: BackupData[] = []\n        const expiredBackups: BackupData[] = []\n\n        for (const backup of rawHistory) {\n          const age = now - backup.timestamp\n          if (age > BACKUP_HISTORY_TTL_MS) {\n            expiredBackups.push(backup)\n          } else {\n            validBackups.push(backup)\n          }\n        }\n\n        backupHistory.value = validBackups\n        stats.value.historyCount = validBackups.length\n\n        // Log pruned backups\n        if (expiredBackups.length > 0) {\n          console.log(`🧹 [TASK-156] Pruned ${expiredBackups.length} backups older than 30 days`)\n          // Save updated history without expired backups\n          localStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(validBackups))\n        }\n      }\n\n      // Load last backup time from latest\n      const latest = localStorage.getItem(STORAGE_KEYS.LATEST)\n      if (latest) {\n        const latestBackup = JSON.parse(latest)\n        stats.value.lastBackupTime = latestBackup.timestamp\n      }\n    } catch (error) {\n      console.error('[Backup] Failed to load history:', error)\n    }\n  }\n\n  /**\n   * Get the latest backup\n   */\n  function getLatestBackup(): BackupData | null {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEYS.LATEST)\n      return stored ? JSON.parse(stored) : null\n    } catch (error) {\n      console.error('[Backup] Failed to get latest backup:', error)\n      return null\n    }\n  }\n\n  /**\n   * Clear all backup history\n   */\n  function clearHistory(): void {\n    backupHistory.value = []\n    localStorage.removeItem(STORAGE_KEYS.HISTORY)\n    localStorage.removeItem(STORAGE_KEYS.LATEST)\n    stats.value.historyCount = 0\n  }\n\n  // ============================================================================\n  // Auto-Backup\n  // ============================================================================\n\n  /**\n   * Start automatic backup scheduler\n   */\n  function startAutoBackup(): void {\n    if (autoBackupInterval) {\n      stopAutoBackup()\n    }\n\n    if (!config.value.enabled || config.value.autoSaveInterval <= 0) {\n      return\n    }\n\n    console.log(`[Backup] Starting auto-backup every ${config.value.autoSaveInterval / 1000}s`)\n\n    autoBackupInterval = setInterval(async () => {\n      if (config.value.enabled) {\n        await createBackup('auto')\n      }\n    }, config.value.autoSaveInterval)\n  }\n\n  /**\n   * Stop automatic backup scheduler\n   */\n  function stopAutoBackup(): void {\n    if (autoBackupInterval) {\n      clearInterval(autoBackupInterval)\n      autoBackupInterval = null\n      console.log('[Backup] Auto-backup stopped')\n    }\n  }\n\n  // ============================================================================\n  // Export/Import\n  // ============================================================================\n\n  /**\n   * Export backup as JSON string\n   */\n  async function exportBackup(): Promise<string> {\n    const backup = await createBackup('manual')\n    if (!backup) {\n      throw new Error('Failed to create backup for export')\n    }\n\n    return JSON.stringify({\n      ...backup,\n      metadata: {\n        ...backup.metadata,\n        exportedAt: new Date().toISOString()\n      }\n    }, null, 2)\n  }\n\n  /**\n   * Import backup from JSON string\n   */\n  async function importBackup(jsonString: string): Promise<boolean> {\n    try {\n      const data = JSON.parse(jsonString)\n      return await restoreBackup(data)\n    } catch (error) {\n      console.error('[Backup] Import failed:', error)\n      state.value.error = 'Invalid backup file format'\n      return false\n    }\n  }\n\n  /**\n   * Download backup as file\n   */\n  async function downloadBackup(backup?: BackupData): Promise<void> {\n    const data = backup || getLatestBackup()\n    if (!data) {\n      throw new Error('No backup available to download')\n    }\n\n    const filename = `flow-state-backup-${new Date().toISOString().split('T')[0]}.json`\n    const content = JSON.stringify(data, null, 2)\n    const blob = new Blob([content], { type: 'application/json' })\n    const url = URL.createObjectURL(blob)\n\n    const link = document.createElement('a')\n    link.href = url\n    link.download = filename\n    document.body.appendChild(link)\n    link.click()\n    document.body.removeChild(link)\n    URL.revokeObjectURL(url)\n\n    console.log('[Backup] Downloaded:', filename)\n  }\n\n  /**\n   * Restore from uploaded file\n   */\n  async function restoreFromFile(file: File): Promise<boolean> {\n    try {\n      const text = await file.text()\n      return await importBackup(text)\n    } catch (error) {\n      console.error('[Backup] Failed to restore from file:', error)\n      state.value.error = 'Failed to read backup file'\n      return false\n    }\n  }\n\n  // ============================================================================\n  // Utility Methods\n  // ============================================================================\n\n  /**\n   * Check if backup contains Hebrew content\n   */\n  function hasHebrewContent(backup: BackupData): boolean {\n    if (!backup?.tasks) return false\n    const hebrewRegex = /[\\u0590-\\u05FF]/\n    return backup.tasks.some(task => task.title && hebrewRegex.test(task.title))\n  }\n\n  /**\n   * Get backup status summary\n   */\n  function getStatus() {\n    return {\n      isReady: state.value.isReady,\n      isEnabled: config.value.enabled,\n      lastBackupTime: stats.value.lastBackupTime,\n      formattedLastBackup: stats.value.lastBackupTime\n        ? formatTimestamp(stats.value.lastBackupTime)\n        : 'Never',\n      historyCount: stats.value.historyCount,\n      isBackupInProgress: stats.value.isBackupInProgress,\n      isRestoring: state.value.isRestoring,\n      error: state.value.error\n    }\n  }\n\n  // ============================================================================\n  // Lifecycle\n  // ============================================================================\n\n  /**\n   * Initialize backup system\n   */\n  async function initialize(): Promise<void> {\n    console.log('[Backup] Initializing...')\n\n    // Load history\n    loadHistory()\n\n    // Wait for tasks to be available\n    await waitForTasks()\n\n    // Start auto-backup\n    startAutoBackup()\n\n    // Create initial backup if none exists\n    if (!getLatestBackup()) {\n      await createBackup('auto')\n    }\n\n    state.value.isReady = true\n    console.log('[Backup] Initialized successfully')\n  }\n\n  /**\n   * Wait for task store to be ready\n   */\n  async function waitForTasks(timeout = 10000): Promise<void> {\n    const startTime = Date.now()\n\n    return new Promise((resolve) => {\n      const check = () => {\n        if (Array.isArray(taskStore.tasks)) {\n          resolve()\n          return\n        }\n\n        if (Date.now() - startTime > timeout) {\n          console.warn('[Backup] Timeout waiting for tasks')\n          resolve()\n          return\n        }\n\n        setTimeout(check, 100)\n      }\n      check()\n    })\n  }\n\n  // Lifecycle hooks\n  if (getCurrentInstance()) {\n    onMounted(() => {\n      // Delay initialization to ensure stores are ready\n      setTimeout(initialize, 1500)\n    })\n\n    onUnmounted(() => {\n      stopAutoBackup()\n    })\n  }\n\n  // ============================================================================\n  // Return Public API\n  // ============================================================================\n\n  return {\n    // State\n    config,\n    state: computed(() => state.value),\n    stats: computed(() => stats.value),\n    backupHistory: computed(() => backupHistory.value),\n\n    // Core operations\n    createBackup,\n    restoreBackup,\n\n    // History\n    getLatestBackup,\n    clearHistory,\n\n    // Auto-backup\n    startAutoBackup,\n    stopAutoBackup,\n\n    // Export/Import\n    exportBackup,\n    importBackup,\n    downloadBackup,\n    restoreFromFile,\n\n    // Utilities\n    hasHebrewContent,\n    getStatus,\n\n    // Initialize (can be called manually if needed)\n    initialize,\n\n    // BUG-059 FIX: Golden backup and safety methods\n    getGoldenBackup,\n    getMaxTaskCount,\n\n    // TASK-153: Validate golden backup before restore\n    validateGoldenBackup,\n\n    // Restore from golden backup (last known good state)\n    // TASK-153: Now filters out items deleted in Supabase before restoring\n    restoreFromGoldenBackup: async (skipValidation: boolean = false) => {\n      const golden = getGoldenBackup()\n      if (!golden) {\n        console.error('[Backup] No golden backup available')\n        return false\n      }\n\n      // TASK-153: Validate and warn about age/deleted items\n      if (!skipValidation) {\n        const validation = await validateGoldenBackup()\n        if (validation) {\n          if (validation.warnings.length > 0) {\n            console.warn('[Backup] Golden backup validation warnings:', validation.warnings)\n          }\n          console.log(`[Backup] Golden backup preview:`, {\n            tasks: `${validation.preview.tasks.toRestore}/${validation.preview.tasks.total} (${validation.preview.tasks.filtered} filtered)`,\n            projects: `${validation.preview.projects.toRestore}/${validation.preview.projects.total} (${validation.preview.projects.filtered} filtered)`,\n            groups: `${validation.preview.groups.toRestore}/${validation.preview.groups.total} (${validation.preview.groups.filtered} filtered)`\n          })\n        }\n      }\n\n      // TASK-153: Filter out items that are deleted in Supabase\n      const filteredGolden = await filterGoldenBackupData(golden)\n\n      console.log(`[Backup] Restoring from golden backup: ${filteredGolden.metadata?.taskCount} tasks (filtered from ${golden.metadata?.taskCount})`)\n      return await restoreBackup(filteredGolden)\n    },\n\n    // TASK-153: Get validation info for UI display before restore\n    getGoldenBackupValidation: validateGoldenBackup,\n\n    // TASK-154: Shadow Mirror (System 3) Recovery\n    fetchShadowBackup: async () => {\n      try {\n        const response = await fetch('/shadow-latest.json?t=' + Date.now())\n        if (!response.ok) throw new Error('Shadow snapshot not found')\n        return await response.json()\n      } catch (error) {\n        console.warn('[Backup] Shadow sync info not available:', error)\n        return null\n      }\n    },\n\n    restoreFromShadow: async (shadowData: any) => {\n      console.log(`[Backup] Restoring from Shadow Hub: ${shadowData.meta?.counts?.tasks} tasks`)\n      return await restoreBackup({\n        ...shadowData,\n        id: `shadow_${shadowData.meta.timestamp}`,\n        timestamp: shadowData.meta.timestamp,\n        type: 'emergency',\n        version: BACKUP_SCHEMA_VERSION,\n        checksum: '',\n        metadata: {\n          taskCount: shadowData.meta.counts.tasks,\n          projectCount: shadowData.meta.counts.projects,\n          groupCount: shadowData.meta.counts.groups\n        }\n      })\n    }\n  }\n}\n\n// Default export for convenience\nexport default useBackupSystem\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useBrainDump.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useBrowserTab.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCalendarCore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCalendarDragCreate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCanvasPerformanceTesting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCanvasProgressiveLoading.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCanvasRenderingOptimization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCanvasVirtualization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useContextMenu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCopy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useCrossTabSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'canvasStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":56,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2297,2300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2297,2300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'payload' is defined but never used. Allowed unused args must match /^_/u.","line":128,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":128,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'payload' is defined but never used. Allowed unused args must match /^_/u.","line":129,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":17},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":144,"column":60,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":144,"endColumn":77}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onUnmounted, getCurrentInstance, onMounted } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useUIStore } from '@/stores/ui'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useAuthStore } from '@/stores/auth'\nimport { useBroadcastChannelSync } from './sync/useBroadcastChannelSync'\nimport { useTimerLeaderElection } from './sync/useTimerLeaderElection'\nimport { useSupabaseRealtimeSync } from './sync/useSupabaseRealtimeSync'\n\n// Types for cross-tab messages\nexport interface CrossTabMessage {\n  id: string\n  type: 'task_operation' | 'ui_state_change' | 'canvas_change' | 'heartbeat' | 'timer_session'\n  timestamp: number\n  tabId: string\n  data: unknown\n}\n\nexport interface TimerSessionSync {\n  action: 'claim_leadership' | 'heartbeat' | 'session_update' | 'session_stop'\n  leaderId: string\n  sessionState?: unknown\n  timestamp: number\n}\n\nexport interface TaskOperation {\n  operation: 'create' | 'update' | 'delete' | 'bulk_update' | 'bulk_delete'\n  taskId?: string\n  taskIds?: string[]\n  taskData?: unknown\n  oldData?: unknown\n  timestamp: number\n}\n\nexport interface UIStateChange {\n  store: 'ui' | 'canvas'\n  action: string\n  data: unknown\n  timestamp: number\n}\n\nexport interface CanvasChange {\n  action: 'node_move' | 'section_collapse' | 'viewport_change'\n  data: unknown\n  timestamp: number\n}\n\n// Global state for synchronization\nconst isListening = ref(false)\nconst pendingLocalOperations = ref<Map<string, TaskOperation>>(new Map())\n\nexport function useCrossTabSync() {\n  const authStore = useAuthStore()\n  const taskStore = useTaskStore()\n  const uiStore = useUIStore()\n  const canvasStore = useCanvasStore()\n\n  // Initialize sub-composables\n  const { tabId: currentTabId, connect, disconnect, broadcast, onMessage } = useBroadcastChannelSync()\n\n  // Define callbacks for timer state updates (set by timer store)\n  let _onTimerSessionUpdate: ((session: unknown) => void) | null = null\n  let _onBecomeLeader: (() => void) | null = null\n  let _onLoseLeadership: (() => void) | null = null\n\n  const {\n    isLeader: isTimerLeader,\n    leaderState: timerLeaderState,\n    claimLeadership: claimTimerLeadership,\n    handleLeaderMessage,\n    cleanup: cleanupLeader\n  } = useTimerLeaderElection({\n    tabId: currentTabId.value,\n    broadcastMessage: (msg: any) => broadcast('timer_session', msg),\n    onBecomeLeader: () => _onBecomeLeader?.(),\n    onLoseLeadership: () => _onLoseLeadership?.(),\n    onSessionUpdate: (session) => _onTimerSessionUpdate?.(session)\n  })\n\n  const { subscribe: subscribeRealtime, unsubscribe: unsubscribeRealtime } = useSupabaseRealtimeSync({\n    userId: authStore.user?.id\n  })\n\n  // Message processing logic\n  const handleTaskOperation = async (operation: TaskOperation) => {\n    switch (operation.operation) {\n      case 'create':\n        if (operation.taskData && operation.taskId) {\n          await taskStore.loadFromDatabase()\n        }\n        break\n      case 'update':\n        if (operation.taskId && operation.taskData) {\n          const task = taskStore.tasks.find(t => t.id === operation.taskId)\n          if (task) Object.assign(task, operation.taskData)\n        }\n        break\n      case 'delete':\n        if (operation.taskId) {\n          const index = taskStore.tasks.findIndex(t => t.id === operation.taskId)\n          if (index > -1) taskStore.tasks.splice(index, 1)\n        }\n        break\n    }\n  }\n\n  const handleUIStateChange = (change: UIStateChange) => {\n    if (change.store === 'ui') {\n      if (change.action === 'sidebar_toggle') {\n        const data = change.data as { isOpen: boolean }\n        uiStore.mainSidebarVisible = data.isOpen\n      }\n    }\n  }\n\n  // Set up message handlers\n  onMessage('task_operation', handleTaskOperation)\n  onMessage('ui_state_change', handleUIStateChange)\n  onMessage('timer_session', handleLeaderMessage)\n\n  const initialize = () => {\n    if (isListening.value) return\n    connect()\n    isListening.value = true\n\n    if (authStore.user?.id) {\n      subscribeRealtime(\n        (payload) => { /* handle task change */ },\n        (payload) => { /* handle timer change */ }\n      )\n    }\n  }\n\n  const cleanup = () => {\n    disconnect()\n    unsubscribeRealtime()\n    cleanupLeader()\n    isListening.value = false\n  }\n\n  const trackLocalOperation = (operation: TaskOperation) => {\n    if (operation.taskId) {\n      pendingLocalOperations.value.set(operation.taskId, operation)\n      setTimeout(() => pendingLocalOperations.value.delete(operation.taskId!), 5000)\n    }\n  }\n\n  // Lifecycle\n  if (getCurrentInstance()) {\n    onMounted(initialize)\n    onUnmounted(cleanup)\n  } else {\n    initialize()\n  }\n\n  return {\n    isListening,\n    currentTabId,\n    pendingLocalOperations,\n    isTimerLeader,\n    timerLeaderState,\n    initialize,\n    cleanup,\n    broadcastTimerSession: (session: unknown) => {\n      if (isTimerLeader.value) {\n        broadcast('timer_session', {\n          action: session ? 'session_update' : 'session_stop',\n          leaderId: currentTabId.value,\n          sessionState: session,\n          timestamp: Date.now()\n        })\n      }\n    },\n    claimTimerLeadership,\n    setTimerCallbacks: (callbacks: {\n      onSessionUpdate?: (session: unknown) => void\n      onBecomeLeader?: () => void\n      onLoseLeadership?: () => void\n    }) => {\n      _onTimerSessionUpdate = callbacks.onSessionUpdate || null\n      _onBecomeLeader = callbacks.onBecomeLeader || null\n      _onLoseLeadership = callbacks.onLoseLeadership || null\n    },\n    trackLocalOperation,\n    broadcastTaskOperation: (op: TaskOperation) => broadcast('task_operation', op),\n    broadcastUIStateChange: (change: UIStateChange) => broadcast('ui_state_change', change),\n    broadcastCanvasChange: (change: CanvasChange) => broadcast('canvas_change', change)\n  }\n}\n\n// Singleton for easier store access\nlet _syncInstance: ReturnType<typeof useCrossTabSync> | null = null\nexport const getCrossTabSync = () => {\n  if (!_syncInstance) _syncInstance = useCrossTabSync()\n  return _syncInstance\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useDatabaseAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useDateTransition.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":44}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TASK-082: Date Transition Composable\n *\n * Watches for midnight (00:00) transitions and emits events when the day changes.\n * Used by canvas to auto-move tasks from \"Today\" to \"Overdue\" groups.\n *\n * Features:\n * - Calculates time until next midnight and sets precise timeout\n * - Continuous monitoring after each midnight\n * - Cleanup on component unmount\n * - Manual trigger for testing\n */\n\nimport { ref, onMounted, onUnmounted, watch } from 'vue'\n\nexport interface DateTransitionOptions {\n  /** Callback when day changes */\n  onDayChange?: (previousDate: Date, newDate: Date) => void\n  /** Whether to start watching immediately (default: true) */\n  autoStart?: boolean\n  /** Enable debug logging (default: false) */\n  debug?: boolean\n}\n\nexport function useDateTransition(options: DateTransitionOptions = {}) {\n  const { onDayChange, autoStart = true, debug = false } = options\n\n  // Current tracked date (just the day, month, year)\n  const currentDate = ref<Date>(new Date())\n  const isWatching = ref(false)\n\n  // Track the timeout/interval ID for cleanup\n  let midnightTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  const log = (...args: unknown[]) => {\n    if (debug) {\n      console.log('[useDateTransition]', ...args)\n    }\n  }\n\n  /**\n   * Get milliseconds until next midnight\n   */\n  const getMsUntilMidnight = (): number => {\n    const now = new Date()\n    const tomorrow = new Date(now)\n    tomorrow.setDate(tomorrow.getDate() + 1)\n    tomorrow.setHours(0, 0, 0, 0)\n    return tomorrow.getTime() - now.getTime()\n  }\n\n  /**\n   * Check if the date has changed since last check\n   */\n  const hasDateChanged = (): boolean => {\n    const now = new Date()\n    const lastDate = currentDate.value\n\n    return (\n      now.getDate() !== lastDate.getDate() ||\n      now.getMonth() !== lastDate.getMonth() ||\n      now.getFullYear() !== lastDate.getFullYear()\n    )\n  }\n\n  /**\n   * Handle the date transition\n   */\n  const handleDateTransition = () => {\n    const previousDate = new Date(currentDate.value)\n    const newDate = new Date()\n\n    log('Date transition detected!', {\n      from: previousDate.toDateString(),\n      to: newDate.toDateString()\n    })\n\n    // Update tracked date\n    currentDate.value = newDate\n\n    // Call the callback if provided\n    if (onDayChange) {\n      try {\n        onDayChange(previousDate, newDate)\n      } catch (error) {\n        console.error('[useDateTransition] Error in onDayChange callback:', error)\n      }\n    }\n\n    // Schedule next midnight check\n    scheduleMidnightCheck()\n  }\n\n  /**\n   * Schedule a check for the next midnight\n   */\n  const scheduleMidnightCheck = () => {\n    // Clear any existing timeout\n    if (midnightTimeoutId) {\n      clearTimeout(midnightTimeoutId)\n      midnightTimeoutId = null\n    }\n\n    if (!isWatching.value) {\n      return\n    }\n\n    const msUntilMidnight = getMsUntilMidnight()\n\n    // Add a small buffer (100ms) to ensure we're past midnight\n    const timeoutMs = msUntilMidnight + 100\n\n    log(`Scheduling midnight check in ${Math.round(timeoutMs / 1000 / 60)} minutes`)\n\n    midnightTimeoutId = setTimeout(() => {\n      if (hasDateChanged()) {\n        handleDateTransition()\n      } else {\n        // In case of timing edge cases, check again in 1 minute\n        log('Date has not changed yet, rechecking in 1 minute')\n        midnightTimeoutId = setTimeout(() => {\n          if (hasDateChanged()) {\n            handleDateTransition()\n          } else {\n            // Reschedule for next midnight\n            scheduleMidnightCheck()\n          }\n        }, 60000) // 1 minute\n      }\n    }, timeoutMs)\n  }\n\n  /**\n   * Start watching for date transitions\n   */\n  const startWatching = () => {\n    if (isWatching.value) {\n      log('Already watching')\n      return\n    }\n\n    log('Starting date transition watcher')\n    isWatching.value = true\n    currentDate.value = new Date()\n    scheduleMidnightCheck()\n  }\n\n  /**\n   * Stop watching for date transitions\n   */\n  const stopWatching = () => {\n    log('Stopping date transition watcher')\n    isWatching.value = false\n\n    if (midnightTimeoutId) {\n      clearTimeout(midnightTimeoutId)\n      midnightTimeoutId = null\n    }\n  }\n\n  /**\n   * Manually trigger a date transition check (useful for testing)\n   */\n  const triggerCheck = () => {\n    log('Manual trigger check')\n    if (hasDateChanged()) {\n      handleDateTransition()\n    } else {\n      log('No date change detected')\n    }\n  }\n\n  /**\n   * Manually trigger a transition (for testing purposes)\n   * This simulates the day changing without waiting for midnight\n   */\n  const simulateTransition = () => {\n    log('Simulating date transition')\n    handleDateTransition()\n  }\n\n  // Auto-start if enabled\n  onMounted(() => {\n    if (autoStart) {\n      startWatching()\n    }\n  })\n\n  // Cleanup on unmount\n  onUnmounted(() => {\n    stopWatching()\n  })\n\n  // Also watch for page visibility changes - recheck when page becomes visible\n  if (typeof document !== 'undefined') {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible' && isWatching.value) {\n        log('Page became visible, checking for date change')\n        if (hasDateChanged()) {\n          handleDateTransition()\n        } else {\n          // Reschedule in case timeout was imprecise while tab was hidden\n          scheduleMidnightCheck()\n        }\n      }\n    }\n\n    onMounted(() => {\n      document.addEventListener('visibilitychange', handleVisibilityChange)\n    })\n\n    onUnmounted(() => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange)\n    })\n  }\n\n  return {\n    /** Current tracked date */\n    currentDate,\n    /** Whether the watcher is active */\n    isWatching,\n    /** Start watching for date transitions */\n    startWatching,\n    /** Stop watching for date transitions */\n    stopWatching,\n    /** Manually trigger a check */\n    triggerCheck,\n    /** Simulate a date transition (for testing) */\n    simulateTransition,\n    /** Get milliseconds until next midnight */\n    getMsUntilMidnight\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useDemoGuard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useDragAndDrop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useDynamicImports.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stats' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":319,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":319,"endColumn":14}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1893,1896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1893,1896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":289,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7291,7294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7291,7294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":289,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7301,7304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7301,7304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7522,7525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7522,7525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7532,7535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7532,7535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Dynamic Import Manager - Standardized Import System\n *\n * Fixes dynamic import conflicts by providing a centralized, caching system\n * for all composables and components that need lazy loading\n */\n\nimport { ref as _ref, reactive } from 'vue'\n\n// Type definitions for dynamic imports\ntype _DynamicImport<T = unknown> = () => Promise<T>\ntype ImportCache = Map<string, unknown>\n\n// Import configuration interface\ninterface ImportConfig {\n  path: () => Promise<unknown>\n  preload?: boolean\n  timeout: number\n}\n\n// Global import cache to prevent duplicate loading\nconst _importCache: ImportCache = new Map()\n\n// Loading states for tracking imports\nconst loadingStates = reactive<Record<string, boolean>>({})\n\n// Error states for tracking failed imports\nconst errorStates = reactive<Record<string, Error | null>>({})\n\n/**\n * Import configuration for common composables\n * NOTE: PouchDB/CouchDB sync entries removed Jan 2026 - app uses Supabase now\n */\nexport const IMPORT_CONFIG = {\n  // Undo/Redo system imports\n  useUnifiedUndoRedo: {\n    path: () => import('@/composables/useUnifiedUndoRedo'),\n    preload: false, // Load on demand\n    timeout: 3000\n  },\n\n  // Canvas-related imports\n  CanvasView: {\n    path: () => import('@/views/CanvasView.vue'),\n    preload: false, // Load on demand\n    timeout: 5000\n  },\n\n  // Store imports\n  useTasksStore: {\n    path: () => import('@/stores/tasks'),\n    preload: false, // Load on demand\n    timeout: 3000\n  },\n\n  useCanvasStore: {\n    path: () => import('@/stores/canvas'),\n    preload: false, // Load on demand\n    timeout: 3000\n  }\n} as const\n\ntype ImportKey = keyof typeof IMPORT_CONFIG\n\n/**\n * Dynamic import manager with caching and error handling\n */\nexport class DynamicImportManager {\n  private cache: ImportCache = new Map()\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private loadingPromises: Map<string, Promise<any>> = new Map()\n\n  /**\n   * Import a module with caching, timeout, and error handling\n   */\n  async import<T = unknown>(key: ImportKey): Promise<T> {\n    const config = IMPORT_CONFIG[key]\n\n    if (!config) {\n      throw new Error(`Import key \"${key}\" not found in IMPORT_CONFIG`)\n    }\n\n    // Return cached version if available\n    if (this.cache.has(key)) {\n      return this.cache.get(key) as T\n    }\n\n    // Return existing promise if currently loading\n    if (this.loadingPromises.has(key)) {\n      return this.loadingPromises.get(key) as Promise<T>\n    }\n\n    // Create and store loading promise\n    const loadingPromise = this.performImport<T>(key, config)\n    this.loadingPromises.set(key, loadingPromise)\n\n    try {\n      const result = await loadingPromise\n      this.cache.set(key, result)\n      errorStates[key] = null\n      return result\n    } catch (error) {\n      errorStates[key] = error as Error\n      throw error\n    } finally {\n      this.loadingPromises.delete(key)\n    }\n  }\n\n  /**\n   * Perform the actual import with timeout\n   */\n  private async performImport<T>(key: string, config: ImportConfig): Promise<T> {\n    loadingStates[key] = true\n\n    try {\n      const importPromise = config.path()\n\n      // Add timeout\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => {\n          reject(new Error(`Import timeout for \"${key}\" after ${config.timeout}ms`))\n        }, config.timeout)\n      })\n\n      const module = await Promise.race([importPromise, timeoutPromise]) as { default?: T } | T\n\n\n      return (module as { default?: T }).default || module as T\n\n    } catch (error) {\n      console.error(`❌ Failed to import: ${key}`, error)\n      throw new Error(`Failed to import ${key}: ${(error as Error).message}`)\n    } finally {\n      loadingStates[key] = false\n    }\n  }\n\n  /**\n   * Preload critical imports\n   */\n  async preloadCritical(): Promise<void> {\n    const criticalImports = Object.entries(IMPORT_CONFIG)\n      .filter(([_, config]) => config.preload)\n      .map(([key]) => key as ImportKey)\n\n\n\n    await Promise.allSettled(\n      criticalImports.map(key =>\n        this.import(key).catch(error => {\n          console.warn(`⚠️ Failed to preload ${key}:`, error.message)\n          return null\n        })\n      )\n    )\n\n\n  }\n\n  /**\n   * Check if an import is currently loading\n   */\n  isLoading(key: ImportKey): boolean {\n    return loadingStates[key] || this.loadingPromises.has(key)\n  }\n\n  /**\n   * Check if an import has failed\n   */\n  hasError(key: ImportKey): boolean {\n    return errorStates[key] !== null\n  }\n\n  /**\n   * Get the error for an import\n   */\n  getError(key: ImportKey): Error | null {\n    return errorStates[key]\n  }\n\n  /**\n   * Clear cache for a specific import or all imports\n   */\n  clearCache(key?: ImportKey): void {\n    if (key) {\n      this.cache.delete(key)\n      errorStates[key] = null\n    } else {\n      this.cache.clear()\n      Object.keys(errorStates).forEach(k => {\n        errorStates[k] = null\n      })\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats() {\n    return {\n      cached: this.cache.size,\n      loading: this.loadingPromises.size,\n      errors: Object.values(errorStates).filter(e => e !== null).length,\n      total: Object.keys(IMPORT_CONFIG).length\n    }\n  }\n}\n\n// Global instance\nconst dynamicImportManager = new DynamicImportManager()\n\n/**\n * Composable for using dynamic imports\n */\nexport function useDynamicImports() {\n  /**\n   * Import a composable or component\n   */\n  const importModule = async <T = unknown>(key: ImportKey): Promise<T> => {\n    return await dynamicImportManager.import<T>(key)\n  }\n\n  /**\n   * Import multiple modules in parallel\n   */\n  const importModules = async <T = unknown>(keys: ImportKey[]): Promise<T[]> => {\n    const promises = keys.map(key => dynamicImportManager.import<T>(key))\n    return await Promise.all(promises)\n  }\n\n  /**\n   * Import with fallback\n   */\n  const importWithFallback = async <T = unknown>(\n    key: ImportKey,\n    fallback: T | (() => T)\n  ): Promise<T> => {\n    try {\n      return await dynamicImportManager.import<T>(key)\n    } catch (error) {\n      console.warn(`⚠️ Import failed for ${key}, using fallback:`, (error as Error).message)\n      return typeof fallback === 'function' ? (fallback as () => T)() : fallback\n    }\n  }\n\n  /**\n   * Check import status\n   */\n  const getStatus = (key: ImportKey) => ({\n    loading: dynamicImportManager.isLoading(key),\n    error: dynamicImportManager.hasError(key),\n    errorDetail: dynamicImportManager.getError(key)\n  })\n\n  /**\n   * Preload specific imports\n   */\n  const preload = async (keys: ImportKey[]): Promise<void> => {\n    await Promise.allSettled(\n      keys.map(key =>\n        dynamicImportManager.import(key).catch(error => {\n          console.warn(`⚠️ Failed to preload ${key}:`, error.message)\n        })\n      )\n    )\n  }\n\n  return {\n    import: importModule,\n    importModules,\n    importWithFallback,\n    getStatus,\n    preload,\n    manager: dynamicImportManager\n  }\n}\n\n/**\n * Convenience functions for common imports\n * NOTE: PouchDB/CouchDB sync helpers removed Jan 2026 - app uses Supabase now\n */\n\n// Helper type for dynamic modules\ntype ModuleShape = Record<string, unknown>\n\n// Undo/Redo composable with caching\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const getUndoRedoComposable = async (): Promise<(...args: any[]) => any> => {\n  const module = await dynamicImportManager.import<ModuleShape>('useUnifiedUndoRedo')\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (module.useUnifiedUndoRedo || module) as (...args: any[]) => any\n}\n\n// Store imports with caching\nexport const getTasksStore = async () => {\n  const module = await dynamicImportManager.import<ModuleShape>('useTasksStore')\n  return module.useTasksStore || module.default || module\n}\n\nexport const getCanvasStore = async () => {\n  const module = await dynamicImportManager.import<ModuleShape>('useCanvasStore')\n  return module.useCanvasStore || module.default || module\n}\n\n/**\n * Initialize the dynamic import system\n * Call this early in app startup\n */\nexport const initializeDynamicImports = async (): Promise<void> => {\n\n\n  // Preload critical imports\n  await dynamicImportManager.preloadCritical()\n\n\n\n  // Log statistics\n  const stats = dynamicImportManager.getStats()\n\n}\n\n// Export the ImportKey type for external use\nexport type { ImportKey }\n\nexport default useDynamicImports","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useErrorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useFavicon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useFocusManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useFocusMode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useGroupSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useHebrewAlignment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useHorizontalDragScroll.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":325,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":325,"endColumn":40,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[10645,10678],"text":"// @ts-expect-error - internal handlers"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":327,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":327,"endColumn":40,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[10802,10835],"text":"// @ts-expect-error - internal handlers"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onMounted, onUnmounted, type Ref } from 'vue'\n\nexport interface HorizontalDragScrollOptions {\n  /**\n   * Minimum drag distance before scrolling starts\n   */\n  threshold?: number\n\n  /**\n   * Scroll multiplier for drag sensitivity\n   */\n  sensitivity?: number\n\n  /**\n   * Momentum friction coefficient (0-1)\n   */\n  friction?: number\n\n  /**\n   * Enable touch events for mobile\n   */\n  touchEnabled?: boolean\n\n  /**\n   * CSS cursor during drag\n   */\n  dragCursor?: string\n\n  /**\n   * Callback when drag starts\n   */\n  onDragStart?: () => void\n\n  /**\n   * Callback when drag ends\n   */\n  onDragEnd?: () => void\n}\n\nexport function useHorizontalDragScroll(\n  scrollContainer: Ref<HTMLElement | null>,\n  options: HorizontalDragScrollOptions = {}\n) {\n  const {\n    threshold = 10,\n    sensitivity = 1,\n    friction = 0.95,\n    touchEnabled = true,\n    dragCursor = 'grabbing',\n    onDragStart,\n    onDragEnd\n  } = options\n\n  const isPreparingToDrag = ref(false)\n  const isDragging = ref(false)\n  const isScrolling = ref(false)\n  const startX = ref(0)\n  const startY = ref(0)\n  const scrollLeft = ref(0)\n  const velocity = ref(0)\n  const lastX = ref(0)\n  const animationFrameId = ref<number>()\n\n  // Comprehensive drag intent detection - FIXED: Check BEFORE preventDefault\n  const detectDragIntent = (target: HTMLElement, _clientX: number, _clientY: number): boolean => {\n    // Check for draggable elements (from mapping documentation)\n    const draggableElement = target.closest<HTMLElement>(\n      '.draggable, [data-draggable=\"true\"], [draggable=\"true\"], .task-card, .inbox-task-card, ' +\n      '[data-inbox-task=\"true\"], .vuedraggable, .vue-flow__node, .vue-flow__handle, ' +\n      '.drag-area, .task-item, .task-item-mini, .tasks-container, ' + // More comprehensive list\n      '.calendar-event, .time-slot, .week-event, .month-event'\n    )\n\n    if (draggableElement) {\n      console.log('🎯 [HorizontalDragScroll] Detected drag intent, allowing drag-and-drop')\n      return true\n    }\n\n    // Check for interactive elements within draggable components\n    const interactiveElement = target.closest<HTMLElement>(\n      'button, input, textarea, select, [role=\"button\"], .draggable-handle, ' +\n      '.status-icon-button, .task-title, .card-header, .metadata-badges, .card-actions, .task-item-mini, ' +\n      '.resize-handle, .event-content, .event-actions'\n    )\n\n    if (interactiveElement) {\n      console.log('🔘 [HorizontalDragScroll] Detected interactive element, allowing interaction')\n      return true\n    }\n\n    return false\n  }\n\n  // Momentum scrolling\n  const applyMomentum = () => {\n    if (!scrollContainer.value) return\n\n    if (Math.abs(velocity.value) > 0.1) {\n      scrollContainer.value.scrollLeft += velocity.value\n      velocity.value *= friction\n      animationFrameId.value = requestAnimationFrame(applyMomentum)\n    } else {\n      velocity.value = 0\n      isScrolling.value = false\n    }\n  }\n\n  // Start drag (only called after drag intent check passes)\n  const handleStart = (clientX: number, clientY: number, target: HTMLElement) => {\n    if (!scrollContainer.value) return\n\n    // Check if target is within our scroll container\n    if (!scrollContainer.value.contains(target)) {\n      return // Only handle events within our container\n    }\n\n    isPreparingToDrag.value = true\n    isDragging.value = false\n    startX.value = clientX\n    startY.value = clientY\n    scrollLeft.value = scrollContainer.value.scrollLeft\n    lastX.value = clientX\n    velocity.value = 0\n\n    // Cancel any existing momentum\n    if (animationFrameId.value) {\n      cancelAnimationFrame(animationFrameId.value)\n    }\n\n    // Don't set styles here, wait for actual drag in handleMove\n  }\n\n  // We don't onDragStart here anymore, we do it in handleMove once threshold is met\n\n  // Drag move\n  const handleMove = (clientX: number, clientY: number, e: MouseEvent | TouchEvent) => {\n    if ((!isDragging.value && !isPreparingToDrag.value) || !scrollContainer.value) return\n\n    const deltaX = clientX - startX.value\n    const deltaY = clientY - startY.value\n\n    // Check if we've moved enough to start scrolling\n    if (Math.abs(deltaX) < threshold && Math.abs(deltaY) < threshold) {\n      return\n    }\n\n    // Now that we've crossed the threshold, check if move is primarily horizontal\n    if (!isDragging.value) {\n      // If move is primarily vertical, this is likely a sort/drag within a column, NOT a board scroll\n      if (Math.abs(deltaY) > Math.abs(deltaX)) {\n        isPreparingToDrag.value = false // Yield to vertical dragging\n        return\n      }\n\n      isDragging.value = true\n      isPreparingToDrag.value = false\n\n      // Stop event propagation and prevent default once we're SURE it's a board scroll\n      e.preventDefault()\n      e.stopPropagation()\n\n      // Set cursor and styles\n      if (scrollContainer.value) {\n        scrollContainer.value.style.cursor = dragCursor\n        scrollContainer.value.style.userSelect = 'none'\n        scrollContainer.value.style.touchAction = 'none' // Prevent all touch after we take over\n      }\n\n      onDragStart?.()\n      return\n    }\n\n    // If we're already dragging, always prevent default browser behavior\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Calculate velocity for momentum\n    const currentVelocity = (clientX - lastX.value) * sensitivity\n    velocity.value = currentVelocity * 0.8 + velocity.value * 0.2 // Smooth velocity\n    lastX.value = clientX\n\n    // Apply scroll - only modify scrollLeft, don't transform elements\n    const walk = deltaX * sensitivity\n    const newScrollLeft = scrollLeft.value - walk\n\n    // Ensure we don't scroll beyond boundaries\n    const maxScrollLeft = scrollContainer.value.scrollWidth - scrollContainer.value.clientWidth\n    scrollContainer.value.scrollLeft = Math.max(0, Math.min(newScrollLeft, maxScrollLeft))\n\n    // Prevent default browser behavior and stop propagation\n    e.preventDefault()\n    e.stopPropagation()\n  }\n\n  // End drag\n  const handleEnd = (e?: MouseEvent | TouchEvent) => {\n    const wasDragging = isDragging.value\n    isPreparingToDrag.value = false\n    isDragging.value = false\n\n    // Reset cursor and styles\n    if (scrollContainer.value) {\n      scrollContainer.value.style.cursor = ''\n      scrollContainer.value.style.userSelect = ''\n      scrollContainer.value.style.touchAction = ''\n    }\n\n    // Stop event propagation\n    if (e) {\n      e.stopPropagation()\n    }\n\n    // Start momentum scrolling if we have velocity\n    if (wasDragging && Math.abs(velocity.value) > 0.5) {\n      isScrolling.value = true\n      applyMomentum()\n    }\n\n    if (wasDragging) {\n      onDragEnd?.()\n    }\n  }\n\n  // Mouse events\n  const handleMouseDown = (e: MouseEvent) => {\n    // If the event was already handled (e.g. by vuedraggable), respect it\n    if (e.defaultPrevented) return\n\n    // Check for interactive/draggable elements that should manage their own clicks/drags\n    const isInteractingWithDraggable = detectDragIntent(e.target as HTMLElement, e.clientX, e.clientY)\n    if (isInteractingWithDraggable) {\n      console.log('🎯 [HorizontalDragScroll] Allowing event to pass to draggable child')\n      return\n    }\n\n    // DON'T preventDefault or stopPropagation here!\n    // We only want to start scrolling if the user moves beyond the threshold.\n    handleStart(e.clientX, e.clientY, e.target as HTMLElement)\n\n    // Add global listeners when potential drag starts\n    if (scrollContainer.value) {\n      const container = scrollContainer.value as HTMLElement & { _globalMouseMoveHandler?: (e: MouseEvent) => void, _globalMouseUpHandler?: (e: MouseEvent) => void }\n      if (container._globalMouseMoveHandler) document.addEventListener('mousemove', container._globalMouseMoveHandler)\n      if (container._globalMouseUpHandler) document.addEventListener('mouseup', container._globalMouseUpHandler)\n    }\n  }\n\n  const handleMouseMove = (e: MouseEvent) => {\n    if (!isPreparingToDrag.value && !isDragging.value) return\n    handleMove(e.clientX, e.clientY, e)\n  }\n\n  const handleGlobalMouseMove = (e: MouseEvent) => {\n    if (isPreparingToDrag.value || isDragging.value) {\n      handleMouseMove(e)\n    }\n  }\n\n  const handleGlobalMouseUp = (e: MouseEvent) => {\n    handleEnd(e)\n    // ALWAYS remove these if we have them\n    if (scrollContainer.value) {\n      const container = scrollContainer.value as HTMLElement & { _globalMouseMoveHandler?: (e: MouseEvent) => void, _globalMouseUpHandler?: (e: MouseEvent) => void }\n      if (container._globalMouseMoveHandler) document.removeEventListener('mousemove', container._globalMouseMoveHandler)\n      if (container._globalMouseUpHandler) document.removeEventListener('mouseup', container._globalMouseUpHandler)\n    }\n  }\n\n  // Touch events\n  const handleTouchStart = (e: TouchEvent) => {\n    if (!touchEnabled) return\n    const touch = e.touches[0]\n\n    // FIXED: Check for draggable elements BEFORE calling preventDefault()\n    const shouldAllowDrag = detectDragIntent(e.target as HTMLElement, touch.clientX, touch.clientY)\n    if (shouldAllowDrag) {\n      // Don't interfere with drag operations - let them proceed naturally\n      return\n    }\n\n    // DON'T prevent default here. If we do, we block ALL native gestures including vertical scroll.\n    // handleStart will set up the initial coordinates.\n    // handleMove will decide whether to take over (preventDefault) or yield.\n    handleStart(touch.clientX, touch.clientY, e.target as HTMLElement)\n  }\n\n  const handleTouchMove = (e: TouchEvent) => {\n    if (!touchEnabled || (!isPreparingToDrag.value && !isDragging.value)) return\n    const touch = e.touches[0]\n    // handleMove will call preventDefault() ONLY if it's a horizontal scroll\n    handleMove(touch.clientX, touch.clientY, e)\n  }\n\n  const handleTouchEnd = (e: TouchEvent) => {\n    if (!touchEnabled || !isDragging.value) return\n    e.preventDefault()\n    e.stopPropagation()\n    handleEnd(e)\n  }\n\n  // Wheel event for smooth horizontal scrolling\n  const handleWheel = (e: WheelEvent) => {\n    if (!scrollContainer.value) return\n\n    // Check if we can scroll horizontally\n    const canScrollHorizontally =\n      scrollContainer.value.scrollWidth > scrollContainer.value.clientWidth\n\n    if (canScrollHorizontally && e.shiftKey) {\n      e.preventDefault()\n      scrollContainer.value.scrollLeft += e.deltaY\n    }\n  }\n\n  // Setup event listeners\n  onMounted(() => {\n    if (!scrollContainer.value) return\n\n    const container = scrollContainer.value\n\n    // Mouse events - only on container, not document\n    container.addEventListener('mousedown', handleMouseDown)\n\n      // Store global handlers for cleanup and dynamic attachment\n      // @ts-ignore - internal handlers\n      ; (container as unknown as Record<string, unknown>)._globalMouseMoveHandler = handleGlobalMouseMove as unknown\n      // @ts-ignore - internal handlers\n      ; (container as unknown as Record<string, unknown>)._globalMouseUpHandler = handleGlobalMouseUp as unknown\n\n    // Touch events\n    if (touchEnabled) {\n      container.addEventListener('touchstart', handleTouchStart, { passive: false })\n      container.addEventListener('touchmove', handleTouchMove, { passive: false })\n      container.addEventListener('touchend', handleTouchEnd)\n      container.addEventListener('touchcancel', handleTouchEnd)\n    }\n\n    // Wheel event\n    container.addEventListener('wheel', handleWheel, { passive: false })\n  })\n\n  // Cleanup\n  onUnmounted(() => {\n    if (animationFrameId.value) {\n      cancelAnimationFrame(animationFrameId.value)\n    }\n\n    if (!scrollContainer.value) return\n\n    const container = scrollContainer.value as HTMLElement & { _globalMouseMoveHandler?: (e: MouseEvent) => void, _globalMouseUpHandler?: (e: MouseEvent) => void }\n\n    container.removeEventListener('mousedown', handleMouseDown)\n\n    // Clean up global listeners if they exist\n    if (container._globalMouseMoveHandler) {\n      document.removeEventListener('mousemove', container._globalMouseMoveHandler)\n    }\n    if (container._globalMouseUpHandler) {\n      document.removeEventListener('mouseup', container._globalMouseUpHandler)\n    }\n\n    if (touchEnabled) {\n      container.removeEventListener('touchstart', handleTouchStart)\n      container.removeEventListener('touchmove', handleTouchMove)\n      container.removeEventListener('touchend', handleTouchEnd)\n      container.removeEventListener('touchcancel', handleTouchEnd)\n    }\n\n    container.removeEventListener('wheel', handleWheel)\n\n    const containerCleanup = container as unknown as Record<string, unknown>\n    delete containerCleanup._globalMouseMoveHandler\n    delete containerCleanup._globalMouseUpHandler\n  })\n\n  // Public methods\n  const scrollTo = (position: number, smooth = true) => {\n    if (!scrollContainer.value) return\n\n    if (smooth) {\n      scrollContainer.value.scrollTo({\n        left: position,\n        behavior: 'smooth'\n      })\n    } else {\n      scrollContainer.value.scrollLeft = position\n    }\n  }\n\n  const scrollBy = (delta: number, smooth = true) => {\n    if (!scrollContainer.value) return\n\n    if (smooth) {\n      scrollContainer.value.scrollBy({\n        left: delta,\n        behavior: 'smooth'\n      })\n    } else {\n      scrollContainer.value.scrollLeft += delta\n    }\n  }\n\n  const scrollToElement = (element: HTMLElement, offset = 0) => {\n    if (!scrollContainer.value) return\n\n    const containerRect = scrollContainer.value.getBoundingClientRect()\n    const elementRect = element.getBoundingClientRect()\n\n    const targetScroll = elementRect.left - containerRect.left + scrollContainer.value.scrollLeft - offset\n\n    scrollTo(targetScroll, true)\n  }\n\n  return {\n    isDragging,\n    isScrolling,\n    scrollTo,\n    scrollBy,\n    scrollToElement\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useInboxDrag.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useInboxFiltering.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":150,"column":65,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":150,"endColumn":88}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue'\nimport { useTaskStore, type Task } from '@/stores/tasks'\n// TASK-144: Use centralized duration categories\nimport { type DurationCategory, matchesDurationCategory } from '@/utils/durationCategories'\n\nexport function useInboxFiltering() {\n    const taskStore = useTaskStore()\n\n    // Filter state\n    const activeTimeFilter = ref<'all' | 'now' | 'today' | 'tomorrow' | 'thisWeek' | 'noDate'>('all')\n    const unscheduledOnly = ref(false)\n    const selectedPriority = ref<'high' | 'medium' | 'low' | null>(null)\n    const selectedProject = ref<string | null>(null)\n    const selectedDuration = ref<DurationCategory | null>(null)\n\n    // Helper functions for date calculations\n    const getToday = () => {\n        const today = new Date()\n        today.setHours(0, 0, 0, 0)\n        return today\n    }\n\n    const getTomorrow = () => {\n        const tomorrow = new Date(getToday())\n        tomorrow.setDate(tomorrow.getDate() + 1)\n        return tomorrow\n    }\n\n    const getWeekEnd = () => {\n        const weekEnd = new Date(getToday())\n        weekEnd.setDate(weekEnd.getDate() + 7)\n        return weekEnd\n    }\n\n    const isThisWeek = (dateStr?: string) => {\n        if (!dateStr) return false\n        const today = getToday()\n        const weekEnd = getWeekEnd()\n        const date = new Date(dateStr)\n        date.setHours(0, 0, 0, 0)\n        return date >= today && date < weekEnd\n    }\n\n    const hasDate = (task: Task) => {\n        // Check dueDate first (set via context menu)\n        if (task.dueDate) return true\n        // Check instances (new format)\n        if (task.instances && task.instances.length > 0) {\n            return task.instances.some((inst) => inst.scheduledDate)\n        }\n        // Fallback to legacy scheduledDate\n        return !!task.scheduledDate\n    }\n\n    const isScheduledOnCalendar = (task: Task): boolean => {\n        if (!task.instances || task.instances.length === 0) return false\n        return task.instances.some((inst) => inst.scheduledDate)\n    }\n\n    // Get ONLY inbox tasks (tasks without canvas position, excluding done tasks)\n    const baseInboxTasks = computed(() =>\n        taskStore.filteredTasks.filter(task =>\n            !task.canvasPosition && task.status !== 'done'\n        )\n    )\n\n    // Check if task is scheduled/due for a specific date\n    const isTaskForDate = (task: Task, dateStr: string): boolean => {\n        // Check dueDate first (set via context menu \"Set Due Date\")\n        if (task.dueDate === dateStr) return true\n        // Check instances (calendar scheduling)\n        if (task.instances && task.instances.length > 0) {\n            if (task.instances.some((inst) => inst.scheduledDate === dateStr)) return true\n        }\n        // Check legacy scheduledDate\n        if (task.scheduledDate === dateStr) return true\n        return false\n    }\n\n    // Count tasks scheduled/due for today\n    const todayCount = computed(() => {\n        const todayStr = getToday().toISOString().split('T')[0]\n        return baseInboxTasks.value.filter(task => isTaskForDate(task, todayStr)).length\n    })\n\n    // Apply time-based filtering\n    const timeFilteredTasks = computed(() => {\n        const tasks = baseInboxTasks.value\n\n        switch (activeTimeFilter.value) {\n            case 'all':\n                return tasks\n\n            case 'today':\n            case 'now': {\n                // BUG-046 FIX: Check dueDate, instances, AND scheduledDate\n                const today = getToday().toISOString().split('T')[0]\n                return tasks.filter(task => isTaskForDate(task, today))\n            }\n\n            case 'tomorrow': {\n                const tomorrow = getTomorrow().toISOString().split('T')[0]\n                return tasks.filter(task => isTaskForDate(task, tomorrow))\n            }\n\n            case 'thisWeek':\n                return tasks.filter(task => {\n                    // Check dueDate\n                    if (isThisWeek(task.dueDate)) return true\n                    // Check instances\n                    if (task.instances && task.instances.length > 0) {\n                        if (task.instances.some((inst) => isThisWeek(inst.scheduledDate))) return true\n                    }\n                    // Check legacy scheduledDate\n                    if (isThisWeek(task.scheduledDate)) return true\n                    return false\n                })\n\n            case 'noDate':\n                return tasks.filter(task => !hasDate(task))\n\n            default:\n                return tasks\n        }\n    })\n\n    // Apply additional filters (Unscheduled, Priority, Project, Duration)\n    const inboxTasks = computed(() => {\n        let tasks = timeFilteredTasks.value\n\n        if (unscheduledOnly.value) {\n            tasks = tasks.filter(task => !isScheduledOnCalendar(task))\n        }\n\n        if (selectedPriority.value !== null) {\n            tasks = tasks.filter(task => task.priority === selectedPriority.value)\n        }\n\n        if (selectedProject.value !== null) {\n            if (selectedProject.value === 'none') {\n                tasks = tasks.filter(task => !task.projectId)\n            } else {\n                tasks = tasks.filter(task => task.projectId === selectedProject.value)\n            }\n        }\n\n        // TASK-144: Use centralized duration matching\n        if (selectedDuration.value !== null) {\n            tasks = tasks.filter(task =>\n                matchesDurationCategory(task.estimatedDuration, selectedDuration.value!)\n            )\n        }\n\n        return tasks\n    })\n\n    const clearAllFilters = () => {\n        unscheduledOnly.value = false\n        selectedPriority.value = null\n        selectedProject.value = null\n        selectedDuration.value = null\n    }\n\n    return {\n        activeTimeFilter,\n        unscheduledOnly,\n        selectedPriority,\n        selectedProject,\n        selectedDuration,\n        baseInboxTasks,\n        todayCount,\n        inboxTasks,\n        clearAllFilters\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useLazyComponent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useNetworkOptimizer.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2118,2121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2118,2121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useOptimisticUI.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[471,474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[471,474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[562,565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[562,565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Optimistic UI Updates Composable\n * Provides immediate UI feedback while operations are queued offline\n */\n\nimport { ref, computed, reactive } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\n// import { useToast } from '@/composables/useToast' // Not implemented\n// Types for optimistic operations\nexport interface QueuedOperation {\n  id: string\n  type: 'create' | 'update' | 'delete'\n  entityType: 'task' | 'project' | 'group'\n  entityId: string\n  data: any\n  timestamp: number\n  retryCount: number\n  priority?: string | number\n  originalData?: any\n  optimisticId?: string\n  maxRetries?: number\n  status?: string\n  dependencies?: string[]\n}\n\nexport interface OnlineStatus {\n  isOnline: boolean\n  connectionType: 'online' | 'offline' | 'slow'\n  lastConnected: number\n  connectionQuality: number // 0-1\n  syncStrategy: 'immediate' | 'batch' | 'manual'\n}\n\ninterface OptimisticUpdate {\n  id: string\n  operation: QueuedOperation\n  originalData: unknown\n  optimisticData: unknown\n  timestamp: number\n  status: 'pending' | 'success' | 'failed' | 'reverted'\n  uiElements: string[] // CSS selectors or component IDs affected\n  rollback?: () => void\n}\n\ninterface OfflineIndicator {\n  show: boolean\n  message: string\n  type: 'info' | 'warning' | 'error'\n  count: number\n  estimatedTime?: number\n}\n\nexport function useOptimisticUI() {\n  const tasksStore = useTaskStore()\n  // const toast = useToast() // Not implemented\n\n  // Reactive state\n  const optimisticUpdates = ref<Map<string, OptimisticUpdate>>(new Map())\n  const offlineIndicator = reactive<OfflineIndicator>({\n    show: false,\n    message: '',\n    type: 'info',\n    count: 0,\n    estimatedTime: undefined\n  })\n\n  const onlineStatus = ref<OnlineStatus>({\n    isOnline: navigator.onLine,\n    connectionType: 'online',\n    lastConnected: Date.now(),\n    connectionQuality: 1,\n    syncStrategy: 'immediate'\n  })\n\n  // Computed properties\n  const hasPendingUpdates = computed(() =>\n    Array.from(optimisticUpdates.value.values()).some(update =>\n      update.status === 'pending'\n    )\n  )\n\n  const pendingUpdatesCount = computed(() =>\n    Array.from(optimisticUpdates.value.values()).filter(update =>\n      update.status === 'pending'\n    ).length\n  )\n\n  const failedUpdatesCount = computed(() =>\n    Array.from(optimisticUpdates.value.values()).filter(update =>\n      update.status === 'failed'\n    ).length\n  )\n\n  /**\n   * Apply optimistic update for task creation\n   */\n  const createTaskOptimistic = async (taskData: Record<string, unknown>): Promise<string> => {\n    const optimisticId = `optimistic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n\n    const optimisticTask = {\n      id: optimisticId,\n      ...taskData,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      optimistic: true,\n      pendingSync: true\n    }\n\n    // Store original data (empty for creation)\n    const originalData = null\n\n    // Apply optimistic update to local store\n    tasksStore.createTask(optimisticTask)\n\n    // Create optimistic update record\n    const optimisticUpdate: OptimisticUpdate = {\n      id: optimisticId,\n      operation: {\n        id: optimisticId,\n        type: 'create',\n        entityType: 'task',\n        entityId: optimisticId,\n        data: taskData,\n        timestamp: Date.now(),\n        priority: 'normal',\n        retryCount: 0,\n        maxRetries: 3,\n        status: 'pending',\n        dependencies: []\n      },\n      originalData: originalData,\n      optimisticData: optimisticTask,\n      timestamp: Date.now(),\n      status: 'pending',\n      uiElements: [`[data-task-id=\"${optimisticId}\"]`],\n      rollback: () => {\n        tasksStore.deleteTask(optimisticId)\n      }\n    }\n\n    optimisticUpdates.value.set(optimisticId, optimisticUpdate)\n\n    // Show success toast for immediate feedback\n    // toast.success('Task created (syncing...)', {\n    //   duration: 3000,\n    //   action: {\n    //     label: 'View',\n    //     handler: () => {\n    //       // Focus on the created task\n    //       const element = document.querySelector(`[data-task-id=\"${optimisticId}\"]`)\n    //       element?.scrollIntoView({ behavior: 'smooth', block: 'center' })\n    //     }\n    //   }\n    // })\n\n    updateOfflineIndicator()\n\n    return optimisticId\n  }\n\n  /**\n   * Apply optimistic update for task update\n   */\n  const updateTaskOptimistic = async (taskId: string, updates: Record<string, unknown>): Promise<void> => {\n    const originalTask = tasksStore.getTask(taskId)\n    if (!originalTask) {\n      throw new Error('Task not found for optimistic update')\n    }\n\n    // Create optimistic version\n    const optimisticTask = {\n      ...originalTask,\n      ...updates,\n      updatedAt: new Date(),\n      optimistic: true,\n      pendingSync: true\n    }\n\n    // Store original data for rollback\n    const originalData = { ...originalTask }\n\n    // Apply optimistic update to local store\n    tasksStore.updateTask(taskId, optimisticTask)\n\n    // Create optimistic update record\n    const updateId = `update-${taskId}-${Date.now()}`\n    const optimisticUpdate: OptimisticUpdate = {\n      id: updateId,\n      operation: {\n        id: updateId,\n        type: 'update',\n        entityType: 'task',\n        entityId: taskId,\n        data: updates,\n        originalData: originalTask,\n        timestamp: Date.now(),\n        priority: 'normal',\n        retryCount: 0,\n        maxRetries: 3,\n        status: 'pending',\n        dependencies: []\n      },\n      originalData: originalTask,\n      optimisticData: optimisticTask,\n      timestamp: Date.now(),\n      status: 'pending',\n      uiElements: [`[data-task-id=\"${taskId}\"]`],\n      rollback: () => {\n        tasksStore.updateTask(taskId, originalData)\n      }\n    }\n\n    optimisticUpdates.value.set(updateId, optimisticUpdate)\n\n    // Show subtle success indicator\n    // toast.info('Task updated (syncing...)', { duration: 2000 })\n\n    updateOfflineIndicator()\n  }\n\n  /**\n   * Apply optimistic update for task deletion\n   */\n  const deleteTaskOptimistic = async (taskId: string): Promise<void> => {\n    const originalTask = tasksStore.getTask(taskId)\n    if (!originalTask) {\n      throw new Error('Task not found for optimistic deletion')\n    }\n\n    // Remove from UI immediately\n    tasksStore.deleteTask(taskId)\n\n    // Create optimistic update record\n    const updateId = `delete-${taskId}-${Date.now()}`\n    const optimisticUpdate: OptimisticUpdate = {\n      id: updateId,\n      operation: {\n        id: updateId,\n        type: 'delete',\n        entityType: 'task',\n        entityId: taskId,\n        data: {},\n        originalData: originalTask,\n        timestamp: Date.now(),\n        priority: 'normal',\n        retryCount: 0,\n        maxRetries: 3,\n        status: 'pending',\n        dependencies: []\n      },\n      originalData: originalTask,\n      optimisticData: null,\n      timestamp: Date.now(),\n      status: 'pending',\n      uiElements: [`[data-task-id=\"${taskId}\"]`],\n      rollback: () => {\n        tasksStore.createTask(originalTask)\n      }\n    }\n\n    optimisticUpdates.value.set(updateId, optimisticUpdate)\n\n    // Show deletion toast with undo option\n    // toast.warning('Task deleted (syncing...)', {\n    //   duration: 5000,\n    //   action: {\n    //     label: 'Undo',\n    //     handler: () => {\n    //       rollbackOptimisticUpdate(updateId)\n    //     }\n    //   }\n    // })\n\n    updateOfflineIndicator()\n  }\n\n  /**\n   * Handle successful operation completion\n   */\n  const handleOperationSuccess = (operationId: string, serverId?: string): void => {\n    // Find optimistic update\n    const update = Array.from(optimisticUpdates.value.values()).find(\n      u => u.operation.id === operationId\n    )\n\n    if (!update) return\n\n    // Update status\n    update.status = 'success'\n\n    // Remove optimistic flags from the actual data\n    if (update.optimisticData && typeof update.optimisticData === 'object') {\n      const data = update.optimisticData as Record<string, unknown>\n      const { optimistic: _optimistic, pendingSync: _pendingSync, ...cleanData } = data\n      if (serverId && typeof cleanData.id === 'string' && cleanData.id.startsWith('optimistic-')) {\n        cleanData.id = serverId\n      }\n\n      // Update the real data in store\n      if (update.operation.type === 'create') {\n        tasksStore.updateTask(update.operation.optimisticId || update.id, cleanData)\n      } else if (update.operation.type === 'update') {\n        tasksStore.updateTask(update.operation.entityId, cleanData)\n      }\n    }\n\n    // Remove from pending updates after a delay\n    setTimeout(() => {\n      optimisticUpdates.value.delete(update.id)\n      updateOfflineIndicator()\n    }, 2000)\n\n    // Show success notification\n    // toast.success('Changes synced successfully', { duration: 3000 })\n  }\n\n  /**\n   * Handle operation failure\n   */\n  const handleOperationFailure = (operationId: string, _error: string): void => {\n    // Find optimistic update\n    const update = Array.from(optimisticUpdates.value.values()).find(\n      u => u.operation.id === operationId\n    )\n\n    if (!update) return\n\n    update.status = 'failed'\n\n    // Show error notification with retry option\n    // toast.error(`Failed to sync: ${error}`, {\n    //   duration: 0, // Persistent until dismissed\n    //   action: {\n    //     label: 'Retry',\n    //     handler: () => {\n    //       // Retry the operation\n    //       update.status = 'pending'\n    //       optimisticUpdates.value.set(update.id, update)\n    //       updateOfflineIndicator()\n    //     }\n    //   }\n    // })\n\n    // Add visual error state to affected UI elements\n    update.uiElements.forEach(selector => {\n      const elements = document.querySelectorAll(selector)\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i] as HTMLElement\n        element.classList.add('optimistic-error')\n        // Pulsing error animation\n        element.style.animation = 'pulse 1s infinite'\n      }\n    })\n\n    updateOfflineIndicator()\n  }\n\n  /**\n   * Rollback optimistic update\n   */\n  const rollbackOptimisticUpdate = (updateId: string): void => {\n    const update = optimisticUpdates.value.get(updateId)\n    if (!update || !update.rollback) return\n\n    try {\n      update.rollback()\n      optimisticUpdates.value.delete(updateId)\n\n      // toast.info('Changes reverted', { duration: 2000 })\n      updateOfflineIndicator()\n    } catch (error) {\n      console.error('Failed to rollback optimistic update:', error)\n      // toast.error('Failed to revert changes')\n    }\n  }\n\n  /**\n   * Update offline indicator\n   */\n  const updateOfflineIndicator = (): void => {\n    const pendingCount = pendingUpdatesCount.value\n    const failedCount = failedUpdatesCount.value\n\n    if (pendingCount > 0) {\n      offlineIndicator.show = true\n      offlineIndicator.count = pendingCount\n      offlineIndicator.type = failedCount > 0 ? 'warning' : 'info'\n\n      if (pendingCount === 1) {\n        offlineIndicator.message = '1 change syncing...'\n      } else {\n        offlineIndicator.message = `${pendingCount} changes syncing...`\n      }\n\n      // Add estimated time (rough calculation)\n      offlineIndicator.estimatedTime = pendingCount * 2000 // 2 seconds per operation\n    } else if (failedCount > 0) {\n      offlineIndicator.show = true\n      offlineIndicator.count = failedCount\n      offlineIndicator.type = 'error'\n      offlineIndicator.message = `${failedCount} sync ${failedCount === 1 ? 'failure' : 'failures'}`\n    } else {\n      offlineIndicator.show = false\n      offlineIndicator.message = ''\n      offlineIndicator.count = 0\n      offlineIndicator.estimatedTime = undefined\n    }\n  }\n\n  /**\n   * Update online status\n   */\n  const updateOnlineStatus = (status: OnlineStatus): void => {\n    onlineStatus.value = status\n\n    // Show connection status notifications\n    if (status.isOnline && !onlineStatus.value.isOnline) {\n      // Just came online\n      // toast.success('Connection restored', { duration: 3000 })\n\n      // If there are pending updates, show syncing notification\n      if (pendingUpdatesCount.value > 0) {\n        // toast.info(`Syncing ${pendingUpdatesCount.value} pending changes...`, { duration: 5000 })\n      }\n    } else if (!status.isOnline && onlineStatus.value.isOnline) {\n      // Just went offline\n      // toast.warning('Connection lost - working offline', { duration: 5000 })\n    }\n  }\n\n  /**\n   * Clear all optimistic updates\n   */\n  const clearAllUpdates = (): void => {\n    optimisticUpdates.value.clear()\n    updateOfflineIndicator()\n  }\n\n  /**\n   * Get all pending operations\n   */\n  const getPendingOperations = (): QueuedOperation[] => {\n    return Array.from(optimisticUpdates.value.values())\n      .filter(update => update.status === 'pending')\n      .map(update => update.operation)\n  }\n\n  /**\n   * Retry failed operations\n   */\n  const retryFailedOperations = (): void => {\n    Array.from(optimisticUpdates.value.values())\n      .filter(update => update.status === 'failed')\n      .forEach(update => {\n        update.status = 'pending'\n        optimisticUpdates.value.set(update.id, update)\n      })\n\n    updateOfflineIndicator()\n    // toast.info('Retrying failed operations...', { duration: 3000 })\n  }\n\n  return {\n    // State\n    optimisticUpdates: computed(() => Array.from(optimisticUpdates.value.values())),\n    offlineIndicator: computed(() => offlineIndicator),\n    onlineStatus: computed(() => onlineStatus.value),\n    hasPendingUpdates,\n    pendingUpdatesCount,\n    failedUpdatesCount,\n\n    // Actions\n    createTaskOptimistic,\n    updateTaskOptimistic,\n    deleteTaskOptimistic,\n    handleOperationSuccess,\n    handleOperationFailure,\n    rollbackOptimisticUpdate,\n    updateOnlineStatus,\n    clearAllUpdates,\n    retryFailedOperations,\n\n    // Utilities\n    getPendingOperations\n  }\n}\n\nexport default useOptimisticUI","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/usePerformanceManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1948,1951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1948,1951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1958,1961],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1958,1961],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2274,2277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2274,2277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2284,2287],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2284,2287],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2602,2605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2602,2605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2612,2615],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2612,2615],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Manager Composable\n * Centralized performance optimization with debouncing, memoization, and cleanup\n */\n\nimport { ref, computed as _computed, watch as _watch, onMounted, onUnmounted, nextTick as _nextTick } from 'vue'\nimport { useDebounceFn, useThrottleFn, useStorage as _useStorage, useRafFn } from '@vueuse/core'\n\nexport interface PerformanceConfig {\n  debounceDelay?: number\n  throttleDelay?: number\n  maxCacheSize?: number\n  enableMemoization?: boolean\n  enableCleanup?: boolean\n  cleanupInterval?: number\n  memoryThreshold?: number\n}\n\nexport interface PerformanceMetrics {\n  memoryUsage: number\n  cacheSize: number\n  cacheHitRate: number\n  debouncedOperations: number\n  throttledOperations: number\n  memoizedComputations: number\n  cleanupRuns: number\n  lastCleanupTime: number\n}\n\nexport interface CacheEntry<T = unknown> {\n  key: string\n  value: T\n  timestamp: number\n  hits: number\n  size: number\n}\n\nexport function usePerformanceManager(config: PerformanceConfig = {}) {\n  const {\n    debounceDelay = 300,\n    throttleDelay = 16, // ~60fps\n    maxCacheSize = 100,\n    enableMemoization = true,\n    enableCleanup = true,\n    cleanupInterval = 30000, // 30 seconds\n    memoryThreshold = 100 * 1024 * 1024 // 100MB\n  } = config\n\n  // Reactive state\n  const cache = ref<Map<string, CacheEntry>>(new Map())\n  const metrics = ref<PerformanceMetrics>({\n    memoryUsage: 0,\n    cacheSize: 0,\n    cacheHitRate: 0,\n    debouncedOperations: 0,\n    throttledOperations: 0,\n    memoizedComputations: 0,\n    cleanupRuns: 0,\n    lastCleanupTime: 0\n  })\n\n  // Memoization helpers\n  const memoizedComputations = ref<Map<string, { result: unknown, deps: unknown[], timestamp: number }>>(new Map())\n  const memoizationStats = ref({ hits: 0, misses: 0 })\n\n  // Memory monitoring\n  const memoryUsage = ref(0)\n  const memoryMonitorInterval = ref<NodeJS.Timeout>()\n\n  // Debounce function factory\n  const createDebounced = <T extends (...args: any[]) => any>(\n    fn: T,\n    delay: number = debounceDelay\n  ) => {\n    const debouncedFn = useDebounceFn(fn, delay)\n\n    return (...args: Parameters<T>) => {\n      metrics.value.debouncedOperations++\n      return debouncedFn(...args)\n    }\n  }\n\n  // Throttle function factory\n  const createThrottled = <T extends (...args: any[]) => any>(\n    fn: T,\n    delay: number = throttleDelay\n  ) => {\n    const throttledFn = useThrottleFn(fn, delay)\n\n    return (...args: Parameters<T>) => {\n      metrics.value.throttledOperations++\n      return throttledFn(...args)\n    }\n  }\n\n  // Memoized computation factory\n  const createMemoized = <T extends (...args: any[]) => any>(\n    fn: T,\n    key: string,\n    dependencies: unknown[] = []\n  ) => {\n    if (!enableMemoization) {\n      return fn\n    }\n\n    return (...args: Parameters<T>): ReturnType<T> => {\n      const cached = memoizedComputations.value.get(key)\n\n      if (cached && Date.now() - cached.timestamp < 300000) { // 5 minutes TTL\n        const depsMatch = dependencies.length === cached.deps.length &&\n          dependencies.every((dep, i) => dep === cached.deps[i])\n\n        if (depsMatch) {\n          memoizationStats.value.hits++\n          metrics.value.memoizedComputations++\n          return cached.result as ReturnType<T>\n        }\n      }\n\n      const result = fn(...args)\n      memoizedComputations.value.set(key, {\n        result,\n        deps: dependencies,\n        timestamp: Date.now()\n      })\n\n      memoizationStats.value.misses++\n      metrics.value.memoizedComputations++\n      return result as ReturnType<T>\n    }\n  }\n\n  // Cache management\n  const setCache = <T>(key: string, value: T, _ttl: number = 300000) => {\n    if (!enableMemoization) return\n\n    const size = calculateSize(value)\n    const entry: CacheEntry<T> = {\n      key,\n      value,\n      timestamp: Date.now(),\n      hits: 0,\n      size\n    }\n\n    cache.value.set(key, entry)\n\n    // Check cache size limit\n    if (cache.value.size > maxCacheSize) {\n      cleanupCache()\n    }\n\n    updateMetrics()\n  }\n\n  const getCache = <T>(key: string): T | null => {\n    if (!enableMemoization) return null\n\n    const entry = cache.value.get(key) as CacheEntry<T>\n\n    if (entry) {\n      const now = Date.now()\n      if (now - entry.timestamp < 300000) { // 5 minutes TTL\n        entry.hits++\n        return entry.value\n      } else {\n        cache.value.delete(key)\n      }\n    }\n\n    return null\n  }\n\n  const hasCache = (key: string): boolean => {\n    if (!enableMemoization) return false\n\n    const entry = cache.value.get(key)\n    if (!entry) return false\n\n    const now = Date.now()\n    if (now - entry.timestamp >= 300000) {\n      cache.value.delete(key)\n      return false\n    }\n\n    return true\n  }\n\n  const deleteCache = (key: string): boolean => {\n    return cache.value.delete(key)\n  }\n\n  const clearCache = () => {\n    cache.value.clear()\n    memoizedComputations.value.clear()\n    updateMetrics()\n  }\n\n  // Cache cleanup\n  const cleanupCache = () => {\n    if (!enableCleanup) return\n\n    const now = Date.now()\n    const entries = Array.from(cache.value.entries())\n\n    // Sort by hits (keep most used) and recency\n    entries.sort(([, a], [, b]) => {\n      const aScore = a.hits + (now - a.timestamp) / 1000\n      const bScore = b.hits + (now - b.timestamp) / 1000\n      return bScore - aScore\n    })\n\n    // Keep only top entries\n    const keepCount = Math.floor(maxCacheSize * 0.8)\n    const toKeep = entries.slice(0, keepCount)\n\n    cache.value.clear()\n    toKeep.forEach(([key, entry]) => cache.value.set(key, entry))\n\n    // Clean expired memoized computations\n    for (const [key, comp] of memoizedComputations.value.entries()) {\n      if (now - comp.timestamp > 300000) {\n        memoizedComputations.value.delete(key)\n      }\n    }\n\n    metrics.value.cleanupRuns++\n    metrics.value.lastCleanupTime = now\n    updateMetrics()\n  }\n\n  // Calculate size of object (rough estimation)\n  const calculateSize = (obj: unknown): number => {\n    try {\n      return JSON.stringify(obj).length * 2 // 2 bytes per character\n    } catch {\n      return 1000 // Default size for non-serializable objects\n    }\n  }\n\n  // Update performance metrics\n  const updateMetrics = () => {\n    metrics.value.cacheSize = cache.value.size\n    metrics.value.memoryUsage = memoryUsage.value\n\n    const totalHits = Array.from(cache.value.values()).reduce((sum, entry) => sum + entry.hits, 0)\n    metrics.value.cacheHitRate = cache.value.size > 0 ? totalHits / cache.value.size : 0\n  }\n\n  // Memory monitoring\n  const startMemoryMonitoring = () => {\n    if (typeof performance !== 'undefined' && 'memory' in performance) {\n      memoryMonitorInterval.value = setInterval(() => {\n        const perf = performance as unknown as Record<string, unknown>\n        const memory = perf.memory as Record<string, number>\n        if (memory) {\n          memoryUsage.value = memory.usedJSHeapSize\n\n          // Auto-cleanup if memory threshold exceeded\n          if (memoryUsage.value > memoryThreshold) {\n            cleanupCache()\n          }\n        }\n        updateMetrics()\n      }, 5000) // Check every 5 seconds\n    }\n  }\n\n  const stopMemoryMonitoring = () => {\n    if (memoryMonitorInterval.value) {\n      clearInterval(memoryMonitorInterval.value)\n    }\n  }\n\n  // Performance optimization helpers\n  const optimizeForLargeLists = <T>(items: T[]) => {\n    if (items.length > 1000) {\n      // For very large lists, use more aggressive debouncing\n      return createDebounced(<R>(fn: () => R) => fn(), 500)\n    }\n    return createDebounced(<R>(fn: () => R) => fn(), debounceDelay)\n  }\n\n  const optimizeForAnimations = <T>(fn: T) => {\n    // Use RAF for animations\n    const raf = useRafFn(fn as () => void)\n    return raf.pause\n  }\n\n  const batchOperations = <T>(operations: (() => T)[]) => {\n    const results: T[] = []\n\n    // Batch operations in a single frame\n    requestAnimationFrame(() => {\n      operations.forEach(op => {\n        try {\n          results.push(op())\n        } catch (error) {\n          console.error('Batch operation failed:', error)\n        }\n      })\n    })\n\n    return results\n  }\n\n  // RAF-based rendering optimization\n  const scheduleRender = (fn: () => void) => {\n    return requestAnimationFrame(fn)\n  }\n\n  const cancelRender = (id: number) => {\n    cancelAnimationFrame(id)\n  }\n\n  // Cleanup on unmount\n  onMounted(() => {\n    startMemoryMonitoring()\n\n    if (enableCleanup) {\n      setInterval(cleanupCache, cleanupInterval)\n    }\n  })\n\n  onUnmounted(() => {\n    stopMemoryMonitoring()\n    clearCache()\n  })\n\n  return {\n    // Core utilities\n    createDebounced,\n    createThrottled,\n    createMemoized,\n\n    // Cache management\n    setCache,\n    getCache,\n    hasCache,\n    deleteCache,\n    clearCache,\n    cleanupCache,\n\n    // Performance helpers\n    optimizeForLargeLists,\n    optimizeForAnimations,\n    batchOperations,\n    scheduleRender,\n    cancelRender,\n\n    // Metrics and monitoring\n    metrics,\n    memoizationStats,\n    memoryUsage,\n\n    // Utilities\n    updateMetrics,\n    calculateSize\n  }\n}\n\n// Global performance manager instance\nexport const globalPerformanceManager = usePerformanceManager()\n\n// Performance presets for common scenarios\nexport const performancePresets = {\n  // For heavy computations\n  heavyComputation: {\n    debounceDelay: 500,\n    throttleDelay: 100,\n    maxCacheSize: 50,\n    enableMemoization: true,\n    cleanupInterval: 60000\n  },\n\n  // For real-time updates\n  realtime: {\n    debounceDelay: 50,\n    throttleDelay: 16,\n    maxCacheSize: 200,\n    enableMemoization: true,\n    cleanupInterval: 15000\n  },\n\n  // For infrequent operations\n  batched: {\n    debounceDelay: 1000,\n    throttleDelay: 200,\n    maxCacheSize: 100,\n    enableMemoization: true,\n    cleanupInterval: 120000\n  },\n\n  // For minimal overhead\n  minimal: {\n    debounceDelay: 100,\n    throttleDelay: 50,\n    maxCacheSize: 20,\n    enableMemoization: false,\n    cleanupInterval: 300000\n  }\n}\n\nexport default usePerformanceManager","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/usePerformanceMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/usePersistentStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/usePowerKeywords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useProgressiveDisclosure.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useQuickSort.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useRenderOptimization.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6478,6481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6478,6481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6506,6509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6506,6509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Render Optimization Composable\n * Optimizes Vue component rendering, reduces unnecessary re-renders\n */\n\nimport { ref, computed, onMounted, onUnmounted, nextTick, shallowRef, triggerRef } from 'vue'\nimport { useThrottleFn, useDebounceFn } from '@vueuse/core'\n\nexport interface RenderOptimizationOptions {\n  enableShallowReactive?: boolean\n  enableVirtualScrolling?: boolean\n  enableLazyLoading?: boolean\n  throttleRenderEvents?: boolean\n  enableRenderBatching?: boolean\n  batchSize?: number\n  batchDelay?: number\n  enableComponentCaching?: boolean\n  maxComponentCache?: number\n}\n\nexport interface RenderMetrics {\n  totalRenders: number\n  componentRenders: Map<string, number>\n  averageRenderTime: number\n  slowRenders: number\n  skippedRenders: number\n  cachedComponents: number\n  memoryUsage: number\n  lastRenderTime: number\n}\n\nexport function useRenderOptimization(options: RenderOptimizationOptions = {}) {\n  const {\n    enableShallowReactive = true,\n    enableVirtualScrolling: _enableVirtualScrolling = true,\n    enableLazyLoading = true,\n    throttleRenderEvents = true,\n    enableRenderBatching = true,\n    batchSize = 20,\n    batchDelay = 16, // ~60fps\n    enableComponentCaching = true,\n    maxComponentCache = 50\n  } = options\n\n  // Reactive state\n  const renderMetrics = ref<RenderMetrics>({\n    totalRenders: 0,\n    componentRenders: new Map(),\n    averageRenderTime: 0,\n    slowRenders: 0,\n    skippedRenders: 0,\n    cachedComponents: 0,\n    memoryUsage: 0,\n    lastRenderTime: 0\n  })\n\n  interface CachedComponent {\n    timestamp: number\n    ttl: number\n    component: unknown\n  }\n\n  const componentCache = ref<Map<string, CachedComponent>>(new Map())\n  const pendingRenders = ref<Set<() => void>>(new Set())\n  const isProcessingBatch = ref(false)\n  const renderQueue = ref<(() => void)[]>([])\n\n  // Performance monitoring\n  const performanceObserver = ref<PerformanceObserver | null>(null)\n  const renderTimes = ref<number[]>([])\n\n  // Throttled render function\n  const throttledRender = throttleRenderEvents\n    ? useThrottleFn((fn: () => void) => fn(), batchDelay)\n    : (fn: () => void) => fn()\n\n  // Debounced batch processor\n  const processRenderBatch = useDebounceFn(async () => {\n    if (renderQueue.value.length === 0 || isProcessingBatch.value) return\n\n    isProcessingBatch.value = true\n    const batch = renderQueue.value.splice(0, batchSize)\n\n    try {\n      // Process all renders in a single frame\n      await nextTick()\n\n      const startTime = performance.now()\n      batch.forEach(renderFn => {\n        try {\n          renderFn()\n        } catch (error) {\n          console.error('Render batch item failed:', error)\n        }\n      })\n\n      const renderTime = performance.now() - startTime\n      renderTimes.value.push(renderTime)\n\n      // Keep only recent render times\n      if (renderTimes.value.length > 100) {\n        renderTimes.value = renderTimes.value.slice(-50)\n      }\n\n      // Update metrics\n      renderMetrics.value.totalRenders += batch.length\n      renderMetrics.value.averageRenderTime = renderTimes.value.reduce((a, b) => a + b, 0) / renderTimes.value.length\n      renderMetrics.value.lastRenderTime = renderTime\n\n      // Mark slow renders\n      if (renderTime > 16) { // More than 60fps threshold\n        renderMetrics.value.slowRenders++\n      }\n\n    } finally {\n      isProcessingBatch.value = false\n    }\n  }, batchDelay)\n\n  // Optimized render function\n  const optimizedRender = (renderFn: () => void, componentId?: string) => {\n    const startTime = performance.now()\n\n    const wrappedRender = () => {\n      try {\n        renderFn()\n\n        // Track component renders\n        if (componentId) {\n          const currentCount = renderMetrics.value.componentRenders.get(componentId) || 0\n          renderMetrics.value.componentRenders.set(componentId, currentCount + 1)\n        }\n\n      } catch (error) {\n        console.error(`Render failed for component ${componentId}:`, error)\n      }\n    }\n\n    if (enableRenderBatching) {\n      renderQueue.value.push(wrappedRender)\n      processRenderBatch()\n    } else {\n      throttledRender(wrappedRender)\n    }\n\n    const renderTime = performance.now() - startTime\n    renderMetrics.value.lastRenderTime = renderTime\n  }\n\n  // Shallow reactive wrapper for large arrays/objects\n  const createShallowReactive = <T>(value: T): { value: T; trigger: () => void } => {\n    if (!enableShallowReactive) {\n      return { value, trigger: () => { } }\n    }\n\n    const shallowRefValue = shallowRef(value)\n\n    return {\n      get value() {\n        return shallowRefValue.value\n      },\n      set value(newValue) {\n        shallowRefValue.value = newValue\n      },\n      trigger: () => triggerRef(shallowRefValue)\n    }\n  }\n\n  // Component caching\n  const cacheComponent = (key: string, component: unknown, ttl: number = 300000) => {\n    if (!enableComponentCaching) return\n\n    // Clear old entries if cache is full\n    if (componentCache.value.size >= maxComponentCache) {\n      const entries = Array.from(componentCache.value.entries())\n      // Remove oldest 25% of entries\n      const toRemove = Math.floor(entries.length * 0.25)\n      for (let i = 0; i < toRemove; i++) {\n        componentCache.value.delete(entries[i][0])\n      }\n    }\n\n    componentCache.value.set(key, {\n      component,\n      timestamp: Date.now(),\n      ttl\n    })\n\n    renderMetrics.value.cachedComponents = componentCache.value.size\n  }\n\n  const getCachedComponent = (key: string): unknown => {\n    if (!enableComponentCaching) return null\n\n    const cached = componentCache.value.get(key)\n    if (!cached) return null\n\n    // Check TTL\n    if (Date.now() - cached.timestamp > cached.ttl) {\n      componentCache.value.delete(key)\n      renderMetrics.value.cachedComponents = componentCache.value.size\n      return null\n    }\n\n    renderMetrics.value.skippedRenders++\n    return cached.component\n  }\n\n  // Conditional render helper\n  const shouldRender = (condition: () => boolean, lastValue?: boolean): boolean => {\n    const current = condition()\n    const shouldUpdate = lastValue !== current\n    return shouldUpdate\n  }\n\n  // Memoized component factory\n  const createMemoizedComponent = (\n    componentFactory: () => unknown,\n    dependencyKeys: string[],\n    componentId: string\n  ) => {\n    let cachedComponent: unknown = null\n    let lastDependencyValues: unknown[] = []\n\n    return () => {\n      const currentDependencyValues = dependencyKeys.map(key => {\n        try {\n          return (window as any)[key] || (globalThis as any)[key]\n        } catch {\n          return undefined\n        }\n      })\n\n      const dependenciesChanged = !lastDependencyValues.every(\n        (value, index) => value === currentDependencyValues[index]\n      )\n\n      if (!cachedComponent || dependenciesChanged) {\n        cachedComponent = componentFactory()\n        lastDependencyValues = currentDependencyValues\n\n        renderMetrics.value.componentRenders.set(\n          componentId,\n          (renderMetrics.value.componentRenders.get(componentId) || 0) + 1\n        )\n      } else {\n        renderMetrics.value.skippedRenders++\n      }\n\n      return cachedComponent\n    }\n  }\n\n  // Lazy loading helper\n  const createLazyLoader = <T>(\n    loader: () => Promise<T>,\n    fallback?: T,\n    componentId?: string\n  ) => {\n    if (!enableLazyLoading) {\n      return { load: () => loader(), isLoaded: ref(true), data: ref(null) }\n    }\n\n    const isLoaded = ref(false)\n    const isLoading = ref(false)\n    const data = ref<T | null>(null)\n    const error = ref<Error | null>(null)\n\n    const load = async () => {\n      if (isLoaded.value || isLoading.value) return\n\n      isLoading.value = true\n      error.value = null\n\n      try {\n        const startTime = performance.now()\n        const result = await loader()\n        const loadTime = performance.now() - startTime\n\n        data.value = result\n        isLoaded.value = true\n\n        if (componentId) {\n          console.log(`🚀 Lazy loaded ${componentId} in ${loadTime.toFixed(2)}ms`)\n        }\n\n      } catch (err) {\n        error.value = err as Error\n        console.error(`❌ Failed to lazy load component ${componentId}:`, err)\n\n        // Use fallback if provided\n        if (fallback !== undefined) {\n          data.value = fallback\n          isLoaded.value = true\n        }\n      } finally {\n        isLoading.value = false\n      }\n    }\n\n    return { load, isLoaded, isLoading, data, error }\n  }\n\n  // Performance monitoring setup\n  const setupPerformanceMonitoring = () => {\n    if ('PerformanceObserver' in window) {\n      performanceObserver.value = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'measure' && entry.name.includes('render')) {\n            renderTimes.value.push(entry.duration)\n          }\n        }\n      })\n\n      performanceObserver.value.observe({ entryTypes: ['measure'] })\n    }\n  }\n\n  // Memory monitoring\n  const updateMemoryUsage = () => {\n    const perf = performance as unknown as { memory?: { usedJSHeapSize: number } }\n    if (perf.memory) {\n      renderMetrics.value.memoryUsage = perf.memory.usedJSHeapSize\n    }\n  }\n\n  // Cleanup function\n  const cleanup = () => {\n    if (performanceObserver.value) {\n      performanceObserver.value.disconnect()\n    }\n\n    componentCache.value.clear()\n    renderQueue.value = []\n    pendingRenders.value.clear()\n    renderTimes.value = []\n\n    console.log('🧹 Render optimization cleanup completed')\n  }\n\n  // Performance metrics computed property\n  const performanceStats = computed(() => ({\n    ...renderMetrics.value,\n    renderEfficiency: renderMetrics.value.skippedRenders / (renderMetrics.value.totalRenders + renderMetrics.value.skippedRenders) || 0,\n    cacheHitRate: renderMetrics.value.cachedComponents / maxComponentCache,\n    averageRenderTime: renderMetrics.value.averageRenderTime,\n    isPerformant: renderMetrics.value.averageRenderTime < 16, // 60fps threshold\n    memoryEfficiency: renderMetrics.value.memoryUsage < 50 * 1024 * 1024 // 50MB threshold\n  }))\n\n  // Setup on mount\n  onMounted(() => {\n    setupPerformanceMonitoring()\n\n    // Monitor memory usage periodically\n    const memoryInterval = setInterval(updateMemoryUsage, 5000)\n\n    onUnmounted(() => {\n      clearInterval(memoryInterval)\n    })\n  })\n\n  // Cleanup on unmount\n  onUnmounted(cleanup)\n\n  return {\n    // Core optimization functions\n    optimizedRender,\n    createShallowReactive,\n    createMemoizedComponent,\n    createLazyLoader,\n\n    // Caching\n    cacheComponent,\n    getCachedComponent,\n\n    // Utilities\n    shouldRender,\n\n    // Performance monitoring\n    performanceStats,\n    renderMetrics,\n\n    // State\n    isProcessingBatch,\n    queueLength: computed(() => renderQueue.value.length),\n\n    // Cleanup\n    cleanup\n  }\n}\n\n// Global render optimization instance\nexport const globalRenderOptimizer = useRenderOptimization()\n\nexport default useRenderOptimization","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useSafeI18n.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[435,438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[435,438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Safe i18n composable that works in both main app and Storybook\n *\n * In Storybook, the global i18n scope may not be available due to how\n * Storybook creates multiple Vue app instances. This composable provides\n * a standalone translation function that doesn't depend on vue-i18n's\n * composition API, avoiding \"Unexpected return type in composer\" errors.\n */\nimport { ref, computed } from 'vue'\n\ntype Messages = Record<string, any>\n\n// Inline translations for auth components\n// This bypasses vue-i18n's message compiler which transforms JSON imports to AST objects\nconst messages: Record<string, Messages> = {\n  en: {\n    auth: {\n      displayName: 'Display Name',\n      displayNamePlaceholder: 'Enter your display name',\n      email: 'Email',\n      emailPlaceholder: 'Enter your email',\n      password: 'Password',\n      passwordPlaceholder: 'Enter your password',\n      confirmPassword: 'Confirm Password',\n      confirmPasswordPlaceholder: 'Confirm your password',\n      passwordMismatch: 'Passwords do not match',\n      createAccount: 'Create Account',\n      creatingAccount: 'Creating Account...',\n      or: 'or',\n      haveAccount: 'Already have an account?',\n      signIn: 'Sign In',\n      sending: 'Sending...',\n      sendResetLink: 'Send Reset Link',\n      backToLogin: 'Back to Login',\n      login: {\n        title: 'Sign In',\n        subtitle: 'Welcome back! Sign in to access your tasks',\n        email: 'Email',\n        emailPlaceholder: 'Enter your email',\n        password: 'Password',\n        passwordPlaceholder: 'Enter your password',\n        forgotPassword: 'Forgot password?',\n        or: 'or',\n        noAccount: \"Don't have an account?\",\n        signUp: 'Sign Up',\n        signingIn: 'Signing In...',\n        signIn: 'Sign In'\n      },\n      signup: {\n        title: 'Create Account',\n        subtitle: 'Join Pomo-Flow to boost your productivity'\n      },\n      resetPassword: {\n        title: 'Reset Password',\n        subtitle: 'Enter your email to receive a password reset link',\n        emailSent: 'Email Sent!',\n        checkEmail: 'Check your inbox for the password reset link',\n        didntReceive: \"Didn't receive the email?\",\n        resend: 'Resend'\n      }\n    }\n  },\n  he: {\n    auth: {\n      displayName: 'שם תצוגה',\n      displayNamePlaceholder: 'הזן את שם התצוגה שלך',\n      email: 'אימייל',\n      emailPlaceholder: 'הזן את האימייל שלך',\n      password: 'סיסמה',\n      passwordPlaceholder: 'הזן את הסיסמה שלך',\n      confirmPassword: 'אימות סיסמה',\n      confirmPasswordPlaceholder: 'אמת את הסיסמה שלך',\n      passwordMismatch: 'הסיסמאות לא תואמות',\n      createAccount: 'צור חשבון',\n      creatingAccount: 'יוצר חשבון...',\n      or: 'או',\n      haveAccount: 'כבר יש לך חשבון?',\n      signIn: 'התחבר',\n      sending: 'שולח...',\n      sendResetLink: 'שלח קישור לאיפוס',\n      backToLogin: 'חזור להתחברות',\n      login: {\n        title: 'התחברות',\n        subtitle: 'ברוך שובך! התחבר כדי לגשת למשימות שלך',\n        email: 'אימייל',\n        emailPlaceholder: 'הזן את האימייל שלך',\n        password: 'סיסמה',\n        passwordPlaceholder: 'הזן את הסיסמה שלך',\n        forgotPassword: 'שכחת סיסמה?',\n        or: 'או',\n        noAccount: 'אין לך חשבון?',\n        signUp: 'הירשם',\n        signingIn: 'מתחבר...',\n        signIn: 'התחבר'\n      },\n      signup: {\n        title: 'צור חשבון',\n        subtitle: 'הצטרף ל-Pomo-Flow כדי להגביר את הפרודוקטיביות שלך'\n      },\n      resetPassword: {\n        title: 'איפוס סיסמה',\n        subtitle: 'הזן את האימייל שלך כדי לקבל קישור לאיפוס סיסמה',\n        emailSent: 'האימייל נשלח!',\n        checkEmail: 'בדוק את תיבת הדואר שלך לקישור לאיפוס סיסמה',\n        didntReceive: 'לא קיבלת את האימייל?',\n        resend: 'שלח שוב'\n      }\n    }\n  }\n}\n\n// Shared reactive locale - defaults to 'en', syncs with global if available\nconst currentLocale = ref('en')\n\n/**\n * Get nested value from object using dot notation\n */\nfunction getNestedValue(obj: Messages, path: string): string {\n  const value = path.split('.').reduce((acc, key) => acc?.[key], obj)\n  return typeof value === 'string' ? value : path\n}\n\n/**\n * Safe i18n hook that works in both main app and Storybook\n *\n * Uses a standalone implementation that doesn't rely on vue-i18n's\n * composition API, which fails in Storybook's multi-app environment.\n */\nexport function useSafeI18n() {\n  const locale = computed({\n    get: () => currentLocale.value,\n    set: (val: string) => { currentLocale.value = val }\n  })\n\n  /**\n   * Translation function - returns translated string or key if not found\n   */\n  function t(key: string, params?: Record<string, string | number>): string {\n    const msgLocale = messages[currentLocale.value] || messages.en\n    let translation = getNestedValue(msgLocale, key)\n\n    // Handle interpolation if params provided\n    if (params && translation !== key) {\n      Object.entries(params).forEach(([paramKey, value]) => {\n        translation = translation.replace(new RegExp(`\\\\{${paramKey}\\\\}`, 'g'), String(value))\n      })\n    }\n\n    return translation\n  }\n\n  return { t, locale }\n}\n\n/**\n * Set the locale for useSafeI18n (can be called from app initialization)\n */\nexport function setSafeI18nLocale(newLocale: string) {\n  if (messages[newLocale]) {\n    currentLocale.value = newLocale\n  }\n}\n\nexport default useSafeI18n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useSidebarToggle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useSmartViews.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useStaticResourceCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useSupabaseDatabase.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":31,"column":11,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":31,"endColumn":31,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[1301,1335],"text":"type DatabaseDependencies = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[1301,1335],"text":"type DatabaseDependencies = unknown"},"desc":"Replace empty interface with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'deps' is assigned a value but never used. Allowed unused args must match /^_/u.","line":33,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getUserId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":41,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2060,2063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2060,2063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2204,2207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2204,2207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":238,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8546,8549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8546,8549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8773,8776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8773,8776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12094,12097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12094,12097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":329,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12312,12315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12312,12315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15496,15499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15496,15499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":439,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16165,16168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16165,16168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":459,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":459,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16831,16834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16831,16834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":501,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":501,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18498,18501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18498,18501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":514,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":514,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18891,18894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18891,18894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":526,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":526,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19292,19295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19292,19295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":662,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":662,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24859,24862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24859,24862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":686,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":686,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25608,25611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25608,25611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":713,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":713,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26623,26626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26623,26626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":734,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":734,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27247,27250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27247,27250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":755,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":755,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28051,28054],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28051,28054],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":772,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":772,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28594,28597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28594,28597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":804,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":804,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29843,29846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29843,29846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":814,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":814,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30266,30269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30266,30269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":826,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":826,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30707,30710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30707,30710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":834,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":834,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30991,30994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30991,30994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":860,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":860,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32277,32280],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32277,32280],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":860,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":860,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32288,32291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32288,32291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3322,3325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3322,3325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":3,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\nimport { supabase } from '@/services/auth/supabase'\nimport { useAuthStore } from '@/stores/auth'\nimport type { Task, Project } from '@/types/tasks'\nimport type { ScheduledNotification } from '@/types/recurrence'\nimport {\n    toSupabaseTask, fromSupabaseTask,\n    toSupabaseProject, fromSupabaseProject,\n    toSupabaseGroup, fromSupabaseGroup,\n    toSupabaseNotification, fromSupabaseNotification,\n    toSupabaseTimerSession, fromSupabaseTimerSession,\n    toSupabaseUserSettings, fromSupabaseUserSettings,\n    toSupabaseQuickSortSession, fromSupabaseQuickSortSession,\n    type SupabaseTask, type SupabaseProject, type SupabaseGroup,\n    type SupabaseNotification, type SupabaseTimerSession, type SupabaseUserSettings, type SupabaseQuickSortSession\n} from '@/utils/supabaseMappers'\nimport { errorHandler, ErrorSeverity, ErrorCategory } from '@/utils/errorHandler'\n\n// FORCE_HMR_UPDATE: Clearing stale cache for position_version schema\n// App Types are defined locally or imported for convenience\nexport interface TimerSettings {\n    workDuration: number\n    shortBreakDuration: number\n    longBreakDuration: number\n    autoStartBreaks: boolean\n    autoStartPomodoros: boolean\n    playNotificationSounds: boolean\n}\n\n// Define DatabaseDependencies for the new function signature\ninterface DatabaseDependencies { }\n\nexport function useSupabaseDatabase(deps: DatabaseDependencies = {}) {\n\n    const authStore = useAuthStore()\n    const isSyncing = ref(false)\n    const lastSyncError = ref<string | null>(null)\n\n    // -- Helpers --\n\n    const getUserId = () => {\n        if (!authStore.user?.id) {\n            throw new Error('User not authenticated')\n        }\n        return authStore.user.id\n    }\n\n    const getUserIdSafe = (): string | null => {\n        return authStore.user?.id || null\n    }\n\n    /**\n     * Helper to execute Supabase operations with transient error retries (e.g. clock skew)\n     */\n    const withRetry = async <T>(operation: () => Promise<T>, context: string, maxRetries = 2): Promise<T> => {\n        let lastErr: any = null\n\n        for (let i = 0; i < maxRetries; i++) {\n            try {\n                return await operation()\n            } catch (err: any) {\n                lastErr = err\n                const message = err?.message || String(err)\n\n                // Check for \"JWT issued at future\" (Clock Skew)\n                if (message.includes('JWT issued at future')) {\n                    console.warn(`🕒 [CLOCK-SKEW] ${context} failed due to clock skew. Retrying in 1s... (Attempt ${i + 1}/${maxRetries})`)\n                    await new Promise(resolve => setTimeout(resolve, 1000))\n                    continue\n                }\n\n                // For other errors, don't retry immediately unless they look transient\n                throw err\n            }\n        }\n\n        throw lastErr\n    }\n\n    const handleError = (error: unknown, context: string) => {\n        // Handle Supabase/Postgrest errors which are objects but not Error instances\n        let message = 'Unknown error'\n        let details = ''\n\n        if (error instanceof Error) {\n            message = error.message\n        } else if (typeof error === 'object' && error !== null) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const e = error as any\n            message = e.message || String(error)\n            details = e.details || e.hint || ''\n        } else {\n            message = String(error)\n        }\n\n        const finalMessage = details ? `${message} (${details})` : message\n        const err = error instanceof Error ? error : new Error(finalMessage)\n\n        errorHandler.report({\n            error: err,\n            message: `Sync Error(${context}): ${finalMessage}`,\n            severity: ErrorSeverity.ERROR,\n            category: ErrorCategory.SYNC,\n            showNotification: true\n        })\n        lastSyncError.value = finalMessage\n    }\n\n    // -- Projects --\n\n    const fetchProjects = async (): Promise<Project[]> => {\n        try {\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('projects')\n                    .select('*')\n                    .order('created_at', { ascending: true })\n\n                if (error) throw error\n                if (!data) return []\n\n                return (data as SupabaseProject[]).map(fromSupabaseProject)\n            }, 'fetchProjects')\n        } catch (e: unknown) {\n            handleError(e, 'fetchProjects')\n            return []\n        }\n    }\n\n    const saveProject = async (project: Project): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveProject - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = toSupabaseProject(project, userId)\n            const { error } = await supabase.from('projects').upsert(payload)\n            if (error) throw error\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveProject')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const saveProjects = async (projects: Project[]): Promise<void> => {\n        if (projects.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveProjects - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = projects.map(p => toSupabaseProject(p, userId))\n            // BUG-171 FIX: Add .select() and verify data.length to detect RLS partial write failures\n            const { data, error } = await supabase.from('projects').upsert(payload).select('id')\n            if (error) throw error\n            if (!data || data.length !== payload.length) {\n                const writtenCount = data?.length ?? 0\n                const failedCount = payload.length - writtenCount\n                throw new Error(`RLS blocked ${failedCount} of ${payload.length} project writes (only ${writtenCount} succeeded)`)\n            }\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveProjects')\n            throw e // BUG-171: Re-throw so callers know the save failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const deleteProject = async (projectId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            const { error } = await supabase\n                .from('projects')\n                .update({ is_deleted: true, deleted_at: new Date().toISOString() })\n                .eq('id', projectId)\n            if (error) throw error\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'deleteProject')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const restoreProject = async (projectId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            const { error } = await supabase\n                .from('projects')\n                .update({ is_deleted: false, deleted_at: null })\n                .eq('id', projectId)\n            if (error) throw error\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'restoreProject')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const permanentlyDeleteProject = async (projectId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            const { error } = await supabase\n                .from('projects')\n                .delete()\n                .eq('id', projectId)\n            if (error) throw error\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'permanentlyDeleteProject')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // -- Tasks --\n\n    const fetchTasks = async (): Promise<Task[]> => {\n        try {\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('tasks')\n                    .select('*')\n                    .eq('is_deleted', false)\n\n                if (error) throw error\n                if (!data) return []\n\n                // TASK-142 DEBUG: Log what positions we receive from Supabase\n                const tasksWithPos = data.filter((d: any) => d.position)\n                if (tasksWithPos.length > 0) {\n                    console.log(`📥 [TASK-142] LOADED ${tasksWithPos.length} tasks with positions from Supabase:`,\n                        tasksWithPos.map((d: any) => ({ id: d.id?.substring(0, 8), pos: d.position })))\n                } else {\n                    console.log(`📥 [TASK-142] LOADED ${data.length} tasks - NONE have positions in DB`)\n                }\n\n                return (data as SupabaseTask[]).map(fromSupabaseTask)\n            }, 'fetchTasks')\n        } catch (e: unknown) {\n            handleError(e, 'fetchTasks')\n            return []\n        }\n    }\n\n    const fetchTrash = async (): Promise<Task[]> => {\n        try {\n            const { data, error } = await supabase\n                .from('tasks')\n                .select('*')\n                .eq('is_deleted', true)\n                .order('deleted_at', { ascending: false })\n\n            if (error) throw error\n            if (!data) return []\n\n            return (data as SupabaseTask[]).map(fromSupabaseTask)\n        } catch (e: unknown) {\n            handleError(e, 'fetchTrash')\n            return []\n        }\n    }\n\n    const saveTask = async (task: Task): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveTask - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = toSupabaseTask(task, userId)\n\n            await withRetry(async () => {\n                const { error } = await supabase.from('tasks').upsert(payload)\n                if (error) throw error\n            }, 'saveTask')\n\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveTask')\n            throw e\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const saveTasks = async (tasks: Task[]): Promise<void> => {\n        if (tasks.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveTasks - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = tasks.map(t => toSupabaseTask(t, userId))\n\n            // TASK-142 DEBUG: Log what we're sending\n            const tasksWithPos = payload.filter(p => p.position)\n            if (tasksWithPos.length > 0) {\n                console.log(`📤 [TASK-142] SENDING ${tasksWithPos.length} tasks with positions:`,\n                    tasksWithPos.map(t => ({ id: t.id?.substring(0, 8), pos: t.position })))\n            }\n\n            // TASK-142 FIX: Add .select() and check data.length to detect RLS silent failures\n            // Supabase RLS can block writes but return { error: null, data: [] }\n            // Also detect PARTIAL failures where some rows are blocked\n            await withRetry(async () => {\n                const { data, error } = await supabase.from('tasks').upsert(payload).select('id, position')\n                if (error) throw error\n                if (!data || data.length !== payload.length) {\n                    const writtenCount = data?.length ?? 0\n                    const failedCount = payload.length - writtenCount\n                    throw new Error(`RLS blocked ${failedCount} of ${payload.length} writes (only ${writtenCount} succeeded)`)\n                }\n                // TASK-142 DEBUG: Log what Supabase returned\n                const positionSaves = data.filter((d: any) => d.position)\n                if (positionSaves.length > 0) {\n                    console.log(`📥 [TASK-142] RECEIVED ${positionSaves.length} tasks with positions:`,\n                        positionSaves.map((d: any) => ({ id: d.id?.substring(0, 8), pos: d.position })))\n                } else if (tasksWithPos.length > 0) {\n                    console.error(`❌ [TASK-142] POSITION LOST! Sent ${tasksWithPos.length} with positions, received 0 back!`)\n                }\n            }, 'saveTasks')\n\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveTasks')\n            throw e\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const deleteTask = async (taskId: string): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping deleteTask - not authenticated')\n            return\n        }\n        console.log(`🗑️ [SUPABASE-DELETE] Starting soft-delete for task: ${taskId}`)\n        try {\n            isSyncing.value = true\n\n            const { error, count } = await supabase\n                .from('tasks')\n                .update({ is_deleted: true, deleted_at: new Date().toISOString() })\n                .eq('id', taskId)\n                .select('*', { count: 'exact' })\n\n            console.log(`🗑️ [SUPABASE-DELETE] Result - error: ${error?.message || 'none'}, affected rows: ${count ?? 'unknown'}`)\n\n            if (error) throw error\n            lastSyncError.value = null\n            console.log(`✅ [SUPABASE-DELETE] Task ${taskId} marked as deleted`)\n        } catch (e: unknown) {\n            console.error(`❌ [SUPABASE-DELETE] Failed to delete task ${taskId}:`, e)\n            handleError(e, 'deleteTask')\n            throw e  // Re-throw so caller knows it failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const restoreTask = async (taskId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            const { error } = await supabase\n                .from('tasks')\n                .update({ is_deleted: false, deleted_at: null })\n                .eq('id', taskId)\n            if (error) throw error\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'restoreTask')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const permanentlyDeleteTask = async (taskId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            const { error } = await supabase\n                .from('tasks')\n                .delete()\n                .eq('id', taskId)\n            if (error) throw error\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'permanentlyDeleteTask')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // TASK-153: Fetch IDs of deleted tasks (for golden backup validation)\n    const fetchDeletedTaskIds = async (): Promise<string[]> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return []\n\n            const { data, error } = await supabase\n                .from('tasks')\n                .select('id')\n                .eq('is_deleted', true)\n                .eq('user_id', userId)\n\n            if (error) throw error\n            return data?.map((d: any) => d.id) || []\n        } catch (e: unknown) {\n            console.error('[TASK-153] Failed to fetch deleted task IDs:', e)\n            return []\n        }\n    }\n\n    // TASK-153: Fetch IDs of deleted projects (for golden backup validation)\n    const fetchDeletedProjectIds = async (): Promise<string[]> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return []\n\n            const { data, error } = await supabase\n                .from('projects')\n                .select('id')\n                .eq('is_deleted', true)\n                .eq('user_id', userId)\n\n            if (error) throw error\n            return data?.map((d: any) => d.id) || []\n        } catch (e: unknown) {\n            console.error('[TASK-153] Failed to fetch deleted project IDs:', e)\n            return []\n        }\n    }\n\n    // TASK-153: Fetch IDs of deleted groups (for golden backup validation)\n    const fetchDeletedGroupIds = async (): Promise<string[]> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return []\n\n            const { data, error } = await supabase\n                .from('groups')\n                .select('id')\n                .eq('is_deleted', true)\n                .eq('user_id', userId)\n\n            if (error) throw error\n            return data?.map((d: any) => d.id) || []\n        } catch (e: unknown) {\n            console.error('[TASK-153] Failed to fetch deleted group IDs:', e)\n            return []\n        }\n    }\n\n    // BUG-025 FIX: Atomic bulk delete using Supabase .in() operator\n    const bulkDeleteTasks = async (taskIds: string[]): Promise<void> => {\n        if (taskIds.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping bulkDeleteTasks - not authenticated')\n            return\n        }\n        console.log(`🗑️ [SUPABASE-BULK-DELETE] Starting atomic soft-delete for ${taskIds.length} tasks`)\n        try {\n            isSyncing.value = true\n\n            const { error, count } = await supabase\n                .from('tasks')\n                // FIX: Schema compatibility - remove deleted_at if not in DB\n                .update({ is_deleted: true })\n                .in('id', taskIds)\n                .select('*', { count: 'exact' })\n\n            console.log(`🗑️ [SUPABASE-BULK-DELETE] Result - error: ${error?.message || 'none'}, affected rows: ${count ?? 'unknown'}`)\n\n            if (error) throw error\n            lastSyncError.value = null\n            console.log(`✅ [SUPABASE-BULK-DELETE] ${taskIds.length} tasks marked as deleted atomically`)\n        } catch (e: unknown) {\n            console.error(`❌ [SUPABASE-BULK-DELETE] Failed to bulk delete ${taskIds.length} tasks:`, e)\n            handleError(e, 'bulkDeleteTasks')\n            throw e // Re-throw so caller knows it failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // -- Groups --\n\n    const fetchGroups = async (): Promise<any[]> => {\n        try {\n            const { data, error } = await supabase\n                .from('groups')\n                .select('*')\n                .eq('is_deleted', false)\n\n            if (error) throw error\n            if (!data) return []\n\n\n            // DEBUG: Log loaded groups and their dimensions\n            const groups = data as SupabaseGroup[]\n            groups.forEach((g: any) => {\n                const pos = g.position_json\n                console.log(`📦 [GROUP-LOAD] \"${g.name}\" loaded from Supabase: size=${pos?.width}x${pos?.height}`)\n            })\n\n            return (data as SupabaseGroup[]).map(fromSupabaseGroup)\n        } catch (e: unknown) {\n            handleError(e, 'fetchGroups')\n            return []\n        }\n    }\n\n    const saveGroup = async (group: any): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveGroup - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = toSupabaseGroup(group, userId)\n\n            // TASK-142 FIX: Add .select() and check data.length to detect RLS silent failures\n            // BUG FIX: Use position_json (actual DB column name), not position\n            await withRetry(async () => {\n                const { data, error } = await supabase.from('groups').upsert(payload).select('id, position_json')\n                if (error) throw error\n                if (!data || data.length === 0) {\n                    throw new Error('RLS blocked write - upsert returned no data for group')\n                }\n                // Log position save for debugging\n                if (data[0]?.position_json) {\n                    const pos = data[0].position_json\n                    console.log(`📍 [GROUP-SAVE] Saved group \"${group.name}\" pos=(${pos.x?.toFixed(0)}, ${pos.y?.toFixed(0)}) size=${pos.width}x${pos.height} to Supabase - VERIFIED`)\n                }\n            }, 'saveGroup')\n\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            console.error('Save Group Error:', e)\n            throw e // Re-throw so callers know the save failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const deleteGroup = async (groupId: string): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping deleteGroup - not authenticated')\n            return\n        }\n        console.log(`🗑️ [SUPABASE-DELETE-GROUP] Starting soft-delete for group: ${groupId}`)\n        try {\n            isSyncing.value = true\n\n            // TASK-149 FIX: Add user_id filter and verify rows affected\n            const { data, error, count } = await supabase\n                .from('groups')\n                // FIX: Column 'deleted_at' does not exist in schema. Use 'is_deleted' only.\n                .update({ is_deleted: true })\n                .eq('id', groupId)\n                .eq('user_id', userId)\n                .select('id, is_deleted', { count: 'exact' })\n\n            console.log(`🗑️ [SUPABASE-DELETE-GROUP] Result - error: ${error?.message || 'none'}, affected: ${count ?? 'unknown'}`)\n\n            if (error) throw error\n\n            // Verify the delete actually worked\n            if (!data || data.length === 0) {\n                // BUG-208 FIX: Treat \"no rows updated\" as success (idempotent delete).\n                // This handles cases where the group is already deleted in DB but stuck in UI.\n                console.warn(`⚠️ [SUPABASE-DELETE-GROUP] No rows updated - group ${groupId} likely already deleted or RLS blocked. Proceeding with local removal.`)\n                // We do NOT throw here anymore, allowing the UI to proceed with removing the node.\n            } else {\n                console.log(`✅ [SUPABASE-DELETE-GROUP] Group ${groupId} marked as deleted`)\n            }\n        } catch (e: unknown) {\n            console.error(`❌ [SUPABASE-DELETE-GROUP] Failed:`, e)\n            handleError(e, 'deleteGroup')\n            throw e // Only re-throw actual errors (network, auth, etc)\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // -- Notifications --\n\n    const fetchNotifications = async (): Promise<ScheduledNotification[]> => {\n        try {\n            const { data, error } = await supabase\n                .from('notifications')\n                .select('*')\n                .eq('is_dismissed', false)\n\n            if (error) throw error\n            if (!data) return []\n\n            return (data as SupabaseNotification[]).map(fromSupabaseNotification)\n        } catch (e: unknown) {\n            handleError(e, 'fetchNotifications')\n            return []\n        }\n    }\n\n    const saveNotification = async (notification: ScheduledNotification): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveNotification - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabaseNotification(notification, userId)\n            const { error } = await supabase.from('notifications').upsert(payload)\n            if (error) throw error\n        } catch (e: unknown) {\n            handleError(e, 'saveNotification')\n        }\n    }\n\n    const saveNotifications = async (notifications: ScheduledNotification[]): Promise<void> => {\n        if (notifications.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveNotifications - not authenticated')\n            return\n        }\n        try {\n            const payload = notifications.map(n => toSupabaseNotification(n, userId))\n            const { error } = await supabase.from('notifications').upsert(payload)\n            if (error) throw error\n        } catch (e: unknown) {\n            handleError(e, 'saveNotifications')\n        }\n    }\n\n    const deleteNotification = async (id: string): Promise<void> => {\n        try {\n            const { error } = await supabase.from('notifications').delete().eq('id', id)\n            if (error) throw error\n        } catch (e: unknown) {\n            handleError(e, 'deleteNotification')\n        }\n    }\n\n    // -- Timer Sessions --\n\n    const fetchActiveTimerSession = async (): Promise<any | null> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return null\n\n            const { data, error } = await supabase\n                .from('timer_sessions')\n                .select('*')\n                .eq('user_id', userId)\n                .eq('is_active', true)\n                .order('updated_at', { ascending: false })\n                .limit(1)\n                .maybeSingle()\n\n            if (error) throw error\n            if (!data) return null\n\n            return fromSupabaseTimerSession(data as SupabaseTimerSession)\n        } catch (e: unknown) {\n            handleError(e, 'fetchActiveTimerSession')\n            return null\n        }\n    }\n\n    const saveActiveTimerSession = async (session: any, deviceId: string): Promise<void> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return // Skip Supabase sync when not authenticated (local-only mode)\n\n            const payload = toSupabaseTimerSession(session, userId, deviceId)\n            const { error } = await supabase.from('timer_sessions').upsert(payload)\n            if (error) throw error\n        } catch (e: unknown) {\n            handleError(e, 'saveActiveTimerSession')\n        }\n    }\n\n    const deleteTimerSession = async (id: string): Promise<void> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return // Skip Supabase sync when not authenticated (local-only mode)\n\n            const { error } = await supabase.from('timer_sessions').delete().eq('id', id)\n            if (error) throw error\n        } catch (e: unknown) {\n            handleError(e, 'deleteTimerSession')\n        }\n    }\n\n    // -- User Settings --\n\n    const fetchUserSettings = async (): Promise<any | null> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return null\n\n            const { data, error } = await supabase\n                .from('user_settings')\n                .select('*')\n                .eq('user_id', userId)\n                .maybeSingle()\n\n            if (error) throw error\n            if (!data) return null\n\n            return fromSupabaseUserSettings(data as SupabaseUserSettings)\n        } catch (e: unknown) {\n            console.error('Fetch User Settings Error:', e)\n            return null\n        }\n    }\n\n    const saveUserSettings = async (settings: any): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveUserSettings - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabaseUserSettings(settings, userId)\n\n            await withRetry(async () => {\n                // Fix: Explicitly specify conflict target to handle 'user_settings_user_id_key' violation\n                const { error } = await supabase.from('user_settings').upsert(payload, { onConflict: 'user_id' })\n                if (error) throw error\n            }, 'saveUserSettings')\n        } catch (e: unknown) {\n            handleError(e, 'saveUserSettings')\n        }\n    }\n\n    // -- Quick Sort Sessions --\n\n    const fetchQuickSortHistory = async (): Promise<any[]> => {\n        try {\n            const { data, error } = await supabase\n                .from('quick_sort_sessions')\n                .select('*')\n                .order('completed_at', { ascending: false })\n\n            if (error) throw error\n            if (!data) return []\n\n            return (data as SupabaseQuickSortSession[]).map(fromSupabaseQuickSortSession)\n        } catch (e: unknown) {\n            handleError(e, 'fetchQuickSortHistory')\n            return []\n        }\n    }\n\n    const saveQuickSortSession = async (summary: any): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveQuickSortSession - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabaseQuickSortSession(summary, userId)\n            const { error } = await supabase.from('quick_sort_sessions').upsert(payload)\n            if (error) throw error\n        } catch (e: unknown) {\n            handleError(e, 'saveQuickSortSession')\n        }\n    }\n\n    // -- Realtime Subscription --\n\n    const initRealtimeSubscription = (\n        onProjectChange: (payload: unknown) => void,\n        onTaskChange: (payload: unknown) => void,\n        onTimerChange?: (payload: unknown) => void,\n        onNotificationChange?: (payload: unknown) => void\n    ) => {\n        const userId = authStore.user?.id\n        if (!userId) return null\n\n        // Use a unique channel name per user and purpose\n        const channelName = `db-changes-${userId.substring(0, 8)}`\n        const channel = supabase.channel(channelName)\n            .on(\n                'postgres_changes',\n                { event: '*', schema: 'public', table: 'projects', filter: `user_id=eq.${userId}` },\n                (payload: any) => {\n                    // SAFETY: Explicitly verify table to prevent cross-talk\n                    if (payload.table === 'projects') {\n                        onProjectChange(payload)\n                    }\n                }\n            )\n            .on(\n                'postgres_changes',\n                { event: '*', schema: 'public', table: 'tasks', filter: `user_id=eq.${userId}` },\n                (payload: any) => {\n                    // SAFETY: Explicitly verify table\n                    if (payload.table === 'tasks') {\n                        onTaskChange(payload)\n                    }\n                }\n            )\n\n        if (onTimerChange) {\n            channel.on(\n                'postgres_changes',\n                { event: '*', schema: 'public', table: 'timer_sessions', filter: `user_id=eq.${userId}` },\n                (payload: any) => onTimerChange(payload)\n            )\n        }\n\n        if (onNotificationChange) {\n            channel.on(\n                'postgres_changes',\n                { event: '*', schema: 'public', table: 'notifications', filter: `user_id=eq.${userId}` },\n                (payload: any) => onNotificationChange(payload)\n            )\n        }\n\n        // DEBUG: Log auth state before subscription\n        const session = authStore.session\n        console.log(`📡 [REALTIME] Initializing subscription. Auth state: ${session ? 'Authenticated' : 'Anonymous'}, Role: ${session?.user?.role || 'none'}`)\n\n        // PHASE 4 FIX: Clear any existing active channel to prevent zombies\n        if (supabase.realtime.channels.length > 0) {\n            console.log(`📡 [REALTIME] Cleaning up ${supabase.realtime.channels.length} existing channels...`)\n            supabase.removeAllChannels()\n        }\n\n        // Delay subscription to ensure client state is synced and auth is stable\n        const connectRealtime = async () => {\n            console.log('📡 [REALTIME] Preparing connection...')\n\n            try {\n                // BUG-202: CRITICAL - Ensure we have a fresh token BEFORE any .subscribe() call\n                const { data: { session: freshSession } } = await supabase.auth.getSession()\n                if (freshSession?.access_token) {\n                    console.log('📡 [REALTIME] Setting fresh auth token for WebSocket')\n                    supabase.realtime.setAuth(freshSession.access_token)\n                }\n\n                channel.subscribe((status: any, err?: any) => {\n                    if (status === 'SUBSCRIBED') {\n                        console.log('📡 [REALTIME] Successfully subscribed to database changes')\n                    } else if (status === 'CHANNEL_ERROR') {\n                        console.error('📡 [REALTIME] Handshake failed or connection error:', err || 'Check RLS and JWT expiration')\n\n                        // Retrying auth refresh if we get a 403\n                        if (String(err).includes('403') || !err) {\n                            console.log('📡 [REALTIME] Attempting emergency auth refresh...')\n                            supabase.auth.refreshSession().then(() => {\n                                console.log('📡 [REALTIME] Session refreshed, system will auto-retry connection')\n                            }).catch((refreshErr: unknown) => {\n                                console.error('[ASYNC-ERROR] initRealtimeSubscription refreshSession failed', refreshErr)\n                            })\n                        }\n                    }\n                })\n            } catch (authErr) {\n                console.warn('📡 [REALTIME] Initialization failed:', authErr)\n            }\n        }\n\n        // Start connection\n        connectRealtime()\n\n        return channel\n    }\n\n    return {\n        isSyncing,\n        lastSyncError,\n        fetchProjects,\n        saveProject,\n        saveProjects,\n        deleteProject,\n        restoreProject,\n        permanentlyDeleteProject,\n        fetchTasks,\n        fetchTrash,\n        saveTask,\n        saveTasks,\n        deleteTask,\n        bulkDeleteTasks,\n        restoreTask,\n        permanentlyDeleteTask,\n        // TASK-153: Fetch deleted item IDs for golden backup validation\n        fetchDeletedTaskIds,\n        fetchDeletedProjectIds,\n        fetchDeletedGroupIds,\n        fetchGroups,\n        saveGroup,\n        deleteGroup,\n        fetchNotifications,\n        saveNotification,\n        saveNotifications,\n        deleteNotification,\n        fetchActiveTimerSession,\n        saveActiveTimerSession,\n        deleteTimerSession,\n        fetchUserSettings,\n        saveUserSettings,\n        fetchQuickSortHistory,\n        saveQuickSortSession,\n        initRealtimeSubscription\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useTabVisibility.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useTaskLifecycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useTaskRecurrence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useTaskSmartGroups.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useTextOverflow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useUnifiedUndoRedo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useVirtualList.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useVirtualScrolling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useVueFlowErrorHandling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useVueFlowStability.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":564,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":564,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16012,16015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16012,16015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vue Flow Stability Management System\n * Handles Vue Flow component lifecycle, state management, error recovery, and performance optimization\n */\n\nimport { ref, computed, watch, onMounted, onBeforeUnmount, nextTick, getCurrentInstance, type Ref } from 'vue'\nimport type { Node, Edge, NodeChange as _NodeChange, EdgeChange as _EdgeChange, Connection as _Connection, VueFlowStore } from '@vue-flow/core'\n\nexport interface VueFlowStabilityConfig {\n  maxNodes?: number\n  maxEdges?: number\n  enablePerformanceMonitoring?: boolean\n  enableAutoRecovery?: boolean\n  recoveryAttempts?: number\n  debounceDelay?: number\n}\n\nexport interface VueFlowPerformanceMetrics {\n  nodeCount: number\n  edgeCount: number\n  renderTime: number\n  lastUpdate: number\n  errorCount: number\n  recoveryCount: number\n  memoryUsage?: number\n}\n\nexport interface VueFlowStateSnapshot {\n  nodes: Node[]\n  edges: Edge[]\n  selectedNodes: string[]\n  viewport: {\n    x: number\n    y: number\n    zoom: number\n  }\n  timestamp: number\n}\n\n/**\n * Vue Flow Stability Manager\n */\nexport function useVueFlowStability(\n  nodes: Ref<Node[]>,\n  edges: Ref<Edge[]>,\n  vueFlowStore: Ref<VueFlowStore | null>,\n  config: VueFlowStabilityConfig = {},\n  isInteracting?: Ref<boolean>\n) {\n  const {\n    maxNodes = 1000,\n    maxEdges = 2000,\n    enablePerformanceMonitoring = false,\n    enableAutoRecovery = true,\n    recoveryAttempts = 3,\n    debounceDelay = 100\n  } = config\n\n  // State management\n  const isInitialized = ref(false)\n  const isRecovering = ref(false)\n  const hasErrors = ref(false)\n  const lastError = ref<Error | null>(null)\n  const recoveryAttemptsRemaining = ref(recoveryAttempts)\n\n  // Performance metrics\n  const performanceMetrics = ref<VueFlowPerformanceMetrics>({\n    nodeCount: 0,\n    edgeCount: 0,\n    renderTime: 0,\n    lastUpdate: Date.now(),\n    errorCount: 0,\n    recoveryCount: 0\n  })\n\n  // State snapshots for recovery\n  const stateSnapshots = ref<VueFlowStateSnapshot[]>([])\n  const maxSnapshots = 5\n\n  // Performance monitoring\n  const renderStartTime = ref(0)\n  const updateQueue = ref<Set<() => void>>(new Set())\n  const isUpdateScheduled = ref(false)\n\n  // Computed properties\n  const isOverloaded = computed(() =>\n    nodes.value.length > maxNodes || edges.value.length > maxEdges\n  )\n\n  const performanceStatus = computed(() => {\n    if (hasErrors.value) return 'error'\n    if (isRecovering.value) return 'recovering'\n    if (isOverloaded.value) return 'overloaded'\n    if (performanceMetrics.value.renderTime > 100) return 'slow'\n    return 'healthy'\n  })\n\n  /**\n   * Initialize Vue Flow stability system\n   */\n  const initialize = async () => {\n    console.log('🔧 [VUE_FLOW_STABILITY] Initializing Vue Flow stability system...')\n\n    try {\n      // Set up watchers for nodes and edges\n      setupWatchers()\n\n      // Set up performance monitoring\n      if (enablePerformanceMonitoring) {\n        setupPerformanceMonitoring()\n      }\n\n      // Set up error recovery\n      if (enableAutoRecovery) {\n        setupErrorRecovery()\n      }\n\n      // Create initial state snapshot\n      await createStateSnapshot()\n\n      isInitialized.value = true\n      console.log('✅ [VUE_FLOW_STABILITY] Initialization complete')\n    } catch (error) {\n      console.error('❌ [VUE_FLOW_STABILITY] Initialization failed:', error)\n      hasErrors.value = true\n      lastError.value = error as Error\n    }\n  }\n\n  /**\n   * Set up reactive watchers for nodes and edges\n   */\n  const setupWatchers = () => {\n    // Watch nodes with debounced updates - guarded by isInteracting\n    watch(\n      () => (isInteracting?.value ? null : nodes.value),\n      debounce((val, oldVal) => {\n        if (val) {\n          handleNodesChange(val, oldVal || [])\n        }\n      }, debounceDelay),\n      { deep: true }\n    )\n\n    // Watch edges with debounced updates - guarded by isInteracting\n    watch(\n      () => (isInteracting?.value ? null : edges.value),\n      debounce((val, oldVal) => {\n        if (val) {\n          handleEdgesChange(val, oldVal || [])\n        }\n      }, debounceDelay),\n      { deep: true }\n    )\n\n    // Watch for overload conditions\n    watch(isOverloaded, (overloaded) => {\n      if (overloaded) {\n        console.warn('⚠️ [VUE_FLOW_STABILITY] Canvas overloaded - performance may degrade')\n        handleOverloadCondition()\n      }\n    })\n  }\n\n  /**\n   * Set up performance monitoring\n   */\n  const setupPerformanceMonitoring = () => {\n    if (typeof window !== 'undefined' && 'performance' in window) {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        entries.forEach((entry) => {\n          if (entry.name.includes('vue-flow') || entry.name.includes('render')) {\n            performanceMetrics.value.renderTime = entry.duration\n            performanceMetrics.value.lastUpdate = Date.now()\n          }\n        })\n      })\n\n      try {\n        observer.observe({ entryTypes: ['measure', 'navigation'] })\n      } catch (error) {\n        console.warn('⚠️ [VUE_FLOW_STABILITY] Performance observer setup failed:', error)\n      }\n    }\n  }\n\n  /**\n   * Set up error recovery mechanisms\n   */\n  const setupErrorRecovery = () => {\n    // Monitor for Vue Flow errors\n    if (typeof window !== 'undefined') {\n      window.addEventListener('error', (event) => {\n        if (event.filename?.includes('vue-flow') || event.message?.includes('vue-flow')) {\n          handleError(new Error(event.message), event)\n        }\n      })\n\n      window.addEventListener('unhandledrejection', (event) => {\n        if (event.reason?.message?.includes('vue-flow')) {\n          handleError(new Error(event.reason.message), event)\n        }\n      })\n    }\n  }\n\n  /**\n   * Handle nodes change\n   */\n  const handleNodesChange = (newNodes: Node[], _oldNodes: Node[]) => {\n    try {\n      renderStartTime.value = performance.now()\n\n      // Validate nodes\n      const validNodes = validateNodes(newNodes)\n      if (validNodes.length !== newNodes.length) {\n        console.warn(`⚠️ [VUE_FLOW_STABILITY] Filtered ${newNodes.length - validNodes.length} invalid nodes`)\n        nodes.value = validNodes\n        return\n      }\n\n      // Update metrics\n      performanceMetrics.value.nodeCount = validNodes.length\n      performanceMetrics.value.lastUpdate = Date.now()\n\n      // Create state snapshot periodically\n      if (Math.random() < 0.1) { // 10% chance\n        scheduleStateSnapshot()\n      }\n\n    } catch (error) {\n      handleError(error as Error, { context: 'handleNodesChange' })\n    } finally {\n      if (renderStartTime.value) {\n        performanceMetrics.value.renderTime = performance.now() - renderStartTime.value\n      }\n    }\n  }\n\n  /**\n   * Handle edges change\n   */\n  const handleEdgesChange = (newEdges: Edge[], _oldEdges: Edge[]) => {\n    try {\n      // Validate edges\n      const validEdges = validateEdges(newEdges)\n      if (validEdges.length !== newEdges.length) {\n        console.warn(`⚠️ [VUE_FLOW_STABILITY] Filtered ${newEdges.length - validEdges.length} invalid edges`)\n        edges.value = validEdges\n        return\n      }\n\n      // Update metrics\n      performanceMetrics.value.edgeCount = validEdges.length\n      performanceMetrics.value.lastUpdate = Date.now()\n\n    } catch (error) {\n      handleError(error as Error, { context: 'handleEdgesChange' })\n    }\n  }\n\n  /**\n   * Validate nodes array\n   */\n  const validateNodes = (nodes: Node[]): Node[] => {\n    return nodes.filter(node => {\n      // Check required properties\n      if (!node.id || typeof node.id !== 'string') return false\n      if (!node.position || typeof node.position.x !== 'number' || typeof node.position.y !== 'number') return false\n      if (!node.data || typeof node.data !== 'object') return false\n\n      // Check position bounds\n      if (Math.abs(node.position.x) > 100000 || Math.abs(node.position.y) > 100000) {\n        console.warn(`⚠️ [VUE_FLOW_STABILITY] Node ${node.id} has extreme position:`, node.position)\n        return false\n      }\n\n      return true\n    })\n  }\n\n  /**\n   * Validate edges array\n   */\n  const validateEdges = (edges: Edge[]): Edge[] => {\n    return edges.filter(edge => {\n      // Check required properties\n      if (!edge.id || typeof edge.id !== 'string') return false\n      if (!edge.source || !edge.target) return false\n\n      // Check for self-loops if not allowed\n      if (edge.source === edge.target) return false\n\n      return true\n    })\n  }\n\n  /**\n   * Handle error conditions\n   */\n  const handleError = (error: Error, context?: unknown) => {\n    console.error('❌ [VUE_FLOW_STABILITY] Error:', error, context)\n\n    hasErrors.value = true\n    lastError.value = error\n    performanceMetrics.value.errorCount++\n\n    // Attempt recovery if enabled and attempts remain\n    if (enableAutoRecovery && recoveryAttemptsRemaining.value > 0) {\n      attemptRecovery()\n    }\n  }\n\n  /**\n   * Attempt error recovery\n   */\n  const attemptRecovery = async () => {\n    if (isRecovering.value) {\n      console.log('🔄 [VUE_FLOW_STABILITY] Recovery already in progress')\n      return\n    }\n\n    isRecovering.value = true\n    recoveryAttemptsRemaining.value--\n    performanceMetrics.value.recoveryCount++\n\n    console.log(`🔄 [VUE_FLOW_STABILITY] Attempting recovery (${recoveryAttempts - recoveryAttemptsRemaining.value + 1}/${recoveryAttempts})`)\n\n    try {\n      // Try to restore from the last good snapshot\n      const snapshot = getLastGoodSnapshot()\n      if (snapshot) {\n        await restoreFromSnapshot(snapshot)\n        console.log('✅ [VUE_FLOW_STABILITY] Recovery successful from snapshot')\n      } else {\n        // Fallback: reset to basic state\n        await performBasicRecovery()\n        console.log('✅ [VUE_FLOW_STABILITY] Basic recovery completed')\n      }\n\n      hasErrors.value = false\n      lastError.value = null\n\n    } catch (error) {\n      console.error('❌ [VUE_FLOW_STABILITY] Recovery failed:', error)\n\n      if (recoveryAttemptsRemaining.value === 0) {\n        console.error('💀 [VUE_FLOW_STABILITY] All recovery attempts exhausted')\n      }\n    } finally {\n      isRecovering.value = false\n    }\n  }\n\n  /**\n   * Handle overload conditions\n   */\n  const handleOverloadCondition = async () => {\n    console.log('⚠️ [VUE_FLOW_STABILITY] Handling overload condition...')\n\n    try {\n      // Implement virtualization or pagination for large datasets\n      if (nodes.value.length > maxNodes) {\n        // Keep only the most recent/important nodes\n        const priorityNodes = nodes.value.slice(0, maxNodes)\n        nodes.value = priorityNodes\n        console.log(`📊 [VUE_FLOW_STABILITY] Reduced nodes from ${nodes.value.length} to ${priorityNodes.length}`)\n      }\n\n      if (edges.value.length > maxEdges) {\n        // Keep edges for priority nodes only\n        const priorityNodeIds = new Set(nodes.value.map(n => n.id))\n        const priorityEdges = edges.value.filter(e =>\n          priorityNodeIds.has(e.source) && priorityNodeIds.has(e.target)\n        )\n        edges.value = priorityEdges\n        console.log(`📊 [VUE_FLOW_STABILITY] Reduced edges from ${edges.value.length} to ${priorityEdges.length}`)\n      }\n\n    } catch (error) {\n      console.error('❌ [VUE_FLOW_STABILITY] Overload handling failed:', error)\n    }\n  }\n\n  /**\n   * Create state snapshot\n   */\n  const createStateSnapshot = async (): Promise<VueFlowStateSnapshot> => {\n    const store = vueFlowStore.value as unknown as { getTransform: () => number[] } | null\n    const viewport = store ? {\n      x: store.getTransform?.()[0] || 0,\n      y: store.getTransform?.()[1] || 0,\n      zoom: store.getTransform?.()[2] || 1\n    } : { x: 0, y: 0, zoom: 1 }\n\n    const snapshot: VueFlowStateSnapshot = {\n      nodes: [...nodes.value],\n      edges: [...edges.value],\n      selectedNodes: nodes.value.filter((n: Node) => (n as { selected?: boolean }).selected).map((n: Node) => n.id),\n      viewport,\n      timestamp: Date.now()\n    }\n\n    // Add to snapshots array\n    stateSnapshots.value.push(snapshot)\n\n    // Keep only recent snapshots\n    if (stateSnapshots.value.length > maxSnapshots) {\n      stateSnapshots.value = stateSnapshots.value.slice(-maxSnapshots)\n    }\n\n    return snapshot\n  }\n\n  /**\n   * Schedule state snapshot creation\n   */\n  const scheduleStateSnapshot = () => {\n    if (!isUpdateScheduled.value) {\n      isUpdateScheduled.value = true\n      nextTick(async () => {\n        await createStateSnapshot()\n        isUpdateScheduled.value = false\n      })\n    }\n  }\n\n  /**\n   * Get last good snapshot\n   */\n  const getLastGoodSnapshot = (): VueFlowStateSnapshot | null => {\n    // Return the most recent snapshot that doesn't have errors\n    return stateSnapshots.value\n      .filter(s => s.timestamp > performanceMetrics.value.lastUpdate - 60000) // Within last minute\n      .pop() || null\n  }\n\n  /**\n   * Restore from snapshot\n   * BUG-052 FIX: Removed viewport restoration - preserves user's current viewport\n   */\n  const restoreFromSnapshot = async (snapshot: VueFlowStateSnapshot) => {\n    nodes.value = [...snapshot.nodes]\n    edges.value = [...snapshot.edges]\n\n    // BUG-052: DO NOT restore viewport from snapshot\n    // The user's current viewport position should be preserved\n    // Restoring old viewport positions causes jarring jumps\n  }\n\n  /**\n   * Perform basic recovery\n   * BUG-052 FIX: Removed fitView() call which was causing viewport to jump randomly\n   */\n  const performBasicRecovery = async () => {\n    // Clear invalid nodes and edges\n    nodes.value = validateNodes(nodes.value)\n    edges.value = validateEdges(edges.value)\n\n    // BUG-052: DO NOT reset viewport during recovery - this causes jarring UX\n    // The user's viewport position should be preserved\n    // If viewport reset is truly needed, it should be explicit user action\n  }\n\n  /**\n   * Schedule update with debouncing\n   */\n  const scheduleUpdate = (updateFn: () => void) => {\n    updateQueue.value.add(updateFn)\n\n    if (!isUpdateScheduled.value) {\n      isUpdateScheduled.value = true\n\n      nextTick(() => {\n        try {\n          updateQueue.value.forEach(fn => fn())\n          updateQueue.value.clear()\n        } catch (error) {\n          handleError(error as Error, { context: 'scheduleUpdate' })\n        } finally {\n          isUpdateScheduled.value = false\n        }\n      })\n    }\n  }\n\n  /**\n   * Get memory usage (if available)\n   */\n  const getMemoryUsage = (): number | null => {\n    if (typeof window !== 'undefined' && 'performance' in window && 'memory' in performance) {\n      const memory = (performance as unknown as { memory: { usedJSHeapSize: number } }).memory\n      return memory ? memory.usedJSHeapSize : null\n    }\n    return null\n  }\n\n  /**\n   * Update performance metrics\n   */\n  const updateMetrics = () => {\n    performanceMetrics.value.nodeCount = nodes.value.length\n    performanceMetrics.value.edgeCount = edges.value.length\n    performanceMetrics.value.memoryUsage = getMemoryUsage() || undefined\n    performanceMetrics.value.lastUpdate = Date.now()\n  }\n\n  /**\n   * Cleanup function\n   */\n  const cleanup = () => {\n    updateQueue.value.clear()\n    stateSnapshots.value = []\n    isInitialized.value = false\n    isRecovering.value = false\n    console.log('🧹 [VUE_FLOW_STABILITY] Cleanup completed')\n  }\n\n  // Auto-initialize on mount\n  if (getCurrentInstance()) {\n    onMounted(() => {\n      initialize()\n    })\n\n    onBeforeUnmount(() => {\n      cleanup()\n    })\n  }\n\n  return {\n    // State\n    isInitialized: computed(() => isInitialized.value),\n    isRecovering: computed(() => isRecovering.value),\n    hasErrors: computed(() => hasErrors.value),\n    isOverloaded,\n    performanceStatus,\n\n    // Metrics\n    performanceMetrics: computed(() => ({\n      ...performanceMetrics.value,\n      memoryUsage: getMemoryUsage()\n    })),\n\n    // Actions\n    initialize,\n    createStateSnapshot,\n    restoreFromSnapshot,\n    attemptRecovery,\n    scheduleUpdate,\n    updateMetrics,\n    cleanup,\n\n    // Utilities\n    validateNodes,\n    validateEdges,\n    getLastGoodSnapshot\n  }\n}\n\n/**\n * Debounce utility function\n */\nfunction debounce<T extends (...args: any[]) => void>(func: T, wait: number): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null\n\n  return (...args: Parameters<T>) => {\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n    timeout = setTimeout(() => func(...args), wait)\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/flow-state/src/composables/useVueFlowStateManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'oldVal' is defined but never used. Allowed unused args must match /^_/u.","line":127,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'oldVal' is defined but never used. Allowed unused args must match /^_/u.","line":146,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vue Flow State Management System\n * Provides robust state synchronization for Vue Flow nodes and edges\n */\n\nimport { ref, computed, watch, type Ref, type ComputedRef as _ComputedRef } from 'vue'\nimport type { Node, Edge, NodeChange as _NodeChange, EdgeChange as _EdgeChange, Connection as _Connection } from '@vue-flow/core'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\n\nexport interface VueFlowStateConfig {\n  enableOptimisticUpdates?: boolean\n  enableBatchUpdates?: boolean\n  batchDelay?: number\n  enableStateValidation?: boolean\n  enableConflictResolution?: boolean\n}\n\nexport interface StateOperation {\n  type: 'add' | 'update' | 'remove' | 'move' | 'select'\n  target: 'node' | 'edge'\n  id: string\n  data?: unknown\n  timestamp: number\n}\n\nexport interface StateSnapshot {\n  nodes: Node[]\n  edges: Edge[]\n  operations: StateOperation[]\n  timestamp: number\n}\n\n/**\n * Vue Flow State Manager\n */\nexport function useVueFlowStateManager(\n  nodes: Ref<Node[]>,\n  edges: Ref<Edge[]>,\n  config: VueFlowStateConfig = {},\n  isInteracting?: Ref<boolean>\n) {\n  const {\n    enableOptimisticUpdates: _enableOptimisticUpdates = true,\n    enableBatchUpdates = true,\n    batchDelay = 50,\n    enableStateValidation = true,\n    enableConflictResolution: _enableConflictResolution = true\n  } = config\n\n  // Store references\n  const taskStore = useTaskStore()\n  const _canvasStore = useCanvasStore()\n\n  // State management\n  const isInitialized = ref(false)\n  const pendingOperations = ref<StateOperation[]>([])\n  const operationQueue = ref<Set<() => void>>(new Set())\n  const isProcessingQueue = ref(false)\n  const lastSyncTime = ref(0)\n\n  // State snapshots for undo/redo\n  const stateHistory = ref<StateSnapshot[]>([])\n  const maxHistorySize = 50\n  const currentIndex = ref(-1)\n\n  // Conflict resolution\n  const conflicts = ref<Array<{ type: string; ids: string[]; resolution?: string }>>([])\n\n  // Computed properties\n  const hasPendingOperations = computed(() => pendingOperations.value.length > 0)\n  const canUndo = computed(() => currentIndex.value > 0)\n  const canRedo = computed(() => currentIndex.value < stateHistory.value.length - 1)\n  const stateIntegrity = computed(() => {\n    const nodeIds = new Set(nodes.value.map(n => n.id))\n    const _edgeSources = new Set(edges.value.map(e => e.source))\n    const _edgeTargets = new Set(edges.value.map(e => e.target))\n\n    return {\n      orphanedEdges: edges.value.filter(e => !nodeIds.has(e.source) || !nodeIds.has(e.target)),\n      duplicateNodes: nodes.value.filter((node, index, arr) =>\n        arr.findIndex(n => n.id === node.id) !== index\n      ),\n      duplicateEdges: edges.value.filter((edge, index, arr) =>\n        arr.findIndex(e => e.id === edge.id) !== index\n      )\n    }\n  })\n\n  /**\n   * Initialize state manager\n   */\n  const initialize = async () => {\n    console.log('🔧 [VUE_FLOW_STATE] Initializing state manager...')\n\n    try {\n      // Set up watchers\n      setupWatchers()\n\n      // Set up batch processing\n      if (enableBatchUpdates) {\n        setupBatchProcessing()\n      }\n\n      // Create initial state snapshot\n      await createStateSnapshot()\n\n      // Validate initial state\n      if (enableStateValidation) {\n        validateState()\n      }\n\n      isInitialized.value = true\n      console.log('✅ [VUE_FLOW_STATE] State manager initialized')\n    } catch (error) {\n      console.error('❌ [VUE_FLOW_STATE] Initialization failed:', error)\n    }\n  }\n\n  /**\n   * Set up reactive watchers\n   */\n  const setupWatchers = () => {\n    // Watch for node changes - guarded by isInteracting to prevent traversal during movement\n    watch(\n      () => (isInteracting?.value ? null : nodes.value),\n      (val, oldVal) => {\n        if (isInitialized.value && val) {\n          handleNodeChanges(val, oldNodes || [])\n        }\n      },\n      { deep: true }\n    )\n\n    // Store oldNodes for diffing\n    let oldNodes: Node[] = [...nodes.value]\n    watch(nodes, (newNodes) => {\n      if (!isInteracting?.value) {\n        oldNodes = [...newNodes]\n      }\n    }, { deep: false })\n\n    // Watch for edge changes - guarded by isInteracting\n    watch(\n      () => (isInteracting?.value ? null : edges.value),\n      (val, oldVal) => {\n        if (isInitialized.value && val) {\n          handleEdgeChanges(val, oldEdges || [])\n        }\n      },\n      { deep: true }\n    )\n\n    // Store oldEdges for diffing \n    let oldEdges: Edge[] = [...edges.value]\n    watch(edges, (newEdges) => {\n      if (!isInteracting?.value) {\n        oldEdges = [...newEdges]\n      }\n    }, { deep: false })\n\n    // Watch for conflicts\n    watch(\n      stateIntegrity,\n      (integrity) => {\n        if (isInteracting && isInteracting.value) return\n\n        if (integrity.orphanedEdges.length > 0) {\n          console.warn(`⚠️ [VUE_FLOW_STATE] Found ${integrity.orphanedEdges.length} orphaned edges`)\n          resolveOrphanedEdges(integrity.orphanedEdges)\n        }\n\n        if (integrity.duplicateNodes.length > 0) {\n          console.warn(`⚠️ [VUE_FLOW_STATE] Found ${integrity.duplicateNodes.length} duplicate nodes`)\n          resolveDuplicateNodes(integrity.duplicateNodes)\n        }\n\n        if (integrity.duplicateEdges.length > 0) {\n          console.warn(`⚠️ [VUE_FLOW_STATE] Found ${integrity.duplicateEdges.length} duplicate edges`)\n          resolveDuplicateEdges(integrity.duplicateEdges)\n        }\n      },\n      { deep: true }\n    )\n  }\n\n  /**\n   * Set up batch processing\n   */\n  const setupBatchProcessing = () => {\n    let timeoutId: NodeJS.Timeout | null = null\n\n    const processQueue = () => {\n      if (isProcessingQueue.value || operationQueue.value.size === 0) {\n        return\n      }\n\n      isProcessingQueue.value = true\n\n      try {\n        const operations = Array.from(operationQueue.value)\n        operationQueue.value.clear()\n\n        operations.forEach(operation => {\n          try {\n            operation()\n          } catch (error) {\n            console.error('❌ [VUE_FLOW_STATE] Batch operation failed:', error)\n          }\n        })\n\n        // Create state snapshot after batch\n        createStateSnapshot()\n      } finally {\n        isProcessingQueue.value = false\n        lastSyncTime.value = Date.now()\n      }\n    }\n\n    // Override the scheduleOperation function for batch processing\n    const _originalScheduleOperation = scheduleOperation\n    scheduleOperation = (operation: () => void) => {\n      operationQueue.value.add(operation)\n\n      if (timeoutId) {\n        clearTimeout(timeoutId)\n      }\n\n      timeoutId = setTimeout(processQueue, batchDelay)\n    }\n  }\n\n  /**\n   * Handle node changes with O(N) complexity\n   */\n  const handleNodeChanges = (newNodes: Node[], oldNodes: Node[]) => {\n    const oldNodeMap = new Map(oldNodes.map(n => [n.id, n]))\n    const newNodeMap = new Map(newNodes.map(n => [n.id, n]))\n\n    // Find added nodes\n    newNodes.forEach(node => {\n      if (!oldNodeMap.has(node.id)) {\n        addOperation({\n          type: 'add',\n          target: 'node',\n          id: node.id,\n          data: node,\n          timestamp: Date.now()\n        })\n      }\n    })\n\n    // Find removed nodes\n    oldNodes.forEach(node => {\n      if (!newNodeMap.has(node.id)) {\n        addOperation({\n          type: 'remove',\n          target: 'node',\n          id: node.id,\n          data: node,\n          timestamp: Date.now()\n        })\n      }\n    })\n\n    // Find updated nodes\n    newNodes.forEach(newNode => {\n      const oldNode = oldNodeMap.get(newNode.id)\n      if (oldNode) {\n        // PERF: Only stringify if internal references changed or skip if just position changed (handled elsewhere usually)\n        // But for state manager we want to track everything.\n        // Use a more targeted check if performance is still issue.\n        if (oldNode !== newNode) {\n          // Check if it's actually different content\n          // Using a faster check first: label/data length/keys\n          const dataChanged = JSON.stringify(oldNode.data) !== JSON.stringify(newNode.data)\n          const posChanged = oldNode.position.x !== newNode.position.x || oldNode.position.y !== newNode.position.y\n\n          if (dataChanged || posChanged) {\n            addOperation({\n              type: 'update',\n              target: 'node',\n              id: newNode.id,\n              data: { old: oldNode, new: newNode },\n              timestamp: Date.now()\n            })\n          }\n        }\n      }\n    })\n  }\n\n  /**\n   * Handle edge changes with O(N) complexity\n   */\n  const handleEdgeChanges = (newEdges: Edge[], oldEdges: Edge[]) => {\n    const oldEdgeMap = new Map(oldEdges.map(e => [e.id, e]))\n    const newEdgeMap = new Map(newEdges.map(e => [e.id, e]))\n\n    // Find added edges\n    newEdges.forEach(edge => {\n      if (!oldEdgeMap.has(edge.id)) {\n        addOperation({\n          type: 'add',\n          target: 'edge',\n          id: edge.id,\n          data: edge,\n          timestamp: Date.now()\n        })\n      }\n    })\n\n    // Find removed edges\n    oldEdges.forEach(edge => {\n      if (!newEdgeMap.has(edge.id)) {\n        addOperation({\n          type: 'remove',\n          target: 'edge',\n          id: edge.id,\n          data: edge,\n          timestamp: Date.now()\n        })\n      }\n    })\n\n    // Find updated edges\n    newEdges.forEach(newEdge => {\n      const oldEdge = oldEdgeMap.get(newEdge.id)\n      if (oldEdge && oldEdge !== newEdge) {\n        if (JSON.stringify(oldEdge) !== JSON.stringify(newEdge)) {\n          addOperation({\n            type: 'update',\n            target: 'edge',\n            id: newEdge.id,\n            data: { old: oldEdge, new: newEdge },\n            timestamp: Date.now()\n          })\n        }\n      }\n    })\n  }\n\n  /**\n   * Add operation to pending list\n   */\n  const addOperation = (operation: StateOperation) => {\n    pendingOperations.value.push(operation)\n\n    // Limit operations size\n    if (pendingOperations.value.length > 1000) {\n      pendingOperations.value = pendingOperations.value.slice(-500)\n    }\n  }\n\n  /**\n   * Schedule operation for batch processing\n   */\n  let scheduleOperation = (operation: () => void) => {\n    if (!enableBatchUpdates) {\n      operation()\n      return\n    }\n\n    operationQueue.value.add(operation)\n  }\n\n  /**\n   * Validate state integrity\n   */\n  const validateState = () => {\n    const integrity = stateIntegrity.value\n\n    const issues = [\n      ...integrity.orphanedEdges.map(e => `Orphaned edge: ${e.id}`),\n      ...integrity.duplicateNodes.map(n => `Duplicate node: ${n.id}`),\n      ...integrity.duplicateEdges.map(e => `Duplicate edge: ${e.id}`)\n    ]\n\n    if (issues.length > 0) {\n      console.warn('⚠️ [VUE_FLOW_STATE] State validation issues:', issues)\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Resolve orphaned edges\n   */\n  const resolveOrphanedEdges = (orphanedEdges: Edge[]) => {\n    orphanedEdges.forEach(edge => {\n      const nodeIds = new Set(nodes.value.map(n => n.id))\n\n      if (!nodeIds.has(edge.source) || !nodeIds.has(edge.target)) {\n        console.log(`🗑️ [VUE_FLOW_STATE] Removing orphaned edge: ${edge.id}`)\n\n        scheduleOperation(() => {\n          const index = edges.value.findIndex(e => e.id === edge.id)\n          if (index > -1) {\n            edges.value.splice(index, 1)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Resolve duplicate nodes\n   */\n  const resolveDuplicateNodes = (duplicateNodes: Node[]) => {\n    const seenIds = new Set<string>()\n\n    duplicateNodes.forEach(node => {\n      if (seenIds.has(node.id)) {\n        console.log(`🔧 [VUE_FLOW_STATE] Resolving duplicate node: ${node.id}`)\n\n        scheduleOperation(() => {\n          const index = nodes.value.findIndex(n => n.id === node.id)\n          if (index > -1) {\n            nodes.value.splice(index, 1)\n          }\n        })\n      } else {\n        seenIds.add(node.id)\n      }\n    })\n  }\n\n  /**\n   * Resolve duplicate edges\n   */\n  const resolveDuplicateEdges = (duplicateEdges: Edge[]) => {\n    const seenIds = new Set<string>()\n\n    duplicateEdges.forEach(edge => {\n      if (seenIds.has(edge.id)) {\n        console.log(`🔧 [VUE_FLOW_STATE] Resolving duplicate edge: ${edge.id}`)\n\n        scheduleOperation(() => {\n          const index = edges.value.findIndex(e => e.id === edge.id)\n          if (index > -1) {\n            edges.value.splice(index, 1)\n          }\n        })\n      } else {\n        seenIds.add(edge.id)\n      }\n    })\n  }\n\n  /**\n   * Create state snapshot\n   */\n  const createStateSnapshot = async (): Promise<StateSnapshot> => {\n    const snapshot: StateSnapshot = {\n      nodes: [...nodes.value],\n      edges: [...edges.value],\n      operations: [...pendingOperations.value],\n      timestamp: Date.now()\n    }\n\n    // Add to history\n    stateHistory.value.push(snapshot)\n\n    // Limit history size\n    if (stateHistory.value.length > maxHistorySize) {\n      stateHistory.value = stateHistory.value.slice(-maxHistorySize)\n    }\n\n    // Update current index\n    currentIndex.value = stateHistory.value.length - 1\n\n    return snapshot\n  }\n\n  /**\n   * Restore from snapshot\n   */\n  const restoreFromSnapshot = (snapshot: StateSnapshot) => {\n    nodes.value = [...snapshot.nodes]\n    edges.value = [...snapshot.edges]\n    pendingOperations.value = [...snapshot.operations]\n\n    // Find snapshot index\n    const index = stateHistory.value.findIndex(s => s.timestamp === snapshot.timestamp)\n    if (index > -1) {\n      currentIndex.value = index\n    }\n  }\n\n  /**\n   * Undo last operation\n   */\n  const undo = () => {\n    if (!canUndo.value) {\n      console.warn('⚠️ [VUE_FLOW_STATE] Cannot undo - no history available')\n      return false\n    }\n\n    const targetIndex = currentIndex.value - 1\n    if (targetIndex >= 0 && targetIndex < stateHistory.value.length) {\n      const snapshot = stateHistory.value[targetIndex]\n      restoreFromSnapshot(snapshot)\n      currentIndex.value = targetIndex\n      console.log('↩️ [VUE_FLOW_STATE] Undo completed')\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Redo next operation\n   */\n  const redo = () => {\n    if (!canRedo.value) {\n      console.warn('⚠️ [VUE_FLOW_STATE] Cannot redo - no future state available')\n      return false\n    }\n\n    const targetIndex = currentIndex.value + 1\n    if (targetIndex >= 0 && targetIndex < stateHistory.value.length) {\n      const snapshot = stateHistory.value[targetIndex]\n      restoreFromSnapshot(snapshot)\n      currentIndex.value = targetIndex\n      console.log('↪️ [VUE_FLOW_STATE] Redo completed')\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Clear history\n   */\n  const clearHistory = () => {\n    stateHistory.value = []\n    currentIndex.value = -1\n    pendingOperations.value = []\n    console.log('🗑️ [VUE_FLOW_STATE] History cleared')\n  }\n\n  /**\n   * Sync with stores\n   */\n  const syncWithStores = async () => {\n    try {\n      // Sync nodes with task store\n      const taskNodes = nodes.value.filter(n => n.id.startsWith('task-'))\n      taskNodes.forEach(node => {\n        const taskId = node.id.replace('task-', '')\n        const task = taskStore.tasks.find(t => t.id === taskId)\n\n        if (task && node.position) {\n          // Update task position if different\n          if (task.canvasPosition?.x !== node.position.x || task.canvasPosition?.y !== node.position.y) {\n            taskStore.updateTask(taskId, {\n              canvasPosition: { x: node.position.x, y: node.position.y }\n            })\n          }\n        }\n      })\n\n      // Sync edges with task dependencies\n      edges.value.forEach(edge => {\n        if (edge.source.startsWith('task-') && edge.target.startsWith('task-')) {\n          const sourceTaskId = edge.source.replace('task-', '')\n          const targetTaskId = edge.target.replace('task-', '')\n\n          const sourceTask = taskStore.tasks.find(t => t.id === sourceTaskId)\n          const targetTask = taskStore.tasks.find(t => t.id === targetTaskId)\n\n          if (sourceTask && targetTask) {\n            // Ensure dependency exists\n            if (!(targetTask.dependsOn?.includes(sourceTaskId))) {\n              taskStore.updateTask(targetTaskId, {\n                dependsOn: [...(targetTask.dependsOn || []), sourceTaskId]\n              })\n            }\n          }\n        }\n      })\n\n      console.log('✅ [VUE_FLOW_STATE] Synced with stores')\n    } catch (error) {\n      console.error('❌ [VUE_FLOW_STATE] Store sync failed:', error)\n    }\n  }\n\n  /**\n   * Force state validation and cleanup\n   */\n  const forceValidation = () => {\n    console.log('🔍 [VUE_FLOW_STATE] Forcing state validation...')\n\n    // Validate and fix node integrity\n    const validNodes = nodes.value.filter(node => {\n      if (!node.id || typeof node.id !== 'string') {\n        console.warn(`⚠️ [VUE_FLOW_STATE] Invalid node removed:`, node)\n        return false\n      }\n      if (!node.position || typeof node.position.x !== 'number' || typeof node.position.y !== 'number') {\n        console.warn(`⚠️ [VUE_FLOW_STATE] Node with invalid position removed:`, node.id)\n        return false\n      }\n      return true\n    })\n\n    // Validate and fix edge integrity\n    const validEdges = edges.value.filter(edge => {\n      if (!edge.id || !edge.source || !edge.target) {\n        console.warn(`⚠️ [VUE_FLOW_STATE] Invalid edge removed:`, edge)\n        return false\n      }\n      if (edge.source === edge.target) {\n        console.warn(`⚠️ [VUE_FLOW_STATE] Self-loop edge removed:`, edge.id)\n        return false\n      }\n      return true\n    })\n\n    // Update with validated data\n    scheduleOperation(() => {\n      nodes.value = validNodes\n      edges.value = validEdges\n    })\n\n    // Sync with stores\n    syncWithStores()\n\n    console.log(`✅ [VUE_FLOW_STATE] Validation complete: ${validNodes.length} nodes, ${validEdges.length} edges`)\n  }\n\n  /**\n   * Get performance metrics\n   */\n  const getMetrics = () => ({\n    nodeCount: nodes.value.length,\n    edgeCount: edges.value.length,\n    pendingOperations: pendingOperations.value.length,\n    queueSize: operationQueue.value.size,\n    lastSyncTime: lastSyncTime.value,\n    historySize: stateHistory.value.length,\n    conflicts: conflicts.value.length,\n    integrity: stateIntegrity.value,\n    canUndo: canUndo.value,\n    canRedo: canRedo.value\n  })\n\n  /**\n   * Cleanup function\n   */\n  const cleanup = () => {\n    pendingOperations.value = []\n    operationQueue.value.clear()\n    stateHistory.value = []\n    conflicts.value = []\n    isInitialized.value = false\n    console.log('🧹 [VUE_FLOW_STATE] State manager cleanup completed')\n  }\n\n  return {\n    // State\n    isInitialized: computed(() => isInitialized.value),\n    hasPendingOperations,\n    canUndo,\n    canRedo,\n    stateIntegrity,\n\n    // Actions\n    initialize,\n    undo,\n    redo,\n    clearHistory,\n    syncWithStores,\n    forceValidation,\n    createStateSnapshot,\n    restoreFromSnapshot,\n\n    // Utilities\n    validateState,\n    getMetrics,\n    cleanup\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]}]
