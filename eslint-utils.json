[{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/DragInteractionRecorder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/TaskValidationGuard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/animationBatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/calendar/overlapCalculation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/NodeUpdateBatcher.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[382,385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[382,385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[435,438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[435,438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[522,525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[522,525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { nextTick, type Ref } from 'vue'\n\n// ðŸš€ CPU Optimization: Efficient Node Update Batching System\nexport class NodeUpdateBatcher {\n    private batchQueue: Array<() => void> = []\n    private isProcessing = false\n    private batchTimeout: number | null = null\n    private readonly BATCH_DELAY = 16 // ~60fps\n    private readonly MAX_BATCH_SIZE = 50\n    private vueFlowRef: Ref<any> | null = null\n\n    constructor(vueFlowRef?: Ref<any>) {\n        this.vueFlowRef = vueFlowRef || null\n    }\n\n    setVueFlowRef(ref: Ref<any>) {\n        this.vueFlowRef = ref\n    }\n\n    schedule(update: () => void, priority: 'high' | 'normal' | 'low' = 'normal') {\n        // All priorities go through batching to prevent cascading syncs\n        // High priority uses shorter delay (8ms), normal is 16ms (~60fps), low is 32ms\n        const priorityDelay = {\n            high: 8,\n            normal: this.BATCH_DELAY,\n            low: 32\n        }\n\n        this.batchQueue.push(update)\n\n        // Always restart with appropriate delay when high priority comes in\n        if (priority === 'high') {\n            if (this.batchTimeout) {\n                clearTimeout(this.batchTimeout)\n            }\n            this.batchTimeout = window.setTimeout(() => {\n                this.processBatch()\n            }, priorityDelay.high)\n            return\n        }\n\n        // Start batch processing if not already running\n        if (!this.isProcessing && !this.batchTimeout) {\n            this.startBatchProcessing(priorityDelay[priority])\n        }\n    }\n\n    private startBatchProcessing(delay: number = this.BATCH_DELAY) {\n        if (this.batchTimeout) {\n            clearTimeout(this.batchTimeout)\n        }\n\n        this.batchTimeout = window.setTimeout(() => {\n            this.processBatch()\n        }, delay)\n    }\n\n    private processBatch() {\n        if (this.isProcessing || this.batchQueue.length === 0) return\n\n        this.isProcessing = true\n\n        try {\n            // Process updates in chunks to avoid blocking the main thread\n            const chunk = this.batchQueue.splice(0, Math.min(this.MAX_BATCH_SIZE, this.batchQueue.length))\n\n            // Batch all DOM updates together\n            chunk.forEach(update => {\n                try {\n                    update()\n                } catch (error) {\n                    console.warn('âš ï¸ [BATCH] Error in batched update:', error)\n                }\n            })\n\n            // Update Vue Flow internals once after all updates\n            nextTick(() => {\n                const vueFlowInstance = this.vueFlowRef?.value as { updateNodeInternals?: () => void } | null\n                vueFlowInstance?.updateNodeInternals?.()\n            })\n\n        } catch (error) {\n            console.warn('âš ï¸ [BATCH] Error processing batch:', error)\n        } finally {\n            this.isProcessing = false\n\n            // Continue processing if more items in queue\n            if (this.batchQueue.length > 0) {\n                this.startBatchProcessing()\n            } else {\n                this.batchTimeout = null\n            }\n        }\n    }\n\n    flush() {\n        // Immediately process all pending updates\n        if (this.batchTimeout) {\n            clearTimeout(this.batchTimeout)\n            this.batchTimeout = null\n        }\n        this.processBatch()\n    }\n\n    clear() {\n        if (this.batchTimeout) {\n            clearTimeout(this.batchTimeout)\n            this.batchTimeout = null\n        }\n        this.batchQueue.length = 0\n        this.isProcessing = false\n    }\n\n    getQueueSize(): number {\n        return this.batchQueue.length\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/__tests__/canvasIds.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/canvasIds.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/coordinates.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6436,6439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6436,6439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7211,7214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7211,7214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":236,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7504,7507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7504,7507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'allGroups' is defined but never used. Allowed unused args must match /^_/u.","line":280,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":280,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Canvas Coordinate Utilities\n * TASK-241: Single source of truth for position conversion\n *\n * ============================================================================\n * FULLY ABSOLUTE ARCHITECTURE\n * ============================================================================\n *\n * DATABASE/STORE (Source of Truth):\n *   - Every node (task or group, root or nested) stores ABSOLUTE coordinates\n *   - No node ever stores relative coordinates\n *   - This makes DB values = world positions (simple to reason about)\n *\n * VUE FLOW (Display Layer):\n *   - Root nodes: position = absolute (same as DB)\n *   - Nested nodes: position = relative to parent (Vue Flow requirement)\n *   - parentNode is set for nested items\n *\n * CONVERSION BOUNDARIES:\n *   - READ PATH (DB â†’ Vue Flow): Convert absolute to relative for nested nodes\n *   - WRITE PATH (Vue Flow â†’ DB): Convert relative to absolute for nested nodes\n *\n * These conversions happen ONLY in this file and at the sync boundaries.\n */\n\nimport type { Node } from '@vue-flow/core'\nimport type { Task } from '@/types/tasks'\nimport type { CanvasGroup } from '@/stores/canvas/types'\n\nexport interface Position {\n  x: number\n  y: number\n}\n\nexport interface GroupPosition extends Position {\n  width: number\n  height: number\n}\n\n// =============================================================================\n// CORE CONVERSION FUNCTIONS (Used at Read/Write Boundaries)\n// =============================================================================\n\n/**\n * Convert absolute position (from DB) to relative position (for Vue Flow)\n * Call this when LOADING nodes for display\n *\n * Formula: relative = absolute - parentAbsolute\n */\nexport function toRelativePosition(\n  absolutePos: Position,\n  parentAbsolutePos: Position | null\n): Position {\n  if (!parentAbsolutePos) {\n    return absolutePos // Root nodes stay absolute\n  }\n\n  return {\n    x: absolutePos.x - parentAbsolutePos.x,\n    y: absolutePos.y - parentAbsolutePos.y\n  }\n}\n\n/**\n * Convert relative position (from Vue Flow) to absolute position (for DB)\n * Call this when SAVING after drag end\n *\n * Formula: absolute = relative + parentAbsolute\n */\nexport function toAbsolutePosition(\n  relativePos: Position,\n  parentAbsolutePos: Position | null\n): Position {\n  if (!parentAbsolutePos) {\n    return relativePos // Root nodes are already absolute\n  }\n\n  return {\n    x: relativePos.x + parentAbsolutePos.x,\n    y: relativePos.y + parentAbsolutePos.y\n  }\n}\n\n// =============================================================================\n// GROUP ABSOLUTE POSITION HELPER\n// =============================================================================\n\n/**\n * Get the absolute position of a group from the store\n *\n * FULLY ABSOLUTE ARCHITECTURE:\n * - All groups store absolute coordinates directly in DB/store\n * - Just return the stored position - no parent chain traversal needed\n * - This is the key simplification of the Fully Absolute approach\n *\n * @param groupId The group ID to look up\n * @param allGroups All groups array for lookup\n * @returns The absolute position from the store\n */\nexport function getGroupAbsolutePosition(\n  groupId: string,\n  allGroups: CanvasGroup[]\n): Position {\n  const group = allGroups.find(g => g.id === groupId)\n  if (!group || !group.position) {\n    return { x: 0, y: 0 }\n  }\n\n  // FULLY ABSOLUTE: position in store IS the absolute position\n  // No traversal needed - just return it directly\n  return { x: group.position.x, y: group.position.y }\n}\n\n// =============================================================================\n// READ PATH: DB â†’ Vue Flow (Position Conversion for Display)\n// =============================================================================\n\n/**\n * Convert a group's DB absolute position to Vue Flow position\n * - Root groups: returns absolute (no conversion)\n * - Nested groups: returns relative to parent\n *\n * @param group The group with absolute position from DB\n * @param allGroups All groups for parent lookup\n * @returns Position for Vue Flow (relative if nested, absolute if root)\n */\nexport function groupPositionToVueFlow(\n  group: CanvasGroup,\n  allGroups: CanvasGroup[]\n): Position {\n  const absolutePos = sanitizePosition(group.position)\n\n  if (!group.parentGroupId || group.parentGroupId === 'NONE') {\n    // Root group - use absolute position directly\n    return absolutePos\n  }\n\n  // Nested group - convert absolute to relative for Vue Flow\n  const parentAbsolute = getGroupAbsolutePosition(group.parentGroupId, allGroups)\n  return toRelativePosition(absolutePos, parentAbsolute)\n}\n\n/**\n * Convert a task's DB absolute position to Vue Flow position\n * - Tasks without parent: returns absolute (no conversion)\n * - Tasks in groups: returns relative to parent group\n *\n * @param task The task with absolute position from DB\n * @param allGroups All groups for parent lookup\n * @returns Position for Vue Flow (relative if nested, absolute if root)\n */\nexport function taskPositionToVueFlow(\n  task: Task,\n  allGroups: CanvasGroup[]\n): Position | null {\n  if (!task.canvasPosition) {\n    return null\n  }\n\n  const absolutePos = sanitizePosition(task.canvasPosition)\n\n  if (!task.parentId || task.parentId === 'NONE') {\n    // No parent - use absolute position directly\n    return absolutePos\n  }\n\n  // Task in group - convert absolute to relative for Vue Flow\n  const parentAbsolute = getGroupAbsolutePosition(task.parentId, allGroups)\n  return toRelativePosition(absolutePos, parentAbsolute)\n}\n\n// =============================================================================\n// WRITE PATH: Vue Flow â†’ DB (Position Conversion for Saving)\n// =============================================================================\n\n/**\n * Convert Vue Flow node position to DB absolute position\n * - Root nodes: returns as-is (already absolute)\n * - Nested nodes: converts relative to absolute\n *\n * IMPORTANT: Prefer using Vue Flow's computedPosition when available,\n * as it already provides the world-space absolute position.\n *\n * @param node The Vue Flow node\n * @param parentGroupId The parent group ID (null for root nodes)\n * @param allGroups All groups for parent lookup\n * @returns Absolute position for DB storage\n */\nexport function vueFlowPositionToDb(\n  node: Node,\n  parentGroupId: string | null,\n  allGroups: CanvasGroup[]\n): Position {\n  // If computedPosition is available, use it directly (already absolute)\n  const vfNode = node as any\n  if (vfNode.computedPosition) {\n    return {\n      x: vfNode.computedPosition.x,\n      y: vfNode.computedPosition.y\n    }\n  }\n\n  // Fallback: manually convert relative to absolute\n  const relativePos = sanitizePosition(node.position)\n\n  if (!parentGroupId || parentGroupId === 'NONE') {\n    return relativePos // Already absolute\n  }\n\n  const parentAbsolute = getGroupAbsolutePosition(parentGroupId, allGroups)\n  return toAbsolutePosition(relativePos, parentAbsolute)\n}\n\n// =============================================================================\n// VALIDATION & SANITIZATION\n// =============================================================================\n\n/**\n * Validate that a position is valid (not NaN, not undefined)\n */\nexport function isValidPosition(pos: any): pos is Position {\n  return (\n    pos !== null &&\n    pos !== undefined &&\n    typeof pos.x === 'number' &&\n    typeof pos.y === 'number' &&\n    !isNaN(pos.x) &&\n    !isNaN(pos.y)\n  )\n}\n\n/**\n * Sanitize a position - return fallback if invalid\n */\nexport function sanitizePosition(\n  pos: any,\n  fallback: Position = { x: 0, y: 0 }\n): Position {\n  if (isValidPosition(pos)) {\n    return { x: pos.x, y: pos.y }\n  }\n  return fallback\n}\n\n/**\n * Round position to avoid floating point drift\n */\nexport function roundPosition(pos: Position, decimals: number = 0): Position {\n  const factor = Math.pow(10, decimals)\n  return {\n    x: Math.round(pos.x * factor) / factor,\n    y: Math.round(pos.y * factor) / factor\n  }\n}\n\n/**\n * Check if two positions are equal (within tolerance)\n */\nexport function positionsEqual(\n  a: Position,\n  b: Position,\n  tolerance: number = 0.5\n): boolean {\n  return (\n    Math.abs(a.x - b.x) < tolerance &&\n    Math.abs(a.y - b.y) < tolerance\n  )\n}\n\n// =============================================================================\n// LEGACY COMPATIBILITY (for existing code that uses these)\n// =============================================================================\n\n/**\n * Get absolute position for a task based on its parentId\n * @deprecated Use taskPositionToVueFlow for read path, vueFlowPositionToDb for write path\n */\nexport function getTaskAbsolutePosition(\n  task: Task,\n  allGroups: CanvasGroup[]\n): Position | null {\n  if (!task.canvasPosition) {\n    return null\n  }\n\n  // In Fully Absolute Architecture, task.canvasPosition IS already absolute\n  return sanitizePosition(task.canvasPosition)\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/invariants.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2544,2547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2544,2547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":131,"column":65,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":131,"endColumn":90},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":166,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":166,"endColumn":57},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":225,"column":61,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":225,"endColumn":86},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":268,"column":61,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":268,"endColumn":75},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":317,"column":54,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":317,"endColumn":62,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[11947,11948],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":559,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":559,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20016,20019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20016,20019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":575,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":575,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20623,20626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20623,20626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Canvas Hierarchy Invariant Validation\n *\n * This module defines and validates the three core invariants that must hold\n * for the nested group system to work correctly.\n *\n * ============================================================================\n * INVARIANT A: HIERARCHY CONSISTENCY\n * ============================================================================\n * - If group.parentGroupId === null â†’ Vue Flow node has parentNode: undefined, extent: undefined\n * - If group.parentGroupId !== null â†’ Vue Flow node has parentNode = CanvasIds.groupNodeId(parentGroupId)\n *   (NOTE: Groups do NOT have extent: 'parent' set - this allows childâ†’root drag transitions)\n * - The parent group MUST exist in the store\n *\n * ============================================================================\n * INVARIANT B: POSITION ARCHITECTURE\n * ============================================================================\n * - Store/DB always holds ABSOLUTE world coordinates for ALL nodes\n * - Vue Flow uses:\n *   - Root nodes: position = absolute (no conversion)\n *   - Nested nodes: position = absolute - parentAbsolute (relative to parent)\n *\n * ============================================================================\n * INVARIANT C: RECURSION SAFETY\n * ============================================================================\n * - All recursive functions MUST use a visited set to prevent infinite loops\n * - collectDescendantGroups, getTaskCountInGroupRecursive, getAllDescendantGroupIds\n *   must all accept and use a visited set parameter\n */\n\nimport type { Node } from '@vue-flow/core'\nimport type { CanvasGroup } from '@/stores/canvas/types'\nimport type { Task } from '@/types/tasks'\nimport { CanvasIds } from './canvasIds'\nimport {\n    getGroupAbsolutePosition,\n    toRelativePosition,\n    sanitizePosition\n} from './coordinates'\n\n// Epsilon for position comparison - must match tolerance used in sync code\nconst POSITION_EPSILON = 0.5\n\n// Only log in development mode\nconst isDev = import.meta.env.DEV\n\n/**\n * Invariant violation severity levels\n */\nexport enum InvariantSeverity {\n    ERROR = 'ERROR',     // Must fix immediately - will cause bugs\n    WARNING = 'WARNING', // Should fix - may cause subtle issues\n    INFO = 'INFO'        // Informational - potential optimization\n}\n\n/**\n * Invariant violation report\n */\nexport interface InvariantViolation {\n    invariant: 'A' | 'B' | 'C'\n    severity: InvariantSeverity\n    nodeId: string\n    nodeType: 'group' | 'task'\n    message: string\n    details: Record<string, any>\n}\n\n/**\n * Validate Invariant A: Hierarchy Consistency\n *\n * Checks that Vue Flow node's parentNode and extent match the store's parentGroupId\n */\nexport function validateInvariantA(\n    vueFlowNodes: Node[],\n    storeGroups: CanvasGroup[]\n): InvariantViolation[] {\n    const violations: InvariantViolation[] = []\n    const groupById = new Map(storeGroups.map(g => [g.id, g]))\n\n    for (const node of vueFlowNodes) {\n        if (!CanvasIds.isGroupNode(node.id)) continue\n\n        const { id: groupId } = CanvasIds.parseNodeId(node.id)\n        const storeGroup = groupById.get(groupId)\n\n        if (!storeGroup) {\n            violations.push({\n                invariant: 'A',\n                severity: InvariantSeverity.ERROR,\n                nodeId: groupId,\n                nodeType: 'group',\n                message: `Vue Flow node exists but group not found in store`,\n                details: { nodeId: node.id }\n            })\n            continue\n        }\n\n        const hasStoreParent = storeGroup.parentGroupId && storeGroup.parentGroupId !== 'NONE'\n        const hasVueFlowParent = !!node.parentNode\n        const hasExtent = node.extent === 'parent'\n\n        // Case 1: Store says no parent\n        if (!hasStoreParent) {\n            if (hasVueFlowParent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Store has no parentGroupId but Vue Flow node has parentNode set`,\n                    details: {\n                        storeParentGroupId: storeGroup.parentGroupId,\n                        vueFlowParentNode: node.parentNode\n                    }\n                })\n            }\n            if (hasExtent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.WARNING,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Store has no parentGroupId but Vue Flow node has extent: 'parent'`,\n                    details: { extent: node.extent }\n                })\n            }\n        }\n\n        // Case 2: Store says has parent\n        if (hasStoreParent) {\n            const expectedVueFlowParent = CanvasIds.groupNodeId(storeGroup.parentGroupId!)\n\n            if (!hasVueFlowParent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Store has parentGroupId but Vue Flow node has no parentNode`,\n                    details: {\n                        storeParentGroupId: storeGroup.parentGroupId,\n                        expected: expectedVueFlowParent\n                    }\n                })\n            } else if (node.parentNode !== expectedVueFlowParent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Vue Flow parentNode doesn't match store parentGroupId`,\n                    details: {\n                        storeParentGroupId: storeGroup.parentGroupId,\n                        vueFlowParentNode: node.parentNode,\n                        expected: expectedVueFlowParent\n                    }\n                })\n            }\n\n            // NOTE: We intentionally do NOT check for extent: 'parent' here.\n            // Groups are allowed to NOT have extent set so they can be dragged outside\n            // their parent for childâ†’root transitions. The containment check in\n            // onNodeDragStop handles re-parenting via spatial detection.\n\n            // Check parent exists\n            if (!groupById.has(storeGroup.parentGroupId!)) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Parent group doesn't exist in store`,\n                    details: {\n                        parentGroupId: storeGroup.parentGroupId,\n                        availableGroups: Array.from(groupById.keys())\n                    }\n                })\n            }\n        }\n    }\n\n    return violations\n}\n\n/**\n * Helper: Compare positions with epsilon tolerance\n */\nfunction positionsMatch(\n    actual: { x: number; y: number },\n    expected: { x: number; y: number }\n): boolean {\n    const dx = Math.abs(actual.x - expected.x)\n    const dy = Math.abs(actual.y - expected.y)\n    return dx <= POSITION_EPSILON && dy <= POSITION_EPSILON\n}\n\n/**\n * Validate Invariant B: Position Architecture\n *\n * Checks that Vue Flow positions are correctly computed from store absolute positions.\n * Uses the exact same conversion logic as useCanvasSync.ts to ensure consistency.\n */\nexport function validateInvariantB(\n    vueFlowNodes: Node[],\n    storeGroups: CanvasGroup[],\n    storeTasks: Task[]\n): InvariantViolation[] {\n    const violations: InvariantViolation[] = []\n\n    // Check groups\n    for (const node of vueFlowNodes) {\n        if (!CanvasIds.isGroupNode(node.id)) continue\n\n        const { id: groupId } = CanvasIds.parseNodeId(node.id)\n        const storeGroup = storeGroups.find(g => g.id === groupId)\n        if (!storeGroup) continue\n\n        // Use sanitizePosition to match what useCanvasSync does\n        const storeAbsolute = sanitizePosition(storeGroup.position)\n        const hasParent = storeGroup.parentGroupId && storeGroup.parentGroupId !== 'NONE'\n\n        // Compute expected Vue Flow position using same logic as groupPositionToVueFlow\n        let expectedVueFlowPos: { x: number; y: number }\n        if (hasParent) {\n            const parentAbsolute = getGroupAbsolutePosition(storeGroup.parentGroupId!, storeGroups)\n            expectedVueFlowPos = toRelativePosition(storeAbsolute, parentAbsolute)\n        } else {\n            expectedVueFlowPos = storeAbsolute\n        }\n\n        const actualVueFlowPos = sanitizePosition(node.position)\n\n        if (!positionsMatch(actualVueFlowPos, expectedVueFlowPos)) {\n            violations.push({\n                invariant: 'B',\n                severity: InvariantSeverity.WARNING,\n                nodeId: groupId,\n                nodeType: 'group',\n                message: `Vue Flow position doesn't match expected (${hasParent ? 'relative' : 'absolute'})`,\n                details: {\n                    storeAbsolute,\n                    parentGroupId: storeGroup.parentGroupId,\n                    expectedVueFlowPos,\n                    actualVueFlowPos,\n                    delta: {\n                        x: actualVueFlowPos.x - expectedVueFlowPos.x,\n                        y: actualVueFlowPos.y - expectedVueFlowPos.y\n                    }\n                }\n            })\n        }\n    }\n\n    // Check tasks\n    for (const node of vueFlowNodes) {\n        if (node.type !== 'taskNode') continue\n\n        const task = storeTasks.find(t => t.id === node.id)\n        if (!task || !task.canvasPosition) continue\n\n        // Use sanitizePosition to match what useCanvasSync does\n        const storeAbsolute = sanitizePosition(task.canvasPosition)\n        const hasParent = task.parentId && task.parentId !== 'NONE'\n\n        // Compute expected Vue Flow position using same logic as taskPositionToVueFlow\n        let expectedVueFlowPos: { x: number; y: number }\n        if (hasParent) {\n            const parentAbsolute = getGroupAbsolutePosition(task.parentId!, storeGroups)\n            expectedVueFlowPos = toRelativePosition(storeAbsolute, parentAbsolute)\n        } else {\n            expectedVueFlowPos = storeAbsolute\n        }\n\n        const actualVueFlowPos = sanitizePosition(node.position)\n\n        if (!positionsMatch(actualVueFlowPos, expectedVueFlowPos)) {\n            violations.push({\n                invariant: 'B',\n                severity: InvariantSeverity.WARNING,\n                nodeId: task.id,\n                nodeType: 'task',\n                message: `Vue Flow position doesn't match expected (${hasParent ? 'relative' : 'absolute'})`,\n                details: {\n                    storeAbsolute,\n                    parentId: task.parentId,\n                    expectedVueFlowPos,\n                    actualVueFlowPos: { x: node.position.x, y: node.position.y }\n                }\n            })\n        }\n    }\n\n    return violations\n}\n\n/**\n * Validate Invariant C: No Cycles in Hierarchy\n *\n * Checks that there are no cycles in the parent-child relationships\n */\nexport function validateInvariantC(storeGroups: CanvasGroup[]): InvariantViolation[] {\n    const violations: InvariantViolation[] = []\n\n    for (const group of storeGroups) {\n        if (!group.parentGroupId || group.parentGroupId === 'NONE') continue\n\n        const visited = new Set<string>()\n        let current: CanvasGroup | undefined = group\n        let hasCycle = false\n\n        while (current && current.parentGroupId && current.parentGroupId !== 'NONE') {\n            if (visited.has(current.id)) {\n                hasCycle = true\n                break\n            }\n            visited.add(current.id)\n            current = storeGroups.find(g => g.id === current!.parentGroupId)\n        }\n\n        if (hasCycle) {\n            violations.push({\n                invariant: 'C',\n                severity: InvariantSeverity.ERROR,\n                nodeId: group.id,\n                nodeType: 'group',\n                message: `Cycle detected in parent chain`,\n                details: {\n                    groupId: group.id,\n                    groupName: group.name,\n                    visitedChain: Array.from(visited)\n                }\n            })\n        }\n    }\n\n    return violations\n}\n\n/**\n * Run all invariant validations and log violations\n *\n * Call this after sync operations to verify consistency\n */\nexport function validateAllInvariants(\n    vueFlowNodes: Node[],\n    storeGroups: CanvasGroup[],\n    storeTasks: Task[],\n    context: string = 'unknown'\n): InvariantViolation[] {\n    const allViolations: InvariantViolation[] = []\n\n    // Only run in dev mode\n    if (!isDev) return allViolations\n\n    const violationsA = validateInvariantA(vueFlowNodes, storeGroups)\n    const violationsB = validateInvariantB(vueFlowNodes, storeGroups, storeTasks)\n    const violationsC = validateInvariantC(storeGroups)\n\n    allViolations.push(...violationsA, ...violationsB, ...violationsC)\n\n    if (allViolations.length > 0) {\n        console.group(`[INVARIANT] ${allViolations.length} violation(s) detected in ${context}`)\n\n        const errors = allViolations.filter(v => v.severity === InvariantSeverity.ERROR)\n        const warnings = allViolations.filter(v => v.severity === InvariantSeverity.WARNING)\n\n        if (errors.length > 0) {\n            console.error(`${errors.length} ERROR(s):`)\n            errors.forEach(v => {\n                console.error(`  [${v.invariant}] ${v.nodeType} ${v.nodeId}: ${v.message}`, v.details)\n            })\n        }\n\n        if (warnings.length > 0) {\n            console.warn(`${warnings.length} WARNING(s):`)\n            warnings.forEach(v => {\n                console.warn(`  [${v.invariant}] ${v.nodeType} ${v.nodeId}: ${v.message}`, v.details)\n            })\n        }\n\n        console.groupEnd()\n    } else if (isDev) {\n        // Log success only in very verbose mode\n        // console.log(`[INVARIANT] All invariants passed in ${context}`)\n    }\n\n    return allViolations\n}\n\n/**\n * Log a summary of the current hierarchy state\n *\n * Call this once on load to see the hierarchy at a glance\n */\nexport function logHierarchySummary(storeGroups: CanvasGroup[]): void {\n    if (!isDev) return\n\n    console.group('[HIERARCHY] Group Hierarchy Summary')\n\n    // Find root groups\n    const rootGroups = storeGroups.filter(g => !g.parentGroupId || g.parentGroupId === 'NONE')\n    const nestedGroups = storeGroups.filter(g => g.parentGroupId && g.parentGroupId !== 'NONE')\n\n    console.log(`Total: ${storeGroups.length} groups (${rootGroups.length} root, ${nestedGroups.length} nested)`)\n\n    // Build tree structure\n    const printTree = (groupId: string, indent: string = '') => {\n        const group = storeGroups.find(g => g.id === groupId)\n        if (!group) return\n\n        console.log(`${indent}${group.name} [${group.id.substring(0, 8)}...] @ (${group.position.x}, ${group.position.y})`)\n\n        const children = storeGroups.filter(g => g.parentGroupId === groupId)\n        children.forEach((child, i) => {\n            const isLast = i === children.length - 1\n            printTree(child.id, indent + (isLast ? '  ' : '  '))\n        })\n    }\n\n    rootGroups.forEach(g => printTree(g.id))\n\n    console.groupEnd()\n}\n\n// ============================================================================\n// GEOMETRY CHANGE GUARD\n// ============================================================================\n\n/**\n * Assert that no geometry fields are being changed by a non-authorized source.\n *\n * Smart Groups may only update METADATA (dueDate, priority, status, tags).\n * This guard catches any accidental geometry writes before they happen.\n *\n * @param oldTask - The current task state\n * @param newUpdates - The proposed updates\n * @param context - Description of where this check is being called from\n */\nexport function assertNoGeometryChange(\n    oldTask: { id: string; title?: string; parentId?: string | null; canvasPosition?: { x: number; y: number } | null },\n    newUpdates: { parentId?: string | null; canvasPosition?: { x: number; y: number } | null },\n    context: string\n): void {\n    if (!import.meta.env.DEV) return\n\n    const changedFields: string[] = []\n\n    // Check parentId change\n    if ('parentId' in newUpdates && newUpdates.parentId !== oldTask.parentId) {\n        changedFields.push('parentId')\n    }\n\n    // Check canvasPosition change\n    if ('canvasPosition' in newUpdates) {\n        const oldPos = oldTask.canvasPosition\n        const newPos = newUpdates.canvasPosition\n        if (oldPos?.x !== newPos?.x || oldPos?.y !== newPos?.y) {\n            changedFields.push('canvasPosition')\n        }\n    }\n\n    if (changedFields.length > 0) {\n        console.error('[ASSERT-FAILED] Smart group attempted geometry change', {\n            context,\n            taskId: oldTask.id?.slice(0, 8),\n            taskTitle: oldTask.title?.slice(0, 30),\n            changedFields,\n            oldParentId: oldTask.parentId,\n            newParentId: newUpdates.parentId,\n            oldPosition: oldTask.canvasPosition,\n            newPosition: newUpdates.canvasPosition\n        })\n    }\n}\n\n// ============================================================================\n// DUPLICATE ID DETECTION\n// ============================================================================\n\n/**\n * Result of duplicate ID check\n */\nexport interface DuplicateIdResult {\n    duplicates: Array<{ id: string; count: number }>\n    totalCount: number\n    uniqueIdCount: number\n    hasDuplicates: boolean\n}\n\n/**\n * Assert that no duplicate IDs exist in an array of items\n *\n * This is the authoritative helper for duplicate detection across all layers.\n * Use it in:\n * - tasksWithCanvasPosition (selector layer)\n * - visibleGroups (store layer)\n * - Node builders (final layer)\n *\n * @param items - Array of items with 'id' property\n * @param context - Descriptive context for error messages (e.g., 'tasksToSync', 'groups')\n * @returns DuplicateIdResult with stats and duplicate list\n */\nexport function assertNoDuplicateIds<T extends { id: string }>(\n    items: T[],\n    context: string\n): DuplicateIdResult {\n    const counts = new Map<string, number>()\n\n    for (const item of items) {\n        counts.set(item.id, (counts.get(item.id) ?? 0) + 1)\n    }\n\n    const duplicates = Array.from(counts.entries())\n        .filter(([, count]) => count > 1)\n        .map(([id, count]) => ({ id, count }))\n\n    const result: DuplicateIdResult = {\n        duplicates,\n        totalCount: items.length,\n        uniqueIdCount: counts.size,\n        hasDuplicates: duplicates.length > 0\n    }\n\n    if (result.hasDuplicates) {\n        console.error(`[ASSERT-FAILED] Duplicate ids in ${context}`, {\n            duplicates: duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n            totalCount: result.totalCount,\n            uniqueIdCount: result.uniqueIdCount\n        })\n    }\n\n    return result\n}\n\n/**\n * Alias for assertNoDuplicateIds - preferred naming convention\n */\nexport const checkForDuplicateIds = assertNoDuplicateIds\n\n// ============================================================================\n// GEOMETRY DRIFT DETECTION\n// ============================================================================\n\n/**\n * Fields that constitute \"geometry\" - only drag handlers should modify these\n */\nconst GEOMETRY_FIELDS = ['canvasPosition', 'position', 'parentId', 'parentGroupId'] as const\ntype GeometryField = typeof GEOMETRY_FIELDS[number]\n\n/**\n * Allowed sources that can modify geometry\n */\nconst ALLOWED_GEOMETRY_SOURCES = ['DRAG', 'CREATE', 'MOVE_TO_INBOX', 'INITIAL_RECONCILE'] as const\ntype GeometrySource = typeof ALLOWED_GEOMETRY_SOURCES[number]\n\n/**\n * Check if an update object contains geometry fields\n */\nexport function containsGeometryFields(updates: Record<string, any>): GeometryField[] {\n    return GEOMETRY_FIELDS.filter(field => field in updates)\n}\n\n/**\n * Assert that geometry changes come from an allowed source\n *\n * Call this from updateTask/updateGroup with a source parameter.\n * Logs [GEOMETRY-DRIFT] warning if non-allowed source tries to modify geometry.\n *\n * @param updates - The update object being applied\n * @param source - Who is making the change ('DRAG', 'SYNC', 'SMART-GROUP', etc.)\n * @param entityType - 'task' or 'group'\n * @param entityId - The ID of the entity being updated\n */\nexport function assertGeometrySource(\n    updates: Record<string, any>,\n    source: string | undefined,\n    entityType: 'task' | 'group',\n    entityId: string\n): void {\n    if (!isDev) return\n\n    const geometryFields = containsGeometryFields(updates)\n    if (geometryFields.length === 0) return // No geometry changes\n\n    const isAllowed = source && ALLOWED_GEOMETRY_SOURCES.includes(source as GeometrySource)\n\n    if (isAllowed) {\n        console.debug(`ðŸ“ [GEOMETRY-${source}]`, {\n            entityType,\n            entityId: entityId.slice(0, 8),\n            fields: geometryFields,\n            values: geometryFields.reduce((acc, f) => ({ ...acc, [f]: updates[f] }), {})\n        })\n    } else {\n        console.warn(`âš ï¸ [GEOMETRY-DRIFT] Non-drag source \"${source || 'UNKNOWN'}\" modifying geometry`, {\n            entityType,\n            entityId: entityId.slice(0, 8),\n            fields: geometryFields,\n            values: geometryFields.reduce((acc, f) => ({ ...acc, [f]: updates[f] }), {}),\n            stack: new Error().stack?.split('\\n').slice(2, 5).join('\\n')\n        })\n    }\n}\n\n// ============================================================================\n// SUPABASE DEBUG HELPERS\n// ============================================================================\n//\n// SQL QUERIES FOR FINDING DUPLICATES:\n// ====================================\n//\n// Find duplicate task IDs in database:\n// ```sql\n// SELECT id, COUNT(*) AS cnt\n// FROM tasks\n// GROUP BY id\n// HAVING COUNT(*) > 1;\n// ```\n//\n// Find duplicate group IDs in database:\n// ```sql\n// SELECT id, COUNT(*) AS cnt\n// FROM groups\n// GROUP BY id\n// HAVING COUNT(*) > 1;\n// ```\n//\n// ONE-TIME CLEANUP (DANGEROUS - run manually in Supabase SQL editor):\n// ===================================================================\n// For tasks - keep the row with latest updated_at, delete others:\n// ```sql\n// WITH duplicates AS (\n//   SELECT id, ctid, ROW_NUMBER() OVER (PARTITION BY id ORDER BY updated_at DESC) as rn\n//   FROM tasks\n//   WHERE id IN (\n//     SELECT id FROM tasks GROUP BY id HAVING COUNT(*) > 1\n//   )\n// )\n// DELETE FROM tasks WHERE ctid IN (\n//   SELECT ctid FROM duplicates WHERE rn > 1\n// );\n// ```\n//\n// For groups - keep the row with latest updated_at, delete others:\n// ```sql\n// WITH duplicates AS (\n//   SELECT id, ctid, ROW_NUMBER() OVER (PARTITION BY id ORDER BY updated_at DESC) as rn\n//   FROM groups\n//   WHERE id IN (\n//     SELECT id FROM groups GROUP BY id HAVING COUNT(*) > 1\n//   )\n// )\n// DELETE FROM groups WHERE ctid IN (\n//   SELECT ctid FROM duplicates WHERE rn > 1\n// );\n// ```\n//\n// ============================================================================\n\n/**\n * Log task ID histogram from Supabase fetch results\n *\n * Call after fetchTasks() to detect if Supabase returns duplicates.\n * This would indicate a database-level issue (multiple rows with same ID).\n *\n * @param tasks - Array of tasks from Supabase\n * @param context - Description of the fetch (e.g., 'loadFromDatabase')\n */\nexport function logSupabaseTaskIdHistogram(\n    tasks: Array<{ id: string; title?: string }>,\n    context: string\n): void {\n    if (!isDev) return\n\n    const counts = new Map<string, number>()\n    for (const task of tasks) {\n        counts.set(task.id, (counts.get(task.id) ?? 0) + 1)\n    }\n\n    const duplicates = Array.from(counts.entries())\n        .filter(([, count]) => count > 1)\n        .map(([id, count]) => ({ id: id.slice(0, 8), count }))\n\n    if (duplicates.length > 0) {\n        console.error(`[SUPABASE-DUPLICATES] ${context}`, {\n            duplicates,\n            totalCount: tasks.length,\n            uniqueCount: counts.size\n        })\n    } else {\n        console.debug(`[SUPABASE-HISTOGRAM] ${context}`, {\n            totalCount: tasks.length,\n            uniqueCount: counts.size\n        })\n    }\n}\n\n/**\n * Log group ID histogram from Supabase fetch results\n *\n * Call after fetchGroups() to detect if Supabase returns duplicates.\n * This would indicate a database-level issue (multiple rows with same ID).\n *\n * @param groups - Array of groups from Supabase\n * @param context - Description of the fetch (e.g., 'loadFromDatabase')\n */\nexport function logSupabaseGroupIdHistogram(\n    groups: Array<{ id: string; name?: string }>,\n    context: string\n): void {\n    if (!isDev) return\n\n    const counts = new Map<string, number>()\n    for (const group of groups) {\n        counts.set(group.id, (counts.get(group.id) ?? 0) + 1)\n    }\n\n    const duplicates = Array.from(counts.entries())\n        .filter(([, count]) => count > 1)\n        .map(([id, count]) => ({ id: id.slice(0, 8), count }))\n\n    if (duplicates.length > 0) {\n        console.error(`[SUPABASE-GROUP-DUPLICATES] ${context}`, {\n            duplicates,\n            totalCount: groups.length,\n            uniqueCount: counts.size\n        })\n    } else {\n        console.debug(`[SUPABASE-GROUP-HISTOGRAM] ${context}`, {\n            totalCount: groups.length,\n            uniqueCount: counts.size\n        })\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/positionCalculator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Node' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CanvasGroup' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TaskPosition' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":40}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Node } from '@vue-flow/core'\nimport type { CanvasGroup, TaskPosition } from '@/stores/canvas/types'\nimport { CANVAS } from '@/constants/canvas'\n\n// --- Interfaces ---\n\nexport interface Rect {\n    x: number\n    y: number\n    width: number\n    height: number\n}\n\nexport interface Position {\n    x: number\n    y: number\n}\n\n/**\n * Calculates the inner rect of a group by accounting for the border.\n */\nexport const getInnerRect = (rect: Rect): Rect => {\n    return {\n        x: rect.x + CANVAS.GROUP_BORDER_WIDTH,\n        y: rect.y + CANVAS.GROUP_BORDER_WIDTH,\n        width: Math.max(0, rect.width - (CANVAS.GROUP_BORDER_WIDTH * 2)),\n        height: Math.max(0, rect.height - (CANVAS.GROUP_BORDER_WIDTH * 2))\n    }\n}\n\n/**\n * Calculates the center point of a task node.\n */\nexport const getTaskCenter = (x: number, y: number, width: number = 220, height: number = 100): Position => {\n    return {\n        x: x + (width / 2),\n        y: y + (height / 2)\n    }\n}\n\n// --- Containment Logic ---\n\n/**\n * Checks if a point (x, y) is inside a rectangle.\n */\nexport const isPointInRect = (x: number, y: number, rect: Rect, useInnerRect: boolean = false): boolean => {\n    const targetRect = useInnerRect ? getInnerRect(rect) : rect\n    return x >= targetRect.x && x <= targetRect.x + targetRect.width &&\n        y >= targetRect.y && y <= targetRect.y + targetRect.height\n}\n\n/**\n * Checks if a node is \"mostly\" inside a parent rect (simple center check).\n * Used for task-in-group containment.\n */\nexport const isTaskInsideGroup = (taskPos: Position, taskSize: { width: number, height: number }, groupRect: Rect): boolean => {\n    // Logic: Center Point Containment\n    const centerX = taskPos.x + (taskSize.width / 2)\n    const centerY = taskPos.y + (taskSize.height / 2)\n    return isPointInRect(centerX, centerY, groupRect)\n}\n\n/**\n * Checks if a Rect is more than 50% overlapping another Rect.\n * Used for group-in-group (nested groups) logic.\n */\nexport const isRectMoreThanHalfInside = (inner: Rect, outer: Rect, useInnerRect: boolean = true): boolean => {\n    const targetOuter = useInnerRect ? getInnerRect(outer) : outer\n\n    const intersectionX = Math.max(inner.x, targetOuter.x)\n    const intersectionY = Math.max(inner.y, targetOuter.y)\n    const intersectionW = Math.min(inner.x + inner.width, targetOuter.x + targetOuter.width) - intersectionX\n    const intersectionH = Math.min(inner.y + inner.height, targetOuter.y + targetOuter.height) - intersectionY\n\n    if (intersectionW <= 0 || intersectionH <= 0) return false\n\n    const intersectionArea = intersectionW * intersectionH\n    const innerArea = inner.width * inner.height\n\n    return intersectionArea > (innerArea * 0.5)\n}\n\n/**\n * Find the smallest rectangle that contains a point.\n * Returns null if point is not in any rectangle.\n */\nexport function findSmallestContainingRect<T extends Rect>(\n    x: number,\n    y: number,\n    rects: T[]\n): T | null {\n    const containing = rects.filter(rect => isPointInRect(x, y, rect))\n    if (containing.length === 0) return null\n\n    return containing.reduce((smallest, current) => {\n        const smallestArea = smallest.width * smallest.height\n        const currentArea = current.width * current.height\n        return currentArea < smallestArea ? current : smallest\n    })\n}\n\n/**\n * Find all rectangles that contain a point, sorted by area (largest first).\n */\nexport function findAllContainingRects<T extends Rect>(\n    x: number,\n    y: number,\n    rects: T[]\n): T[] {\n    return rects\n        .filter(rect => isPointInRect(x, y, rect))\n        .sort((a, b) => {\n            const areaA = a.width * a.height\n            const areaB = b.width * b.height\n            return areaB - areaA\n        })\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/positionUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/resourceManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Ref' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":18},{"ruleId":"@typescript-eslint/consistent-type-imports","severity":2,"message":"All imports in the declaration are only used as types. Use `import type`.","line":2,"column":1,"nodeType":"ImportDeclaration","messageId":"typeOverValue","endLine":2,"endColumn":80,"fix":{"range":[31,86],"text":"import type { useVueFlow } from '@vue-flow/core';\nimport { type VueFlow, type Node, type Edge"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Node' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Edge' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":77,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":89,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":99,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":109,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":119,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":132,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":27},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":144,"column":17,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":144,"endColumn":80,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4410,4473],"text":"// @ts-expect-error - destroy method might exist on internal instance"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":146,"column":21,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":146,"endColumn":34,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4568,4581],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":151,"column":17,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":151,"endColumn":30,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4732,4745],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":153,"column":17,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":153,"endColumn":30,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4871,4884],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":171,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":171,"endColumn":23}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport { type VueFlow, type Node, type Edge, useVueFlow } from '@vue-flow/core'\n\nexport interface NodeBatcher {\n    flush: () => void\n    clear: () => void\n}\n\nclass CanvasResourceManager {\n    private static instance: CanvasResourceManager\n\n    // Store all active watchers for cleanup\n    private watchers: Array<() => void> = []\n    // Store all event listeners for cleanup\n    private eventListeners: Array<{ element: EventTarget; event: string; handler: EventListener; options?: AddEventListenerOptions | boolean }> = []\n    // Store all timers for cleanup\n    private timers: Array<number> = []\n    // Store all intervals for cleanup\n    private intervals: Array<number> = []\n    // Store all cleanup callbacks for cleanup\n    private cleanupCallbacks: Array<() => void> = []\n    // Store Vue Flow instance for cleanup\n    private vueFlowInstance: ReturnType<typeof useVueFlow> | null = null\n    // Store Vue Flow ref for cleanup\n    private vueFlowRef: InstanceType<typeof VueFlow> | null = null\n    // Store node update batcher for cleanup\n    private nodeBatcher: NodeBatcher | null = null\n\n    private constructor() { }\n\n    public static getInstance(): CanvasResourceManager {\n        if (!CanvasResourceManager.instance) {\n            CanvasResourceManager.instance = new CanvasResourceManager()\n        }\n        return CanvasResourceManager.instance\n    }\n\n    addWatcher(unwatch: () => void) {\n        this.watchers.push(unwatch)\n    }\n\n    // Add cleanup callback to be called during cleanup\n    addCleanupCallback(callback: () => void) {\n        this.cleanupCallbacks.push(callback)\n    }\n\n    // Add event listener to cleanup list\n    addEventListener(element: EventTarget | null | undefined, event: string, handler: EventListener, options?: AddEventListenerOptions | boolean) {\n        // Add null check to prevent errors when element is not available\n        if (!element) return\n\n        // Check if element has addEventListener method\n        if (typeof element.addEventListener !== 'function') return\n\n        element.addEventListener(event, handler, options)\n        this.eventListeners.push({ element, event, handler, options })\n    }\n\n    // Add timer to cleanup list\n    addTimer(timerId: number) {\n        this.timers.push(timerId)\n        return timerId\n    }\n\n    // Add interval to cleanup list\n    addInterval(intervalId: number) {\n        this.intervals.push(intervalId)\n        return intervalId\n    }\n\n    // Clean up all resources\n    cleanup() {\n        // Clean up watchers\n        this.watchers.forEach(unwatch => {\n            try {\n                unwatch()\n            } catch (error) {\n                // Ignore errors during cleanup\n            }\n        })\n        this.watchers = []\n\n        // Clean up event listeners\n        this.eventListeners.forEach(({ element, event, handler, options }) => {\n            try {\n                if (element && typeof element.removeEventListener === 'function') {\n                    element.removeEventListener(event, handler, options)\n                }\n            } catch (error) {\n                // Ignore\n            }\n        })\n        this.eventListeners = []\n\n        // Clean up timers\n        this.timers.forEach(timerId => {\n            try {\n                clearTimeout(timerId)\n            } catch (error) {\n                // Ignore\n            }\n        })\n        this.timers = []\n\n        // Clean up intervals\n        this.intervals.forEach(intervalId => {\n            try {\n                clearInterval(intervalId)\n            } catch (error) {\n                // Ignore\n            }\n        })\n        this.intervals = []\n\n        // Clean up cleanup callbacks\n        this.cleanupCallbacks.forEach(callback => {\n            try {\n                callback()\n            } catch (error) {\n                // Ignore\n            }\n        })\n        this.cleanupCallbacks = []\n\n        // Enhanced Vue Flow cleanup\n        this.cleanupVueFlow()\n\n        // Clean up node update batcher\n        if (this.nodeBatcher) {\n            try {\n                this.nodeBatcher.clear()\n            } catch (error) {\n                // Ignore\n            }\n            this.nodeBatcher = null\n        }\n    }\n\n    // Enhanced Vue Flow specific cleanup\n    cleanupVueFlow() {\n        try {\n            // Clear Vue Flow instance\n            if (this.vueFlowInstance) {\n                // @ts-ignore - destroy method might exist on internal instance\n                if (typeof this.vueFlowInstance.destroy === 'function') {\n                    // @ts-ignore\n                    this.vueFlowInstance.destroy()\n                }\n\n                // Clear internal maps if exposed methods exist\n                // @ts-ignore\n                if (typeof this.vueFlowInstance.clearNodes === 'function') this.vueFlowInstance.clearNodes()\n                // @ts-ignore\n                if (typeof this.vueFlowInstance.clearEdges === 'function') this.vueFlowInstance.clearEdges()\n\n                this.vueFlowInstance = null\n            }\n\n            // Clean up any remaining DOM elements\n            // Use specific selectors if needed, but generally Vue handles DOM removal.\n            // Explicit DOM removal is risky if Vue is still managing it.\n            // We'll rely on Vue unmount unless specifically orphaned.\n\n            // Clear any global Vue Flow references\n            if (typeof window !== 'undefined') {\n                const windowExt = window as unknown as Record<string, unknown>\n                delete windowExt.__vueFlow\n                delete windowExt.__vueFlowInstances\n            }\n\n        } catch (error) {\n            // Ignore\n        }\n    }\n\n    // Set Vue Flow ref for cleanup\n    setVueFlowRef(ref: InstanceType<typeof VueFlow> | null) {\n        this.vueFlowRef = ref\n    }\n\n    // Set node update batcher for cleanup\n    setNodeBatcher(batcher: NodeBatcher | null) {\n        this.nodeBatcher = batcher\n    }\n}\n\nexport default CanvasResourceManager.getInstance()\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvas/spatialContainment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/canvasBusinessLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/conflict-detector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[139,142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[139,142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export class ConflictDetector {\n    getDeviceId(): string {\n        return 'stub-device-id'\n    }\n\n    async detectAllConflicts(): Promise<any[]> {\n        return []\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/conflict-resolution.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DocumentVersion' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2880,2883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2880,2883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'localData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":184,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":184,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6240,6243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6240,6243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'remoteData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":185,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":185,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6291,6294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6291,6294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6685,6688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6685,6688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":201,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6897,6900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6897,6900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7065,7068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7065,7068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7078,7081],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7078,7081],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7430,7433],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7430,7433],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7443,7446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7443,7446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7449,7452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7449,7452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { UnifiedTask } from '@/types/unified-task';\nimport type { ConflictDiff } from './threeWayMerge';\nimport type {\n  ConflictInfo,\n  ResolutionResult} from '@/types/conflicts';\nimport {\n  ConflictType,\n  ResolutionType,\n  DocumentVersion\n} from '@/types/conflicts';\n\nexport interface TaskConflict {\n  taskId: string;\n  localVersion: UnifiedTask;\n  remoteVersion: UnifiedTask;\n  // Aliases for component compatibility\n  localTask: UnifiedTask;\n  remoteTask: UnifiedTask;\n  conflicts: ConflictDiff[];\n  priority: 'low' | 'medium' | 'high';\n}\n\nexport enum ResolutionStrategy {\n  LAST_WRITE_WINS = 'LAST_WRITE_WINS',\n  SMART_MERGE = 'SMART_MERGE',\n  LOCAL_WINS = 'LOCAL_WINS',\n  REMOTE_WINS = 'REMOTE_WINS',\n  DELETION_WINS = 'DELETION_WINS',\n  MANUAL = 'MANUAL'\n}\n\nexport interface ResolutionRule {\n  field: string;\n  condition: 'always' | 'when-empty' | 'when-longer';\n  action: 'prefer-local' | 'prefer-remote' | 'merge' | 'prefer-truthy' | 'prefer-longer' | 'union';\n  priority: number;\n}\n\n// Added for compatibility with legacy systems\nexport interface UserResolutionRule {\n  name: string\n  field: string\n  condition: 'always' | 'when-empty' | 'when-newer' | 'when-contains' | 'when-longer' | 'custom'\n  value?: unknown\n  action: 'prefer-local' | 'prefer-remote' | 'prefer-non-empty' | 'prefer-true' | 'prefer-false' | 'prefer-longer' | 'prefer-newer' | 'prefer-earlier' | 'prefer-higher' | 'merge' | 'union' | 'merge-deep' | 'ask' | 'custom'\n  priority: number\n  customAction?: (local: unknown, remote: unknown) => unknown\n}\n\nexport class ConflictResolutionService {\n  private rules: Map<string, ResolutionRule[]> = new Map();\n  private deviceId: string;\n\n  constructor(deviceId: string = 'default-device') {\n    this.deviceId = deviceId;\n    this.initializeDefaultRules();\n  }\n\n  private initializeDefaultRules(): void {\n    // Ported from legacy ConflictResolver\n    this.rules.set('title', [\n      { field: 'title', condition: 'when-empty', action: 'prefer-local', priority: 1 },\n      { field: 'title', condition: 'always', action: 'prefer-longer', priority: 2 }\n    ]);\n\n    this.rules.set('description', [\n      { field: 'description', condition: 'always', action: 'merge', priority: 1 }\n    ]);\n  }\n\n  /**\n   * Resolve many task conflicts at once\n   */\n  resolve(conflicts: TaskConflict[]): UnifiedTask[] {\n    console.log(`ðŸ”§ Resolving ${conflicts.length} task conflicts...`);\n    return conflicts.map(conflict => this.resolveSingleConflict(conflict));\n  }\n\n  /**\n   * Backward compatibility method for legacy ConflictResolver usage\n   */\n  async resolveConflict(conflict: ConflictInfo): Promise<ResolutionResult> {\n    console.log(`ðŸ”§ Resolving legacy conflict: ${conflict.documentId} (${conflict.conflictType})`);\n\n    // Select strategy based on conflict type and severity\n    const strategy = this.selectLegacyStrategy(conflict);\n\n    let resolvedDocument: any = conflict.localVersion.data;\n    let winner = 'local';\n\n    if (strategy === ResolutionType.LAST_WRITE_WINS) {\n      const localTime = new Date(conflict.localVersion.updatedAt).getTime();\n      const remoteTime = new Date(conflict.remoteVersion.updatedAt).getTime();\n      if (remoteTime > localTime) {\n        resolvedDocument = conflict.remoteVersion.data;\n        winner = 'remote';\n      }\n    } else if (strategy === ResolutionType.REMOTE_WINS) {\n      resolvedDocument = conflict.remoteVersion.data;\n      winner = 'remote';\n    } else if (strategy === ResolutionType.LOCAL_WINS) {\n      resolvedDocument = conflict.localVersion.data;\n      winner = 'local';\n    }\n    // Note: SMART_MERGE would need full ThreeWayMergeEngine instantiation here\n    // For now, simpler auto-resolutions are prioritized to restore system stability\n\n    return {\n      documentId: conflict.documentId,\n      resolutionType: strategy,\n      resolvedDocument,\n      winner,\n      timestamp: new Date(),\n      conflictData: conflict,\n      metadata: {\n        resolutionReason: `Auto-resolved using ${strategy} via ConflictResolutionService`\n      }\n    };\n  }\n\n  private selectLegacyStrategy(conflict: ConflictInfo): ResolutionType {\n    if (conflict.autoResolvable) {\n      switch (conflict.conflictType) {\n        case ConflictType.EDIT_DELETE:\n          return ResolutionType.PRESERVE_NON_DELETED;\n        case ConflictType.VERSION_MISMATCH:\n          return ResolutionType.LAST_WRITE_WINS;\n        default:\n          return ResolutionType.LAST_WRITE_WINS;\n      }\n    }\n\n    if (conflict.severity === 'high') {\n      return ResolutionType.MANUAL;\n    }\n\n    return ResolutionType.LAST_WRITE_WINS;\n  }\n\n  /**\n   * Resolve a single task conflict using smart strategies\n   */\n  private resolveSingleConflict(conflict: TaskConflict): UnifiedTask {\n    const strategy = this.selectStrategy(conflict);\n\n    switch (strategy) {\n      case ResolutionStrategy.SMART_MERGE:\n        return this.smartMerge(conflict);\n      case ResolutionStrategy.DELETION_WINS:\n        return this.resolveDeletionWins(conflict);\n      case ResolutionStrategy.LOCAL_WINS:\n        return conflict.localTask;\n      case ResolutionStrategy.REMOTE_WINS:\n        return conflict.remoteTask;\n      case ResolutionStrategy.LAST_WRITE_WINS:\n      default:\n        return this.resolveLastWriteWins(conflict);\n    }\n  }\n\n  private selectStrategy(conflict: TaskConflict): ResolutionStrategy {\n    // If one is deleted, deletion wins (prevent task resurrection - BUG-037)\n    if (conflict.localTask.completedAt && !conflict.remoteTask.completedAt) {\n      // Logic for deletion wins...\n    }\n\n    // Default to smart merge for most tasks\n    return ResolutionStrategy.SMART_MERGE;\n  }\n\n  private resolveLastWriteWins(conflict: TaskConflict): UnifiedTask {\n    const localTime = new Date(conflict.localTask.updatedAt).getTime();\n    const remoteTime = new Date(conflict.remoteTask.updatedAt).getTime();\n    return localTime > remoteTime ? conflict.localTask : conflict.remoteTask;\n  }\n\n  private resolveDeletionWins(conflict: TaskConflict): UnifiedTask {\n    // Logic for BUG-037: Deletion always wins\n    return conflict.localTask; // Placeholder\n  }\n\n  private smartMerge(conflict: TaskConflict): UnifiedTask {\n    const mergedTask = { ...conflict.localTask };\n    const localData = conflict.localTask as any;\n    const remoteData = conflict.remoteTask as any;\n\n    for (const diff of conflict.conflicts) {\n      const field = diff.field;\n      const rules = this.rules.get(field);\n\n      if (rules && rules.length > 0) {\n        const sortedRules = [...rules].sort((a, b) => a.priority - b.priority);\n        for (const rule of sortedRules) {\n          if (this.shouldApplyRule(rule, diff.localValue, diff.remoteValue)) {\n            (mergedTask as any)[field] = this.applyRule(rule, diff.localValue, diff.remoteValue);\n            break;\n          }\n        }\n      } else {\n        // Default: local wins for unknown conflicting fields\n        (mergedTask as any)[field] = diff.localValue;\n      }\n    }\n\n    mergedTask.updatedAt = new Date();\n    return mergedTask;\n  }\n\n  private shouldApplyRule(rule: ResolutionRule, local: any, remote: any): boolean {\n    switch (rule.condition) {\n      case 'always': return true;\n      case 'when-empty': return !local || !remote;\n      case 'when-longer':\n        return typeof local === 'string' && typeof remote === 'string' && local.length !== remote.length;\n      default: return false;\n    }\n  }\n\n  private applyRule(rule: ResolutionRule, local: any, remote: any): any {\n    switch (rule.action) {\n      case 'prefer-local': return local;\n      case 'prefer-remote': return remote;\n      case 'prefer-truthy': return local || remote;\n      case 'prefer-longer':\n        if (typeof local === 'string' && typeof remote === 'string') {\n          return local.length >= remote.length ? local : remote;\n        }\n        return local;\n      case 'merge':\n        if (typeof local === 'string' && typeof remote === 'string') {\n          return `${local}\\n\\n---\\n\\n${remote}`;\n        }\n        return local;\n      case 'union':\n        if (Array.isArray(local) && Array.isArray(remote)) {\n          return Array.from(new Set([...local, ...remote]));\n        }\n        return local;\n      default: return local;\n    }\n  }\n}\n\nexport default ConflictResolutionService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/cspManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/csrfProtection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/dateUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/deletedGroupsTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/demoContentGuard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/durationCategories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/emojiSvgMap.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/event-bus.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[348,351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[348,351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { UnifiedTask } from '@/types/unified-task';\n\nexport interface EventData {\n  type: string;\n  taskId: string;\n  data: UnifiedTask;\n  source: string;\n  timestamp: Date;\n}\n\nexport class EventBus {\n  emit(_event: string, _data: EventData): void {\n    console.log('Mock EventBus.emit called');\n  }\n\n  on(_event: string, _callback: (...args: any[]) => void): void {\n    console.log('Mock EventBus.on called');\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/extension-safety.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/globalKeyboardHandlerSimple.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":121,"column":88,"nodeType":"BlockStatement","messageId":"unexpected","endLine":123,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3598,3604],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Global keyboard handler with undo/redo functionality\n// Handles Ctrl+Z (undo) and Ctrl+Y/Ctrl+Shift+Z (redo) shortcuts\n\nimport type { Ref } from 'vue'\n\ninterface KeyboardHandlerOptions {\n  enabled?: boolean\n  preventDefault?: boolean\n  ignoreInputs?: boolean\n  ignoreModals?: boolean\n}\n\ninterface UndoRedoSystem {\n  canUndo: Ref<boolean>\n  canRedo: Ref<boolean>\n  undoCount: Ref<number>\n  redoCount: Ref<number>\n  undo: () => Promise<boolean>\n  redo: () => Promise<boolean>\n}\n\nexport class SimpleGlobalKeyboardHandler {\n  private enabled: boolean = true\n  private preventDefault: boolean = true\n  private ignoreInputs: boolean = true\n  private ignoreModals: boolean = true\n  private keydownHandler: (event: KeyboardEvent) => void\n  private undoRedo: UndoRedoSystem | null = null\n\n  constructor(options: KeyboardHandlerOptions = {}) {\n    this.enabled = options.enabled ?? true\n    this.preventDefault = options.preventDefault ?? true\n    this.ignoreInputs = options.ignoreInputs ?? true\n    this.ignoreModals = options.ignoreModals ?? true\n\n    // Bind the event handler\n    this.keydownHandler = this.handleKeydown.bind(this)\n  }\n\n  /**\n   * Initialize the keyboard handler\n   */\n  async init(): Promise<void> {\n    if (typeof window !== 'undefined') {\n      // Load unified undo/redo functionality\n      try {\n        // Use the shared singleton undo system to ensure all instances share the same state\n        const { getUndoSystem } = await import('@/composables/undoSingleton')\n        this.undoRedo = getUndoSystem() as UndoRedoSystem\n      } catch (error) {\n        console.error('âŒ Failed to load unified undo/redo system:', error)\n      }\n\n      window.addEventListener('keydown', this.keydownHandler, false)\n    }\n  }\n\n  /**\n   * Destroy the keyboard handler\n   */\n  destroy(): void {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('keydown', this.keydownHandler, false)\n    }\n  }\n\n  /**\n   * Check if an element or its parents should be ignored\n   */\n  private shouldIgnoreElement(target: Element): boolean {\n    const element = target as HTMLElement\n\n    // ðŸ”§ FIX: Allow Enter key events on quick task input to pass through\n    // Check if this is the quick task input field\n    if (element.classList.contains('task-input') ||\n      element.closest('.quick-add-input')) {\n      return false // Don't block - allow @keydown.enter to work\n    }\n\n    // Check if we're in an input field and ignoreInputs is true\n    if (this.ignoreInputs) {\n      const tagName = element.tagName?.toLowerCase()\n      const isInput = tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select' ||\n        element.contentEditable === 'true'\n\n      if (isInput) {\n        return true\n      }\n\n      // Check if we're inside an input-like element\n      const parent = element.closest('input, textarea, select, [contenteditable=\"true\"]')\n      if (parent) {\n        return true\n      }\n    }\n\n    // Check if we're in a modal and ignoreModals is true\n    if (this.ignoreModals) {\n      const modal = element.closest('[role=\"dialog\"], .modal, .popup, .overlay')\n      if (modal) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Handle keyboard events\n   */\n  private handleKeydown(event: KeyboardEvent): void {\n    // Comprehensive logging for global keyboard handler debugging\n\n\n    const { ctrlKey, metaKey, shiftKey, key } = event\n    const hasModifier = ctrlKey || metaKey\n\n    // Check if this is Shift+1-5 that might interfere with App.vue\n    if (shiftKey && !ctrlKey && !metaKey && !event.altKey && key >= '1' && key <= '5') {\n\n    }\n\n\n    // Handle Ctrl+Z (Undo) and Ctrl+Shift+Z (Redo)\n    if (hasModifier && key.toLowerCase() === 'z') {\n      if (shiftKey) {\n        // Ctrl+Shift+Z = Redo\n\n      } else {\n        // Ctrl+Z = Undo\n\n      }\n\n      if (this.preventDefault) {\n        event.preventDefault()\n        event.stopPropagation()\n      }\n    }\n\n    // Handle Ctrl+Y (Redo alternative)\n    else if (hasModifier && key.toLowerCase() === 'y') {\n\n\n      if (this.preventDefault) {\n        event.preventDefault()\n        event.stopPropagation()\n      }\n    }\n\n    // Handle Ctrl+N (New Task)\n    else if (hasModifier && key.toLowerCase() === 'n') {\n\n\n      if (this.preventDefault) {\n        event.preventDefault()\n        event.stopPropagation()\n      }\n    }\n  }\n\n  /**\n   * Execute new task - dispatch custom event for App.vue to handle\n   */\n  private executeNewTask(): void {\n\n    window.dispatchEvent(new CustomEvent('global-new-task'))\n  }\n\n  /**\n   * Execute undo operation\n   */\n  private async executeUndo(): Promise<void> {\n    if (!this.undoRedo) {\n      return\n    }\n\n    try {\n      // Check if undo is possible - use fresh reference\n      if (!this.undoRedo.canUndo.value) {\n        return\n      }\n\n      // Execute undo\n      await this.undoRedo.undo()\n    } catch (error) {\n      console.error('âŒ Undo operation failed:', error)\n    }\n  }\n\n  /**\n   * Execute redo operation\n   */\n  private async executeRedo(): Promise<void> {\n    if (!this.undoRedo) {\n      return\n    }\n\n    try {\n      // Check if redo is possible\n      if (!this.undoRedo.canRedo.value) {\n        return\n      }\n\n      // Execute redo\n      await this.undoRedo.redo()\n    } catch (error) {\n      console.error('âŒ Redo operation failed:', error)\n    }\n  }\n\n  /**\n   * Get current settings\n   */\n  getSettings(): KeyboardHandlerOptions {\n    return {\n      enabled: this.enabled,\n      preventDefault: this.preventDefault,\n      ignoreInputs: this.ignoreInputs,\n      ignoreModals: this.ignoreModals\n    }\n  }\n\n  /**\n   * Update settings\n   */\n  updateSettings(options: Partial<KeyboardHandlerOptions>): void {\n    if (options.enabled !== undefined) this.enabled = options.enabled\n    if (options.preventDefault !== undefined) this.preventDefault = options.preventDefault\n    if (options.ignoreInputs !== undefined) this.ignoreInputs = options.ignoreInputs\n    if (options.ignoreModals !== undefined) this.ignoreModals = options.ignoreModals\n  }\n}\n\n// Global instance\nlet globalKeyboardHandler: SimpleGlobalKeyboardHandler | null = null\n\n/**\n * Initialize global keyboard shortcuts (simple version)\n */\nexport const initGlobalKeyboardShortcuts = async (options?: KeyboardHandlerOptions): Promise<SimpleGlobalKeyboardHandler> => {\n  if (globalKeyboardHandler) {\n    globalKeyboardHandler.destroy()\n  }\n\n  globalKeyboardHandler = new SimpleGlobalKeyboardHandler(options)\n  await globalKeyboardHandler.init()\n\n  return globalKeyboardHandler\n}\n\n/**\n * Get the global keyboard handler instance\n */\nexport const getGlobalKeyboardHandler = (): SimpleGlobalKeyboardHandler | null => {\n  return globalKeyboardHandler\n}\n\n/**\n * Destroy the global keyboard handler\n */\nexport const destroyGlobalKeyboardShortcuts = (): void => {\n  if (globalKeyboardHandler) {\n    globalKeyboardHandler.destroy()\n    globalKeyboardHandler = null\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/guestModeStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/id-mapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/integrity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/markdown.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2407,2410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2407,2410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2696,2699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2696,2699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { marked } from 'marked'\nimport DOMPurify from 'dompurify'\n\n/**\n * Sanitize URL to prevent XSS via javascript:, data:, and other dangerous protocols\n * Returns the safe URL or null if the URL is unsafe\n */\nconst SAFE_PROTOCOLS = new Set(['http:', 'https:', 'mailto:'])\nconst BLOCKED_PROTOCOLS = new Set(['javascript:', 'vbscript:', 'data:', 'file:', 'blob:'])\n\nfunction sanitizeUrl(href: string | null | undefined): string | null {\n  if (!href || typeof href !== 'string') return null\n\n  // Normalize and trim\n  const normalizedHref = href.trim().toLowerCase()\n\n  // Check for blocked protocols BEFORE URL parsing (catches obfuscation)\n  for (const blocked of BLOCKED_PROTOCOLS) {\n    if (normalizedHref.startsWith(blocked) ||\n      normalizedHref.includes('\\n' + blocked) ||\n      normalizedHref.includes('\\r' + blocked) ||\n      normalizedHref.includes('\\t' + blocked)) {\n      return null\n    }\n  }\n\n  // Check for URL-encoded dangerous protocols\n  try {\n    const decoded = decodeURIComponent(href)\n    const decodedLower = decoded.toLowerCase()\n    if (decodedLower.startsWith('javascript:') ||\n      decodedLower.startsWith('vbscript:') ||\n      decodedLower.startsWith('data:')) {\n      return null\n    }\n  } catch {\n    // decodeURIComponent failed - URL might be malformed, allow URL parsing to handle it\n  }\n\n  try {\n    const url = new URL(href, window.location.origin)\n\n    // Explicit protocol allowlist check\n    if (!SAFE_PROTOCOLS.has(url.protocol)) {\n      return null\n    }\n\n    // Block protocol-relative URLs that could redirect to malicious sites\n    if (href.startsWith('//')) {\n      return null\n    }\n\n    return url.href\n  } catch {\n    // Invalid URL - return null for safety\n    return null\n  }\n}\n\n/**\n * Configure marked for our needs\n * IMPORTANT: For Tiptap compatibility, task lists must use data-type attributes\n */\nmarked.use({\n  gfm: true,\n  breaks: true,\n  silent: true,\n  renderer: {\n    link({ href, title, text }) {\n      // Sanitize URL to prevent XSS attacks\n      const safeHref = sanitizeUrl(href)\n      if (!safeHref) {\n        // Unsafe URL - render as plain text instead of link\n        return text\n      }\n      return `<a href=\"${safeHref}\" title=\"${title || ''}\" target=\"_blank\" rel=\"noopener noreferrer\">${text}</a>`\n    },\n    list({ items, ordered, start }) {\n      const tag = ordered ? 'ol' : 'ul'\n      const isTask = items.some(item => (item as any).task)\n      // For Tiptap: use data-type=\"taskList\" instead of class\n      const dataAttr = isTask ? ' data-type=\"taskList\"' : ''\n      const startAttr = ordered && start !== 1 ? ` start=\"${start}\"` : ''\n\n      let body = ''\n      for (const item of items) {\n        body += (this as any).listitem(item)\n      }\n\n      return `<${tag}${dataAttr}${startAttr}>\\n${body}</${tag}>\\n`\n    },\n    // For Tiptap: task list items need data-type=\"taskItem\" and data-checked attributes\n    listitem({ text, task, checked }) {\n      if (task) {\n        // Tiptap TaskItem format: <li data-type=\"taskItem\" data-checked=\"true/false\">\n        const checkedVal = checked ? 'true' : 'false'\n        return `<li data-type=\"taskItem\" data-checked=\"${checkedVal}\"><label><input type=\"checkbox\" ${checked ? 'checked' : ''}></label><div>${text}</div></li>\\n`\n      }\n      return `<li>${text}</li>\\n`\n    }\n  }\n})\n\n/**\n * Parses markdown into safe HTML\n */\nexport const parseMarkdown = (content: string): string => {\n  if (!content) return ''\n\n  try {\n    // marked.parse is synchronous for strings in most environments\n    const rawHtml = marked.parse(content) as string\n\n    // Sanitize with checkbox support and Tiptap data attributes\n    const sanitized = DOMPurify.sanitize(rawHtml, {\n      ADD_TAGS: ['input', 'mark'],\n      ADD_ATTR: ['type', 'checked', 'class', 'disabled', 'data-type', 'data-checked']\n    })\n\n    // Convert ==highlight== syntax to <mark> for Tiptap's Highlight extension\n    // This is a non-standard markdown extension commonly used in Obsidian and other editors\n    const withHighlight = sanitized.replace(/==(.*?)==/g, '<mark>$1</mark>')\n\n    return withHighlight\n  } catch (error) {\n    console.error('Error parsing markdown:', error)\n    return content // Fallback to raw text\n  }\n}\n\n/**\n * Convert HTML to Markdown (BUG-013 FIX)\n * Simple conversion for Tiptap output - handles common formatting\n */\nexport function htmlToMarkdown(html: string): string {\n  if (!html || typeof html !== 'string') return ''\n\n  let markdown = html\n\n  // Sanitize first to prevent any XSS in the processing\n  markdown = DOMPurify.sanitize(markdown)\n\n  // Task list items: <input type=\"checkbox\" checked> -> [x], unchecked -> [ ]\n  markdown = markdown.replace(/<input[^>]*type=[\"']?checkbox[\"']?[^>]*checked[^>]*>/gi, '[x] ')\n  markdown = markdown.replace(/<input[^>]*checked[^>]*type=[\"']?checkbox[\"']?[^>]*>/gi, '[x] ')\n  markdown = markdown.replace(/<input[^>]*type=[\"']?checkbox[\"']?[^>]*>/gi, '[ ] ')\n\n  // Bold: <strong> or <b> -> **text**\n  markdown = markdown.replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '**$1**')\n  markdown = markdown.replace(/<b[^>]*>(.*?)<\\/b>/gi, '**$1**')\n\n  // Italic: <em> or <i> -> *text*\n  markdown = markdown.replace(/<em[^>]*>(.*?)<\\/em>/gi, '*$1*')\n  markdown = markdown.replace(/<i[^>]*>(.*?)<\\/i>/gi, '*$1*')\n\n  // Strikethrough: <s> or <del> -> ~~text~~\n  markdown = markdown.replace(/<s[^>]*>(.*?)<\\/s>/gi, '~~$1~~')\n  markdown = markdown.replace(/<del[^>]*>(.*?)<\\/del>/gi, '~~$1~~')\n\n  // Underline: <u> -> no standard markdown, keep as HTML for now\n  // Some parsers support __text__ but it conflicts with bold\n  markdown = markdown.replace(/<u[^>]*>(.*?)<\\/u>/gi, '<u>$1</u>')\n\n  // Highlight: <mark> -> ==text== (some markdown flavors support this)\n  markdown = markdown.replace(/<mark[^>]*>(.*?)<\\/mark>/gi, '==$1==')\n\n  // Tables: Convert HTML tables to markdown tables\n  // This is a simplified conversion - handles basic tables\n  markdown = markdown.replace(/<table[^>]*>([\\s\\S]*?)<\\/table>/gi, (_, tableContent) => {\n    const rows: string[][] = []\n    const headerMatch = tableContent.match(/<thead[^>]*>([\\s\\S]*?)<\\/thead>/i)\n    const bodyMatch = tableContent.match(/<tbody[^>]*>([\\s\\S]*?)<\\/tbody>/i)\n\n    // Process header\n    if (headerMatch) {\n      const headerRow = headerMatch[1].match(/<tr[^>]*>([\\s\\S]*?)<\\/tr>/i)\n      if (headerRow) {\n        const cells = headerRow[1].match(/<th[^>]*>([\\s\\S]*?)<\\/th>/gi) || []\n        rows.push(cells.map((cell: string) => cell.replace(/<th[^>]*>([\\s\\S]*?)<\\/th>/i, '$1').replace(/<[^>]+>/g, '').trim()))\n      }\n    }\n\n    // Process body rows\n    const content = bodyMatch ? bodyMatch[1] : tableContent\n    const bodyRows = content.match(/<tr[^>]*>[\\s\\S]*?<\\/tr>/gi) || []\n    for (const row of bodyRows) {\n      const cells = row.match(/<t[dh][^>]*>([\\s\\S]*?)<\\/t[dh]>/gi) || []\n      if (cells.length > 0) {\n        rows.push(cells.map((cell: string) => cell.replace(/<t[dh][^>]*>([\\s\\S]*?)<\\/t[dh]>/i, '$1').replace(/<[^>]+>/g, '').trim()))\n      }\n    }\n\n    if (rows.length === 0) return ''\n\n    // Build markdown table\n    const colCount = Math.max(...rows.map(r => r.length))\n    let mdTable = '\\n'\n\n    // First row (header or first data row)\n    mdTable += '| ' + rows[0].map(c => c || ' ').join(' | ') + ' |\\n'\n    // Separator\n    mdTable += '| ' + Array(colCount).fill('---').join(' | ') + ' |\\n'\n    // Remaining rows\n    for (let i = 1; i < rows.length; i++) {\n      mdTable += '| ' + rows[i].map(c => c || ' ').join(' | ') + ' |\\n'\n    }\n\n    return mdTable\n  })\n\n  // Horizontal rule: <hr> -> ---\n  markdown = markdown.replace(/<hr[^>]*\\/?>/gi, '\\n---\\n')\n\n  // Links: <a href=\"url\">text</a> -> [text](url)\n  markdown = markdown.replace(/<a[^>]*href=[\"']([^\"']*)[\"'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)')\n\n  // Code blocks: <pre><code> -> ```code```\n  markdown = markdown.replace(/<pre[^>]*><code[^>]*>([\\s\\S]*?)<\\/code><\\/pre>/gi, '\\n```\\n$1\\n```\\n')\n  markdown = markdown.replace(/<pre[^>]*>([\\s\\S]*?)<\\/pre>/gi, '\\n```\\n$1\\n```\\n')\n\n  // Inline code: <code> -> `text`\n  markdown = markdown.replace(/<code[^>]*>(.*?)<\\/code>/gi, '`$1`')\n\n  // Headings\n  markdown = markdown.replace(/<h1[^>]*>(.*?)<\\/h1>/gi, '# $1\\n')\n  markdown = markdown.replace(/<h2[^>]*>(.*?)<\\/h2>/gi, '## $1\\n')\n  markdown = markdown.replace(/<h3[^>]*>(.*?)<\\/h3>/gi, '### $1\\n')\n\n  // List items: <li> -> - (for task lists, the checkbox is already handled above)\n  // Handle task list items specially (they have data-type or are in task lists)\n  markdown = markdown.replace(/<li[^>]*data-checked=[\"']true[\"'][^>]*>(.*?)<\\/li>/gi, '- [x] $1\\n')\n  markdown = markdown.replace(/<li[^>]*data-checked=[\"']false[\"'][^>]*>(.*?)<\\/li>/gi, '- [ ] $1\\n')\n  markdown = markdown.replace(/<li[^>]*>(.*?)<\\/li>/gi, '- $1\\n')\n\n  // Remove list wrappers\n  markdown = markdown.replace(/<\\/?ul[^>]*>/gi, '')\n  markdown = markdown.replace(/<\\/?ol[^>]*>/gi, '')\n\n  // Paragraphs: <p> -> text with newline\n  markdown = markdown.replace(/<p[^>]*>(.*?)<\\/p>/gi, '$1\\n')\n\n  // Line breaks\n  markdown = markdown.replace(/<br\\s*\\/?>/gi, '\\n')\n\n  // Blockquotes\n  markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\\/blockquote>/gi, '> $1\\n')\n\n  // Remove any remaining HTML tags\n  markdown = markdown.replace(/<[^>]+>/g, '')\n\n  // Decode HTML entities\n  markdown = markdown.replace(/&nbsp;/g, ' ')\n  markdown = markdown.replace(/&amp;/g, '&')\n  markdown = markdown.replace(/&lt;/g, '<')\n  markdown = markdown.replace(/&gt;/g, '>')\n  markdown = markdown.replace(/&quot;/g, '\"')\n  markdown = markdown.replace(/&#39;/g, \"'\")\n\n  // Clean up extra whitespace\n  markdown = markdown.replace(/\\n{3,}/g, '\\n\\n')\n  markdown = markdown.trim()\n\n  return markdown\n}\n\n// Export sanitizeUrl for use in TiptapEditor link validation (BUG-014 FIX)\nexport { sanitizeUrl }\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/mockTaskDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/performanceBenchmark.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":161,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":161,"endColumn":22,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4729,4742],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":170,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":170,"endColumn":22,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5019,5032],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":183,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":183,"endColumn":22,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5564,5577],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":185,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":185,"endColumn":22,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5681,5694],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Benchmarking Suite\n * Comprehensive performance testing and validation for the Pomo-Flow application\n */\n\nimport { ref } from 'vue'\nimport { usePerformanceManager } from '@/composables/usePerformanceManager'\nimport { useVirtualScrolling } from '@/composables/useVirtualScrolling'\nimport { useNetworkOptimizer } from '@/composables/useNetworkOptimizer'\nimport { useRenderOptimization } from '@/composables/useRenderOptimization'\n\nexport interface BenchmarkConfig {\n  iterations?: number\n  timeout?: number\n  warmupIterations?: number\n  enableMemoryProfiling?: boolean\n  enableCPUGProfiling?: boolean\n  enableNetworkProfiling?: boolean\n}\n\nexport interface BenchmarkResult {\n  name: string\n  iterations: number\n  totalTime: number\n  averageTime: number\n  minTime: number\n  maxTime: number\n  standardDeviation: number\n  throughput: number\n  memoryUsage?: number\n  memoryDelta?: number\n  cpuUsage?: number\n  successRate: number\n  errors: string[]\n}\n\nexport interface BenchmarkSuite {\n  canvasPerformance: BenchmarkResult\n  virtualScrolling: BenchmarkResult\n  taskStoreOperations: BenchmarkResult\n  networkRequests: BenchmarkResult\n  renderPerformance: BenchmarkResult\n  memoryEfficiency: BenchmarkResult\n  bundleSize: BenchmarkResult\n}\n\nexport interface PerformanceThresholds {\n  maxAverageRenderTime: number\n  maxMemoryUsage: number\n  minCacheHitRate: number\n  minNetworkEfficiency: number\n  maxBundleSize: number\n  minThroughput: number\n}\n\nexport const PERFORMANCE_THRESHOLDS: PerformanceThresholds = {\n  maxAverageRenderTime: 16, // 60fps\n  maxMemoryUsage: 100 * 1024 * 1024, // 100MB\n  minCacheHitRate: 0.8, // 80%\n  minNetworkEfficiency: 0.7, // 70%\n  maxBundleSize: 500 * 1024, // 500KB\n  minThroughput: 1000 // operations per second\n}\n\nexport class PerformanceBenchmark {\n  private performanceManager = usePerformanceManager()\n  private networkOptimizer = useNetworkOptimizer()\n  private renderOptimizer = useRenderOptimization()\n\n  private results = ref<Partial<BenchmarkSuite>>({})\n  private isRunning = ref(false)\n  private progress = ref(0)\n\n  // Memory tracking\n  private initialMemory = 0\n  private memorySnapshots: number[] = []\n\n  // CPU tracking\n  private cpuSnapshots: number[] = []\n\n  constructor(private config: BenchmarkConfig = {}) {\n    this.config = {\n      iterations: 100,\n      timeout: 30000,\n      warmupIterations: 10,\n      enableMemoryProfiling: true,\n      enableCPUGProfiling: true,\n      enableNetworkProfiling: true,\n      ...config\n    }\n  }\n\n  // Main benchmark execution\n  async runFullSuite(): Promise<BenchmarkSuite> {\n    console.log('ðŸš€ Starting performance benchmark suite...')\n    this.isRunning.value = true\n    this.progress.value = 0\n\n    try {\n      // Initial memory snapshot\n      this.initialMemory = this.getMemoryUsage()\n\n      // Run benchmarks\n      const results = {\n        canvasPerformance: await this.benchmarkCanvasPerformance(),\n        virtualScrolling: await this.benchmarkVirtualScrolling(),\n        taskStoreOperations: await this.benchmarkTaskStoreOperations(),\n        networkRequests: await this.benchmarkNetworkRequests(),\n        renderPerformance: await this.benchmarkRenderPerformance(),\n        memoryEfficiency: await this.benchmarkMemoryEfficiency(),\n        bundleSize: await this.benchmarkBundleSize()\n      }\n\n      this.results.value = results\n\n      // Generate report\n      await this.generateReport(results)\n\n      this.progress.value = 100\n      return results\n\n    } finally {\n      this.isRunning.value = false\n    }\n  }\n\n  // Canvas performance benchmark\n  private async benchmarkCanvasPerformance(): Promise<BenchmarkResult> {\n    console.log('ðŸ–¼ï¸ Benchmarking canvas performance...')\n    const times: number[] = []\n    const errors: string[] = []\n\n    const nodeCounts = [100, 500, 1000]\n\n    try {\n      // Lazy load stores to avoid circular dependencies\n      const { useTaskStore } = await import('@/stores/tasks')\n      const { useCanvasStore } = await import('@/stores/canvas')\n      const taskStore = useTaskStore()\n      const canvasStore = useCanvasStore()\n\n      for (const nodeCount of nodeCounts) {\n        const startTime = performance.now()\n\n        // 1. Create tasks\n        const testTasks = Array.from({ length: nodeCount }, (_, i) => ({\n          id: `bench-task-${nodeCount}-${i}`,\n          title: `Benchmark Task ${i}`,\n          status: 'planned' as const,\n          priority: 'medium' as const,\n          projectId: 'bench-project',\n          canvasPosition: { x: (i % 20) * 250, y: Math.floor(i / 20) * 150 },\n          isInInbox: false,\n          subtasks: [],\n          tags: [],\n          createdAt: new Date(),\n          updatedAt: new Date()\n        }))\n\n        // Measure batch addition\n        // @ts-ignore\n        taskStore._rawTasks.push(...testTasks)\n\n        // Wait for next tick to ensure computed properties update\n        const { nextTick } = await import('vue')\n        await nextTick()\n\n        // 2. Measure Canvas Sync\n        const syncStart = performance.now()\n        // @ts-ignore\n        canvasStore.syncTasksToCanvas(taskStore.tasks || [])\n        const syncEnd = performance.now()\n\n        // 3. Measure Render (wait for multiple frames to ensure layout)\n        await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)))\n        const renderEnd = performance.now()\n\n        const duration = renderEnd - startTime\n        // Ensure duration is at least very small but non-zero for stats if work was done\n        times.push(Math.max(duration, 0.001))\n\n        // Cleanup\n        // @ts-ignore\n        taskStore._rawTasks = taskStore._rawTasks.filter(t => !t.id.startsWith('bench-task-'))\n        // @ts-ignore\n        canvasStore.nodes = canvasStore.nodes.filter(n => !n.id.startsWith('bench-task-'))\n        await nextTick()\n\n        console.log(`   - ${nodeCount} nodes: ${duration.toFixed(2)}ms (Sync: ${(syncEnd - syncStart).toFixed(2)}ms)`)\n      }\n\n    } catch (error) {\n      errors.push(error instanceof Error ? error.message : String(error))\n    }\n\n    this.progress.value = 10\n    return this.calculateBenchmarkResult('Canvas Performance', times, errors)\n  }\n\n  // Virtual scrolling benchmark\n  private async benchmarkVirtualScrolling(): Promise<BenchmarkResult> {\n    console.log('ðŸ“Š Benchmarking virtual scrolling...')\n\n    const itemCounts = [100, 500, 1000, 5000, 10000]\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupVirtualScrolling()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const itemCount = itemCounts[i % itemCounts.length]\n      const items = Array.from({ length: itemCount }, (_, index) => ({\n        id: index,\n        title: `Task ${index}`,\n        height: 60 + Math.random() * 40,\n        data: { id: index, title: `Task ${index}` }\n      }))\n\n      try {\n        const startTime = performance.now()\n\n        // Create virtual scrolling instance\n        const virtualScroll = useVirtualScrolling(items, {\n          itemHeight: 80,\n          containerHeight: 600,\n          threshold: 100\n        })\n\n        // Simulate scrolling operations\n        for (let scroll = 0; scroll < 10; scroll++) {\n          virtualScroll.scrollToItem(Math.floor(Math.random() * itemCount))\n          await new Promise(resolve => setTimeout(resolve, 10))\n        }\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n        // Memory snapshot\n        if (this.config.enableMemoryProfiling) {\n          this.memorySnapshots.push(this.getMemoryUsage())\n        }\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = (i / (this.config.iterations || 5)) * 20 // 20% of total\n    }\n\n    return this.calculateBenchmarkResult('Virtual Scrolling', times, errors)\n  }\n\n  // Task store operations benchmark\n  private async benchmarkTaskStoreOperations(): Promise<BenchmarkResult> {\n    console.log('ðŸ’¾ Benchmarking task store operations...')\n\n    const operations = ['create', 'read', 'update', 'delete'] as const\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupTaskStore()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const operation = operations[i % operations.length]\n      const task = {\n        id: `task-${i}`,\n        title: `Test Task ${i}`,\n        status: 'pending',\n        priority: 'medium',\n        timestamp: Date.now()\n      }\n\n      try {\n        const startTime = performance.now()\n\n        // Simulate task store operation\n        switch (operation) {\n          case 'create':\n            await this.simulateTaskCreate(task)\n            break\n          case 'read':\n            await this.simulateTaskRead(task.id)\n            break\n          case 'update':\n            await this.simulateTaskUpdate(task)\n            break\n          case 'delete':\n            await this.simulateTaskDelete(task.id)\n            break\n        }\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 20 + (i / (this.config.iterations || 5)) * 15 // 20-35% of total\n    }\n\n    return this.calculateBenchmarkResult('Task Store Operations', times, errors)\n  }\n\n  // Network requests benchmark\n  private async benchmarkNetworkRequests(): Promise<BenchmarkResult> {\n    console.log('ðŸŒ Benchmarking network requests...')\n\n    const endpoints = [\n      { url: 'https://httpbin.org/json', method: 'GET' as const },\n      { url: 'https://httpbin.org/post', method: 'POST' as const },\n      { url: 'https://httpbin.org/put', method: 'PUT' as const }\n    ]\n\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupNetworkRequests()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const endpoint = endpoints[i % endpoints.length]\n      const data = i % 2 === 0 ? null : { test: 'data', index: i }\n\n      try {\n        const startTime = performance.now()\n\n        // Use network optimizer for request\n        await this.networkOptimizer.makeRequest({\n          url: endpoint.url,\n          method: endpoint.method,\n          data,\n          priority: 'normal'\n        })\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 35 + (i / (this.config.iterations || 5)) * 15 // 35-50% of total\n    }\n\n    return this.calculateBenchmarkResult('Network Requests', times, errors)\n  }\n\n  // Render performance benchmark\n  private async benchmarkRenderPerformance(): Promise<BenchmarkResult> {\n    console.log('ðŸŽ¨ Benchmarking render performance...')\n\n    const componentCounts = [10, 50, 100, 250, 500]\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupRenderPerformance()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const componentCount = componentCounts[i % componentCounts.length]\n\n      try {\n        const startTime = performance.now()\n\n        // Simulate component rendering\n        for (let j = 0; j < componentCount; j++) {\n          this.renderOptimizer.optimizedRender(() => {\n            // Simulate DOM operations\n            const div = document.createElement('div')\n            div.textContent = `Component ${j}`\n            document.body.appendChild(div)\n            document.body.removeChild(div)\n          }, `component-${j}`)\n        }\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 50 + (i / (this.config.iterations || 5)) * 15 // 50-65% of total\n    }\n\n    return this.calculateBenchmarkResult('Render Performance', times, errors)\n  }\n\n  // Memory efficiency benchmark\n  private async benchmarkMemoryEfficiency(): Promise<BenchmarkResult> {\n    console.log('ðŸ§  Benchmarking memory efficiency...')\n\n    const times: number[] = []\n    const errors: string[] = []\n    const memoryUsage: number[] = []\n\n    const initialMemory = this.getMemoryUsage()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      try {\n        const startTime = performance.now()\n\n        // Create large dataset\n        const largeDataset = Array.from({ length: 10000 }, (_, index) => ({\n          id: index,\n          data: new Array(1000).fill(Math.random()),\n          metadata: {\n            created: Date.now(),\n            updated: Date.now(),\n            tags: Array.from({ length: 10 }, (_, j) => `tag-${j}`)\n          }\n        }))\n\n        // Use performance manager to cache data\n        this.performanceManager.setCache(`dataset-${i}`, largeDataset, 60000)\n\n        // Retrieve from cache\n        const _cached = this.performanceManager.getCache(`dataset-${i}`)\n\n        // Clean up\n        this.performanceManager.deleteCache(`dataset-${i}`)\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n        const currentMemory = this.getMemoryUsage()\n        memoryUsage.push(currentMemory)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 65 + (i / (this.config.iterations || 5)) * 15 // 65-80% of total\n    }\n\n    const finalMemory = this.getMemoryUsage()\n    const memoryDelta = finalMemory - initialMemory\n\n    const result = this.calculateBenchmarkResult('Memory Efficiency', times, errors)\n    result.memoryDelta = memoryDelta\n    result.memoryUsage = finalMemory\n\n    return result\n  }\n\n  // Bundle size benchmark\n  private async benchmarkBundleSize(): Promise<BenchmarkResult> {\n    console.log('ðŸ“¦ Benchmarking bundle size...')\n\n    const times: number[] = []\n    const errors: string[] = []\n    let bundleSize = 0\n\n    try {\n      const startTime = performance.now()\n\n      // Analyze bundle size (simplified version)\n      const scripts = document.querySelectorAll('script[src]')\n      let totalSize = 0\n\n      for (const script of scripts) {\n        const src = script.getAttribute('src')\n        if (src && src.includes('/src/')) {\n          try {\n            // Simulate bundle size calculation\n            // In a real app, you'd fetch and calculate actual sizes\n            totalSize += Math.random() * 100000 // Simulated size\n          } catch (_error) {\n            errors.push(`Failed to calculate bundle size for ${src}`)\n          }\n        }\n      }\n\n      bundleSize = totalSize\n\n      const duration = performance.now() - startTime\n      times.push(duration)\n\n    } catch (error) {\n      errors.push(error instanceof Error ? error.message : String(error))\n    }\n\n    this.progress.value = 80 + 20 // 100% of total\n\n    const result = this.calculateBenchmarkResult('Bundle Size Analysis', times, errors)\n    result.throughput = bundleSize / 1024 // Convert to KB\n\n    return result\n  }\n\n  // Warmup functions\n  private async warmupVirtualScrolling() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      const items = Array.from({ length: 100 }, (_, index) => ({ id: index, data: null }))\n      useVirtualScrolling(items, { threshold: 50 })\n      await new Promise(resolve => setTimeout(resolve, 10))\n    }\n  }\n\n  private async warmupTaskStore() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      await this.simulateTaskCreate({ id: `warmup-${i}`, title: 'Warmup Task' })\n    }\n  }\n\n  private async warmupNetworkRequests() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      try {\n        await fetch('https://httpbin.org/status/200')\n      } catch {\n        // Ignore warmup errors\n      }\n    }\n  }\n\n  private async warmupRenderPerformance() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      this.renderOptimizer.optimizedRender(() => {\n        document.createElement('div')\n      })\n    }\n  }\n\n  // Simulation functions\n  private async simulateTaskCreate(_task: unknown): Promise<void> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 10))\n  }\n\n  private async simulateTaskRead(id: string): Promise<unknown> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 5))\n    return { id, title: `Task ${id}` }\n  }\n\n  private async simulateTaskUpdate(_task: unknown): Promise<void> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 8))\n  }\n\n  private async simulateTaskDelete(_id: string): Promise<void> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 3))\n  }\n\n  // Utility functions\n  private calculateBenchmarkResult(name: string, times: number[], errors: string[]): BenchmarkResult {\n    const validTimes = times.length > 0 ? times : [0]\n\n    const total = validTimes.reduce((sum, time) => sum + time, 0)\n    const average = total / validTimes.length\n    const min = Math.min(...validTimes)\n    const max = Math.max(...validTimes)\n\n    // Calculate standard deviation\n    const variance = validTimes.reduce((sum, time) => sum + Math.pow(time - average, 2), 0) / validTimes.length\n    const standardDeviation = Math.sqrt(variance)\n\n    return {\n      name,\n      iterations: times.length,\n      totalTime: total,\n      averageTime: average,\n      minTime: min,\n      maxTime: max,\n      standardDeviation,\n      throughput: total > 0 ? (times.length / (total / 1000)) : 0, // operations per second\n      successRate: times.length > 0 ? (((times.length - errors.length) / times.length) * 100) : 0,\n      errors\n    }\n  }\n\n  private getMemoryUsage(): number {\n    if ('memory' in performance) {\n      return (performance as unknown as { memory: { usedJSHeapSize: number } }).memory.usedJSHeapSize\n    }\n    return 0\n  }\n\n  private async generateReport(results: BenchmarkSuite): Promise<void> {\n    console.log('\\nðŸ“Š PERFORMANCE BENCHMARK REPORT')\n    console.log('=====================================')\n\n    const report = {\n      timestamp: new Date().toISOString(),\n      config: this.config,\n      results,\n      thresholds: PERFORMANCE_THRESHOLDS,\n      summary: this.generateSummary(results)\n    }\n\n    // Log results\n    for (const [category, result] of Object.entries(results)) {\n      console.log(`\\nðŸ·ï¸  ${category.toUpperCase()}:`)\n      console.log(`   Average Time: ${result.averageTime.toFixed(2)}ms`)\n      console.log(`   Throughput: ${result.throughput.toFixed(0)} ops/sec`)\n      console.log(`   Success Rate: ${result.successRate.toFixed(1)}%`)\n      console.log(`   Min/Max: ${result.minTime.toFixed(2)}ms / ${result.maxTime.toFixed(2)}ms`)\n\n      if (result.memoryUsage) {\n        console.log(`   Memory Usage: ${(result.memoryUsage / 1024 / 1024).toFixed(1)}MB`)\n      }\n\n      if (result.errors.length > 0) {\n        console.log(`   Errors: ${result.errors.length}`)\n      }\n    }\n\n    // Performance comparison\n    console.log('\\nðŸŽ¯ PERFORMANCE COMPARISON:')\n    for (const [threshold, _value] of Object.entries(PERFORMANCE_THRESHOLDS)) {\n      const passed = this.checkThreshold(threshold as keyof PerformanceThresholds, results)\n      console.log(`   ${threshold}: ${passed ? 'âœ… PASS' : 'âŒ FAIL'}`)\n    }\n\n    console.log('\\nðŸ“ˆ SUMMARY:')\n    console.log(report.summary)\n\n    // Save to localStorage for persistence\n    try {\n      localStorage.setItem('pomo-flow-benchmark-report', JSON.stringify(report))\n      console.log('\\nðŸ’¾ Report saved to localStorage')\n    } catch (error) {\n      console.warn('Failed to save report to localStorage:', error)\n    }\n  }\n\n  private generateSummary(results: BenchmarkSuite): string {\n    const overallPerformance = Object.values(results).reduce((sum, result) => {\n      const score = (result.successRate / 100) * (1000 / Math.max(result.averageTime, 1))\n      return sum + score\n    }, 0) / Object.keys(results).length\n\n    let summary = `Overall Performance Score: ${overallPerformance.toFixed(0)}/1000\\n`\n\n    if (overallPerformance > 800) {\n      summary += 'Status: ðŸŸ¢ EXCELLENT - Application performs exceptionally well'\n    } else if (overallPerformance > 600) {\n      summary += 'Status: ðŸŸ¡ GOOD - Application performs well with minor optimizations possible'\n    } else if (overallPerformance > 400) {\n      summary += 'Status: ðŸŸ  FAIR - Application needs performance optimizations'\n    } else {\n      summary += 'Status: ðŸ”´ POOR - Application requires significant performance improvements'\n    }\n\n    return summary\n  }\n\n  private checkThreshold(threshold: keyof PerformanceThresholds, results: BenchmarkSuite): boolean {\n    switch (threshold) {\n      case 'maxAverageRenderTime':\n        return results.renderPerformance.averageTime <= PERFORMANCE_THRESHOLDS[threshold]\n      case 'maxMemoryUsage': {\n        const memoryUsage = results.memoryEfficiency.memoryUsage || 0\n        return memoryUsage <= PERFORMANCE_THRESHOLDS[threshold]\n      }\n      case 'minThroughput':\n        return results.taskStoreOperations.throughput >= PERFORMANCE_THRESHOLDS[threshold]\n      default:\n        return true\n    }\n  }\n\n  // Public API\n  get isBenchmarkRunning(): boolean {\n    return this.isRunning.value\n  }\n\n  get currentProgress(): number {\n    return this.progress.value\n  }\n\n  get benchmarkResults(): Partial<BenchmarkSuite> {\n    return this.results.value\n  }\n\n  async getLatestReport(): Promise<unknown> {\n    try {\n      const report = localStorage.getItem('pomo-flow-benchmark-report')\n      return report ? JSON.parse(report) : null\n    } catch {\n      return null\n    }\n  }\n\n  clearResults(): void {\n    this.results.value = {}\n    this.progress.value = 0\n  }\n}\n\n// Export singleton instance\nexport const performanceBenchmark = new PerformanceBenchmark()\n\nexport default PerformanceBenchmark","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/productionLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/retryManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/safariITPProtection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/securityHeaderManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/securityHeaders.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/securityMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/storageQuotaMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/supabaseMappers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3413,3416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3413,3416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3766,3769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3766,3769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3823,3826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3823,3826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3853,3856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3853,3856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3883,3886],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3883,3886],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3959,3962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3959,3962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5132,5135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5132,5135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5158,5161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5158,5161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5475,5478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5475,5478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":238,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7066,7069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7066,7069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":298,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9553,9556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9553,9556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":299,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":299,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9602,9605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9602,9605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":300,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9659,9662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9659,9662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":300,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9697,9700],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9697,9700],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":429,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":429,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14924,14927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14924,14927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":447,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":447,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15756,15759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15756,15759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":497,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":497,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17590,17593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17590,17593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":521,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18603,18606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18603,18606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":546,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":546,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19591,19594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19591,19594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":565,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":565,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20326,20329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20326,20329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport type { Task, Project, Subtask, TaskInstance, TaskRecurrence, RecurringTaskInstance, NotificationPreferences } from '../types/tasks'\nimport type { ScheduledNotification } from '../types/recurrence'\n\n// -- Validation Helpers --\n\n/**\n * Validates if a string is a valid UUID v4 format\n */\nconst isValidUUID = (str: string | null | undefined): boolean => {\n    if (!str) return false\n    // BUG-FIX: Allow both UUIDs (v4) and Timestamp IDs (legacy/current task creation)\n    // Timestamp IDs are usually 13 digits, UUIDs are 36 chars\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n    const timestampRegex = /^\\d{10,20}$/ // Simple numeric check for timestamps\n    return uuidRegex.test(str) || timestampRegex.test(str)\n}\n\n/**\n * Sanitizes a potential UUID field - returns null for invalid/placeholder values\n */\nconst sanitizeUUID = (value: string | null | undefined): string | null => {\n    // Handle null/undefined\n    if (value === null || value === undefined) return null\n    // Handle string literals that should be null\n    if (value === 'undefined' || value === 'null' || value === '') return null\n    // Handle non-UUID placeholder values\n    if (value === 'uncategorized' || value === '1') return null\n    // Validate UUID format\n    if (!isValidUUID(value)) {\n        console.warn(`[SUPABASE-MAPPER] Invalid UUID detected: \"${value}\", converting to null`)\n        return null\n    }\n    return value\n}\n\n// -- Types matching the Supabase Schema --\n\nexport interface SupabaseProject {\n    id: string\n    user_id: string\n    name: string\n    color?: string\n    color_type?: 'hex' | 'emoji'\n    view_type?: 'status' | 'date' | 'priority' | 'list' | 'board'\n    parent_id?: string | null\n    order?: number\n    is_deleted?: boolean\n    deleted_at?: string | null\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseTask {\n    id: string\n    user_id: string\n    project_id?: string | null\n    title: string\n    description?: string\n    status: string\n    priority?: string | null\n\n    // Progress\n    progress?: number\n    total_pomodoros?: number\n    estimated_pomodoros?: number\n    completed_pomodoros?: number\n\n    // Timing\n    due_date?: string | null\n    due_time?: string | null\n    estimated_duration?: number\n\n    // JSON & Arrays\n    subtasks?: Subtask[] | null // stored as jsonb, Supabase client handles object/array\n    tags?: string[] | null\n    depends_on?: string[] | null\n\n    // Complex JSON fields (mapped to camelCase in jsonb)\n    position?: { x: number; y: number; parentId?: string; format?: 'absolute' | 'relative' } | null\n    position_version?: number // Optimistic locking for canvas position sync\n    instances?: TaskInstance[] | null\n    connection_types?: Record<string, 'sequential' | 'blocker' | 'reference'> | null\n    recurrence?: TaskRecurrence | null\n    recurring_instances?: RecurringTaskInstance[] | null\n    notification_prefs?: NotificationPreferences | null\n\n    // Hierarchy\n    parent_task_id?: string | null\n\n    // Metadata\n    order?: number\n    column_id?: string | null\n    is_in_inbox?: boolean\n\n    is_deleted?: boolean\n    deleted_at?: string | null\n    completed_at?: string | null\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseGroup {\n    id: string\n    user_id: string\n    name: string\n    type: string\n    color?: string\n\n    position_json?: any // Fixed: Use legacy database column name\n    position_version?: number // Optimistic locking for canvas position sync\n    position_format?: string // TASK-240: Transition to relative-only\n    layout?: string\n\n    is_visible?: boolean\n    is_collapsed?: boolean\n    collapsed_height?: number\n\n    parent_group_id?: string | null\n\n    filters_json?: any\n    is_power_mode?: boolean\n    power_keyword_json?: any\n    assign_on_drop_json?: any\n    collect_filter_json?: any\n    auto_collect?: boolean\n    is_pinned?: boolean\n    property_value?: any\n\n    is_deleted?: boolean\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseNotification {\n    id: string\n    user_id: string\n    task_id: string\n    title: string\n    body: string\n    scheduled_time: string\n    snoozed_until?: string | null\n    is_shown?: boolean\n    is_dismissed?: boolean\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseTimerSession {\n    id: string\n    user_id: string\n    task_id: string\n    start_time: string\n    duration: number\n    remaining_time: number\n    is_active?: boolean\n    is_paused?: boolean\n    is_break?: boolean\n    completed_at?: string | null\n    device_leader_id?: string | null\n    device_leader_last_seen?: string | null\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseUserSettings {\n    id?: string\n    user_id: string\n    work_duration?: number\n    short_break_duration?: number\n    long_break_duration?: number\n    auto_start_breaks?: boolean\n    auto_start_pomodoros?: boolean\n    play_notification_sounds?: boolean\n    theme?: string\n    language?: string\n    sidebar_collapsed?: boolean\n    board_density?: string\n    kanban_settings?: any\n    canvas_viewport?: any\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseQuickSortSession {\n    id: string\n    user_id: string\n    tasks_processed: number\n    time_spent: number\n    efficiency: number\n    streak_days: number\n    completed_at: string\n}\n\n// -- Mappers --\n\nexport function toSupabaseGroup(group: any, userId: string): SupabaseGroup {\n    // SAFETY: Sanitize parent_group_id (though groups table uses text type, still good to sanitize)\n    const sanitizedParentGroupId = group.parentGroupId &&\n        group.parentGroupId !== 'undefined' &&\n        group.parentGroupId !== 'null'\n        ? group.parentGroupId\n        : null\n\n    return {\n        id: group.id,\n        user_id: userId,\n        name: group.name,\n        type: group.type,\n        color: group.color,\n\n        position_json: group.position, // Fixed: Map internal position to DB position_json\n        // Note: position_version is managed by DB triggers, not sent on update\n        layout: group.layout,\n\n        is_visible: group.isVisible,\n        is_collapsed: group.isCollapsed,\n        collapsed_height: group.collapsedHeight,\n\n        parent_group_id: sanitizedParentGroupId,\n\n        filters_json: group.filters,\n        is_power_mode: group.isPowerMode,\n        power_keyword_json: group.powerKeyword,\n        assign_on_drop_json: group.assignOnDrop,\n        collect_filter_json: group.collectFilter,\n        auto_collect: group.autoCollect,\n        is_pinned: group.isPinned,\n        property_value: typeof group.propertyValue === 'object' ? JSON.stringify(group.propertyValue) : group.propertyValue,\n\n        // Let the database default handle new groups (default: false)\n        // Upsert will only update fields present in the payload\n        // position_format removed - column does not exist in DB\n        updated_at: new Date().toISOString()\n    }\n}\n\nexport function fromSupabaseGroup(record: SupabaseGroup): any {\n    return {\n        id: record.id,\n        name: record.name,\n        type: record.type,\n        color: record.color,\n\n        position: record.position_json, // Fixed: Map DB position_json to internal position\n        positionVersion: record.position_version ?? 0, // Read position_version for optimistic locking\n        layout: record.layout,\n\n        isVisible: record.is_visible,\n        isCollapsed: record.is_collapsed,\n        collapsedHeight: record.collapsed_height,\n\n        parentGroupId: record.parent_group_id,\n\n        filters: record.filters_json,\n        isPowerMode: record.is_power_mode,\n        powerKeyword: record.power_keyword_json,\n        assignOnDrop: record.assign_on_drop_json,\n        collectFilter: record.collect_filter_json,\n        autoCollect: record.auto_collect,\n        isPinned: record.is_pinned,\n        propertyValue: record.property_value, // Might need parsing if it was stringified object\n        positionFormat: 'absolute', // Default to absolute since DB column is missing\n\n        updatedAt: record.updated_at\n    }\n}\n\nexport function toSupabaseProject(project: Project, userId: string): SupabaseProject {\n    // Determine color type and extract primary color (handling legacy array colors if any)\n    const primaryColor = Array.isArray(project.color) ? project.color[0] : project.color;\n    // Check if color is likely an emoji (if not hex)\n    const isEmoji = project.colorType === 'emoji' || (project.emoji && !primaryColor?.startsWith('#'));\n\n    // SAFETY: Validate UUID fields to prevent 400 errors from Supabase\n    const sanitizedId = project.id\n    const sanitizedParentId = sanitizeUUID(project.parentId)\n\n    // SAFETY: Ensure name is never null (required by DB constraint)\n    const sanitizedName = project.name || 'Unnamed Project'\n\n    // Log if we're sanitizing invalid data\n    if (project.parentId && !sanitizedParentId) {\n        console.warn(`[SUPABASE-MAPPER] Project \"${sanitizedName}\" had invalid parentId: \"${project.parentId}\", sanitized to null`)\n    }\n    if (!project.name) {\n        console.warn(`[SUPABASE-MAPPER] Project \"${sanitizedId}\" had null/empty name, defaulting to \"Unnamed Project\"`)\n    }\n\n    return {\n        id: sanitizedId,\n        user_id: userId,\n        name: sanitizedName,\n        color: primaryColor,\n        color_type: project.colorType || (isEmoji ? 'emoji' : 'hex'),\n        view_type: project.viewType || 'status',\n        parent_id: sanitizedParentId,\n        order: (project as any).order || 0,\n        is_deleted: (project as any).isDeleted || false,\n        deleted_at: (project as any).deletedAt ? new Date((project as any).deletedAt).toISOString() : null,\n        created_at: project.createdAt instanceof Date ? project.createdAt.toISOString() : project.createdAt,\n        updated_at: new Date().toISOString()\n    }\n}\n\nexport function fromSupabaseProject(record: SupabaseProject): Project {\n    return {\n        id: record.id,\n        name: record.name,\n        color: record.color || '#000000',\n        colorType: (record.color_type as Project['colorType']) || 'hex',\n        emoji: record.color_type === 'emoji' ? record.color : undefined,\n        viewType: (record.view_type as Project['viewType']) || 'status',\n        parentId: record.parent_id || null,\n        createdAt: new Date(record.created_at || Date.now()),\n        updatedAt: new Date(record.updated_at || Date.now())\n    }\n}\n\nexport function toSupabaseTask(task: Task, userId: string): SupabaseTask {\n    const now = new Date().toISOString()\n\n    // SAFETY: Sanitize UUID fields to prevent 400 errors from Supabase\n    const sanitizedProjectId = sanitizeUUID(task.projectId)\n    const sanitizedParentTaskId = sanitizeUUID(task.parentTaskId)\n\n    // Sanitize depends_on array - filter out invalid UUIDs\n    const sanitizedDependsOn = (task.dependsOn || []).filter(id => isValidUUID(id))\n\n    return {\n        id: task.id,\n        user_id: userId,\n        project_id: sanitizedProjectId,\n        title: task.title,\n        description: task.description,\n        status: task.status,\n        priority: task.priority,\n\n        progress: task.progress,\n        total_pomodoros: task.completedPomodoros,\n        completed_pomodoros: task.completedPomodoros,\n        estimated_pomodoros: task.estimatedPomodoros,\n\n        due_date: task.dueDate || null,\n        due_time: task.dueTime || null,\n        estimated_duration: task.estimatedDuration,\n\n        subtasks: task.subtasks || [],\n        tags: task.tags || [],\n        depends_on: sanitizedDependsOn.length > 0 ? sanitizedDependsOn : null,\n\n        // JSONB mappings\n        position: task.canvasPosition ? {\n            x: task.canvasPosition.x,\n            y: task.canvasPosition.y,\n            parentId: task.parentId, // Serialize parentId into position JSON\n            format: 'absolute' // Default for existing tasks during migration\n        } : null,\n        // Note: position_version is managed by DB triggers, not sent on update\n        instances: task.instances || [],\n        connection_types: task.connectionTypes || null,\n        recurrence: task.recurrence || null,\n        recurring_instances: task.recurringInstances || [],\n        notification_prefs: task.notificationPreferences || null,\n\n        parent_task_id: sanitizedParentTaskId,\n\n        order: task.order || 0,\n        column_id: task.columnId || null,\n        is_in_inbox: task.isInInbox || false,\n\n        is_deleted: task._soft_deleted || false,\n        deleted_at: task.deletedAt ? new Date(task.deletedAt).toISOString() : null,\n        completed_at: task.completedAt ? new Date(task.completedAt).toISOString() : null,\n\n        created_at: task.createdAt instanceof Date ? task.createdAt.toISOString() : (task.createdAt || now),\n        updated_at: now\n    }\n}\n\nexport function fromSupabaseTask(record: SupabaseTask): Task {\n    return {\n        id: record.id,\n        title: record.title,\n        description: record.description || '',\n        status: record.status as Task['status'],\n        priority: (record.priority as Task['priority']) || null,\n\n        projectId: record.project_id || 'uncategorized',\n        parentTaskId: record.parent_task_id || null,\n\n        completedPomodoros: record.completed_pomodoros || 0,\n        estimatedPomodoros: record.estimated_pomodoros || 1,\n        progress: record.progress || 0,\n\n        dueDate: record.due_date || '', // App uses empty string for no date sometimes? Types say string.\n        dueTime: record.due_time || undefined,\n        estimatedDuration: record.estimated_duration || undefined,\n\n        subtasks: record.subtasks || [],\n        tags: record.tags || undefined,\n        dependsOn: record.depends_on || undefined,\n\n        canvasPosition: record.position ? { x: record.position.x, y: record.position.y } : undefined,\n        positionVersion: record.position_version ?? 0, // Read position_version for optimistic locking\n        parentId: record.position?.parentId,\n        positionFormat: record.position?.format || 'absolute',\n        instances: record.instances || [],\n        connectionTypes: record.connection_types || undefined,\n        recurrence: record.recurrence || undefined,\n        recurringInstances: record.recurring_instances || [],\n        notificationPreferences: record.notification_prefs || undefined,\n\n        isInInbox: record.is_in_inbox || false,\n        order: record.order || 0,\n        columnId: record.column_id || undefined,\n\n        createdAt: new Date(record.created_at || Date.now()),\n        updatedAt: new Date(record.updated_at || Date.now()),\n        completedAt: record.completed_at ? new Date(record.completed_at) : undefined,\n\n        _soft_deleted: record.is_deleted || false,\n        deletedAt: record.deleted_at ? new Date(record.deleted_at) : undefined\n    }\n}\n\n// -- User Settings Mappers --\n\nexport function toSupabaseUserSettings(settings: any, userId: string): SupabaseUserSettings {\n    return {\n        user_id: userId,\n        work_duration: settings.workDuration,\n        short_break_duration: settings.shortBreakDuration,\n        long_break_duration: settings.longBreakDuration,\n        auto_start_breaks: settings.autoStartBreaks,\n        auto_start_pomodoros: settings.autoStartPomodoros,\n        play_notification_sounds: settings.playNotificationSounds,\n        theme: settings.theme || 'system',\n        language: settings.language || 'en',\n        sidebar_collapsed: settings.sidebarCollapsed || false,\n        board_density: settings.boardDensity || 'comfortable',\n        kanban_settings: settings.kanbanSettings || {},\n        canvas_viewport: settings.canvasViewport || null\n    }\n}\n\nexport function fromSupabaseUserSettings(record: SupabaseUserSettings): any {\n    return {\n        workDuration: record.work_duration,\n        shortBreakDuration: record.short_break_duration,\n        longBreakDuration: record.long_break_duration,\n        autoStartBreaks: record.auto_start_breaks,\n        autoStartPomodoros: record.auto_start_pomodoros,\n        playNotificationSounds: record.play_notification_sounds,\n        theme: record.theme,\n        language: record.language,\n        sidebarCollapsed: record.sidebar_collapsed,\n        boardDensity: record.board_density,\n        kanbanSettings: record.kanban_settings,\n        canvasViewport: record.canvas_viewport\n    }\n}\n\n// -- Notification Mappers --\n\nexport function toSupabaseNotification(notification: ScheduledNotification, userId: string): SupabaseNotification {\n    return {\n        id: notification.id,\n        user_id: userId,\n        task_id: notification.taskId,\n        title: notification.title,\n        body: notification.body,\n        scheduled_time: notification.scheduledTime.toISOString(),\n        snoozed_until: notification.snoozedUntil?.toISOString() || null,\n        is_shown: notification.isShown,\n        is_dismissed: notification.isDismissed,\n        created_at: notification.createdAt.toISOString()\n    }\n}\n\nexport function fromSupabaseNotification(record: SupabaseNotification): ScheduledNotification {\n    return {\n        id: record.id,\n        taskId: record.task_id,\n        title: record.title,\n        body: record.body,\n        scheduledTime: new Date(record.scheduled_time),\n        isShown: record.is_shown || false,\n        isDismissed: record.is_dismissed || false,\n        snoozedUntil: record.snoozed_until ? new Date(record.snoozed_until) : undefined,\n        createdAt: new Date(record.created_at || Date.now())\n    }\n}\n\n// -- Timer Session Mappers --\n\nexport function toSupabaseTimerSession(session: any, userId: string, deviceId: string): SupabaseTimerSession {\n    // SAFETY: Validate session ID - generate new UUID if invalid (prevents timestamp IDs from breaking DB)\n    const validSessionId = isValidUUID(session.id) ? session.id : crypto.randomUUID()\n\n    if (!isValidUUID(session.id)) {\n        console.warn(`[SUPABASE-MAPPER] Timer session had invalid ID: \"${session.id}\", generated new UUID: ${validSessionId}`)\n    }\n\n    return {\n        id: validSessionId,\n        user_id: userId,\n        task_id: session.taskId,\n        start_time: session.startTime.toISOString(),\n        duration: session.duration,\n        remaining_time: session.remainingTime,\n        is_active: session.isActive,\n        is_paused: session.isPaused,\n        is_break: session.isBreak,\n        completed_at: session.completedAt?.toISOString() || null,\n        device_leader_id: deviceId,\n        device_leader_last_seen: new Date().toISOString()\n    }\n}\n\nexport function fromSupabaseTimerSession(record: SupabaseTimerSession): any {\n    // SAFETY: Ensure ID is valid UUID when loading (in case DB has corrupted data)\n    const validId = isValidUUID(record.id) ? record.id : crypto.randomUUID()\n\n    if (!isValidUUID(record.id)) {\n        console.warn(`[SUPABASE-MAPPER] Loaded timer session had invalid ID: \"${record.id}\", generated new UUID: ${validId}`)\n    }\n\n    return {\n        id: validId,\n        taskId: record.task_id,\n        startTime: new Date(record.start_time),\n        duration: record.duration,\n        remainingTime: record.remaining_time,\n        isActive: record.is_active,\n        isPaused: record.is_paused,\n        isBreak: record.is_break,\n        completedAt: record.completed_at ? new Date(record.completed_at) : undefined,\n        deviceLeaderId: record.device_leader_id,\n        deviceLeaderLastSeen: record.device_leader_last_seen ? new Date(record.device_leader_last_seen).getTime() : undefined\n    }\n}\n\n// -- Quick Sort Mappers --\n\nexport function toSupabaseQuickSortSession(summary: any, userId: string): SupabaseQuickSortSession {\n    // SAFETY: Validate session ID - generate new UUID if invalid\n    const validId = isValidUUID(summary.id) ? summary.id : crypto.randomUUID()\n\n    if (!isValidUUID(summary.id)) {\n        console.warn(`[SUPABASE-MAPPER] QuickSort session had invalid ID: \"${summary.id}\", generated new UUID: ${validId}`)\n    }\n\n    return {\n        id: validId,\n        user_id: userId,\n        tasks_processed: summary.tasksProcessed,\n        time_spent: summary.timeSpent,\n        efficiency: summary.efficiency,\n        streak_days: summary.streakDays,\n        completed_at: summary.completedAt.toISOString()\n    }\n}\n\nexport function fromSupabaseQuickSortSession(record: SupabaseQuickSortSession): any {\n    return {\n        id: record.id,\n        tasksProcessed: record.tasks_processed,\n        timeSpent: record.time_spent,\n        efficiency: record.efficiency,\n        streakDays: record.streak_days,\n        completedAt: new Date(record.completed_at)\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/taskValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'validPriorities' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":313,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":313,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Task Validation Utility\n * BUG-060 FIX: Multi-layer defense against undefined/invalid task IDs\n *\n * This utility provides centralized validation for task data integrity,\n * preventing phantom tasks, sync loops, and data corruption.\n */\n\nimport type { Task } from '@/types/tasks'\n\n/**\n * Validation result with detailed error information\n */\nexport interface TaskValidationResult {\n  isValid: boolean\n  errors: string[]\n  warnings: string[]\n  taskId: string | undefined\n}\n\n/**\n * Batch validation result\n */\nexport interface BatchValidationResult {\n  validTasks: Task[]\n  invalidTasks: { task: unknown; errors: string[] }[]\n  totalProcessed: number\n  validCount: number\n  invalidCount: number\n}\n\n/**\n * UUID regex pattern for validation\n */\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n\n/**\n * Check if a task ID is valid\n * Valid IDs must be:\n * - Non-empty strings\n * - Not 'undefined' or 'null' literals\n * - Valid UUID format OR legacy prefixed format (group-xxx, instance-xxx, etc.)\n */\nexport function isValidTaskId(id: unknown): id is string {\n  if (typeof id !== 'string') return false\n  if (id === '') return false\n  if (id === 'undefined') return false\n  if (id === 'null') return false\n  if (id.trim() === '') return false\n\n  // Check for valid UUID format (Supabase requirement)\n  if (UUID_REGEX.test(id)) return true\n\n  // Allow legacy prefixed IDs (group-xxx, instance-xxx, recovered-xxx, etc.)\n  if (id.includes('-') && !id.match(/^\\d+$/)) return true\n\n  // Block pure numeric IDs (e.g., \"1767970660403\") - these break Supabase\n  if (/^\\d+$/.test(id)) {\n    console.warn(`ðŸ›¡ï¸ [VALIDATION] Blocking numeric ID: ${id} (not UUID compatible)`)\n    return false\n  }\n\n  return true\n}\n\n/**\n * Generate a fallback task ID\n * Used when a task has no valid ID but needs to be preserved\n */\nexport function generateFallbackId(prefix: string = 'recovered'): string {\n  return `${prefix}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`\n}\n\n/**\n * Validate a single task object\n */\nexport function validateTask(task: unknown): TaskValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  // Check if task is an object\n  if (!task || typeof task !== 'object') {\n    return {\n      isValid: false,\n      errors: ['Task is not a valid object'],\n      warnings: [],\n      taskId: undefined\n    }\n  }\n\n  const taskObj = task as Record<string, unknown>\n\n  // Critical: Check ID\n  if (!isValidTaskId(taskObj.id)) {\n    errors.push(`Invalid task ID: ${JSON.stringify(taskObj.id)} (type: ${typeof taskObj.id})`)\n  }\n\n  // Check title (optional but warned)\n  if (!taskObj.title || typeof taskObj.title !== 'string' || taskObj.title.trim() === '') {\n    warnings.push('Task has no valid title')\n  }\n\n  // Check for required fields\n  if (!taskObj.status) {\n    warnings.push('Task has no status, will default to \"planned\"')\n  }\n\n  // Check dates\n  if (taskObj.createdAt && !(taskObj.createdAt instanceof Date) && typeof taskObj.createdAt !== 'string') {\n    warnings.push('Task has invalid createdAt format')\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n    taskId: isValidTaskId(taskObj.id) ? taskObj.id : undefined\n  }\n}\n\n/**\n * Validate and sanitize a batch of tasks\n * Returns valid tasks and reports on invalid ones\n */\nexport function validateAndSanitizeTasks(tasks: unknown[]): BatchValidationResult {\n  const validTasks: Task[] = []\n  const invalidTasks: { task: unknown; errors: string[] }[] = []\n\n  if (!Array.isArray(tasks)) {\n    console.error('ðŸ›¡ï¸ [VALIDATION] validateAndSanitizeTasks received non-array:', typeof tasks)\n    return {\n      validTasks: [],\n      invalidTasks: [],\n      totalProcessed: 0,\n      validCount: 0,\n      invalidCount: 0\n    }\n  }\n\n  for (const task of tasks) {\n    const result = validateTask(task)\n\n    if (result.isValid) {\n      validTasks.push(task as Task)\n    } else {\n      invalidTasks.push({ task, errors: result.errors })\n      console.warn('ðŸ›¡ï¸ [VALIDATION] Invalid task detected:', {\n        errors: result.errors,\n        taskSnapshot: JSON.stringify(task).substring(0, 200)\n      })\n    }\n\n    // Log warnings even for valid tasks\n    if (result.warnings.length > 0 && result.isValid) {\n      console.warn(`ðŸ›¡ï¸ [VALIDATION] Task ${result.taskId} has warnings:`, result.warnings)\n    }\n  }\n\n  return {\n    validTasks,\n    invalidTasks,\n    totalProcessed: tasks.length,\n    validCount: validTasks.length,\n    invalidCount: invalidTasks.length\n  }\n}\n\n/**\n * Sanitize a task by fixing recoverable issues\n * Returns null if task is unrecoverable\n */\nexport function sanitizeTask(task: unknown, options: {\n  generateIdIfMissing?: boolean\n  idPrefix?: string\n} = {}): Task | null {\n  const { generateIdIfMissing = true, idPrefix = 'sanitized' } = options\n\n  if (!task || typeof task !== 'object') {\n    return null\n  }\n\n  const taskObj = task as Record<string, unknown>\n\n  // Handle missing/invalid ID\n  let taskId = taskObj.id as string | undefined\n  if (!isValidTaskId(taskId)) {\n    if (generateIdIfMissing) {\n      taskId = generateFallbackId(idPrefix)\n      // console.log(`ðŸ›¡ï¸ [SANITIZE] Generated fallback ID: ${taskId}`)\n    } else {\n      console.error('ðŸ›¡ï¸ [SANITIZE] Task has invalid ID and generateIdIfMissing is false')\n      return null\n    }\n  }\n\n  // Build sanitized task\n  const sanitizedTask: Task = {\n    id: taskId,\n    title: (typeof taskObj.title === 'string' && taskObj.title.trim())\n      ? taskObj.title\n      : 'Recovered Task',\n    description: typeof taskObj.description === 'string' ? taskObj.description : '',\n    status: isValidStatus(taskObj.status) ? taskObj.status : 'planned',\n    priority: isValidPriority(taskObj.priority) ? taskObj.priority : 'medium',\n    progress: typeof taskObj.progress === 'number' ? taskObj.progress : 0,\n    completedPomodoros: typeof taskObj.completedPomodoros === 'number' ? taskObj.completedPomodoros : 0,\n    subtasks: Array.isArray(taskObj.subtasks) ? taskObj.subtasks : [],\n    dueDate: typeof taskObj.dueDate === 'string' ? taskObj.dueDate : new Date().toISOString().split('T')[0],\n    projectId: typeof taskObj.projectId === 'string' ? taskObj.projectId : 'uncategorized',\n    createdAt: parseDate(taskObj.createdAt) || new Date(),\n    updatedAt: parseDate(taskObj.updatedAt) || new Date(),\n    instances: Array.isArray(taskObj.instances) ? taskObj.instances : [],\n    isInInbox: typeof taskObj.isInInbox === 'boolean' ? taskObj.isInInbox : true,\n    canvasPosition: taskObj.canvasPosition as Task['canvasPosition'],\n    parentTaskId: typeof taskObj.parentTaskId === 'string' ? taskObj.parentTaskId : null\n  }\n\n  return sanitizedTask\n}\n\n/**\n * Load-time sanitization for tasks from database\n * Filters out invalid tasks and sanitizes recoverable ones\n */\nexport function sanitizeLoadedTasks(loadedData: unknown): Task[] {\n  if (!Array.isArray(loadedData)) {\n    console.warn('ðŸ›¡ï¸ [LOAD-SANITIZE] Loaded data is not an array')\n    return []\n  }\n\n  const sanitizedTasks: Task[] = []\n  const droppedCount = { invalid: 0, recovered: 0 }\n\n  for (const item of loadedData) {\n    const validation = validateTask(item)\n\n    if (validation.isValid) {\n      // Task is valid, add directly\n      sanitizedTasks.push(item as Task)\n    } else {\n      // Try to sanitize\n      const sanitized = sanitizeTask(item, {\n        generateIdIfMissing: true,\n        idPrefix: 'db-recovery'\n      })\n\n      if (sanitized) {\n        sanitizedTasks.push(sanitized)\n        droppedCount.recovered++\n        // console.log(`ðŸ›¡ï¸ [LOAD-SANITIZE] Recovered task: ${sanitized.id}`)\n      } else {\n        droppedCount.invalid++\n        console.error('ðŸ›¡ï¸ [LOAD-SANITIZE] Dropped unrecoverable task:', item)\n      }\n    }\n  }\n\n  if (droppedCount.invalid > 0 || droppedCount.recovered > 0) {\n    // console.log(`ðŸ›¡ï¸ [LOAD-SANITIZE] Summary: ${sanitizedTasks.length} valid, ${droppedCount.recovered} recovered, ${droppedCount.invalid} dropped`)\n  }\n\n  return sanitizedTasks\n}\n\n/**\n * Pre-save validation - blocks saving of invalid tasks\n */\nexport function validateBeforeSave(tasks: Task[]): {\n  canSave: boolean\n  validTasks: Task[]\n  blockedTasks: Task[]\n  reason?: string\n} {\n  const validTasks: Task[] = []\n  const blockedTasks: Task[] = []\n\n  for (const task of tasks) {\n    if (isValidTaskId(task.id)) {\n      validTasks.push(task)\n    } else {\n      blockedTasks.push(task)\n      console.error(`ðŸ›¡ï¸ [PRE-SAVE] BLOCKED task with invalid ID:`, {\n        id: task.id,\n        title: task.title,\n        stack: new Error().stack\n      })\n    }\n  }\n\n  if (blockedTasks.length > 0) {\n    return {\n      canSave: true, // Still save valid tasks\n      validTasks,\n      blockedTasks,\n      reason: `Blocked ${blockedTasks.length} tasks with invalid IDs`\n    }\n  }\n\n  return {\n    canSave: true,\n    validTasks,\n    blockedTasks: []\n  }\n}\n\n// Helper functions\nfunction isValidStatus(status: unknown): status is Task['status'] {\n  const validStatuses = ['planned', 'in_progress', 'done', 'backlog', 'on_hold']\n  return typeof status === 'string' && validStatuses.includes(status)\n}\n\nfunction isValidPriority(priority: unknown): priority is Task['priority'] {\n  const validPriorities = ['low', 'medium', 'high', null]\n  return priority === null || (typeof priority === 'string' && ['low', 'medium', 'high'].includes(priority))\n}\n\nfunction parseDate(value: unknown): Date | null {\n  if (value instanceof Date) return value\n  if (typeof value === 'string') {\n    const parsed = new Date(value)\n    return isNaN(parsed.getTime()) ? null : parsed\n  }\n  if (typeof value === 'number') {\n    return new Date(value)\n  }\n  return null\n}\n\n/**\n * Debug utility: Log task ID statistics\n */\nexport function logTaskIdStats(tasks: Task[], context: string = 'unknown'): void {\n  const stats = {\n    total: tasks.length,\n    validIds: 0,\n    emptyStringIds: 0,\n    undefinedStringIds: 0,\n    nullStringIds: 0,\n    actualUndefined: 0,\n    actualNull: 0,\n    otherInvalid: 0\n  }\n\n  for (const task of tasks) {\n    if (isValidTaskId(task.id)) {\n      stats.validIds++\n    } else if (task.id === '') {\n      stats.emptyStringIds++\n    } else if (task.id === 'undefined') {\n      stats.undefinedStringIds++\n    } else if (task.id === 'null') {\n      stats.nullStringIds++\n    } else if (task.id === undefined) {\n      stats.actualUndefined++\n    } else if (task.id === null) {\n      stats.actualNull++\n    } else {\n      stats.otherInvalid++\n    }\n  }\n\n  if (stats.validIds !== stats.total) {\n    console.warn(`ðŸ›¡ï¸ [ID-STATS] ${context}:`, stats)\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/threeWayMerge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/timer/formatTime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/timezoneCompatibility.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/userResolutionRules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/home/endlessblink/my-projects/ai-development/productivity/pomo-flow/src/utils/verificationReportGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]}]
