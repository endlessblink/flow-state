[{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/App.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ContextMenu.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/QuickSortCard.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ai/AIChatPanel.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ai/AIInsightsPanel.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ai/AITaskAssistPopover.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ai/ChatMessage.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1569,1572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1569,1572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":101,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":104,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1598,1601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1598,1601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":112,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":115,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1609,1612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1609,1612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":123,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":126,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1620,1623],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1620,1623],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1725,1728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1725,1728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1754,1757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1754,1757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1764,1767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1764,1767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":99,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":102,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1775,1778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1775,1778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4713,4716],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4713,4716],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4895,4898],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4895,4898],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5108,5111],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5108,5111],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5500,5503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5500,5503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":146,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5832,5835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5832,5835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6158,6161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6158,6161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6422,6425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6422,6425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6615,6618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6615,6618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6803,6806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6803,6806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6980,6983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6980,6983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7176,7179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7176,7179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7334,7337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7334,7337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7528,7531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7528,7531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9309,9312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9309,9312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9337,9340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9337,9340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9786,9789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9786,9789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"vue/no-v-html","severity":1,"message":"'v-html' directive can lead to XSS attack.","line":393,"column":9,"nodeType":"VAttribute","messageId":"unexpected","endLine":393,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * Chat Message Component\n *\n * Displays a single message in the AI chat panel.\n * Supports:\n * - User and assistant message styling\n * - Markdown rendering via markdown-it\n * - Tool JSON stripping\n * - Copy to clipboard\n * - Streaming animation with thinking indicator\n * - Action buttons\n * - Tool result display\n * - Error states\n * - RTL support\n *\n * @see TASK-1120 in MASTER_PLAN.md\n */\n\nimport { computed, ref } from 'vue'\nimport { User, Sparkles, Loader2, Check, Copy, CheckCheck, Zap, PenLine, Trash2, Trophy, Flame, Shield, Swords, TrendingUp, Target, Play, CheckCircle2, CalendarDays } from 'lucide-vue-next'\nimport MarkdownIt from 'markdown-it'\nimport type { ChatMessage, ChatAction } from '@/stores/aiChat'\nimport { formatRelativeDate } from '@/utils/dateUtils'\nimport TaskQuickEditPopover from './TaskQuickEditPopover.vue'\nimport { executeTool } from '@/services/ai/tools'\n\n// ============================================================================\n// Props\n// ============================================================================\n\nconst props = defineProps<{\n  message: ChatMessage\n}>()\n\nconst emit = defineEmits<{\n  'selectTask': [taskId: string]\n}>()\n\n// ============================================================================\n// Markdown Setup\n// ============================================================================\n\nconst md = new MarkdownIt({\n  html: false,\n  linkify: true,\n  breaks: true\n})\n\n// Make links open in new tab\nconst defaultRender = md.renderer.rules.link_open || function (tokens: any[], idx: number, options: any, _env: any, self: any) {\n  return self.renderToken(tokens, idx, options)\n}\nmd.renderer.rules.link_open = function (tokens: any[], idx: number, options: any, env: any, self: any) {\n  tokens[idx].attrSet('target', '_blank')\n  tokens[idx].attrSet('rel', 'noopener noreferrer')\n  return defaultRender(tokens, idx, options, env, self)\n}\n\n// ============================================================================\n// State\n// ============================================================================\n\nconst loadingActions = ref<Set<string>>(new Set())\nconst copied = ref(false)\n\n// Track which tasks have been actioned (for visual feedback)\nconst completedTaskIds = ref<Set<string>>(new Set())\nconst timerStartedTaskIds = ref<Set<string>>(new Set())\nconst actionLoading = ref<Record<string, string>>({}) // taskId -> 'done' | 'timer'\n\n// ============================================================================\n// Computed\n// ============================================================================\n\nconst isUser = computed(() => props.message.role === 'user')\nconst isAssistant = computed(() => props.message.role === 'assistant')\nconst isStreaming = computed(() => props.message.isStreaming)\nconst hasError = computed(() => !!props.message.error)\nconst hasActions = computed(() =>\n  props.message.actions && props.message.actions.length > 0\n)\nconst isThinking = computed(() =>\n  isStreaming.value && (!props.message.content || props.message.content.trim() === '')\n)\n\n/**\n * Strip tool JSON blocks and AI preamble, then render markdown.\n */\nconst renderedContent = computed(() => {\n  let content = props.message.content || ''\n\n  if (isAssistant.value) {\n    // Strip ```json tool call blocks\n    content = content.replace(/```json\\s*\\{[\\s\\S]*?\\}\\s*```/g, '')\n    // Strip bare JSON tool calls (models sometimes output without code fences)\n    content = content.replace(/\\{\\s*\"tool\"\\s*:\\s*\"[^\"]+\"\\s*,\\s*\"parameters\"\\s*:\\s*\\{[^}]*\\}\\s*\\}/g, '')\n    // Strip \"I'll use the X tool\" preamble lines (EN)\n    content = content.replace(/^I['']ll (?:use|call|invoke) the \\w[\\w\\s]* tool.*$/gm, '')\n    // Strip standalone tool name references (e.g. \"list_tasks\" on its own or at end of line)\n    content = content.replace(/\\b(list_tasks|get_overdue_tasks|search_tasks|get_daily_summary|get_timer_status|get_productivity_stats|suggest_next_task|get_weekly_summary|get_gamification_status|get_active_challenges|get_achievements_near_completion|list_projects|list_groups|create_task|update_task|delete_task|mark_task_done|start_timer|stop_timer|bulk_update_tasks|bulk_delete_tasks)\\b/g, '')\n    // Strip raw HTML tags that AI models may hallucinate (with html:false they appear as raw text)\n    content = content.replace(/<[^>]+>/g, '')\n    // Clean up extra blank lines left behind\n    content = content.replace(/\\n{3,}/g, '\\n\\n').trim()\n  }\n\n  if (!content) return ''\n\n  return md.render(content)\n})\n\n/**\n * Tool results extracted from metadata for display.\n * Includes full data for rich rendering (task lists, summaries, etc.)\n */\nconst toolResults = computed(() => {\n  const meta = props.message.metadata as any\n  if (!meta?.toolResults || !Array.isArray(meta.toolResults)) return []\n  return meta.toolResults as Array<{\n    tool: string\n    message: string\n    success: boolean\n    data?: any\n    type?: 'read' | 'write' | 'destructive'\n  }>\n})\n\n/**\n * Check if a tool result contains a task list that should be rendered as clickable items.\n */\nfunction isTaskListResult(result: { tool: string; data?: any }): boolean {\n  if (!result.data) return false\n  // Direct array of tasks\n  if (Array.isArray(result.data) && result.data.length > 0 && result.data[0]?.title) return true\n  // Daily summary with nested task arrays\n  if (result.data.dueTodayTasks?.length > 0 || result.data.overdueTasks?.length > 0) return true\n  return false\n}\n\nfunction getTasksFromResult(result: { tool: string; data?: any }): Array<{ id: string; title: string; dueDate?: string; priority?: string; status?: string; daysOverdue?: number }> {\n  if (!result.data) return []\n  // Direct array (get_overdue_tasks, list_tasks, search_tasks)\n  if (Array.isArray(result.data)) return result.data\n  // Daily summary — merge overdue + due today\n  const tasks: any[] = []\n  if (result.data.overdueTasks) tasks.push(...result.data.overdueTasks)\n  if (result.data.dueTodayTasks) tasks.push(...result.data.dueTodayTasks)\n  return tasks\n}\n\n/**\n * Check if a tool result is a daily summary with stats to render as a rich card.\n */\nfunction isDailySummaryResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'get_daily_summary' && result.data && typeof result.data.totalTasks === 'number'\n}\n\n/**\n * Gamification & productivity tool result detection helpers\n */\n\nfunction isGamificationStatusResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'get_gamification_status' && result.data && typeof result.data.level === 'number'\n}\n\nfunction isActiveChallengesResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'get_active_challenges' && result.data && Array.isArray(result.data.dailies)\n}\n\nfunction isAchievementsNearResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'get_achievements_near_completion' && Array.isArray(result.data)\n}\n\nfunction isProductivityStatsResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'get_productivity_stats' && result.data && typeof result.data.totalTasks === 'number'\n}\n\nfunction isSuggestNextTaskResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'suggest_next_task' && Array.isArray(result.data)\n}\n\nfunction isWeeklySummaryResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'get_weekly_summary' && result.data && typeof result.data.completedThisWeek === 'number'\n}\n\nfunction isWeeklyPlanResult(result: { tool: string; data?: any }): boolean {\n  return result.tool === 'generate_weekly_plan' && result.data && result.data.plan\n}\n\nconst PLAN_DAY_LABELS: Record<string, string> = {\n  monday: 'Monday', tuesday: 'Tuesday', wednesday: 'Wednesday',\n  thursday: 'Thursday', friday: 'Friday', saturday: 'Saturday', sunday: 'Sunday',\n}\n\nfunction formatMinutes(minutes: number): string {\n  if (minutes < 60) return `${minutes}m`\n  const h = Math.floor(minutes / 60)\n  const m = minutes % 60\n  return m > 0 ? `${h}h ${m}m` : `${h}h`\n}\n\nfunction formatTimeRemaining(minutes: number): string {\n  if (minutes < 60) return `${minutes}m left`\n  const h = Math.floor(minutes / 60)\n  const m = minutes % 60\n  return m > 0 ? `${h}h ${m}m left` : `${h}h left`\n}\n\nfunction tierColor(tier?: string): string {\n  switch (tier) {\n    case 'bronze': return '#cd7f32'\n    case 'silver': return '#c0c0c0'\n    case 'gold': return '#ffd700'\n    case 'platinum': return '#e5e4e2'\n    default: return 'var(--text-secondary, rgba(255,255,255,0.6))'\n  }\n}\n\nfunction priorityColor(priority?: string): string {\n  switch (priority) {\n    case 'urgent': return '#ef4444'\n    case 'high': return '#f97316'\n    case 'medium': return '#eab308'\n    case 'low': return '#22c55e'\n    default: return 'rgba(255,255,255,0.4)'\n  }\n}\n\n// ============================================================================\n// Quick-Edit Popover\n// ============================================================================\n\n// Collapse long task lists — show max 3, expandable\nconst MAX_VISIBLE_TASKS = 3\nconst expandedSections = ref<Set<string>>(new Set())\n\nfunction toggleSection(key: string) {\n  if (expandedSections.value.has(key)) {\n    expandedSections.value.delete(key)\n  } else {\n    expandedSections.value.add(key)\n  }\n}\n\nfunction visibleTasks(tasks: any[], sectionKey: string): any[] {\n  if (expandedSections.value.has(sectionKey) || tasks.length <= MAX_VISIBLE_TASKS) return tasks\n  return tasks.slice(0, MAX_VISIBLE_TASKS)\n}\n\nconst quickEditTask = ref<{ id: string; title: string; priority?: string | null; status?: string; dueDate?: string | null; estimatedDuration?: number | null } | null>(null)\nconst quickEditPos = ref({ x: 0, y: 0 })\nconst quickEditPosition = ref<'left' | 'auto'>('left')\n\nfunction openQuickEdit(task: any, event: MouseEvent) {\n  event.stopPropagation()\n  quickEditTask.value = {\n    id: task.id,\n    title: task.title || '(untitled)',\n    priority: task.priority || null,\n    status: task.status || 'planned',\n    dueDate: task.dueDate || null,\n    estimatedDuration: task.estimatedDuration || null,\n  }\n  const panel = document.querySelector('.ai-chat-panel')\n  const isFullscreen = panel?.classList.contains('panel-fullscreen')\n  if (isFullscreen || !panel) {\n    // Fullscreen or no panel: position at click point with auto layout\n    quickEditPos.value = { x: event.clientX, y: event.clientY }\n    quickEditPosition.value = 'auto'\n  } else {\n    // Compact/expanded: position to the left of the panel\n    const panelRect = panel.getBoundingClientRect()\n    quickEditPos.value = { x: panelRect.left, y: event.clientY }\n    quickEditPosition.value = 'left'\n  }\n}\n\nfunction closeQuickEdit() {\n  quickEditTask.value = null\n}\n\nfunction openFullEditor() {\n  if (quickEditTask.value) {\n    emit('selectTask', quickEditTask.value.id)\n  }\n  closeQuickEdit()\n}\n\n// ============================================================================\n// Actions\n// ============================================================================\n\nasync function handleAction(action: ChatAction) {\n  if (loadingActions.value.has(action.id)) return\n  if (action.completed) return\n\n  loadingActions.value.add(action.id)\n\n  try {\n    await action.handler()\n    action.completed = true\n  } catch (err) {\n    console.error('[ChatMessage] Action failed:', err)\n  } finally {\n    loadingActions.value.delete(action.id)\n  }\n}\n\nfunction isActionLoading(action: ChatAction): boolean {\n  return loadingActions.value.has(action.id)\n}\n\nasync function copyMessage() {\n  try {\n    await navigator.clipboard.writeText(props.message.content || '')\n    copied.value = true\n    setTimeout(() => { copied.value = false }, 2000)\n  } catch (err) {\n    console.error('[ChatMessage] Copy failed:', err)\n  }\n}\n\nfunction toolIcon(type?: string) {\n  switch (type) {\n    case 'write': return PenLine\n    case 'destructive': return Trash2\n    default: return Zap\n  }\n}\n\nasync function markTaskDone(taskId: string, event: MouseEvent) {\n  event.stopPropagation() // Don't open popover\n  if (actionLoading.value[taskId]) return\n\n  actionLoading.value[taskId] = 'done'\n  try {\n    await executeTool({ tool: 'update_task', parameters: { taskId, updates: { status: 'done' } } })\n    completedTaskIds.value.add(taskId)\n  } catch (err) {\n    console.error('[ChatMessage] Mark done failed:', err)\n  } finally {\n    delete actionLoading.value[taskId]\n  }\n}\n\nasync function startTaskTimer(taskId: string, event: MouseEvent) {\n  event.stopPropagation() // Don't open popover\n  if (actionLoading.value[taskId]) return\n\n  actionLoading.value[taskId] = 'timer'\n  try {\n    await executeTool({ tool: 'start_timer', parameters: { taskId } })\n    timerStartedTaskIds.value.add(taskId)\n  } catch (err) {\n    console.error('[ChatMessage] Start timer failed:', err)\n  } finally {\n    delete actionLoading.value[taskId]\n  }\n}\n</script>\n\n<template>\n  <div\n    class=\"chat-message\"\n    :class=\"{\n      'message-user': isUser,\n      'message-assistant': isAssistant,\n      'message-streaming': isStreaming,\n      'message-error': hasError\n    }\"\n  >\n    <!-- Avatar -->\n    <div class=\"message-avatar\">\n      <User v-if=\"isUser\" :size=\"16\" />\n      <Sparkles v-else :size=\"16\" />\n    </div>\n\n    <!-- Content -->\n    <div class=\"message-content\">\n      <!-- Thinking Indicator -->\n      <div v-if=\"isThinking\" class=\"thinking-indicator\">\n        <span class=\"thinking-dot\" />\n        <span class=\"thinking-dot\" />\n        <span class=\"thinking-dot\" />\n      </div>\n\n      <!-- Rendered Message Text -->\n      <div\n        v-else-if=\"renderedContent\"\n        class=\"message-text markdown-body\"\n        dir=\"auto\"\n        v-html=\"renderedContent\"\n      />\n\n      <!-- Streaming cursor (when there IS content) -->\n      <span v-if=\"isStreaming && !isThinking && renderedContent\" class=\"cursor-blink\">|</span>\n\n      <!-- Tool Results -->\n      <div v-if=\"toolResults.length > 0 && !isStreaming\" class=\"tool-results\">\n        <template v-for=\"(result, idx) in toolResults\" :key=\"idx\">\n          <!-- Daily summary stats card -->\n          <div v-if=\"isDailySummaryResult(result)\" class=\"tool-result-card\">\n            <div class=\"tool-result-header tool-read\">\n              <component :is=\"toolIcon(result.type)\" :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <div class=\"summary-stats-grid\">\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.totalTasks }}</span>\n                <span class=\"summary-stat-label\">Total</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.inProgress }}</span>\n                <span class=\"summary-stat-label\">In Progress</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value summary-stat-success\">{{ result.data.completedToday }}</span>\n                <span class=\"summary-stat-label\">Done Today</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.dueToday }}</span>\n                <span class=\"summary-stat-label\">Due Today</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\" :class=\"{ 'summary-stat-danger': result.data.overdueCount > 0 }\">{{ result.data.overdueCount }}</span>\n                <span class=\"summary-stat-label\">Overdue</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.timerSessionsCompleted }}</span>\n                <span class=\"summary-stat-label\">Pomodoros</span>\n              </div>\n            </div>\n            <!-- Overdue task list if any -->\n            <div v-if=\"result.data.overdueTasks?.length > 0\" class=\"task-list\">\n              <div class=\"summary-section-label\">\n                Overdue Tasks\n                <span class=\"section-count\">({{ result.data.overdueTasks.length }})</span>\n              </div>\n              <button\n                v-for=\"task in visibleTasks(result.data.overdueTasks, 'overdue-' + result.tool)\"\n                :key=\"task.id\"\n                class=\"task-list-item\"\n                :class=\"{ 'task-completed': completedTaskIds.has(task.id) }\"\n                @click=\"openQuickEdit(task, $event)\"\n              >\n                <span\n                  class=\"task-priority-dot\"\n                  :style=\"{ background: '#ef4444' }\"\n                />\n                <span class=\"task-title\" dir=\"auto\">{{ task.title || '(untitled)' }}</span>\n                <div class=\"task-meta-row\">\n                  <span v-if=\"task.dueDate\" class=\"task-due-date\">{{ formatRelativeDate(task.dueDate) }}</span>\n                </div>\n                <div class=\"task-inline-actions\" @click.stop>\n                  <button\n                    v-if=\"!completedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-done-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'done' }\"\n                    title=\"Mark done\"\n                    @click=\"markTaskDone(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'done'\" :size=\"12\" class=\"spin\" />\n                    <CheckCircle2 v-else :size=\"12\" />\n                  </button>\n                  <button\n                    v-if=\"!timerStartedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-timer-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'timer' }\"\n                    title=\"Start timer\"\n                    @click=\"startTaskTimer(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'timer'\" :size=\"12\" class=\"spin\" />\n                    <Play v-else :size=\"12\" />\n                  </button>\n                  <span v-if=\"completedTaskIds.has(task.id)\" class=\"inline-action-done-badge\">\n                    <CheckCircle2 :size=\"12\" /> Done\n                  </span>\n                  <span v-if=\"timerStartedTaskIds.has(task.id)\" class=\"inline-action-timer-badge\">\n                    <Play :size=\"12\" /> Timer started\n                  </span>\n                </div>\n              </button>\n              <button\n                v-if=\"result.data.overdueTasks.length > MAX_VISIBLE_TASKS\"\n                class=\"show-more-btn\"\n                @click=\"toggleSection('overdue-' + result.tool)\"\n              >\n                {{ expandedSections.has('overdue-' + result.tool)\n                  ? 'Show less'\n                  : `Show all ${result.data.overdueTasks.length} overdue tasks` }}\n              </button>\n            </div>\n            <!-- Due today task list if any -->\n            <div v-if=\"result.data.dueTodayTasks?.length > 0\" class=\"task-list\">\n              <div class=\"summary-section-label\">\n                Due Today\n                <span class=\"section-count\">({{ result.data.dueTodayTasks.length }})</span>\n              </div>\n              <button\n                v-for=\"task in visibleTasks(result.data.dueTodayTasks, 'duetoday-' + result.tool)\"\n                :key=\"task.id\"\n                class=\"task-list-item\"\n                :class=\"{ 'task-completed': completedTaskIds.has(task.id) }\"\n                @click=\"openQuickEdit(task, $event)\"\n              >\n                <span\n                  class=\"task-priority-dot\"\n                  :style=\"{ background: priorityColor(task.priority) }\"\n                />\n                <span class=\"task-title\" dir=\"auto\">{{ task.title || '(untitled)' }}</span>\n                <div class=\"task-meta-row\">\n                  <span\n                    v-if=\"task.status\"\n                    class=\"task-status-badge\"\n                    :class=\"'status-' + task.status\"\n                  >{{ task.status }}</span>\n                </div>\n                <div class=\"task-inline-actions\" @click.stop>\n                  <button\n                    v-if=\"!completedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-done-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'done' }\"\n                    title=\"Mark done\"\n                    @click=\"markTaskDone(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'done'\" :size=\"12\" class=\"spin\" />\n                    <CheckCircle2 v-else :size=\"12\" />\n                  </button>\n                  <button\n                    v-if=\"!timerStartedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-timer-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'timer' }\"\n                    title=\"Start timer\"\n                    @click=\"startTaskTimer(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'timer'\" :size=\"12\" class=\"spin\" />\n                    <Play v-else :size=\"12\" />\n                  </button>\n                  <span v-if=\"completedTaskIds.has(task.id)\" class=\"inline-action-done-badge\">\n                    <CheckCircle2 :size=\"12\" /> Done\n                  </span>\n                  <span v-if=\"timerStartedTaskIds.has(task.id)\" class=\"inline-action-timer-badge\">\n                    <Play :size=\"12\" /> Timer started\n                  </span>\n                </div>\n              </button>\n              <button\n                v-if=\"result.data.dueTodayTasks.length > MAX_VISIBLE_TASKS\"\n                class=\"show-more-btn\"\n                @click=\"toggleSection('duetoday-' + result.tool)\"\n              >\n                {{ expandedSections.has('duetoday-' + result.tool)\n                  ? 'Show less'\n                  : `Show all ${result.data.dueTodayTasks.length} tasks` }}\n              </button>\n            </div>\n          </div>\n          <!-- Gamification Status Card -->\n          <div v-else-if=\"isGamificationStatusResult(result)\" class=\"tool-result-card gamification-card\">\n            <div class=\"tool-result-header tool-read\">\n              <Trophy :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <div class=\"gam-profile-row\">\n              <div class=\"gam-level-badge\">\n                <span class=\"gam-level-number\">{{ result.data.level }}</span>\n                <span class=\"gam-level-label\">LEVEL</span>\n              </div>\n              <div class=\"gam-xp-section\">\n                <div class=\"gam-xp-bar-wrapper\">\n                  <div class=\"gam-xp-bar\" :style=\"{ width: result.data.levelProgress + '%' }\" />\n                </div>\n                <div class=\"gam-xp-text\">\n                  {{ result.data.totalXp }} XP &middot; {{ result.data.xpToNextLevel }} to next\n                </div>\n              </div>\n            </div>\n            <div class=\"gam-stats-row\">\n              <div class=\"gam-stat\">\n                <Flame :size=\"14\" class=\"gam-stat-icon gam-streak-icon\" />\n                <span class=\"gam-stat-value\">{{ result.data.currentStreak }}</span>\n                <span class=\"gam-stat-label\">Streak</span>\n              </div>\n              <div class=\"gam-stat\">\n                <Shield :size=\"14\" class=\"gam-stat-icon gam-corruption-icon\" :class=\"{ 'gam-corruption-high': result.data.corruptionLevel > 60 }\" />\n                <span class=\"gam-stat-value\">{{ result.data.corruptionLevel }}%</span>\n                <span class=\"gam-stat-label\">Corruption</span>\n              </div>\n              <div class=\"gam-stat\">\n                <Trophy :size=\"14\" class=\"gam-stat-icon gam-achievement-icon\" />\n                <span class=\"gam-stat-value\">{{ result.data.achievementsEarned }}/{{ result.data.achievementsTotal }}</span>\n                <span class=\"gam-stat-label\">Achievements</span>\n              </div>\n            </div>\n            <div v-if=\"result.data.streakAtRisk\" class=\"gam-warning\">\n              Streak at risk! Complete a task today to keep your {{ result.data.currentStreak }}-day streak.\n            </div>\n          </div>\n\n          <!-- Active Challenges Card -->\n          <div v-else-if=\"isActiveChallengesResult(result)\" class=\"tool-result-card challenges-card\">\n            <div class=\"tool-result-header tool-read\">\n              <Swords :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <!-- Daily Challenges -->\n            <div v-if=\"result.data.dailies.length > 0\" class=\"challenge-section\">\n              <div class=\"summary-section-label\">\n                Daily Missions\n              </div>\n              <div\n                v-for=\"ch in result.data.dailies\"\n                :key=\"ch.id\"\n                class=\"challenge-item\"\n              >\n                <div class=\"challenge-header\">\n                  <span class=\"challenge-title\" dir=\"auto\">{{ ch.title }}</span>\n                  <span class=\"challenge-difficulty\" :class=\"'diff-' + ch.difficulty\">{{ ch.difficulty }}</span>\n                </div>\n                <div v-if=\"ch.narrativeFlavor\" class=\"challenge-flavor\" dir=\"auto\">\n                  {{ ch.narrativeFlavor }}\n                </div>\n                <div class=\"challenge-progress-row\">\n                  <div class=\"challenge-progress-bar-wrapper\">\n                    <div\n                      class=\"challenge-progress-bar\"\n                      :style=\"{ width: ch.progressPercent + '%' }\"\n                      :class=\"{ 'bar-complete': ch.progressPercent >= 100 }\"\n                    />\n                  </div>\n                  <span class=\"challenge-progress-text\">{{ ch.objectiveCurrent }}/{{ ch.objectiveTarget }}</span>\n                </div>\n                <div class=\"challenge-meta\">\n                  <span class=\"challenge-reward\">+{{ ch.rewardXp }} XP</span>\n                  <span class=\"challenge-time\">{{ formatTimeRemaining(ch.timeRemaining) }}</span>\n                </div>\n              </div>\n            </div>\n            <!-- Boss Fight -->\n            <div v-if=\"result.data.boss\" class=\"challenge-section\">\n              <div class=\"summary-section-label\">\n                Boss Fight\n              </div>\n              <div class=\"challenge-item challenge-boss\">\n                <div class=\"challenge-header\">\n                  <span class=\"challenge-title boss-title\" dir=\"auto\">{{ result.data.boss.title }}</span>\n                  <span class=\"challenge-difficulty diff-boss\">BOSS</span>\n                </div>\n                <div v-if=\"result.data.boss.narrativeFlavor\" class=\"challenge-flavor\" dir=\"auto\">\n                  {{ result.data.boss.narrativeFlavor }}\n                </div>\n                <div class=\"challenge-progress-row\">\n                  <div class=\"challenge-progress-bar-wrapper boss-bar-wrapper\">\n                    <div\n                      class=\"challenge-progress-bar boss-bar\"\n                      :style=\"{ width: result.data.boss.progressPercent + '%' }\"\n                    />\n                  </div>\n                  <span class=\"challenge-progress-text\">{{ result.data.boss.objectiveCurrent }}/{{ result.data.boss.objectiveTarget }}</span>\n                </div>\n                <div class=\"challenge-meta\">\n                  <span class=\"challenge-reward boss-reward\">+{{ result.data.boss.rewardXp }} XP</span>\n                  <span class=\"challenge-time\">{{ formatTimeRemaining(result.data.boss.timeRemaining) }}</span>\n                </div>\n              </div>\n            </div>\n            <div v-if=\"result.data.dailies.length === 0 && !result.data.boss\" class=\"gam-empty\">\n              No active challenges. New dailies generate each morning.\n            </div>\n          </div>\n\n          <!-- Achievements Near Completion Card -->\n          <div v-else-if=\"isAchievementsNearResult(result)\" class=\"tool-result-card achievements-card\">\n            <div class=\"tool-result-header tool-read\">\n              <Target :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <div v-if=\"result.data.length === 0\" class=\"gam-empty\">\n              No achievements close to completion yet. Keep going!\n            </div>\n            <div\n              v-for=\"ach in result.data\"\n              :key=\"ach.id\"\n              class=\"achievement-item\"\n            >\n              <div class=\"achievement-header\">\n                <span class=\"achievement-tier-dot\" :style=\"{ background: tierColor(ach.tier) }\" />\n                <span class=\"achievement-name\">{{ ach.name }}</span>\n                <span class=\"achievement-percent\">{{ ach.progressPercent }}%</span>\n              </div>\n              <div class=\"achievement-desc\">\n                {{ ach.description }}\n              </div>\n              <div class=\"achievement-progress-row\">\n                <div class=\"achievement-bar-wrapper\">\n                  <div\n                    class=\"achievement-bar\"\n                    :style=\"{ width: ach.progressPercent + '%', background: tierColor(ach.tier) }\"\n                  />\n                </div>\n                <span class=\"achievement-remaining\">{{ ach.remaining }} left</span>\n              </div>\n              <span class=\"achievement-reward\">+{{ ach.xpReward }} XP</span>\n            </div>\n          </div>\n\n          <!-- Productivity Stats Card -->\n          <div v-else-if=\"isProductivityStatsResult(result)\" class=\"tool-result-card\">\n            <div class=\"tool-result-header tool-read\">\n              <TrendingUp :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <div class=\"summary-stats-grid\">\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value summary-stat-success\">{{ result.data.completedToday }}</span>\n                <span class=\"summary-stat-label\">Done Today</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.totalTasks }}</span>\n                <span class=\"summary-stat-label\">Total Tasks</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\" :class=\"{ 'summary-stat-danger': result.data.overdueCount > 0 }\">{{ result.data.overdueCount }}</span>\n                <span class=\"summary-stat-label\">Overdue</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.pomodorosToday }}</span>\n                <span class=\"summary-stat-label\">Pomodoros</span>\n              </div>\n              <div v-if=\"result.data.totalFocusMinutes != null\" class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ formatMinutes(result.data.totalFocusMinutes) }}</span>\n                <span class=\"summary-stat-label\">Focus Time</span>\n              </div>\n              <div v-if=\"result.data.currentStreak != null\" class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.currentStreak }}d</span>\n                <span class=\"summary-stat-label\">Streak</span>\n              </div>\n            </div>\n          </div>\n\n          <!-- Suggest Next Task Card -->\n          <div v-else-if=\"isSuggestNextTaskResult(result)\" class=\"tool-result-card\">\n            <div class=\"tool-result-header tool-read\">\n              <TrendingUp :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <div v-if=\"result.data.length === 0\" class=\"gam-empty\">\n              No suggestions available. All tasks are done!\n            </div>\n            <div class=\"task-list\">\n              <button\n                v-for=\"(task, taskIdx) in result.data\"\n                :key=\"task.id\"\n                class=\"task-list-item suggest-item\"\n                :class=\"{ 'task-completed': completedTaskIds.has(task.id) }\"\n                @click=\"openQuickEdit(task, $event)\"\n              >\n                <span class=\"suggest-rank\">{{ Number(taskIdx) + 1 }}</span>\n                <span class=\"task-title\" dir=\"auto\">{{ task.title }}</span>\n                <div class=\"task-meta-row\">\n                  <span\n                    class=\"task-priority-dot\"\n                    :style=\"{ background: priorityColor(task.priority) }\"\n                  />\n                  <span class=\"suggest-reason\" :class=\"'reason-' + task.reason.replace(/\\s+/g, '-')\">{{ task.reason }}</span>\n                  <span v-if=\"task.dueDate\" class=\"task-due-date\">{{ formatRelativeDate(task.dueDate) }}</span>\n                </div>\n                <div class=\"task-inline-actions\" @click.stop>\n                  <button\n                    v-if=\"!completedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-done-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'done' }\"\n                    title=\"Mark done\"\n                    @click=\"markTaskDone(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'done'\" :size=\"12\" class=\"spin\" />\n                    <CheckCircle2 v-else :size=\"12\" />\n                  </button>\n                  <button\n                    v-if=\"!timerStartedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-timer-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'timer' }\"\n                    title=\"Start timer\"\n                    @click=\"startTaskTimer(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'timer'\" :size=\"12\" class=\"spin\" />\n                    <Play v-else :size=\"12\" />\n                  </button>\n                  <span v-if=\"completedTaskIds.has(task.id)\" class=\"inline-action-done-badge\">\n                    <CheckCircle2 :size=\"12\" /> Done\n                  </span>\n                  <span v-if=\"timerStartedTaskIds.has(task.id)\" class=\"inline-action-timer-badge\">\n                    <Play :size=\"12\" /> Timer started\n                  </span>\n                </div>\n              </button>\n            </div>\n          </div>\n\n          <!-- Weekly Summary Card -->\n          <div v-else-if=\"isWeeklySummaryResult(result)\" class=\"tool-result-card\">\n            <div class=\"tool-result-header tool-read\">\n              <TrendingUp :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <div class=\"summary-stats-grid\">\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value summary-stat-success\">{{ result.data.completedThisWeek }}</span>\n                <span class=\"summary-stat-label\">Done This Week</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.remainingTasks }}</span>\n                <span class=\"summary-stat-label\">Remaining</span>\n              </div>\n              <div v-if=\"result.data.level != null\" class=\"summary-stat\">\n                <span class=\"summary-stat-value\">Lv.{{ result.data.level }}</span>\n                <span class=\"summary-stat-label\">Level</span>\n              </div>\n              <div v-if=\"result.data.currentStreak != null\" class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.currentStreak }}d</span>\n                <span class=\"summary-stat-label\">Streak</span>\n              </div>\n              <div v-if=\"result.data.focusMinutes != null\" class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ formatMinutes(result.data.focusMinutes) }}</span>\n                <span class=\"summary-stat-label\">Focus Time</span>\n              </div>\n              <div v-if=\"result.data.totalXp != null\" class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.totalXp }}</span>\n                <span class=\"summary-stat-label\">Total XP</span>\n              </div>\n            </div>\n            <!-- Challenge info if available -->\n            <div v-if=\"result.data.challenges\" class=\"gam-footer-row\">\n              <span v-if=\"result.data.challenges.completedToday > 0\" class=\"gam-footer-badge gam-badge-success\">\n                {{ result.data.challenges.completedToday }} challenges done today\n              </span>\n              <span v-if=\"result.data.challenges.corruptionLevel > 0\" class=\"gam-footer-badge gam-badge-corruption\">\n                Corruption: {{ result.data.challenges.corruptionLevel }}%\n              </span>\n            </div>\n          </div>\n\n          <!-- Weekly Plan Card -->\n          <div v-else-if=\"isWeeklyPlanResult(result)\" class=\"tool-result-card weekly-plan-card\">\n            <div class=\"tool-result-header tool-read\">\n              <CalendarDays :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n            </div>\n            <div class=\"summary-stats-grid\">\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value summary-stat-success\">{{ result.data.totalScheduled }}</span>\n                <span class=\"summary-stat-label\">Scheduled</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\">{{ result.data.daysUsed }}</span>\n                <span class=\"summary-stat-label\">Days Used</span>\n              </div>\n              <div class=\"summary-stat\">\n                <span class=\"summary-stat-value\" :class=\"{ 'summary-stat-danger': result.data.unscheduled?.length > 0 }\">{{ result.data.unscheduled?.length || 0 }}</span>\n                <span class=\"summary-stat-label\">Unscheduled</span>\n              </div>\n            </div>\n            <template v-for=\"(dayKey) in ['monday','tuesday','wednesday','thursday','friday','saturday','sunday']\" :key=\"dayKey\">\n              <div v-if=\"result.data.plan[dayKey]?.length > 0\" class=\"task-list\">\n                <div class=\"summary-section-label\">\n                  {{ PLAN_DAY_LABELS[dayKey] }}\n                  <span class=\"section-count\">({{ result.data.plan[dayKey].length }})</span>\n                </div>\n                <button\n                  v-for=\"task in result.data.plan[dayKey]\"\n                  :key=\"task.id\"\n                  class=\"task-list-item\"\n                  :class=\"{ 'task-completed': completedTaskIds.has(task.id) }\"\n                  @click=\"openQuickEdit(task, $event)\"\n                >\n                  <span\n                    class=\"task-priority-dot\"\n                    :style=\"{ background: priorityColor(task.priority) }\"\n                  />\n                  <span class=\"task-title\" dir=\"auto\">{{ task.title }}</span>\n                  <div class=\"task-inline-actions\" @click.stop>\n                    <button\n                      v-if=\"!completedTaskIds.has(task.id)\"\n                      class=\"inline-action-btn inline-done-btn\"\n                      :class=\"{ loading: actionLoading[task.id] === 'done' }\"\n                      title=\"Mark done\"\n                      @click=\"markTaskDone(task.id, $event)\"\n                    >\n                      <Loader2 v-if=\"actionLoading[task.id] === 'done'\" :size=\"12\" class=\"spin\" />\n                      <CheckCircle2 v-else :size=\"12\" />\n                    </button>\n                    <button\n                      v-if=\"!timerStartedTaskIds.has(task.id)\"\n                      class=\"inline-action-btn inline-timer-btn\"\n                      :class=\"{ loading: actionLoading[task.id] === 'timer' }\"\n                      title=\"Start timer\"\n                      @click=\"startTaskTimer(task.id, $event)\"\n                    >\n                      <Loader2 v-if=\"actionLoading[task.id] === 'timer'\" :size=\"12\" class=\"spin\" />\n                      <Play v-else :size=\"12\" />\n                    </button>\n                    <span v-if=\"completedTaskIds.has(task.id)\" class=\"inline-action-done-badge\">\n                      <CheckCircle2 :size=\"12\" /> Done\n                    </span>\n                    <span v-if=\"timerStartedTaskIds.has(task.id)\" class=\"inline-action-timer-badge\">\n                      <Play :size=\"12\" /> Timer started\n                    </span>\n                  </div>\n                </button>\n              </div>\n            </template>\n            <div v-if=\"result.data.unscheduled?.length > 0\" class=\"task-list\">\n              <div class=\"summary-section-label\">\n                Unscheduled\n                <span class=\"section-count\">({{ result.data.unscheduled.length }})</span>\n              </div>\n              <button\n                v-for=\"task in result.data.unscheduled\"\n                :key=\"task.id\"\n                class=\"task-list-item task-unscheduled\"\n                @click=\"openQuickEdit(task, $event)\"\n              >\n                <span\n                  class=\"task-priority-dot\"\n                  :style=\"{ background: priorityColor(task.priority) }\"\n                />\n                <span class=\"task-title\" dir=\"auto\">{{ task.title }}</span>\n              </button>\n            </div>\n            <div v-if=\"result.data.reasoning\" class=\"plan-reasoning\">\n              {{ result.data.reasoning }}\n            </div>\n          </div>\n\n          <!-- Rich task list for read tools that return tasks -->\n          <div v-else-if=\"isTaskListResult(result)\" class=\"tool-result-card\">\n            <div class=\"tool-result-header\" :class=\"'tool-' + (result.type || 'read')\">\n              <component :is=\"toolIcon(result.type)\" :size=\"14\" class=\"tool-result-icon\" />\n              <span class=\"tool-result-title\">{{ result.message }}</span>\n              <span v-if=\"getTasksFromResult(result).length > MAX_VISIBLE_TASKS\" class=\"section-count\">({{ getTasksFromResult(result).length }})</span>\n            </div>\n            <div class=\"task-list\">\n              <button\n                v-for=\"task in visibleTasks(getTasksFromResult(result), 'tasklist-' + result.tool)\"\n                :key=\"task.id\"\n                class=\"task-list-item\"\n                :class=\"{ 'task-completed': completedTaskIds.has(task.id) }\"\n                @click=\"openQuickEdit(task, $event)\"\n              >\n                <span\n                  class=\"task-priority-dot\"\n                  :style=\"{ background: priorityColor(task.priority) }\"\n                />\n                <span class=\"task-title\" dir=\"auto\">{{ task.title || '(untitled)' }}</span>\n                <div class=\"task-meta-row\">\n                  <span v-if=\"task.daysOverdue\" class=\"task-overdue-badge\">{{ task.daysOverdue }}d overdue</span>\n                  <span\n                    v-else-if=\"task.dueDate\"\n                    class=\"task-due-date\"\n                  >{{ formatRelativeDate(task.dueDate) }}</span>\n                  <span\n                    v-if=\"task.status\"\n                    class=\"task-status-badge\"\n                    :class=\"'status-' + task.status\"\n                  >{{ task.status }}</span>\n                </div>\n                <div class=\"task-inline-actions\" @click.stop>\n                  <button\n                    v-if=\"!completedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-done-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'done' }\"\n                    title=\"Mark done\"\n                    @click=\"markTaskDone(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'done'\" :size=\"12\" class=\"spin\" />\n                    <CheckCircle2 v-else :size=\"12\" />\n                  </button>\n                  <button\n                    v-if=\"!timerStartedTaskIds.has(task.id)\"\n                    class=\"inline-action-btn inline-timer-btn\"\n                    :class=\"{ loading: actionLoading[task.id] === 'timer' }\"\n                    title=\"Start timer\"\n                    @click=\"startTaskTimer(task.id, $event)\"\n                  >\n                    <Loader2 v-if=\"actionLoading[task.id] === 'timer'\" :size=\"12\" class=\"spin\" />\n                    <Play v-else :size=\"12\" />\n                  </button>\n                  <span v-if=\"completedTaskIds.has(task.id)\" class=\"inline-action-done-badge\">\n                    <CheckCircle2 :size=\"12\" /> Done\n                  </span>\n                  <span v-if=\"timerStartedTaskIds.has(task.id)\" class=\"inline-action-timer-badge\">\n                    <Play :size=\"12\" /> Timer started\n                  </span>\n                </div>\n              </button>\n              <button\n                v-if=\"getTasksFromResult(result).length > MAX_VISIBLE_TASKS\"\n                class=\"show-more-btn\"\n                @click=\"toggleSection('tasklist-' + result.tool)\"\n              >\n                {{ expandedSections.has('tasklist-' + result.tool)\n                  ? 'Show less'\n                  : `Show all ${getTasksFromResult(result).length} tasks` }}\n              </button>\n            </div>\n          </div>\n          <!-- Simple chip for write/destructive results or results without task data -->\n          <div v-else class=\"tool-result-chip\" :class=\"'tool-' + (result.type || 'read')\">\n            <component :is=\"toolIcon(result.type)\" :size=\"12\" class=\"tool-result-icon\" />\n            <span>{{ result.message }}</span>\n          </div>\n        </template>\n      </div>\n\n      <!-- Error -->\n      <div v-if=\"hasError\" class=\"message-error-text\">\n        {{ message.error }}\n      </div>\n\n      <!-- Actions -->\n      <div v-if=\"hasActions && !isStreaming\" class=\"message-actions\">\n        <button\n          v-for=\"action in message.actions\"\n          :key=\"action.id\"\n          class=\"action-btn\"\n          :class=\"{\n            'action-primary': action.variant === 'primary',\n            'action-secondary': action.variant === 'secondary',\n            'action-danger': action.variant === 'danger',\n            'action-completed': action.completed\n          }\"\n          :disabled=\"isActionLoading(action) || action.completed\"\n          @click=\"handleAction(action)\"\n        >\n          <Loader2\n            v-if=\"isActionLoading(action)\"\n            class=\"action-icon spin\"\n            :size=\"14\"\n          />\n          <Check\n            v-else-if=\"action.completed\"\n            class=\"action-icon\"\n            :size=\"14\"\n          />\n          <span>{{ action.label }}</span>\n        </button>\n      </div>\n\n      <!-- Metadata -->\n      <div v-if=\"message.metadata && !isStreaming\" class=\"message-meta\">\n        <span v-if=\"message.metadata.model\">{{ message.metadata.model }}</span>\n        <span v-if=\"message.metadata.latencyMs\">{{ message.metadata.latencyMs }}ms</span>\n      </div>\n    </div>\n\n    <!-- Copy Button (hover overlay) -->\n    <button\n      v-if=\"!isStreaming && message.content\"\n      class=\"copy-btn\"\n      :class=\"{ 'copy-success': copied }\"\n      :title=\"copied ? 'Copied!' : 'Copy message'\"\n      @click=\"copyMessage\"\n    >\n      <CheckCheck v-if=\"copied\" :size=\"14\" />\n      <Copy v-else :size=\"14\" />\n    </button>\n\n    <!-- Task Quick-Edit Popover -->\n    <TaskQuickEditPopover\n      :is-visible=\"!!quickEditTask\"\n      :task=\"quickEditTask\"\n      :x=\"quickEditPos.x\"\n      :y=\"quickEditPos.y\"\n      :position=\"quickEditPosition\"\n      @close=\"closeQuickEdit\"\n      @open-full-editor=\"openFullEditor\"\n    />\n  </div>\n</template>\n\n<style scoped>\n/* ============================================================================\n   Message Container\n   ============================================================================ */\n\n.chat-message {\n  display: flex;\n  gap: var(--space-3);\n  padding: var(--space-3);\n  padding-inline-end: calc(var(--space-3) + 36px); /* Reserve space for copy button */\n  border-radius: var(--radius-lg);\n  animation: fadeIn 0.2s ease;\n  position: relative;\n}\n\n.chat-message:hover .copy-btn {\n  opacity: 1;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n    transform: translateY(var(--space-1));\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n/* ============================================================================\n   User Message\n   ============================================================================ */\n\n.message-user {\n  background: var(--purple-bg-subtle);\n  margin-inline-start: var(--space-4);\n}\n\n.message-user .message-avatar {\n  background: var(--color-focus);\n  color: white;\n}\n\n/* ============================================================================\n   Assistant Message\n   ============================================================================ */\n\n.message-assistant {\n  background: var(--glass-bg-weak);\n  margin-inline-end: var(--space-4);\n}\n\n.message-assistant .message-avatar {\n  background: linear-gradient(135deg, var(--color-focus), #06b6d4);\n  color: white;\n}\n\n/* ============================================================================\n   Avatar\n   ============================================================================ */\n\n.message-avatar {\n  width: 28px;\n  height: 28px;\n  border-radius: var(--radius-md);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n/* ============================================================================\n   Content\n   ============================================================================ */\n\n.message-content {\n  flex: 1;\n  min-width: 0;\n}\n\n.message-text {\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  line-height: 1.6;\n  word-break: break-word;\n}\n\n/* ============================================================================\n   Copy Button\n   ============================================================================ */\n\n.copy-btn {\n  position: absolute;\n  top: var(--space-2);\n  inset-inline-end: var(--space-2);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 28px;\n  height: 28px;\n  border: none;\n  background: var(--border-subtle);\n  color: var(--text-secondary);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity 0.15s ease, background 0.15s ease, color 0.15s ease;\n}\n\n.copy-btn:hover {\n  background: var(--border-medium);\n  color: var(--text-primary);\n}\n\n.copy-btn.copy-success {\n  opacity: 1;\n  color: var(--color-success);\n}\n\n/* ============================================================================\n   Thinking Indicator\n   ============================================================================ */\n\n.thinking-indicator {\n  display: flex;\n  gap: var(--space-1);\n  padding: var(--space-2) 0;\n}\n\n.thinking-dot {\n  width: var(--space-1_5);\n  height: var(--space-1_5);\n  border-radius: 50%;\n  background: var(--color-focus);\n  animation: thinking 1.4s ease-in-out infinite;\n}\n\n.thinking-dot:nth-child(2) {\n  animation-delay: 0.2s;\n}\n\n.thinking-dot:nth-child(3) {\n  animation-delay: 0.4s;\n}\n\n@keyframes thinking {\n  0%, 80%, 100% {\n    opacity: 0.3;\n    transform: scale(0.8);\n  }\n  40% {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n\n/* ============================================================================\n   Streaming Cursor\n   ============================================================================ */\n\n.cursor-blink {\n  animation: blink 1s step-end infinite;\n  color: var(--color-focus);\n  font-weight: bold;\n}\n\n@keyframes blink {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0; }\n}\n\n.message-streaming {\n  border: 1px solid var(--color-focus);\n  border-style: dashed;\n}\n\n/* ============================================================================\n   Markdown Styles\n   ============================================================================ */\n\n.markdown-body :deep(p) {\n  margin: 0 0 var(--space-2);\n}\n\n.markdown-body :deep(p:last-child) {\n  margin-bottom: 0;\n}\n\n.markdown-body :deep(h1),\n.markdown-body :deep(h2),\n.markdown-body :deep(h3),\n.markdown-body :deep(h4) {\n  color: var(--text-primary);\n  font-weight: var(--font-semibold);\n  margin: var(--space-3) 0 var(--space-2);\n}\n\n.markdown-body :deep(h1) { font-size: 1.25em; }\n.markdown-body :deep(h2) { font-size: 1.15em; }\n.markdown-body :deep(h3) { font-size: 1.05em; }\n.markdown-body :deep(h4) { font-size: 1em; }\n\n.markdown-body :deep(h1:first-child),\n.markdown-body :deep(h2:first-child),\n.markdown-body :deep(h3:first-child),\n.markdown-body :deep(h4:first-child) {\n  margin-top: 0;\n}\n\n.markdown-body :deep(ul),\n.markdown-body :deep(ol) {\n  padding-inline-start: var(--space-4);\n  margin: 0 0 var(--space-2);\n}\n\n.markdown-body :deep(li) {\n  margin-bottom: var(--space-1);\n}\n\n.markdown-body :deep(li:last-child) {\n  margin-bottom: 0;\n}\n\n.markdown-body :deep(code) {\n  background: var(--overlay-bg);\n  padding: 1px 5px;\n  border-radius: var(--radius-sm);\n  font-family: 'JetBrains Mono', 'Fira Code', monospace;\n  font-size: 0.9em;\n  color: var(--color-focus);\n}\n\n.markdown-body :deep(pre) {\n  background: var(--overlay-dark);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-md);\n  padding: var(--space-3);\n  margin: var(--space-2) 0;\n  overflow-x: auto;\n}\n\n.markdown-body :deep(pre code) {\n  background: transparent;\n  padding: 0;\n  color: var(--text-primary);\n  font-size: var(--text-meta);\n  line-height: 1.5;\n}\n\n.markdown-body :deep(blockquote) {\n  border-inline-start: 3px solid var(--color-focus);\n  padding-inline-start: var(--space-3);\n  margin: var(--space-2) 0;\n  color: var(--text-secondary);\n  font-style: italic;\n}\n\n.markdown-body :deep(a) {\n  color: var(--color-focus);\n  text-decoration: none;\n}\n\n.markdown-body :deep(a:hover) {\n  text-decoration: underline;\n}\n\n.markdown-body :deep(strong) {\n  color: var(--text-primary);\n  font-weight: var(--font-semibold);\n}\n\n.markdown-body :deep(em) {\n  color: var(--text-secondary);\n}\n\n.markdown-body :deep(hr) {\n  border: none;\n  border-top: 1px solid var(--border-subtle);\n  margin: var(--space-3) 0;\n}\n\n.markdown-body :deep(table) {\n  width: 100%;\n  border-collapse: collapse;\n  margin: var(--space-2) 0;\n  font-size: var(--text-meta);\n}\n\n.markdown-body :deep(th),\n.markdown-body :deep(td) {\n  border: 1px solid var(--border-subtle);\n  padding: var(--space-1) var(--space-2);\n  text-align: inherit;\n}\n\n.markdown-body :deep(th) {\n  background: var(--overlay-dark);\n  font-weight: var(--font-semibold);\n}\n\n/* ============================================================================\n   Tool Result Chips\n   ============================================================================ */\n\n.tool-results {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--space-1);\n  margin-top: var(--space-2);\n}\n\n.tool-result-chip {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-full);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n}\n\n.tool-read {\n  background: var(--blue-bg-light);\n  color: var(--status-planned-text);\n}\n\n.tool-write {\n  background: var(--success-bg-light);\n  color: var(--color-success-500);\n}\n\n.tool-destructive {\n  background: var(--danger-bg-light);\n  color: var(--color-priority-high);\n}\n\n.tool-result-icon {\n  flex-shrink: 0;\n}\n\n/* ============================================================================\n   Rich Tool Result Cards (task lists)\n   ============================================================================ */\n\n.tool-result-card {\n  width: 100%;\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n  overflow: visible;\n  margin-top: var(--space-2);\n}\n\n.tool-result-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n}\n\n.tool-result-header.tool-read {\n  background: var(--blue-bg-subtle);\n  color: var(--status-planned-text);\n}\n\n.tool-result-header.tool-write {\n  background: var(--success-bg-light);\n  color: var(--color-success-500);\n}\n\n.tool-result-header.tool-destructive {\n  background: var(--danger-bg-light);\n  color: var(--color-priority-high);\n}\n\n.tool-result-title {\n  flex: 1;\n  min-width: 0;\n}\n\n.task-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n}\n\n.task-list-item {\n  display: grid;\n  grid-template-columns: auto 1fr auto;\n  grid-template-rows: auto auto;\n  gap: var(--space-0_5) var(--space-2);\n  align-items: center;\n  padding: var(--space-2_5) var(--space-3);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  background: rgba(255, 255, 255, 0.04);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  text-align: start;\n  cursor: pointer;\n  transition: all 0.12s ease;\n  width: 100%;\n  position: relative;\n}\n\n.task-list-item:hover {\n  background: var(--glass-bg-light);\n  border-color: var(--glass-border);\n}\n\n.task-priority-dot {\n  grid-row: 1;\n  grid-column: 1;\n  width: var(--space-2_5);\n  height: var(--space-2_5);\n  border-radius: 50%;\n  flex-shrink: 0;\n  margin-top: var(--space-1);\n  cursor: pointer;\n  /* Bigger click target via padding + negative margin */\n  padding: var(--space-1);\n  background-clip: content-box;\n}\n\n.task-meta-row {\n  grid-row: 2;\n  grid-column: 2 / -1;\n  display: flex;\n  gap: var(--space-1);\n  flex-wrap: wrap;\n  align-items: center;\n}\n\n.task-title {\n  grid-row: 1;\n  grid-column: 2;\n  min-width: 0;\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  word-break: break-word;\n  text-align: start;\n  unicode-bidi: plaintext;\n  font-weight: var(--font-medium);\n  line-height: 1.4;\n}\n\n.task-overdue-badge {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  color: var(--color-priority-high);\n  background: var(--danger-bg-light);\n  padding: 1px var(--space-1_5);\n  border-radius: var(--radius-full);\n  flex-shrink: 0;\n  cursor: pointer;\n}\n\n.task-due-date {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  flex-shrink: 0;\n}\n\n.task-status-badge {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  padding: 1px 5px;\n  border-radius: var(--radius-sm);\n  flex-shrink: 0;\n  text-transform: uppercase;\n  letter-spacing: 0.03em;\n}\n\n.status-planned { background: var(--purple-bg-subtle); color: var(--status-planned-text); }\n.status-in_progress { background: var(--blue-bg-light); color: var(--status-in-progress-text); }\n.status-done { background: var(--success-bg-light); color: var(--status-done-text); }\n.status-backlog { background: var(--glass-bg-light); color: var(--text-muted); }\n\n/* ============================================================================\n   Daily Summary Stats Grid\n   ============================================================================ */\n\n.summary-stats-grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 1px;\n  background: var(--glass-border-faint);\n}\n\n.summary-stat {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-0_5);\n  padding: var(--space-2) var(--space-1);\n  background: var(--overlay-component-bg);\n}\n\n.summary-stat-value {\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n  line-height: 1;\n}\n\n.summary-stat-label {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  color: var(--text-tertiary);\n  text-transform: uppercase;\n  letter-spacing: 0.04em;\n}\n\n.summary-stat-success {\n  color: var(--color-success-500);\n}\n\n.summary-stat-danger {\n  color: var(--color-priority-high);\n}\n\n.summary-section-label {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n  padding: var(--space-2) var(--space-3) var(--space-1);\n  text-transform: uppercase;\n  letter-spacing: 0.04em;\n  border-top: 1px solid var(--glass-border-faint);\n}\n\n.section-count {\n  font-weight: var(--font-medium);\n  color: var(--text-muted);\n  text-transform: none;\n  letter-spacing: normal;\n}\n\n.show-more-btn {\n  display: block;\n  width: 100%;\n  padding: var(--space-2) var(--space-3);\n  border: none;\n  background: transparent;\n  color: var(--accent-primary, #8b5cf6);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  text-align: center;\n  border-top: 1px solid var(--glass-border-faint);\n  transition: background var(--duration-fast) ease;\n}\n\n.show-more-btn:hover {\n  background: var(--purple-bg-subtle);\n}\n\n/* ============================================================================\n   Error\n   ============================================================================ */\n\n.message-error {\n  border: 1px solid var(--color-danger);\n}\n\n.message-error-text {\n  color: var(--color-danger);\n  font-size: var(--text-xs);\n  margin-top: var(--space-2);\n}\n\n/* ============================================================================\n   Actions\n   ============================================================================ */\n\n.message-actions {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--space-2);\n  margin-top: var(--space-3);\n}\n\n.action-btn {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-3);\n  border-radius: var(--radius-md);\n  font-size: var(--text-meta);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all 0.15s ease;\n  border: 1px solid transparent;\n}\n\n.action-primary {\n  background: var(--color-focus);\n  color: white;\n}\n\n.action-primary:hover:not(:disabled) {\n  background: var(--brand-hover);\n}\n\n.action-secondary {\n  background: transparent;\n  border-color: var(--border-medium);\n  color: var(--text-primary);\n}\n\n.action-secondary:hover:not(:disabled) {\n  background: var(--border-subtle);\n}\n\n.action-danger {\n  background: transparent;\n  border-color: var(--color-danger);\n  color: var(--color-danger);\n}\n\n.action-danger:hover:not(:disabled) {\n  background: var(--danger-bg-light);\n}\n\n.action-completed {\n  background: var(--success-bg-light);\n  border-color: var(--color-success);\n  color: var(--color-success);\n}\n\n.action-btn:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.action-icon {\n  flex-shrink: 0;\n}\n\n/* ============================================================================\n   Metadata\n   ============================================================================ */\n\n.message-meta {\n  display: flex;\n  gap: var(--space-2);\n  margin-top: var(--space-2);\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n}\n\n/* ============================================================================\n   Animations\n   ============================================================================ */\n\n.spin {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n/* ============================================================================\n   Gamification Status Card\n   ============================================================================ */\n\n.gam-profile-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3);\n}\n\n.gam-level-badge {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  width: 52px;\n  height: 52px;\n  border-radius: 50%;\n  background: linear-gradient(135deg, var(--color-focus), #06b6d4);\n  flex-shrink: 0;\n}\n\n.gam-level-number {\n  font-size: var(--text-xl);\n  font-weight: 800;\n  color: white;\n  line-height: 1;\n}\n\n.gam-level-label {\n  font-size: 8px;\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n}\n\n.gam-xp-section {\n  flex: 1;\n  min-width: 0;\n}\n\n.gam-xp-bar-wrapper {\n  height: var(--space-2);\n  background: var(--border-subtle);\n  border-radius: var(--radius-full);\n  overflow: hidden;\n}\n\n.gam-xp-bar {\n  height: 100%;\n  background: linear-gradient(90deg, var(--color-focus), #06b6d4);\n  border-radius: var(--radius-full);\n  transition: width 0.3s ease;\n}\n\n.gam-xp-text {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  margin-top: var(--space-1);\n}\n\n.gam-stats-row {\n  display: flex;\n  border-top: 1px solid var(--glass-border-faint);\n}\n\n.gam-stat {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-0_5);\n  padding: var(--space-2) var(--space-1);\n}\n\n.gam-stat-icon {\n  color: var(--text-secondary);\n}\n\n.gam-streak-icon {\n  color: var(--color-priority-medium);\n}\n\n.gam-corruption-icon {\n  color: #06b6d4;\n}\n\n.gam-corruption-icon.gam-corruption-high {\n  color: var(--color-priority-high);\n}\n\n.gam-achievement-icon {\n  color: rgb(var(--tier-gold));\n}\n\n.gam-stat-value {\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.gam-stat-label {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  text-transform: uppercase;\n  letter-spacing: 0.04em;\n}\n\n.gam-warning {\n  padding: var(--space-2) var(--space-3);\n  font-size: var(--text-xs);\n  color: var(--color-priority-medium);\n  background: var(--orange-bg-light);\n  border-top: 1px solid var(--orange-bg-medium);\n}\n\n.gam-empty {\n  padding: var(--space-3);\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  text-align: center;\n  font-style: italic;\n}\n\n/* ============================================================================\n   Challenges Card\n   ============================================================================ */\n\n.challenge-section {\n  /* Sections container */\n}\n\n.challenge-item {\n  padding: var(--space-2) var(--space-3);\n  border-top: 1px solid var(--glass-border-faint);\n}\n\n.challenge-item.challenge-boss {\n  background: var(--danger-bg-subtle);\n}\n\n.challenge-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--space-2);\n}\n\n.challenge-title {\n  font-size: var(--text-meta);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  flex: 1;\n  min-width: 0;\n}\n\n.boss-title {\n  color: var(--color-priority-high);\n}\n\n.challenge-difficulty {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  padding: 1px var(--space-1_5);\n  border-radius: var(--radius-sm);\n  text-transform: uppercase;\n  letter-spacing: 0.04em;\n  flex-shrink: 0;\n}\n\n.diff-easy { background: var(--success-bg-light); color: var(--status-done-text); }\n.diff-normal { background: var(--blue-bg-light); color: var(--status-planned-text); }\n.diff-hard { background: var(--orange-bg-light); color: var(--color-priority-medium); }\n.diff-boss { background: var(--danger-bg-light); color: var(--color-priority-high); }\n\n.challenge-flavor {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  font-style: italic;\n  margin-top: var(--space-0_5);\n}\n\n.challenge-progress-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  margin-top: var(--space-1);\n}\n\n.challenge-progress-bar-wrapper {\n  flex: 1;\n  height: var(--space-1_5);\n  background: var(--border-subtle);\n  border-radius: var(--radius-full);\n  overflow: hidden;\n}\n\n.challenge-progress-bar {\n  height: 100%;\n  background: var(--color-focus);\n  border-radius: var(--radius-full);\n  transition: width 0.3s ease;\n}\n\n.challenge-progress-bar.bar-complete {\n  background: var(--status-done-text);\n}\n\n.boss-bar-wrapper {\n  height: var(--space-2);\n}\n\n.boss-bar {\n  background: linear-gradient(90deg, var(--color-priority-high), var(--color-priority-medium));\n}\n\n.challenge-progress-text {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n  white-space: nowrap;\n}\n\n.challenge-meta {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-top: var(--space-1);\n}\n\n.challenge-reward {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--color-focus);\n}\n\n.boss-reward {\n  color: var(--color-priority-high);\n}\n\n.challenge-time {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n}\n\n/* ============================================================================\n   Achievements Near Completion Card\n   ============================================================================ */\n\n.achievement-item {\n  padding: var(--space-2) var(--space-3);\n  border-top: 1px solid var(--glass-border-faint);\n}\n\n.achievement-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.achievement-tier-dot {\n  width: var(--space-2);\n  height: var(--space-2);\n  border-radius: 50%;\n  flex-shrink: 0;\n}\n\n.achievement-name {\n  font-size: var(--text-meta);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  flex: 1;\n}\n\n.achievement-percent {\n  font-size: var(--text-xs);\n  font-weight: var(--font-bold);\n  color: var(--color-focus);\n}\n\n.achievement-desc {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  margin-top: var(--space-0_5);\n}\n\n.achievement-progress-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  margin-top: var(--space-1);\n}\n\n.achievement-bar-wrapper {\n  flex: 1;\n  height: var(--space-1);\n  background: var(--border-subtle);\n  border-radius: var(--radius-full);\n  overflow: hidden;\n}\n\n.achievement-bar {\n  height: 100%;\n  border-radius: var(--radius-full);\n  transition: width 0.3s ease;\n}\n\n.achievement-remaining {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  white-space: nowrap;\n}\n\n.achievement-reward {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--color-focus);\n}\n\n/* ============================================================================\n   Suggest Next Task Card\n   ============================================================================ */\n\n.suggest-item {\n  grid-template-columns: auto auto 1fr;\n}\n\n.suggest-rank {\n  grid-row: 1;\n  grid-column: 1;\n  width: var(--space-5);\n  height: var(--space-5);\n  border-radius: 50%;\n  background: var(--color-focus);\n  color: white;\n  font-size: var(--text-xs);\n  font-weight: var(--font-bold);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n.suggest-item .task-title {\n  grid-row: 1;\n  grid-column: 2 / -1;\n}\n\n.suggest-item .task-meta-row {\n  grid-row: 2;\n  grid-column: 2 / -1;\n}\n\n.suggest-reason {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  padding: 1px var(--space-1_5);\n  border-radius: var(--radius-full);\n}\n\n.reason-overdue { background: var(--danger-bg-light); color: var(--color-priority-high); }\n.reason-due-today { background: var(--orange-bg-light); color: var(--color-priority-medium); }\n.reason-high-priority { background: var(--purple-bg-subtle); color: var(--status-planned-text); }\n.reason-next-up { background: var(--blue-bg-light); color: var(--status-planned-text); }\n\n/* ============================================================================\n   Weekly Summary Footer\n   ============================================================================ */\n\n.gam-footer-row {\n  display: flex;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  border-top: 1px solid var(--glass-border-faint);\n  flex-wrap: wrap;\n}\n\n.gam-footer-badge {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-full);\n}\n\n.gam-badge-success {\n  background: var(--success-bg-light);\n  color: var(--status-done-text);\n}\n\n.gam-badge-corruption {\n  background: var(--danger-bg-light);\n  color: var(--color-priority-high);\n}\n\n/* ============================================================================\n   Inline Task Actions (hover)\n   ============================================================================ */\n\n.task-inline-actions {\n  grid-row: 1;\n  grid-column: 3;\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  opacity: 0.7;\n  transition: opacity 0.15s ease;\n}\n\n.task-list-item:hover .task-inline-actions {\n  opacity: 1;\n}\n\n.inline-action-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 28px;\n  height: 28px;\n  border: 1px solid var(--glass-border-faint);\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  transition: all 0.15s ease;\n  flex-shrink: 0;\n}\n\n.inline-done-btn {\n  background: var(--success-bg-light);\n  color: var(--color-success);\n}\n\n.inline-done-btn:hover {\n  background: var(--color-success);\n  color: white;\n}\n\n.inline-timer-btn {\n  background: var(--blue-bg-light);\n  color: var(--status-in-progress-text);\n}\n\n.inline-timer-btn:hover {\n  background: var(--status-in-progress-text);\n  color: white;\n}\n\n.inline-action-btn.loading {\n  opacity: 0.6;\n  pointer-events: none;\n}\n\n.inline-action-done-badge,\n.inline-action-timer-badge {\n  display: flex;\n  align-items: center;\n  gap: var(--space-0_5);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  padding: 2px var(--space-1_5);\n  border-radius: var(--radius-sm);\n}\n\n.inline-action-done-badge {\n  background: var(--success-bg-light);\n  color: var(--color-success);\n}\n\n.inline-action-timer-badge {\n  background: var(--blue-bg-light);\n  color: var(--status-in-progress-text);\n}\n\n.task-list-item.task-completed .task-title {\n  text-decoration: line-through;\n  opacity: 0.6;\n}\n\n/* ============================================================================\n   Weekly Plan Card\n   ============================================================================ */\n\n.weekly-plan-card .task-list-item {\n  grid-template-columns: auto 1fr auto;\n  grid-template-rows: auto;\n}\n\n.task-unscheduled {\n  opacity: 0.6;\n}\n\n.plan-reasoning {\n  padding: var(--space-2) var(--space-3);\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  font-style: italic;\n  border-top: 1px solid var(--glass-border-faint);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ai/TaskQuickEditPopover.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ai/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/auth/AuthModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/auth/GoogleSignInButton.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/auth/LoginForm.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/auth/ResetPasswordView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/auth/SignupForm.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/auth/UserProfile.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseBadge.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseButton.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseCard.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseDropdown.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseIconButton.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseInput.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BaseNavItem.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/BasePopover.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/FilterControls.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/OverflowTooltip.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/base/ProjectEmojiIcon.vue","messages":[{"ruleId":"vue/no-v-html","severity":1,"message":"'v-html' directive can lead to XSS attack.","line":21,"column":7,"nodeType":"VAttribute","messageId":"unexpected","endLine":21,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    class=\"project-emoji-icon\"\n    :class=\"{\n      'project-emoji-icon--native': shouldUseNative,\n      'project-emoji-icon--svg': hasSvg || hasColorfulSvg,\n      'project-emoji-icon--clickable': clickable,\n      'project-emoji-icon--default': variant === 'default',\n      'project-emoji-icon--plain': variant === 'plain'\n    }\"\n    :style=\"customStyles\"\n    :title=\"_computedTitle\"\n    :aria-label=\"_computedTitle\"\n    role=\"img\"\n    @click=\"$emit('click', $event)\"\n  >\n    <!-- Colorful SVG (Premium Gradients) -->\n    <div\n      v-if=\"hasColorfulSvg\"\n      class=\"project-emoji-icon__colorful\"\n      v-html=\"colorfulSvg\"\n    />\n\n    <!-- Regular SVG (Crisp Vector) -->\n    <svg\n      v-else-if=\"hasSvg\"\n      class=\"project-emoji-icon__svg\"\n      :viewBox=\"svgData?.viewBox\"\n      aria-hidden=\"true\"\n    >\n      <path :d=\"svgData?.path\" :fill=\"svgData?.fill || 'currentColor'\" />\n    </svg>\n\n    <!-- Native emoji fallback -->\n    <span\n      v-else\n      class=\"project-emoji-icon__native\"\n      :style=\"nativeStyles\"\n      aria-hidden=\"true\"\n    >\n      {{ emoji }}\n    </span>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { getEmojiSvgData, getColorfulSvgData, hasSvgRepresentation, hasColorfulSvgRepresentation } from '@/utils/emojiSvgMap'\n\ninterface Props {\n  emoji: string\n  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl'\n  color?: string\n  clickable?: boolean\n  title?: string\n  variant?: 'default' | 'plain' // 'default' has background/border, 'plain' is just the emoji\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  size: 'sm',\n  color: undefined,\n  clickable: false,\n  title: '',\n  variant: 'plain' // Default to plain (no background/border) to avoid gray dots\n})\n\ndefineEmits<{\n  click: [event: MouseEvent]\n}>()\n\n// SVG Detection\nconst hasSvg = computed(() => hasSvgRepresentation(props.emoji))\nconst hasColorfulSvg = computed(() => hasColorfulSvgRepresentation(props.emoji))\nconst svgData = computed(() => getEmojiSvgData(props.emoji))\nconst colorfulSvg = computed(() => getColorfulSvgData(props.emoji))\n\n// Only use native if no SVG is found\nconst shouldUseNative = computed(() => !hasSvg.value && !hasColorfulSvg.value)\n\n// Size calculations\nconst sizeMap = {\n  xs: 16,\n  sm: 20,\n  md: 24,\n  lg: 32,\n  xl: 48\n}\n\nconst containerSize = computed(() => sizeMap[props.size])\n\n// Dynamic styles\nconst customStyles = computed(() => ({\n  width: `${containerSize.value}px`,\n  height: `${containerSize.value}px`\n}))\n\nconst nativeStyles = computed(() => ({\n  fontSize: `${Math.max(12, Math.floor(containerSize.value * 0.65))}px`,\n  lineHeight: '1'\n}))\n\n// Computed title if not provided\nconst _computedTitle = computed(() => {\n  if (props.title) return props.title\n  return `Project emoji: ${props.emoji}`\n})\n</script>\n\n<style scoped>\n.project-emoji-icon {\n  /* Container with inline-flex for consistent alignment with other inline elements */\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  vertical-align: middle;\n  transition: all var(--duration-fast) var(--spring-smooth);\n  position: relative;\n  overflow: hidden;\n  /* Hardware acceleration for smooth animations */\n  transform: translateZ(0);\n  will-change: transform;\n}\n\n/* Default variant with background and border */\n.project-emoji-icon--default {\n  border-radius: var(--radius-full);\n  background: var(--glass-bg-subtle);\n  backdrop-filter: blur(8px);\n  -webkit-backdrop-filter: blur(8px);\n  border: 1px solid var(--glass-border);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n/* Plain variant - just the emoji, no background or border */\n.project-emoji-icon--plain {\n  /* No background, border, or borderRadius - just the emoji */\n}\n\n.project-emoji-icon--clickable {\n  cursor: pointer;\n}\n\n.project-emoji-icon--default.project-emoji-icon--clickable:hover {\n  transform: scale(1.05);\n  border-color: var(--border-medium);\n  background-color: var(--surface-hover);\n  box-shadow: var(--shadow-sm);\n}\n\n.project-emoji-icon--plain.project-emoji-icon--clickable:hover {\n  transform: scale(1.1);\n  /* No background changes for plain variant */\n}\n\n/* Native emoji styles - optimized for Noto Color Emoji */\n.project-emoji-icon__native {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  /* Enhanced emoji rendering */\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  image-rendering: -webkit-optimize-contrast;\n  image-rendering: crisp-edges;\n  /* Prevent baseline issues */\n  line-height: 1;\n  vertical-align: middle;\n  /* Prioritize Noto Color Emoji for consistency */\n  font-family: \"Noto Color Emoji\", \"Apple Color Emoji\", \"Segoe UI Emoji\", \"EmojiSymbols\", system-ui, sans-serif;\n  /* Ensure consistent sizing */\n  width: 1em;\n  height: 1em;\n  /* Force colorful emoji rendering */\n  font-style: normal;\n  font-weight: normal;\n  /* Ensure proper emoji display */\n  -webkit-text-stroke-width: 0;\n  -webkit-text-stroke-color: transparent;\n}\n\n/* SVG Emoji Styles */\n.project-emoji-icon__svg {\n  width: 75%;\n  height: 75%;\n  display: block;\n}\n\n.project-emoji-icon__colorful {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n/* Ensure raw SVG inside colorful container respects container size */\n.project-emoji-icon__colorful :deep(svg) {\n  width: 85%;\n  height: 85%;\n  display: block;\n}\n\n/* Theme integration - only for default variant */\n.project-emoji-icon--default:hover {\n  background-color: var(--surface-elevated);\n  border-color: var(--brand-border-subtle);\n}\n\n/* Size variants */\n.project-emoji-icon[data-size=\"xs\"] {\n  /* 16px container - minimal */\n}\n\n.project-emoji-icon[data-size=\"sm\"] {\n  /* 20px container - standard */\n}\n\n.project-emoji-icon[data-size=\"md\"] {\n  /* 24px container - larger */\n}\n\n.project-emoji-icon[data-size=\"lg\"] {\n  /* 32px container - prominent */\n}\n\n/* Reduced motion support */\n@media (prefers-reduced-motion: reduce) {\n  .project-emoji-icon {\n    transition: none;\n  }\n}\n\n/* Focus styles for accessibility */\n.project-emoji-icon--clickable:focus-visible {\n  outline: 2px solid var(--color-primary);\n  outline-offset: 2px;\n}\n</style>","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/calendar/CalendarDayView.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2608,2611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2608,2611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { inject, computed } from 'vue'\nimport { Play } from 'lucide-vue-next'\nimport ProjectEmojiIcon from '@/components/base/ProjectEmojiIcon.vue'\nimport type { CalendarEvent, DragGhost } from '@/types/tasks'\nimport type { TimeSlot } from '@/composables/calendar/useCalendarDayView'\nimport type { ExternalCalendarEvent } from '@/composables/calendar/useExternalCalendar'\n\nconst props = defineProps<{\n  timeSlots: TimeSlot[]\n  hours: number[]\n  isViewingToday: boolean\n  timeIndicatorPosition: number\n  dragGhost: DragGhost\n  activeDropSlot: number | null\n  currentTaskId?: string | null\n  isDragging: boolean\n  draggedEventId: string | null\n  hoveredEventId: string | null\n  resizePreview?: {\n    isResizing: boolean\n    taskId: string | null\n    previewDuration: number\n    direction: 'top' | 'bottom'\n  } | null\n  externalEvents?: ExternalCalendarEvent[]\n}>()\n\ndefineEmits<{\n  (e: 'dragover', event: DragEvent, slot: TimeSlot): void\n  (e: 'dragenter', event: DragEvent, slot: TimeSlot): void\n  (e: 'dragleave'): void\n  (e: 'drop', event: DragEvent, slot: TimeSlot): void\n  (e: 'slotMouseDown', event: MouseEvent, slot: TimeSlot): void\n  (e: 'eventMouseEnter', eventId: string): void\n  (e: 'eventMouseLeave'): void\n  (e: 'eventDragStart', event: DragEvent, calEvent: CalendarEvent): void\n  (e: 'eventDragEnd', event: DragEvent, calEvent: CalendarEvent): void\n  (e: 'eventClick', event: MouseEvent, calEvent: CalendarEvent): void\n  (e: 'eventDblClick', calEvent: CalendarEvent): void\n  (e: 'eventContextMenu', event: MouseEvent, calEvent: CalendarEvent): void\n  (e: 'cycleStatus', event: MouseEvent, calEvent: CalendarEvent): void\n  (e: 'removeFromCalendar', calEvent: CalendarEvent): void\n  (e: 'startTimer', calEvent: CalendarEvent): void\n  (e: 'startResize', event: MouseEvent, calEvent: CalendarEvent, direction: 'top' | 'bottom'): void\n}>()\n// Compute positioned external events for time grid\nconst positionedExternalEvents = computed(() => {\n  if (!props.externalEvents?.length) return []\n  return props.externalEvents\n    .filter(e => !e.isAllDay)\n    .map(e => {\n      const startMinutes = e.startTime.getHours() * 60 + e.startTime.getMinutes()\n      const durationMinutes = Math.max(15, (e.endTime.getTime() - e.startTime.getTime()) / 60000)\n      return {\n        ...e,\n        top: startMinutes,\n        height: durationMinutes,\n        formattedTime: `${e.startTime.getHours().toString().padStart(2, '0')}:${e.startTime.getMinutes().toString().padStart(2, '0')}`\n      }\n    })\n})\n// Inject helpers from parent CalendarView\nconst helpers = inject('calendar-helpers') as any\nconst {\n  formatHour,\n  formatEventTime,\n  isCurrentTimeSlot,\n  getTasksForSlot,\n  isTaskPrimarySlot,\n  getSlotTaskStyle,\n  getProjectVisual,\n  getProjectName,\n  getProjectColor,\n  getPriorityClass,\n  getPriorityLabel,\n  getTaskStatus,\n  getStatusLabel,\n  getStatusIcon\n} = helpers\n\n</script>\n\n<template>\n  <div class=\"calendar-grid\">\n    <!-- Time Labels Column -->\n    <div class=\"time-labels\">\n      <div\n        v-for=\"hour in hours\"\n        :key=\"hour\"\n        class=\"time-label\"\n      >\n        {{ formatHour(hour) }}\n      </div>\n    </div>\n\n    <!-- Slots Container -->\n    <div class=\"slots-container\">\n      <!-- Current Time Indicator -->\n      <div\n        v-if=\"isViewingToday\"\n        class=\"current-time-indicator\"\n        :style=\"{ top: `${timeIndicatorPosition}px` }\"\n      >\n        <div class=\"time-indicator-dot\" />\n        <div class=\"time-indicator-line\" />\n      </div>\n\n      <!-- Ghost Preview (during inbox drag) -->\n      <div\n        v-if=\"dragGhost.visible\"\n        class=\"ghost-preview-inline\"\n        :style=\"{\n          position: 'absolute',\n          top: `${dragGhost.slotIndex * 30}px`,\n          height: `${Math.ceil(dragGhost.duration / 30) * 30}px`,\n          width: 'calc(100% - 8px)',\n          left: '4px',\n          zIndex: 40\n        }\"\n      >\n        <div class=\"ghost-content\">\n          <span class=\"ghost-title\">{{ dragGhost.title }}</span>\n          <span class=\"ghost-duration\">{{ dragGhost.duration }}min</span>\n        </div>\n      </div>\n\n      <!-- Time Slots -->\n      <div\n        v-for=\"slot in timeSlots\"\n        :key=\"slot.id\"\n        class=\"time-slot\"\n        :data-slot-index=\"slot.slotIndex\"\n        :class=\"{\n          'drag-over': activeDropSlot === slot.slotIndex,\n          'current-time': isCurrentTimeSlot(slot)\n        }\"\n        @dragover.prevent=\"$emit('dragover', $event, slot)\"\n        @dragenter.prevent=\"$emit('dragenter', $event, slot)\"\n        @dragleave=\"$emit('dragleave')\"\n        @drop.prevent=\"$emit('drop', $event, slot)\"\n        @mousedown=\"$emit('slotMouseDown', $event, slot)\"\n      >\n        <!-- Tasks rendered INSIDE the slot with entrance animation -->\n        <TransitionGroup name=\"task-appear\">\n          <div\n            v-for=\"calEvent in getTasksForSlot(slot)\"\n            v-show=\"isTaskPrimarySlot(slot, calEvent)\"\n            :key=\"`${calEvent.id}-${slot.slotIndex}`\"\n            class=\"slot-task is-primary\"\n            :class=\"{\n              'timer-active-event': currentTaskId === calEvent.taskId,\n              'dragging': isDragging && draggedEventId === calEvent.id,\n              'is-hovered': hoveredEventId === calEvent.id,\n              'has-overlap': calEvent.totalColumns > 1,\n              'is-compact': calEvent.duration <= 30,\n              'status-done': getTaskStatus(calEvent) === 'done'\n            }\"\n            :style=\"getSlotTaskStyle(calEvent)\"\n            draggable=\"true\"\n            @mouseenter=\"$emit('eventMouseEnter', calEvent.id)\"\n            @mouseleave=\"$emit('eventMouseLeave')\"\n            @dragstart=\"$emit('eventDragStart', $event, calEvent)\"\n            @dragend=\"$emit('eventDragEnd', $event, calEvent)\"\n            @click=\"$emit('eventClick', $event, calEvent)\"\n            @dblclick=\"$emit('eventDblClick', calEvent)\"\n            @contextmenu.prevent=\"$emit('eventContextMenu', $event, calEvent)\"\n          >\n            <!-- Project Stripe -->\n            <div\n              v-if=\"getProjectVisual(calEvent).type === 'emoji'\"\n              class=\"project-stripe project-emoji-stripe\"\n              :title=\"`Project: ${getProjectName(calEvent)}`\"\n            >\n              <ProjectEmojiIcon\n                :emoji=\"getProjectVisual(calEvent).content\"\n                size=\"xs\"\n                class=\"project-emoji\"\n              />\n            </div>\n            <div\n              v-else\n              class=\"project-stripe project-color-stripe\"\n              :style=\"{ backgroundColor: getProjectColor(calEvent) }\"\n              :title=\"`Project: ${getProjectName(calEvent)}`\"\n            />\n\n            <!-- Priority Stripe -->\n            <div\n              class=\"priority-stripe\"\n              :class=\"`priority-${getPriorityClass(calEvent)}`\"\n              :title=\"`Priority: ${getPriorityLabel(calEvent)}`\"\n            />\n\n            <!-- Task Content - dir=\"auto\" detects RTL/LTR from content -->\n            <div class=\"task-content--calendar\" dir=\"auto\">\n              <div class=\"task-header\">\n                <div class=\"task-title\" dir=\"auto\" :title=\"calEvent.title\">\n                  {{ calEvent.title }}\n                </div>\n                <div class=\"task-actions\">\n                  <button\n                    class=\"play-timer-btn\"\n                    title=\"Start timer for this task\"\n                    @click.stop=\"$emit('startTimer', calEvent)\"\n                  >\n                    <Play :size=\"12\" />\n                  </button>\n                  <div\n                    class=\"status-indicator\"\n                    :class=\"`status-${getTaskStatus(calEvent)}`\"\n                    :title=\"`Status: ${getStatusLabel(calEvent)} (click to change)`\"\n                    @click.stop=\"$emit('cycleStatus', $event, calEvent)\"\n                  >\n                    {{ getStatusIcon(getTaskStatus(calEvent)) }}\n                  </div>\n                  <button\n                    class=\"remove-from-calendar-btn\"\n                    title=\"Remove from calendar (move to inbox)\"\n                    @click.stop=\"$emit('removeFromCalendar', calEvent)\"\n                  >\n                    ✕\n                  </button>\n                </div>\n              </div>\n              <div class=\"task-meta\">\n                <span v-if=\"formatEventTime(calEvent)\" class=\"task-time\">{{ formatEventTime(calEvent) }}</span>\n                <span class=\"task-duration\">{{ calEvent.duration }}min</span>\n              </div>\n            </div>\n\n            <!-- Resize Handles -->\n            <div\n              class=\"resize-handle resize-top\"\n              title=\"Drag to change start time\"\n              @mousedown.stop=\"$emit('startResize', $event, calEvent, 'top')\"\n            />\n            <div\n              class=\"resize-handle resize-bottom\"\n              title=\"Drag to change duration\"\n              @mousedown.stop=\"$emit('startResize', $event, calEvent, 'bottom')\"\n            />\n\n            <!-- Resize Preview -->\n            <div\n              v-if=\"resizePreview?.isResizing && resizePreview.taskId === calEvent.taskId\"\n              class=\"resize-preview-overlay\"\n              :style=\"{\n                height: `${Math.ceil(resizePreview.previewDuration / 30) * 30}px`,\n                top: resizePreview.direction === 'top' ? 'auto' : '0',\n                bottom: resizePreview.direction === 'top' ? '0' : 'auto'\n              }\"\n            >\n              <span class=\"preview-duration\">{{ resizePreview.previewDuration }}min</span>\n            </div>\n          </div>\n        </TransitionGroup>\n      </div>\n\n      <!-- TASK-1317: External calendar events (read-only overlays) -->\n      <div\n        v-for=\"ext in positionedExternalEvents\"\n        :key=\"`ext-${ext.id}`\"\n        class=\"external-event\"\n        :style=\"{\n          top: `${ext.top}px`,\n          height: `${ext.height}px`,\n          backgroundColor: ext.color + '25',\n          borderColor: ext.color\n        }\"\n        :title=\"`${ext.title}${ext.location ? '\\n📍 ' + ext.location : ''}`\"\n      >\n        <span class=\"external-event-time\">{{ ext.formattedTime }}</span>\n        <span class=\"external-event-title\" dir=\"auto\">{{ ext.title }}</span>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.calendar-grid {\n  flex: 1;\n  display: grid;\n  grid-template-columns: 80px 1fr;\n  overflow: visible;\n  min-height: 0;\n  position: relative;\n  z-index: 1;\n}\n\n.time-labels {\n  background: linear-gradient(\n    135deg,\n    var(--glass-bg-tint) 0%,\n    var(--glass-bg-weak) 100%\n  );\n  backdrop-filter: blur(16px);\n  border-inline-end: 1px solid var(--glass-border-light);\n  overflow-y: auto;\n  box-shadow: var(--shadow-xs);\n  scrollbar-width: none;\n}\n\n.time-labels::-webkit-scrollbar {\n  display: none;\n}\n\n.time-label {\n  height: 60px;\n  display: flex;\n  align-items: flex-start;\n  justify-content: end;\n  padding-top: var(--space-1);\n  padding-inline-end: var(--space-3);\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  border-bottom: 1px solid var(--glass-bg-tint);\n}\n\n.slots-container {\n  position: relative;\n  background: linear-gradient(180deg, var(--glass-bg-subtle) 0%, transparent 100%);\n  overflow-y: auto;\n  z-index: 2;\n}\n\n.slots-container::-webkit-scrollbar {\n  width: 6px;\n}\n\n.slots-container::-webkit-scrollbar-track {\n  background: transparent;\n}\n\n.slots-container::-webkit-scrollbar-thumb {\n  background: var(--glass-border);\n  border-radius: var(--radius-md);\n}\n\n.time-slot {\n  height: 30px;\n  border-bottom: 1px solid var(--glass-border-light);\n  position: relative;\n  transition: background var(--duration-fast);\n}\n\n.time-slot:nth-child(even) {\n  border-bottom-style: dashed;\n  border-bottom-color: var(--glass-border-faint);\n}\n\n.time-slot:hover {\n  background: var(--glass-bg-tint);\n}\n\n.time-slot.drag-over {\n  background: var(--glass-bg-soft);\n  border-color: var(--accent-primary);\n}\n\n.time-slot.current-time {\n  background: var(--color-danger-bg-subtle);\n}\n\n.slot-task {\n  position: relative;\n  margin: var(--space-0_5) var(--space-1);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-tertiary);\n  color: var(--text-primary);\n  font-weight: var(--font-medium);\n  transition: all var(--duration-normal) var(--spring-smooth);\n  pointer-events: auto;\n  box-shadow: var(--shadow-sm);\n  cursor: grab;\n  min-height: 24px;\n  font-size: var(--text-xs);\n  z-index: 5;\n}\n\n.slot-task:hover {\n  background: var(--state-hover-bg);\n  border-color: var(--state-hover-border);\n  backdrop-filter: var(--state-active-glass);\n  transform: translateY(-1px);\n  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);\n}\n\n.slot-task.is-primary {\n  border-left: 4px solid var(--accent-primary);\n  padding-left: calc(var(--space-3) - 2px);\n}\n\n.task-content--calendar {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-0_5);\n  flex: 1;\n  min-width: 0;\n  overflow: hidden;\n}\n\n.task-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--space-2);\n}\n\n.task-title {\n  flex: 1;\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.task-actions {\n  display: flex;\n  gap: var(--space-1);\n  opacity: 0;\n  transition: opacity var(--duration-fast);\n}\n\n.slot-task:hover .task-actions {\n  opacity: 1;\n}\n\n.task-meta {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  white-space: nowrap;\n}\n\n.task-time {\n  opacity: 0.8;\n}\n\n.task-time::after {\n  content: \" · \";\n  opacity: 0.5;\n}\n\n.task-duration {\n  font-weight: var(--font-medium);\n}\n\n/* ========================================\n   COMPACT TASK LAYOUT (short duration tasks)\n   Single horizontal line: Title ... Time · Duration\n   RTL text (Hebrew/Arabic) auto-detected and layout flipped\n   ======================================== */\n\n.slot-task.is-compact {\n  padding: var(--space-1) var(--space-2);\n}\n\n.slot-task.is-compact .task-content--calendar {\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--space-2);\n}\n\n/* RTL: Reverse flex direction so title appears on right, meta on left */\n/* Use :dir(rtl) pseudo-class which detects computed direction from dir=\"auto\" */\n.slot-task.is-compact .task-content--calendar:dir(rtl) {\n  flex-direction: row-reverse;\n}\n\n.slot-task.is-compact .task-header {\n  flex: 1;\n  min-width: 0;\n}\n\n.slot-task.is-compact .task-title {\n  font-size: var(--text-xs);\n}\n\n.slot-task.is-compact .task-meta {\n  flex-shrink: 0;\n  font-size: var(--text-xs);\n}\n\n/* Hide actions in compact mode to save space */\n.slot-task.is-compact .task-actions {\n  display: none;\n}\n\n.project-stripe {\n  width: 3px;\n  border-radius: var(--radius-xs);\n  height: calc(100% - 8px);\n  position: absolute;\n  left: 2px;\n  top: var(--space-1);\n}\n\n.project-emoji-stripe {\n  /* Hide emoji stripe - causes layout issues */\n  display: none;\n}\n\n.project-color-stripe {\n  /* Inherits height and top from .project-stripe */\n}\n\n.priority-stripe {\n  width: 2px;\n  border-radius: 1px;\n  height: calc(100% - 12px);\n  position: absolute;\n  left: 0;\n  top: var(--space-1_5);\n}\n\n.resize-handle {\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 8px;\n  background: transparent;\n  cursor: ns-resize;\n  z-index: 20;\n  opacity: 0;\n  transition: all var(--duration-fast);\n  pointer-events: none;\n}\n\n.resize-handle.resize-top {\n  top: 0;\n  border-radius: var(--radius-lg) var(--radius-lg) 0 0;\n}\n\n.resize-handle.resize-bottom {\n  bottom: 0;\n  border-radius: 0 0 var(--radius-lg) var(--radius-lg);\n}\n\n.slot-task.is-primary:hover .resize-handle,\n.slot-task.is-primary.is-hovered .resize-handle {\n  opacity: 1 !important;\n  pointer-events: auto !important;\n  background: rgba(99, 102, 241, 0.4) !important;\n  transition: none !important;\n}\n\n.resize-preview-overlay {\n  position: absolute;\n  left: 0;\n  right: 0;\n  background: var(--color-indigo-bg-medium);\n  border: 2px dashed rgba(99, 102, 241, 0.6);\n  border-radius: var(--radius-md);\n  pointer-events: none;\n  z-index: 50;\n  display: flex;\n  align-items: flex-end;\n  justify-content: center;\n  padding-bottom: var(--space-1);\n}\n\n.resize-preview-overlay .preview-duration {\n  font-size: var(--text-xs);\n  font-weight: 600;\n  color: rgba(99, 102, 241, 0.9);\n  background: rgba(255, 255, 255, 0.9);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-sm);\n}\n\n.current-time-indicator {\n  position: absolute;\n  left: 0;\n  right: 0;\n  z-index: 2; /* Behind tasks (z-index: 5) so events stay visible */\n  pointer-events: none;\n  display: flex;\n  align-items: center;\n}\n\n.time-indicator-dot {\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n  background: var(--color-danger);\n  box-shadow: 0 0 4px var(--color-danger);\n  flex-shrink: 0;\n  margin-left: calc(-1 * var(--space-1));\n}\n\n.time-indicator-line {\n  flex: 1;\n  height: 2px;\n  background: var(--color-danger);\n  opacity: 0.7; /* Semi-transparent so tasks show through */\n}\n\n.ghost-preview-inline {\n  background: linear-gradient(135deg, var(--calendar-ghost-bg-start) 0%, var(--calendar-ghost-bg-end) 100%);\n  backdrop-filter: blur(8px);\n  border: 3px solid var(--calendar-ghost-border);\n  border-radius: var(--radius-lg);\n  pointer-events: none;\n}\n\n.ghost-content {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  color: var(--text-primary);\n  gap: var(--space-1);\n}\n\n.ghost-title {\n  font-weight: 700;\n  font-size: var(--text-sm);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);\n}\n\n.ghost-duration {\n  font-size: var(--text-xs);\n  font-weight: 500;\n  opacity: 0.9;\n  background: var(--border-hover);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-lg);\n}\n\n.status-indicator {\n  width: 20px;\n  height: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.status-indicator:hover {\n  background: var(--glass-border);\n}\n\n.play-timer-btn {\n  background: transparent;\n  border: none;\n  color: var(--text-muted);\n  padding: var(--space-1);\n  cursor: pointer;\n  border-radius: var(--radius-sm);\n  transition: all var(--duration-fast);\n  line-height: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.play-timer-btn:hover {\n  color: var(--color-success);\n  background: var(--color-success-bg-light, rgba(34, 197, 94, 0.1));\n}\n\n.remove-from-calendar-btn {\n  background: transparent;\n  border: none;\n  color: var(--text-muted);\n  padding: var(--space-1);\n  cursor: pointer;\n  border-radius: var(--radius-sm);\n  transition: all var(--duration-fast);\n  line-height: 1;\n}\n\n.remove-from-calendar-btn:hover {\n  color: var(--color-danger);\n  background: var(--color-danger-bg-light);\n}\n\n/* ========================================\n   TASK ENTRANCE ANIMATION\n   ======================================== */\n\n/* Keyframes for task appearing on calendar */\n@keyframes task-appear {\n  from {\n    opacity: 0;\n    transform: scale(0.95) translateY(-4px);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1) translateY(0);\n  }\n}\n\n/* TransitionGroup animation classes */\n.task-appear-enter-active {\n  animation: task-appear var(--duration-normal) var(--spring-smooth);\n}\n\n.task-appear-leave-active {\n  animation: task-appear var(--duration-fast) var(--spring-smooth) reverse;\n}\n\n.task-appear-move {\n  transition: transform var(--duration-normal) var(--spring-smooth);\n}\n\n/* ========================================\n   RTL (Right-to-Left) SUPPORT\n   ======================================== */\n\n/* Task title and meta inherit document direction */\n.task-title,\n.task-meta {\n  direction: inherit;\n  text-align: start;\n}\n\n/* RTL-specific styles - use element:dir(rtl) since dir=\"auto\" is on the element itself */\n.task-title:dir(rtl) {\n  direction: rtl;\n  unicode-bidi: plaintext;\n  text-align: right;\n}\n\n.task-meta:dir(rtl) {\n  direction: rtl;\n  unicode-bidi: plaintext;\n  text-align: right;\n}\n\n.task-content--calendar:dir(rtl) {\n  text-align: right;\n}\n\n/* Flip project stripe from left to right in RTL */\n:dir(rtl) .slot-task.is-primary {\n  border-left: 1px solid var(--border-subtle);\n  border-right: 4px solid var(--accent-primary);\n  padding-left: var(--space-3);\n  padding-right: calc(var(--space-3) - 2px);\n}\n\n:dir(rtl) .project-stripe {\n  left: auto;\n  right: 2px;\n}\n\n:dir(rtl) .priority-stripe {\n  left: auto;\n  right: 0;\n}\n\n/* ========================================\n   TIMER-ACTIVE HIGHLIGHT\n   Amber glow when task has active timer\n   ======================================== */\n\n.slot-task.timer-active-event {\n  border-color: var(--timer-active-border);\n  box-shadow: var(--timer-active-glow), var(--timer-active-shadow);\n  animation: timer-pulse 2s ease-in-out infinite;\n}\n\n.slot-task.timer-active-event:hover {\n  box-shadow: var(--timer-active-glow-strong), var(--timer-active-shadow-hover);\n}\n\n@keyframes timer-pulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.85; }\n}\n\n/* BUG-1304: Visual indicator for done tasks — low opacity only, no strikethrough */\n.slot-task.status-done {\n  filter: grayscale(0.6) brightness(0.85);\n  opacity: 0.55;\n}\n\n/* TASK-1317: External calendar events (read-only overlays) */\n.external-event {\n  position: absolute;\n  right: 4px;\n  width: 35%;\n  min-height: 20px;\n  border-left: 3px solid;\n  border-radius: var(--radius-md);\n  padding: var(--space-1) var(--space-2);\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  pointer-events: auto;\n  z-index: 3;\n  overflow: hidden;\n  border-style: solid;\n  border-width: 1px 1px 1px 3px;\n  display: flex;\n  flex-direction: column;\n  gap: 1px;\n  cursor: default;\n}\n\n.external-event-time {\n  font-weight: var(--font-semibold);\n  font-size: 10px;\n  opacity: 0.8;\n}\n\n.external-event-title {\n  font-size: var(--text-xs);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/calendar/CalendarHeader.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/calendar/CalendarMonthView.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3354,3357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3354,3357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3832,3835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3832,3835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, inject, computed } from 'vue'\nimport ProjectEmojiIcon from '@/components/base/ProjectEmojiIcon.vue'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { CalendarEvent } from '@/types/tasks'\nimport type { MonthDay } from '@/composables/calendar/useCalendarMonthView'\nimport type { ExternalCalendarEvent } from '@/composables/calendar/useExternalCalendar'\nimport { truncateUrlsInText } from '@/utils/urlTruncate'\n\nconst props = defineProps<{\n  monthDays: MonthDay[]\n  currentTaskId?: string | null\n  externalEvents?: ExternalCalendarEvent[]\n}>()\nconst emit = defineEmits<{\n  (e: 'monthDrop', event: DragEvent, dateString: string): void\n  (e: 'monthDayClick', dateString: string): void\n  (e: 'eventDragStart', event: DragEvent, calEvent: CalendarEvent): void\n  (e: 'eventDragEnd', event: DragEvent): void\n  (e: 'eventDblClick', calEvent: CalendarEvent): void\n  (e: 'eventContextMenu', event: MouseEvent, calEvent: CalendarEvent): void\n  (e: 'cycleStatus', event: MouseEvent, calEvent: CalendarEvent): void\n  (e: 'cellDblClick', dateString: string): void\n}>()\n\n// Debounce single-click vs double-click on day cells\n// Single click → navigate to day view, Double click → open create modal\nlet clickTimer: ReturnType<typeof setTimeout> | null = null\nconst handleDayCellClick = (dateString: string) => {\n  if (clickTimer) clearTimeout(clickTimer)\n  clickTimer = setTimeout(() => {\n    emit('monthDayClick', dateString)\n  }, 250)\n}\nconst handleDayCellDblClick = (dateString: string) => {\n  if (clickTimer) { clearTimeout(clickTimer); clickTimer = null }\n  emit('cellDblClick', dateString)\n}\n\n// Local drag state for visual feedback\nconst activeDragDay = ref<string | null>(null)\nconst draggedEventId = ref<string | null>(null)\n\nconst handleCellDragEnter = (dateString: string) => {\n  activeDragDay.value = dateString\n}\n\nconst handleCellDragLeave = (event: DragEvent, dateString: string) => {\n  // Only clear if actually leaving the cell (not entering a child element)\n  const related = event.relatedTarget as HTMLElement | null\n  const cell = event.currentTarget as HTMLElement\n  if (!related || !cell.contains(related)) {\n    if (activeDragDay.value === dateString) {\n      activeDragDay.value = null\n    }\n  }\n}\n\nconst handleCellDrop = (event: DragEvent, dateString: string) => {\n  activeDragDay.value = null\n  emit('monthDrop', event, dateString)\n}\n\nconst handleEventDragStart = (event: DragEvent, calEvent: CalendarEvent) => {\n  draggedEventId.value = calEvent.taskId\n  emit('eventDragStart', event, calEvent)\n}\n\nconst handleEventDragEnd = (event: DragEvent) => {\n  draggedEventId.value = null\n  activeDragDay.value = null\n  emit('eventDragEnd', event)\n}\n\n// External events grouped by date\nconst externalEventsByDate = computed(() => {\n  const map = new Map<string, ExternalCalendarEvent[]>()\n  if (!props.externalEvents?.length) return map\n  for (const event of props.externalEvents) {\n    const d = event.startTime\n    const dateString = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`\n    if (!map.has(dateString)) map.set(dateString, [])\n    map.get(dateString)!.push(event)\n  }\n  return map\n})\n\n// Inject helpers from parent CalendarView\nconst helpers = inject('calendar-helpers') as any\nconst {\n  getProjectVisual,\n  getProjectName,\n  getProjectColor,\n  getPriorityClass,\n  getPriorityLabel,\n  getTaskStatus,\n  getStatusLabel,\n  getStatusIcon,\n  formatEventTime\n} = helpers\n\n// TASK-1321: Dynamic weekday headers based on weekStartsOn setting\nconst { getWeekDayHeaders } = useCalendarCore()\nconst weekDayHeaders = computed(() => getWeekDayHeaders())\n\n// TASK-1322: Tooltip with task description\nconst taskStore = useTaskStore()\n\nconst getEventTooltip = (event: any) => {\n  const task = taskStore.getTask(event.taskId)\n  const lines = [event.title]\n  if (task?.description) {\n    const plain = task.description.replace(/<[^>]*>/g, '').trim()\n    if (plain) lines.push(plain.substring(0, 200))\n  }\n  const time = formatEventTime(event)\n  if (time) lines.unshift(`🕐 ${time}`)\n  const status = getStatusLabel(getTaskStatus(event))\n  if (status) lines.push(`Status: ${status}`)\n  return lines.join('\\n')\n}\n\n</script>\n\n<template>\n  <div class=\"month-view\">\n    <!-- Day-of-week header row -->\n    <div class=\"month-weekday-header\">\n      <div v-for=\"day in weekDayHeaders\" :key=\"day\" class=\"weekday-label\">\n        {{ day }}\n      </div>\n    </div>\n\n    <!-- Month Grid -->\n    <div class=\"month-grid\">\n      <div\n        v-for=\"day in monthDays\"\n        :key=\"day.dateString\"\n        class=\"month-day-cell\"\n        :class=\"{\n          'other-month': !day.isCurrentMonth,\n          'today': day.isToday,\n          'drag-over': activeDragDay === day.dateString\n        }\"\n        @drop.prevent=\"handleCellDrop($event, day.dateString)\"\n        @dragover.prevent\n        @dragenter.prevent=\"handleCellDragEnter(day.dateString)\"\n        @dragleave=\"handleCellDragLeave($event, day.dateString)\"\n        @click=\"handleDayCellClick(day.dateString)\"\n        @dblclick.stop=\"handleDayCellDblClick(day.dateString)\"\n      >\n        <div class=\"day-number\">\n          {{ day.dayNumber }}\n        </div>\n\n        <div class=\"day-events\">\n          <div\n            v-for=\"event in day.events\"\n            :key=\"event.id\"\n            class=\"month-event\"\n            :class=\"{ 'timer-active-event': currentTaskId === event.taskId, 'status-done': getTaskStatus(event) === 'done', 'dragging': draggedEventId === event.taskId }\"\n            :style=\"{ backgroundColor: event.color }\"\n            :title=\"getEventTooltip(event)\"\n            draggable=\"true\"\n            @dragstart=\"handleEventDragStart($event, event)\"\n            @dragend=\"handleEventDragEnd($event)\"\n            @dblclick.stop=\"$emit('eventDblClick', event)\"\n            @contextmenu.prevent.stop=\"$emit('eventContextMenu', $event, event)\"\n            @click.stop\n          >\n            <!-- Project Stripe -->\n            <div\n              v-if=\"getProjectVisual(event).type === 'emoji'\"\n              class=\"project-indicator project-emoji-indicator\"\n              :title=\"`Project: ${getProjectName(event)}`\"\n            >\n              <ProjectEmojiIcon\n                :emoji=\"getProjectVisual(event).content\"\n                size=\"xs\"\n                :title=\"`Project: ${getProjectName(event)}`\"\n                class=\"project-emoji\"\n              />\n            </div>\n            <div\n              v-else\n              class=\"project-indicator project-color-indicator\"\n              :style=\"{ backgroundColor: getProjectColor(event) }\"\n              :title=\"`Project: ${getProjectName(event)}`\"\n            />\n\n            <!-- Priority Stripe -->\n            <div\n              class=\"priority-stripe\"\n              :class=\"`priority-${getPriorityClass(event)}`\"\n              :title=\"`Priority: ${getPriorityLabel(event)}`\"\n            />\n            <span v-if=\"formatEventTime(event)\" class=\"event-time\">{{ formatEventTime(event) }}</span>\n            <span\n              class=\"event-title-short\"\n              dir=\"auto\"\n              :title=\"event.title\"\n              @click.stop=\"$emit('cycleStatus', $event, event)\"\n            >\n              {{ getStatusIcon(getTaskStatus(event)) }} {{ truncateUrlsInText(event.title) }}\n            </span>\n          </div>\n\n          <!-- TASK-1317: External calendar events (read-only pills) -->\n          <div\n            v-for=\"ext in (externalEventsByDate.get(day.dateString) || [])\"\n            :key=\"`ext-${ext.id}`\"\n            class=\"month-event month-event--external\"\n            :style=\"{ borderColor: ext.color, backgroundColor: ext.color + '20' }\"\n            :title=\"`${ext.title}${ext.location ? '\\n📍 ' + ext.location : ''}`\"\n          >\n            <div class=\"external-dot\" :style=\"{ backgroundColor: ext.color }\" />\n            <span class=\"event-title-short\" dir=\"auto\">{{ ext.title }}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.month-view {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative;\n  z-index: 1;\n}\n\n.month-weekday-header {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  gap: 1px;\n  background: var(--glass-border-light);\n  flex-shrink: 0;\n}\n\n.weekday-label {\n  background: var(--glass-panel-bg);\n  padding: var(--space-2);\n  text-align: center;\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n}\n\n.month-grid {\n  flex: 1;\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  grid-template-rows: repeat(6, 1fr);\n  gap: 1px;\n  background: var(--glass-border-light);\n  overflow-y: auto;\n}\n\n.month-day-cell {\n  background: var(--glass-panel-bg);\n  min-height: 120px;\n  padding: var(--space-2);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  cursor: pointer;\n  transition: background var(--duration-fast);\n}\n\n.month-day-cell:hover {\n  background: var(--glass-bg-subtle);\n}\n\n.month-day-cell.drag-over {\n  background: rgba(99, 102, 241, 0.2) !important;\n  box-shadow: inset 0 0 0 2px rgba(99, 102, 241, 0.5) !important;\n  opacity: 1 !important;\n}\n\n.month-day-cell.other-month {\n  background: var(--glass-bg-tint);\n  opacity: 0.6;\n}\n\n.month-day-cell.today {\n  background: rgba(239, 68, 68, 0.05);\n}\n\n.day-number {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n  text-align: right;\n}\n\n.month-day-cell.today .day-number {\n  color: var(--color-danger);\n  background: var(--color-danger);\n  color: white;\n  width: 24px;\n  height: 24px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 50%;\n  margin-left: auto;\n}\n\n.day-events {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-0_5);\n  flex: 1;\n  overflow-y: auto;\n}\n\n/* TASK-1322: Vertical compact layout — shows more content per event */\n.month-event {\n  padding: var(--space-0_5) var(--space-1);\n  padding-left: var(--space-2_5);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: white;\n  cursor: grab;\n  position: relative;\n  line-height: 1.3;\n}\n\n.month-event.timer-active-event {\n  box-shadow: 0 0 8px rgba(255, 255, 255, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.5);\n}\n\n.event-time {\n  font-weight: var(--font-bold);\n  opacity: 0.8;\n  font-size: 0.6rem;\n  display: block;\n  margin-bottom: 1px;\n}\n\n.project-indicator {\n  width: 4px;\n  height: calc(100% - 4px);\n  border-radius: var(--radius-xs);\n  position: absolute;\n  left: var(--space-0_5);\n  top: var(--space-0_5);\n}\n\n.project-emoji-indicator {\n  width: 12px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.priority-stripe {\n  width: 2px;\n  height: calc(100% - 6px);\n  border-radius: 1px;\n  position: absolute;\n  left: 0;\n  top: 3px;\n}\n\n.event-title-short {\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  word-break: break-word;\n}\n\n/* BUG-1304: Visual indicator for done tasks — low opacity only, no strikethrough */\n.month-event.status-done {\n  filter: grayscale(0.6) brightness(0.85);\n  opacity: 0.55;\n}\n\n.month-event.dragging {\n  opacity: 0.35 !important;\n  transform: scale(0.95);\n}\n\n/* TASK-1317: External calendar events */\n.month-event--external {\n  background: transparent !important;\n  border: 1px solid;\n  color: var(--text-secondary) !important;\n  cursor: default;\n  padding-left: var(--space-1);\n}\n\n.month-event--external:hover {\n  filter: brightness(1.1);\n}\n\n.external-dot {\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  flex-shrink: 0;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/calendar/CalendarStatusOverlays.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/calendar/CalendarWeekView.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[433,436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[433,436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1897,1900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1897,1900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2161,2164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2161,2164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3974,3977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3974,3977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, computed, inject } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { WeekEvent, DragGhost } from '@/types/tasks'\nimport type { TimeSlot } from '@/composables/calendar/useCalendarDayView'\nimport type { ExternalCalendarEvent } from '@/composables/calendar/useExternalCalendar'\nimport { truncateUrlsInText } from '@/utils/urlTruncate'\n\nconst props = defineProps<{\n  weekDays: any[]\n  workingHours: number[]\n  weekEvents: WeekEvent[]\n  currentTaskId?: string | null\n  // Same props as CalendarDayView for drag/resize visual feedback\n  dragGhost: DragGhost\n  isDragging: boolean\n  draggedEventId: string | null\n  resizePreview?: {\n    isResizing: boolean\n    taskId: string | null\n    previewDuration: number\n    direction: 'top' | 'bottom'\n  } | null\n  externalEvents?: ExternalCalendarEvent[]\n}>()\n\n// Same emit signatures as CalendarDayView — uses TimeSlot for drop targets\ndefineEmits<{\n  (e: 'dragover', event: DragEvent, slot: TimeSlot): void\n  (e: 'dragenter', event: DragEvent, slot: TimeSlot): void\n  (e: 'dragleave'): void\n  (e: 'drop', event: DragEvent, slot: TimeSlot): void\n  (e: 'eventDragStart', event: DragEvent, weekEvent: WeekEvent): void\n  (e: 'eventDragEnd', event: DragEvent, weekEvent: WeekEvent): void\n  (e: 'eventClick', event: MouseEvent, weekEvent: WeekEvent): void\n  (e: 'eventDblClick', weekEvent: WeekEvent): void\n  (e: 'eventContextMenu', event: MouseEvent, weekEvent: WeekEvent): void\n  (e: 'cycleStatus', event: MouseEvent, weekEvent: WeekEvent): void\n  (e: 'removeFromCalendar', weekEvent: WeekEvent): void\n  (e: 'startTimer', weekEvent: WeekEvent): void\n  (e: 'startResize', event: MouseEvent, weekEvent: WeekEvent, direction: 'top' | 'bottom'): void\n  (e: 'cellDblClick', dateString: string, hour: number): void\n}>()\n\n// Inject helpers from parent CalendarView\nconst helpers = inject('calendar-helpers') as any\nconst {\n  formatHour,\n  formatEventTime,\n  isCurrentWeekTimeCell,\n  getPriorityClass,\n  getTaskStatus,\n  getStatusIcon,\n  getStatusLabel\n} = helpers\n\n// TASK-1322: Tooltip with task description\nconst taskStore = useTaskStore()\n\nconst getEventTooltip = (event: any) => {\n  const task = taskStore.getTask(event.taskId)\n  const lines = [event.title]\n  if (task?.description) {\n    const plain = task.description.replace(/<[^>]*>/g, '').trim()\n    if (plain) lines.push(plain.substring(0, 200))\n  }\n  const time = formatEventTime(event)\n  if (time) lines.unshift(`🕐 ${time}`)\n  const status = getStatusLabel(getTaskStatus(event))\n  if (status) lines.push(`Status: ${status}`)\n  return lines.join('\\n')\n}\n\n// Local drag cell tracking for ghost preview positioning\nconst activeDragCell = ref<{ dayIndex: number; hour: number } | null>(null)\n\n// Create a TimeSlot from week cell data — same shape as day view slots\nconst createSlot = (dateString: string, hour: number): TimeSlot => ({\n  id: `${dateString}-${hour}-0`,\n  hour,\n  minute: 0,\n  slotIndex: hour * 2,\n  date: dateString\n})\n\n// Group events by their starting cell for in-cell rendering (like day view)\nconst eventsByCell = computed(() => {\n  const map = new Map<string, WeekEvent[]>()\n  for (const event of props.weekEvents) {\n    const startHour = Math.floor(event.startSlot / 2) + 6\n    const key = `${event.dayIndex}-${startHour}`\n    if (!map.has(key)) map.set(key, [])\n    map.get(key)!.push(event)\n  }\n  return map\n})\n\nconst getEventsForCell = (dayIndex: number, hour: number): WeekEvent[] => {\n  return eventsByCell.value.get(`${dayIndex}-${hour}`) || []\n}\n\n// TASK-1317: External events grouped by cell\nconst externalEventsByCell = computed(() => {\n  const map = new Map<string, ExternalCalendarEvent[]>()\n  if (!props.externalEvents?.length) return map\n  for (const event of props.externalEvents) {\n    const d = event.startTime\n    const dateString = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`\n    const dayIndex = props.weekDays.findIndex((day: any) => day.dateString === dateString)\n    if (dayIndex === -1) continue\n    const hour = d.getHours()\n    const key = `${dayIndex}-${hour}`\n    if (!map.has(key)) map.set(key, [])\n    map.get(key)!.push(event)\n  }\n  return map\n})\n\n// Absolute positioning for time-spanning blocks (like Google Calendar)\n// Overlapping events split into side-by-side columns using event.column / event.totalColumns\nconst HALF_HOUR_HEIGHT = 30\nconst getWeekEventCellStyle = (event: WeekEvent) => {\n  const topOffset = (event.startSlot % 2) * HALF_HOUR_HEIGHT\n  const height = event.slotSpan * HALF_HOUR_HEIGHT\n  if (event.totalColumns > 1) {\n    const widthPercent = 100 / event.totalColumns\n    const leftPercent = widthPercent * event.column\n    return {\n      position: 'absolute' as const,\n      top: `${topOffset}px`,\n      height: `${height}px`,\n      width: `calc(${widthPercent}% - 4px)`,\n      left: `calc(${leftPercent}% + 2px)`,\n      zIndex: 10 + event.column\n    }\n  }\n  return {\n    position: 'absolute' as const,\n    top: `${topOffset}px`,\n    height: `${height}px`,\n    left: '2px',\n    right: '2px',\n    zIndex: 10\n  }\n}\n\n</script>\n\n<template>\n  <div class=\"week-view\">\n    <!-- Week Header -->\n    <div class=\"week-header\">\n      <div class=\"week-time-label\" />\n      <div\n        v-for=\"(day, index) in weekDays\"\n        :key=\"index\"\n        class=\"week-day-header\"\n      >\n        <div class=\"week-day-name\">\n          {{ day.dayName }}\n        </div>\n        <div class=\"week-day-date\">\n          {{ day.date }}\n        </div>\n      </div>\n    </div>\n\n    <!-- Week Grid Container -->\n    <div class=\"week-grid-container\">\n      <!-- Time Labels -->\n      <div class=\"week-time-labels\">\n        <div\n          v-for=\"hour in workingHours\"\n          :key=\"hour\"\n          class=\"week-time-label\"\n        >\n          {{ formatHour(hour) }}\n        </div>\n      </div>\n\n      <!-- Week Days Grid -->\n      <div class=\"week-days-grid\">\n        <div class=\"week-time-grid\">\n          <div\n            v-for=\"(day, dayIndex) in weekDays\"\n            :key=\"`col-${dayIndex}`\"\n            class=\"week-day-column\"\n          >\n            <div\n              v-for=\"hour in workingHours\"\n              :key=\"`${dayIndex}-${hour}`\"\n              class=\"week-time-cell\"\n              :class=\"{\n                'current-time': isCurrentWeekTimeCell(day.dateString, hour),\n                'drag-over': activeDragCell?.dayIndex === dayIndex && activeDragCell?.hour === hour\n              }\"\n              @dragover.prevent=\"activeDragCell = { dayIndex, hour }; $emit('dragover', $event, createSlot(day.dateString, hour))\"\n              @dragenter.prevent=\"activeDragCell = { dayIndex, hour }; $emit('dragenter', $event, createSlot(day.dateString, hour))\"\n              @dragleave=\"$emit('dragleave')\"\n              @drop.prevent=\"activeDragCell = null; $emit('drop', $event, createSlot(day.dateString, hour))\"\n              @dblclick.self=\"$emit('cellDblClick', day.dateString, hour)\"\n            >\n              <!-- Ghost Preview (during inbox drag) — same as day view -->\n              <div\n                v-if=\"dragGhost.visible && activeDragCell?.dayIndex === dayIndex && activeDragCell?.hour === hour\"\n                class=\"ghost-preview-inline\"\n                :style=\"{\n                  position: 'absolute',\n                  top: '0',\n                  height: `${Math.ceil(dragGhost.duration / 30) * 30}px`,\n                  left: '2px',\n                  right: '2px',\n                  zIndex: 40\n                }\"\n              >\n                <div class=\"ghost-content\">\n                  <span class=\"ghost-title\">{{ dragGhost.title }}</span>\n                  <span class=\"ghost-duration\">{{ dragGhost.duration }}min</span>\n                </div>\n              </div>\n\n              <!-- Week events as absolute-positioned time-spanning blocks -->\n              <div\n                v-for=\"event in getEventsForCell(dayIndex, hour)\"\n                :key=\"event.id\"\n                class=\"week-event\"\n                :class=\"{\n                  'timer-active-event': currentTaskId === event.taskId,\n                  'dragging': isDragging && draggedEventId === event.id,\n                  'status-done': getTaskStatus(event) === 'done'\n                }\"\n                :style=\"{ ...getWeekEventCellStyle(event), backgroundColor: event.color }\"\n                :title=\"getEventTooltip(event)\"\n                draggable=\"true\"\n                @dragstart=\"$emit('eventDragStart', $event, event)\"\n                @dragend=\"$emit('eventDragEnd', $event, event)\"\n                @click.stop=\"$emit('eventClick', $event, event)\"\n                @dblclick.stop=\"$emit('eventDblClick', event)\"\n                @contextmenu.prevent.stop=\"$emit('eventContextMenu', $event, event)\"\n              >\n                <!-- Priority Stripe -->\n                <div\n                  class=\"priority-stripe\"\n                  :class=\"`priority-${getPriorityClass(event)}`\"\n                />\n\n                <!-- Event Content — optimized for narrow columns -->\n                <div class=\"event-content\">\n                  <span class=\"event-time\">{{ formatEventTime(event) }}</span>\n                  <span class=\"event-title\" dir=\"auto\">\n                    {{ getStatusIcon(getTaskStatus(event)) }} {{ truncateUrlsInText(event.title) }}\n                  </span>\n                </div>\n\n                <!-- Resize handle (bottom edge) — drag to change duration -->\n                <div\n                  class=\"resize-handle resize-handle-bottom\"\n                  title=\"Drag to change duration\"\n                  @mousedown.stop.prevent=\"$emit('startResize', $event, event, 'bottom')\"\n                />\n              </div>\n\n              <!-- TASK-1317: External calendar events in this cell -->\n              <div\n                v-for=\"ext in (externalEventsByCell.get(`${dayIndex}-${hour}`) || [])\"\n                :key=\"`ext-${ext.id}`\"\n                class=\"week-event week-event--external\"\n                :style=\"{\n                  position: 'absolute',\n                  top: `${(ext.startTime.getMinutes() >= 30 ? 30 : 0)}px`,\n                  height: `${Math.max(20, Math.ceil((ext.endTime.getTime() - ext.startTime.getTime()) / 60000 / 30) * 30)}px`,\n                  right: '2px',\n                  width: '35%',\n                  borderColor: ext.color,\n                  backgroundColor: ext.color + '20'\n                }\"\n                :title=\"`${ext.title}${ext.location ? '\\n📍 ' + ext.location : ''}`\"\n              >\n                <span class=\"external-event-title\" dir=\"auto\">{{ ext.title }}</span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.week-view {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative;\n  z-index: 1;\n}\n\n.week-header {\n  display: grid;\n  grid-template-columns: 80px repeat(7, 1fr);\n  background: var(--glass-panel-bg);\n  backdrop-filter: blur(8px);\n  border-bottom: 1px solid var(--border-subtle);\n  position: sticky;\n  top: 0;\n  z-index: 20;\n}\n\n.week-time-label {\n  padding: var(--space-2) var(--space-4);\n}\n\n.week-day-header {\n  padding: var(--space-3) var(--space-2);\n  text-align: center;\n  border-left: 1px solid var(--glass-border-light);\n}\n\n.week-day-name {\n  font-size: var(--text-xs);\n  font-weight: var(--font-bold);\n  text-transform: uppercase;\n  color: var(--text-muted);\n  margin-bottom: var(--space-0_5);\n}\n\n.week-day-date {\n  font-size: var(--text-lg);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n}\n\n.week-grid-container {\n  flex: 1;\n  display: grid;\n  grid-template-columns: 80px 1fr;\n  overflow-y: auto;\n  position: relative;\n}\n\n.week-time-labels {\n  background: var(--glass-bg-subtle);\n  border-right: 1px solid var(--border-subtle);\n}\n\n.week-time-label {\n  height: 60px;\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  padding-right: var(--space-4);\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  border-bottom: 1px solid var(--glass-border-light);\n}\n\n.week-days-grid {\n  position: relative;\n  display: grid;\n  grid-template-columns: 1fr;\n}\n\n.week-time-grid {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  height: 100%;\n}\n\n.week-day-column {\n  border-left: 1px solid var(--glass-border-light);\n}\n\n/* Cell — overflow visible so blocks can extend beyond cell boundaries */\n.week-time-cell {\n  height: 60px;\n  border-bottom: 1px solid var(--glass-border-light);\n  position: relative;\n  overflow: visible;\n  transition: background var(--duration-fast);\n}\n\n.week-time-cell:hover {\n  background: var(--glass-bg-tint);\n}\n\n.week-time-cell.drag-over {\n  background: var(--glass-bg-soft);\n  border-color: var(--accent-primary);\n}\n\n.week-time-cell.current-time {\n  background: rgba(239, 68, 68, 0.05);\n  box-shadow: inset 0 -2px 0 var(--color-danger);\n}\n\n/* Week event — absolute-positioned time-spanning block (like Google Calendar) */\n.week-event {\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: white;\n  cursor: grab;\n  overflow: hidden;\n  transition: filter var(--duration-fast), opacity var(--duration-fast);\n}\n\n.week-event:hover {\n  filter: brightness(1.1);\n}\n\n.week-event.dragging {\n  opacity: 0.35 !important;\n  transform: scale(0.95);\n  cursor: grabbing;\n}\n\n/* Event content — column layout, time at top, title below */\n.event-content {\n  padding: 2px 4px 2px 6px;\n  display: flex;\n  flex-direction: column;\n  gap: 0;\n  height: 100%;\n  overflow: hidden;\n}\n\n/* Time — bold, always visible at top of block */\n.event-time {\n  font-weight: var(--font-bold);\n  opacity: 0.9;\n  font-size: 0.6rem;\n  white-space: nowrap;\n  flex-shrink: 0;\n  line-height: 1.4;\n}\n\n/* Title — aggressive truncation for narrow 1/7th columns */\n.event-title {\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  word-break: break-word;\n  line-height: 1.2;\n  font-size: 0.65rem;\n}\n\n/* Priority stripe — thin left edge */\n.priority-stripe {\n  width: 3px;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  border-radius: var(--radius-sm) 0 0 var(--radius-sm);\n}\n\n/* Resize handle — appears on hover at bottom edge of event block */\n.resize-handle {\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 6px;\n  cursor: ns-resize;\n  opacity: 0;\n  transition: opacity var(--duration-fast);\n}\n\n.resize-handle-bottom {\n  bottom: 0;\n  border-radius: 0 0 var(--radius-sm) var(--radius-sm);\n  background: rgba(255, 255, 255, 0.3);\n}\n\n.week-event:hover .resize-handle {\n  opacity: 1;\n}\n\n/* Ghost preview — IDENTICAL to day view */\n.ghost-preview-inline {\n  background: linear-gradient(135deg, var(--calendar-ghost-bg-start) 0%, var(--calendar-ghost-bg-end) 100%);\n  backdrop-filter: blur(8px);\n  border: 3px solid var(--calendar-ghost-border);\n  border-radius: var(--radius-lg);\n  pointer-events: none;\n  z-index: 40;\n}\n\n.ghost-content {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  color: var(--text-primary);\n  gap: var(--space-1);\n}\n\n.ghost-title {\n  font-weight: 700;\n  font-size: var(--text-xs);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  max-width: 100%;\n  padding: 0 var(--space-1);\n}\n\n.ghost-duration {\n  font-size: var(--text-xs);\n  font-weight: 500;\n  opacity: 0.9;\n  background: var(--border-hover);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-lg);\n}\n\n/* Timer active glow */\n.week-event.timer-active-event {\n  box-shadow: 0 0 8px rgba(255, 255, 255, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.5);\n  animation: timer-pulse 2s ease-in-out infinite;\n}\n\n@keyframes timer-pulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.85; }\n}\n\n/* BUG-1304: Visual indicator for done tasks */\n.week-event.status-done {\n  filter: grayscale(0.6) brightness(0.85);\n  opacity: 0.55;\n}\n\n/* TASK-1317: External calendar events */\n.week-event--external {\n  background: transparent !important;\n  border: 1px solid;\n  color: var(--text-secondary) !important;\n  cursor: default;\n  padding-left: var(--space-1);\n}\n\n.week-event--external:hover {\n  filter: brightness(1.1);\n}\n\n.week-event--external .external-event-title {\n  font-size: 10px;\n  color: var(--text-secondary);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  padding: 2px 4px;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasContextMenu.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasContextMenus.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasEmptyState.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasGroup.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasLoadingOverlay.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasModals.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3225,3228],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3225,3228],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3271,3274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3271,3274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3317,3320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3317,3320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3373,3376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3373,3376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <!-- Task Edit Modal -->\n  <TaskEditModal\n    :is-open=\"modals.isEditModalOpen\"\n    :task=\"modals.selectedTask\"\n    @close=\"modals.closeEditModal\"\n  />\n\n  <!-- Quick Task Create Modal -->\n  <QuickTaskCreateModal\n    :is-open=\"modals.isQuickTaskCreateOpen\"\n    :loading=\"false\"\n    @cancel=\"modals.closeQuickTaskCreate\"\n    @create=\"handleQuickTaskCreateAndClose\"\n  />\n\n  <!-- Batch Edit Modal -->\n  <BatchEditModal\n    :is-open=\"modals.isBatchEditModalOpen\"\n    :task-ids=\"modals.batchEditTaskIds\"\n    @close=\"modals.closeBatchEditModal\"\n    @applied=\"$emit('handleBatchEditApplied')\"\n  />\n\n  <!-- Section Settings Modal -->\n  <GroupSettingsMenu\n    :section=\"modals.editingSection\"\n    :is-visible=\"modals.isSectionSettingsOpen\"\n    @close=\"modals.closeSectionSettings\"\n    @save=\"(settings) => $emit('handleSectionSettingsSave', settings)\"\n  />\n\n  <!-- Unified Group Modal (create + edit with optional smart settings) -->\n  <UnifiedGroupModal\n    :is-open=\"modals.isGroupModalOpen\"\n    :group=\"modals.selectedGroup\"\n    :position=\"modals.groupModalPosition\"\n    @close=\"modals.closeGroupModal\"\n    @created=\"(group) => $emit('handleGroupCreated', group)\"\n    @updated=\"(group) => $emit('handleGroupUpdated', group)\"\n  />\n\n  <!-- Group Edit Modal -->\n  <GroupEditModal\n    :section=\"modals.selectedSectionForEdit\"\n    :is-visible=\"modals.isGroupEditModalOpen\"\n    @close=\"modals.closeGroupEditModal\"\n    @save=\"(updatedSection) => $emit('handleGroupEditSave', updatedSection)\"\n  />\n\n  <!-- Group Delete Confirmation Modal -->\n  <ConfirmationModal\n    :is-open=\"modals.isDeleteGroupModalOpen\"\n    title=\"Delete Group\"\n    :message=\"modals.deleteGroupMessage\"\n    confirm-text=\"Delete\"\n    @confirm=\"handleDeleteGroupConfirm\"\n    @cancel=\"modals.closeDeleteGroupModal\"\n  />\n\n  <!-- Bulk Delete Confirmation Modal (Shift+Delete on multiple items) -->\n  <ConfirmationModal\n    :is-open=\"modals.isBulkDeleteModalOpen\"\n    :title=\"modals.bulkDeleteTitle\"\n    :message=\"modals.bulkDeleteMessage\"\n    :details=\"modals.bulkDeleteItems.map(item => `${item.type === 'section' ? '▤' : '📌'} ${item.name}`)\"\n    :confirm-text=\"modals.bulkDeleteIsPermanent ? 'Delete Permanently' : 'Remove'\"\n    @confirm=\"handleBulkDeleteConfirm\"\n    @cancel=\"modals.closeBulkDeleteModal\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport { useCanvasModalsStore } from '@/stores/canvas/modals'\n\n// Components\nimport TaskEditModal from '@/components/tasks/TaskEditModal.vue'\nimport QuickTaskCreateModal from '@/components/tasks/QuickTaskCreateModal.vue'\nimport BatchEditModal from '@/components/tasks/BatchEditModal.vue'\nimport GroupSettingsMenu from '@/components/canvas/GroupSettingsMenu.vue'\nimport UnifiedGroupModal from '@/components/canvas/UnifiedGroupModal.vue'\nimport GroupEditModal from '@/components/canvas/GroupEditModal.vue'\nimport ConfirmationModal from '@/components/common/ConfirmationModal.vue'\n\ninterface QuickTaskData {\n  title: string\n  description: string\n  status: string\n  priority: 'low' | 'medium' | 'high'\n  dueDate?: string\n  projectId?: string\n}\n\nconst emit = defineEmits<{\n  (e: 'handleQuickTaskCreate', data: QuickTaskData): void\n  (e: 'handleBatchEditApplied'): void\n  (e: 'handleSectionSettingsSave', settings: any): void\n  (e: 'handleGroupCreated', group: any): void\n  (e: 'handleGroupUpdated', group: any): void\n  (e: 'handleGroupEditSave', updatedSection: any): void\n  (e: 'confirmDeleteGroup'): void\n  (e: 'confirmBulkDelete'): void\n}>()\n\nconst modals = useCanvasModalsStore()\n\n// FIX: Handle quick task create - emit full data AND close modal\nconst handleQuickTaskCreateAndClose = (data: QuickTaskData) => {\n  emit('handleQuickTaskCreate', data)\n  modals.closeQuickTaskCreate()\n}\n\n// BUG-1074 FIX: Use explicit emit function to ensure proper event propagation\n// BUG-1089 FIX: Close modal via Pinia store after emitting confirm event\nconst handleBulkDeleteConfirm = () => {\n  emit('confirmBulkDelete')\n  modals.closeBulkDeleteModal()\n}\n\n// BUG-1076 FIX: Handler for delete group confirmation\n// BUG-1089 FIX: Close modal via Pinia store after emitting confirm event\nconst handleDeleteGroupConfirm = () => {\n  emit('confirmDeleteGroup')\n  modals.closeDeleteGroupModal()\n}\n\n</script>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasSelectionBox.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasStatusBanner.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/CanvasToolbar.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/EdgeContextMenu.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/GroupEditModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/GroupNodeSimple.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useTaskStore' is defined but never used. Allowed unused vars must match /^_/u.","line":88,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"useTaskStore"},"fix":{"range":[3217,3262],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3558,3561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3558,3561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4533,4536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4533,4536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nearMin' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":263,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":263,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nearMax' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":264,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":264,"endColumn":18}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    class=\"section-node\"\n    :class=\"[`section-type-${section.type}`, { 'collapsed': isCollapsed, 'is-dragging': dragging }]\"\n    :style=\"{ borderColor: groupColor, backgroundColor: groupColor + '25' }\"\n    @contextmenu.prevent=\"handleContextMenu\"\n  >\n    <!-- Section Header -->\n    <div class=\"section-header\" :style=\"{ background: groupColor + '20' }\">\n      <div class=\"section-color-dot\" :style=\"{ background: groupColor }\" />\n      <button class=\"collapse-btn\" :title=\"isCollapsed ? 'Expand group' : 'Collapse group'\" @click=\"toggleCollapse\">\n        <ChevronDown v-if=\"!isCollapsed\" :size=\"14\" />\n        <ChevronRight v-else :size=\"14\" />\n      </button>\n      <input\n        v-model=\"sectionName\"\n        class=\"section-name-input\"\n        placeholder=\"Group name...\"\n        :disabled=\"isCollapsed\"\n        @blur=\"updateName\"\n        @keydown.enter=\"($event.target as HTMLInputElement).blur()\"\n      >\n      <!-- TASK-130: Show date suffix for day-of-week groups (e.g., \"/ Jan 10\") -->\n      <!-- TASK-166: Clickable date picker for bi-directional editing -->\n      <NPopover\n        v-if=\"dayOfWeekDateSuffix\"\n        trigger=\"click\"\n        placement=\"bottom\"\n        :show=\"showDatePicker\"\n        @update:show=\"showDatePicker = $event\"\n      >\n        <template #trigger>\n          <span\n            class=\"section-date-suffix clickable\"\n            title=\"Click to change date\"\n            @click.stop=\"showDatePicker = true\"\n          >\n            / {{ dayOfWeekDateSuffix }}\n          </span>\n        </template>\n        <NDatePicker\n          panel\n          type=\"date\"\n          :value=\"currentTargetTimestamp\"\n          @update:value=\"handleDateSelect\"\n        />\n      </NPopover>\n\n      <!-- TASK-068: All actions moved to context menu for cleaner header -->\n\n      <div class=\"section-count\" :class=\"{ 'has-tasks': taskCount > 0 }\">\n        {{ taskCount }}\n        <span v-if=\"isCollapsed && taskCount > 0\" class=\"hidden-indicator\" :title=\"`${taskCount} hidden tasks`\">📦</span>\n      </div>\n    </div>\n\n    <!-- TASK-141: ADD SLOT FOR CHILD NODES (CRITICAL FOR VUE FLOW NESTING) -->\n    <div v-if=\"!isCollapsed\" class=\"section-body\">\n      <slot />\n    </div>\n\n    <!-- RESIZE HANDLES - BUG-043: Enable all corners AND edges for resizing -->\n    <!-- TASK-290: Always render NodeResizer, use CSS to show/hide on hover -->\n    <NodeResizer\n      is-visible\n      :min-width=\"200\"\n      :min-height=\"80\"\n      :max-width=\"50000\"\n      :max-height=\"50000\"\n      :line-positions=\"[Position.Top, Position.Right, Position.Bottom, Position.Left]\"\n      @resize-start=\"handleResizeStart\"\n      @resize=\"handleResize\"\n      @resize-end=\"handleResizeEnd\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, onMounted } from 'vue'\nimport { ChevronDown, ChevronRight } from 'lucide-vue-next'\nimport { NodeResizer } from '@vue-flow/node-resizer'\nimport '@vue-flow/node-resizer/dist/style.css'\n// TASK-072: Import useNode for reactive node data from Vue Flow state\n// TASK-072: Use reactive node data if needed\n// BUG-043: Import Position for edge resize handles\nimport { Position } from '@vue-flow/core'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\n// TASK-167: Direct import to ensure latest logic\nimport { detectPowerKeyword } from '@/composables/usePowerKeywords'\n// TASK-166: Date picker for bi-directional day group editing\nimport { NPopover, NDatePicker } from 'naive-ui'\n\n// Define Props\nconst props = defineProps<{\n  id: string\n  data: any\n  selected?: boolean\n  dragging?: boolean\n}>()\n\n// Define Emits\nconst emit = defineEmits([\n  'update',\n  'collect',\n  'contextMenu',\n  'open-settings',\n  'resizeStart',\n  'resize',\n  'resizeEnd'\n])\n\n// Initialize Stores\nconst canvasStore = useCanvasStore()\n\n// Computed Properties\n// Ensure we handle both structure formats (direct props or nested in data)\nconst section = computed(() => props.data?.section || props.data)\nconst isCollapsed = computed(() => !!props.data?.isCollapsed)\n\n// BUG-225 FIX: Get color reactively from store instead of static props.data\n// This ensures color updates immediately when changed in the modal without page refresh\nconst groupColor = computed(() => {\n  const groupId = props.data?.id\n  if (!groupId) return props.data?.color || '#3b82f6'\n  const storeGroup = canvasStore.groups.find(g => g.id === groupId)\n  return storeGroup?.color || props.data?.color || '#3b82f6'\n})\nconst taskCount = computed(() => {\n  const data = props.data as any\n  if (!data) return 0\n\n  // Determine which count to show based on whether this is a root or child group\n  // - Root groups (no parent): show aggregated count (includes descendants)\n  // - Child groups: show only direct count (tasks in this group only)\n  const isRootGroup = !data.parentGroupId || data.parentGroupId === 'NONE'\n  const direct = data.directTaskCount ?? 0\n  const aggregated = data.aggregatedTaskCount ?? direct\n\n  return isRootGroup ? aggregated : direct\n})\n\n// Local State\nconst sectionName = ref(props.data?.name || '')\n\n// TASK-166: Date picker state for bi-directional day group editing\nconst showDatePicker = ref(false)\nconst DAY_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n\n// Get the current target date as timestamp for the date picker\nconst currentTargetTimestamp = computed(() => {\n  const currentName = sectionName.value\n  if (!currentName) return Date.now()\n\n  const explicitKeyword = detectPowerKeyword(currentName)\n  if (!explicitKeyword || explicitKeyword.category !== 'day_of_week') {\n    return Date.now()\n  }\n\n  const targetDayIndex = parseInt(explicitKeyword.value, 10)\n  if (isNaN(targetDayIndex)) return Date.now()\n\n  const today = new Date()\n  const daysUntilTarget = ((7 + targetDayIndex - today.getDay()) % 7) || 7\n  const targetDate = new Date(today)\n  targetDate.setDate(today.getDate() + daysUntilTarget)\n  return targetDate.getTime()\n})\n\n// Handle date selection from picker\nconst handleDateSelect = (timestamp: number | null) => {\n  if (!timestamp) return\n\n  const selectedDate = new Date(timestamp)\n  const dayName = DAY_NAMES[selectedDate.getDay()]\n\n  // Update the group name to the new day\n  sectionName.value = dayName\n  emit('update', { name: dayName })\n\n  showDatePicker.value = false\n}\n\n// TASK-130: Compute upcoming date for day-of-week groups\nconst dayOfWeekDateSuffix = computed(() => {\n  // Use local name ref for immediate reactivity\n  const currentName = sectionName.value\n  if (!currentName) return null\n  \n  // Re-detect keyword locally to ensure reactivity allows \"instant\" feedback\n  const explicitKeyword = detectPowerKeyword(currentName)\n  \n  if (!explicitKeyword || explicitKeyword.category !== 'day_of_week') {\n    return null\n  }\n\n  const targetDayIndex = parseInt(explicitKeyword.value, 10)\n  if (isNaN(targetDayIndex)) return null\n\n  const today = new Date()\n  // Calculate next occurrence: same formula as drag-drop\n  const daysUntilTarget = ((7 + targetDayIndex - today.getDay()) % 7) || 7\n  const targetDate = new Date(today)\n  targetDate.setDate(today.getDate() + daysUntilTarget)\n\n  // Format as \"D.M.YY\" (e.g. 10.1.26)\n  const day = targetDate.getDate()\n  const month = targetDate.getMonth() + 1\n  const year = targetDate.getFullYear().toString().slice(-2)\n  \n  return `${day}.${month}.${year}`\n})\n\n// Watch for external name changes\nwatch(() => props.data.name, (newName) => {\n  sectionName.value = newName\n})\n\nconst updateName = () => {\n  if (sectionName.value !== props.data.name) {\n    emit('update', { name: sectionName.value })\n  }\n}\n\nconst toggleCollapse = () => {\n  // Use props.data.id (raw group ID), not props.id (Vue Flow node ID 'section-xxx')\n  const groupId = props.data?.id || props.id.replace('section-', '')\n  canvasStore.toggleSectionCollapse(groupId)\n}\n\n// TASK-068: Removed toggleAutoCollect - feature consolidated\n\nconst handleContextMenu = (event: MouseEvent) => {\n  emit('contextMenu', event, props.data)\n}\n\n// Resize event handlers\nconst handleResizeStart = (event: unknown) => {\n  emit('resizeStart', { sectionId: props.id, event })\n}\n\nconst rafId = ref<number | null>(null)\nconst isMounting = ref(true)\n\nonMounted(() => {\n  // Guard against spurious resize events during initial render\n  setTimeout(() => {\n    isMounting.value = false\n  }, 500)\n})\n\nconst handleResize = (event: unknown) => {\n  if (isMounting.value) return\n  if (rafId.value) cancelAnimationFrame(rafId.value)\n\n  rafId.value = requestAnimationFrame(() => {\n    // Try to cast for logging\n    const resizeEvent = event as { height?: number; params?: { height?: number } }\n    // Extract height being requested by NodeResizer\n    const nodeResizerHeight = resizeEvent?.height || resizeEvent?.params?.height\n\n    // Only log when near constraints to reduce noise\n    const nearMin = nodeResizerHeight && nodeResizerHeight <= 120\n    const nearMax = nodeResizerHeight && nodeResizerHeight >= 1950\n\n    emit('resize', { sectionId: props.id, event })\n    rafId.value = null\n  })\n}\n\nconst handleResizeEnd = (event: unknown) => {\n  if (isMounting.value) return\n  emit('resizeEnd', { sectionId: props.id, event })\n}\n</script>\n\n<style scoped>\n/* TASK-073 + TASK-079: Enhanced group outline styling for visibility and distinction */\n.section-node {\n  width: 100%;\n  height: 100%;\n  /* BUG-251 FIX: Use flexbox so section-body can fill remaining space */\n  display: flex;\n  flex-direction: column;\n  /* TASK-073: Double-line border effect - inner solid + outer subtle */\n  border: var(--space-0_5) solid rgba(var(--color-slate-50), 0.35) !important;\n  border-radius: var(--radius-lg);\n  /* BUG-1216: backdrop-filter removed for performance */\n  background: rgba(45, 48, 58, 0.92) !important;\n  position: relative;\n  z-index: 1;\n  /* TASK-073: Outer line via outline for double-border effect */\n  outline: var(--space-0_5) solid rgba(var(--color-slate-50), 0.12);\n  outline-offset: var(--space-0_5);\n  box-shadow:\n    0 var(--space-2) var(--space-6) rgba(var(--color-slate-900), 0.4),\n    inset 0 var(--space-0_5) 0 rgba(var(--color-slate-50), 0.08);\n  /* BUG-1216: removed 80px glow spread - too expensive during pan/zoom */\n  /* BUG-1216: explicit properties only - 'all' causes drag sluggishness */\n  transition: box-shadow var(--duration-fast) ease, border-color var(--duration-fast) ease, outline var(--duration-fast) ease, opacity var(--duration-fast) ease;\n}\n\n.section-node.is-dragging {\n  transition: none !important;\n  backdrop-filter: none !important;\n  -webkit-backdrop-filter: none !important;\n  filter: none !important;\n  box-shadow: 0 var(--space-2) var(--space-8) rgba(var(--color-slate-900), 0.4) !important;\n}\n\n.section-node:hover {\n  /* TASK-073: Enhanced hover - brighter border and stronger outline */\n  border-color: rgba(var(--color-slate-50), 0.50) !important;\n  outline: var(--space-0_5) solid rgba(var(--color-slate-50), 0.20);\n  outline-offset: var(--space-0_75);\n  box-shadow:\n    0 var(--space-3) var(--space-8) rgba(var(--color-slate-900), 0.5),\n    inset 0 var(--space-0_5) 0 rgba(var(--color-slate-50), 0.1);\n  /* BUG-1216: removed 100px glow spread on hover */\n}\n\n/* TASK-073: Selected group state - highly visible */\n.section-node.selected,\n.section-node:focus-within {\n  border-color: var(--accent-primary) !important;\n  outline: var(--space-0_5) solid rgba(99, 102, 241, 0.4);\n  outline-offset: var(--space-0_75);\n  box-shadow:\n    0 var(--space-5) var(--space-14) rgba(var(--color-slate-900), 0.55),\n    0 var(--space-2_5) var(--space-7) rgba(var(--color-slate-900), 0.35),\n    0 0 var(--space-25) var(--space-6_25) currentColor,\n    /* Accent glow for selection */\n    0 0 var(--space-5) var(--space-1) rgba(99, 102, 241, 0.4),\n    inset 0 var(--space-0_5) 0 rgba(var(--color-slate-50), 0.12);\n}\n\n.section-header {\n  position: relative;\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  padding-right: var(--space-12_5); /* Make space for count badge */\n  border-bottom: var(--space-0_5) solid var(--glass-border-soft);\n  border-radius: var(--radius-lg) var(--radius-lg) 0 0;\n  min-height: var(--space-10); /* Ensure consistent header height */\n  overflow: hidden; /* Prevent header overflow */\n  flex-shrink: 0; /* BUG-251: Don't shrink header when using flexbox layout */\n}\n\n.section-color-dot {\n  width: var(--space-2_5);\n  height: var(--space-2_5);\n  border-radius: var(--radius-full);\n  flex-shrink: 0;\n}\n\n.collapse-btn {\n  background: transparent;\n  border: none;\n  color: var(--text-secondary);\n  cursor: pointer;\n  padding: var(--space-1);\n  border-radius: var(--radius-sm);\n  transition: all var(--duration-fast);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n.collapse-btn:hover {\n  background: var(--glass-bg-heavy);\n  color: var(--text-primary);\n}\n\n.collapse-btn:focus {\n  outline: var(--space-0_5) solid var(--accent-primary);\n  outline-offset: var(--space-0_5);\n}\n\n/* Header Actions Container - handles overflow gracefully */\n.header-actions {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  flex-shrink: 1;\n  min-width: 0; /* Allow shrinking below content size */\n  overflow: hidden;\n  position: relative;\n}\n\n/* Fade mask to indicate overflow */\n.header-actions::after {\n  content: '';\n  position: absolute;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: var(--space-4);\n  background: linear-gradient(to right, transparent, var(--glass-bg-light));\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity var(--duration-fast);\n}\n\n/* Show fade mask when container might be overflowing */\n.section-header:hover .header-actions::after {\n  opacity: 0.8;\n}\n\n/* TASK-068: Removed .auto-collect-btn CSS - feature removed to reduce clutter */\n\n.section-name-input {\n  flex: 1 1 var(--space-15); /* Grow, shrink, min basis of 60px */\n  min-width: var(--space-15); /* Minimum readable width */\n  background: transparent;\n  border: none;\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  outline: none;\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-sm);\n  transition: background var(--duration-fast);\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n}\n\n.section-name-input:hover,\n.section-name-input:focus {\n  background: var(--glass-bg-medium);\n}\n\n/* TASK-130: Day-of-week date suffix styling */\n/* TASK-166: Made clickable for date picker */\n.section-date-suffix {\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  white-space: nowrap;\n  flex-shrink: 0;\n  padding-left: var(--space-1);\n}\n\n.section-date-suffix.clickable {\n  cursor: pointer;\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-sm);\n  transition: all var(--duration-fast);\n}\n\n.section-date-suffix.clickable:hover {\n  background: var(--glass-bg-medium);\n  color: var(--text-primary);\n}\n\n/* TASK-068: Removed .section-type-badge CSS - non-actionable element removed */\n\n.section-count {\n  /* Position badge absolutely to prevent overflow */\n  position: absolute;\n  top: 50%;\n  right: var(--space-3);\n  transform: translateY(-50%);\n\n  /* Badge styling */\n  background: var(--glass-bg-medium);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-sm);\n  min-width: var(--space-5);\n  text-align: center;\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n\n  /* Prevent interference with resize handles */\n  pointer-events: none;\n  z-index: 10;\n}\n\n.section-count.has-tasks {\n  background: var(--blue-bg-medium);\n  color: var(--blue-text);\n  border: var(--space-0_5) solid var(--blue-border-active);\n}\n\n.hidden-indicator {\n  font-size: var(--text-xs);\n  opacity: 0.7;\n  animation: hidden-pulse 2s ease-in-out infinite;\n}\n\n@keyframes hidden-pulse {\n  0%, 100% {\n    opacity: 0.5;\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(1.1);\n  }\n}\n\n/* BUG-251 FIX: Ensure section body captures right-click events */\n.section-body {\n  flex: 1;\n  min-height: var(--space-10); /* Minimum clickable area even when empty */\n  position: relative;\n  /* Ensure clicks on empty space are captured by the group, not the pane */\n  pointer-events: auto;\n}\n\n.section-node.collapsed {\n  min-height: auto;\n  height: auto !important;\n  cursor: pointer;\n  /* TASK-073: Subtle dashed outline for collapsed state distinction */\n  border-style: dashed !important;\n  border-color: var(--border-interactive) !important;\n  outline: var(--space-0_5) dashed rgba(var(--color-slate-50), 0.08);\n  outline-offset: var(--space-0_5);\n}\n\n.section-node.collapsed:hover {\n  border-color: rgba(var(--color-slate-50), 0.40) !important;\n  outline: var(--space-0_5) dashed rgba(var(--color-slate-50), 0.15);\n}\n\n.section-node.collapsed .section-header {\n  border-bottom: none;\n  border-radius: var(--radius-lg);\n}\n\n/* Hide Vue Flow handles when collapsed */\n.section-node.collapsed .vue-flow__handle {\n  display: none;\n}\n\n/* TASK-073: Collapsed + selected state with accent outline */\n.section-node.collapsed.vue-flow__node--selected {\n  border-color: var(--accent-primary) !important;\n  outline: var(--space-0_5) solid rgba(99, 102, 241, 0.4);\n  outline-offset: var(--space-0_75);\n  box-shadow:\n    0 var(--space-4) var(--space-12) rgba(var(--color-slate-900), 0.5),\n    0 var(--space-2) var(--space-6) rgba(var(--color-slate-900), 0.3),\n    0 0 var(--space-5) var(--space-1) rgba(99, 102, 241, 0.4);\n}\n\n/* Visual hint for collapsed sections */\n.section-node.collapsed::after {\n  content: '';\n  position: absolute;\n  bottom: var(--space-2);\n  right: var(--space-2);\n  width: 0;\n  height: 0;\n  border-left: var(--space-1) solid transparent;\n  border-right: var(--space-1) solid transparent;\n  border-top: var(--space-1) solid var(--text-secondary);\n  opacity: 0.3;\n}\n\n/* Power Mode Styles - TASK-068: Removed redundant .power-indicator (toggle button shows state) */\n\n.collect-wrapper {\n  position: relative;\n  flex-shrink: 0;\n}\n\n.collect-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-0_5);\n  background: var(--glass-bg-medium);\n  border: var(--space-0_5) solid var(--glass-border);\n  color: var(--text-secondary);\n  padding: var(--space-0_5) var(--space-1);\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n  font-size: var(--text-xs);\n}\n\n.collect-btn:hover {\n  background: var(--glass-bg-heavy);\n  color: var(--text-primary);\n}\n\n.collect-btn.has-matches {\n  background: var(--blue-bg-medium);\n  border-color: var(--blue-border-active);\n  color: var(--blue-text);\n}\n\n.collect-badge {\n  background: var(--blue-bg-medium);\n  color: var(--blue-text);\n  font-size: var(--text-2xs);\n  font-weight: var(--font-bold);\n  padding: 0 var(--space-1);\n  border-radius: var(--radius-full);\n  min-width: var(--space-3_5);\n  text-align: center;\n}\n\n.collect-menu {\n  position: absolute;\n  top: 100%;\n  right: 0;\n  margin-top: var(--space-1);\n  background: var(--glass-bg-solid);\n  backdrop-filter: blur(var(--space-5));\n  -webkit-backdrop-filter: blur(var(--space-5));\n  border: var(--space-0_5) solid var(--glass-border);\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-xl);\n  z-index: 100;\n  min-width: 180px;\n  overflow: hidden;\n}\n\n.collect-option {\n  display: block;\n  width: 100%;\n  padding: var(--space-2) var(--space-3);\n  background: transparent;\n  border: none;\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  text-align: left;\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.collect-option:hover {\n  background: var(--glass-bg-medium);\n  color: var(--text-primary);\n}\n\n.power-toggle-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--glass-bg-light);\n  border: var(--space-0_5) solid var(--glass-border);\n  color: var(--text-muted);\n  padding: var(--space-0_5);\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n  flex-shrink: 0;\n}\n\n.power-toggle-btn:hover {\n  background: var(--glass-bg-medium);\n  color: var(--text-secondary);\n}\n\n.power-toggle-btn.power-active {\n  background: var(--amber-bg-medium);\n  border-color: var(--amber-border-active);\n  color: var(--amber-text);\n}\n\n/* Settings Button */\n.settings-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--glass-bg-light);\n  border: var(--space-0_5) solid var(--glass-border);\n  color: var(--text-muted);\n  padding: var(--space-0_5);\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n  flex-shrink: 0;\n}\n\n.settings-btn:hover {\n  background: var(--glass-bg-medium);\n  color: var(--text-primary);\n  border-color: var(--glass-border-hover);\n}\n\n.settings-btn:active {\n  background: var(--glass-bg-heavy);\n  transform: scale(0.95);\n}\n\n/* TASK-290: Resize handle styles moved to canvas-view-overrides.css for global control */\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/GroupSettingsMenu.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/InboxFilters.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":334,"column":3,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":334,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":345,"column":3,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":345,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":356,"column":3,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":356,"endColumn":66}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"inbox-filters\">\n    <!-- TASK-1073: Sort Controls -->\n    <div class=\"sort-row\">\n      <span class=\"sort-label\">Sort:</span>\n      <div class=\"sort-buttons\">\n        <button\n          class=\"sort-btn\"\n          :class=\"{ active: sortBy === 'newest' }\"\n          title=\"Sort by newest first\"\n          @click=\"$emit('update:sortBy', 'newest')\"\n        >\n          <Clock :size=\"12\" />\n          Newest\n        </button>\n        <button\n          class=\"sort-btn\"\n          :class=\"{ active: sortBy === 'priority' }\"\n          title=\"Sort by priority (high first)\"\n          @click=\"$emit('update:sortBy', 'priority')\"\n        >\n          <Flag :size=\"12\" />\n          Priority\n        </button>\n        <button\n          class=\"sort-btn\"\n          :class=\"{ active: sortBy === 'dueDate' }\"\n          title=\"Sort by due date\"\n          @click=\"$emit('update:sortBy', 'dueDate')\"\n        >\n          <CalendarDays :size=\"12\" />\n          Due\n        </button>\n        <button\n          v-if=\"context !== 'canvas'\"\n          class=\"sort-btn\"\n          :class=\"{ active: sortBy === 'canvasOrder' }\"\n          title=\"Sort by canvas position (top to bottom)\"\n          @click=\"$emit('update:sortBy', 'canvasOrder')\"\n        >\n          <LayoutGrid :size=\"12\" />\n          Canvas\n        </button>\n      </div>\n    </div>\n\n    <div class=\"filter-divider\" />\n\n    <!-- Filter Chips Row -->\n    <div class=\"filter-chips-row\">\n      <!-- All Tasks (Reset Filters) -->\n      <button\n        class=\"filter-chip\"\n        :class=\"{ active: !hasActiveFilters }\"\n        title=\"Show all tasks\"\n        @click=\"clearAllFilters\"\n      >\n        <List :size=\"14\" />\n        <span class=\"chip-label\">All</span>\n      </button>\n\n      <!-- TASK-076: Hide Done Toggle -->\n      <button\n        v-if=\"hideDoneTasks !== undefined\"\n        class=\"filter-chip\"\n        :class=\"{ active: hideDoneTasks }\"\n        title=\"Hide completed tasks\"\n        @click=\"$emit('update:hideDoneTasks', !hideDoneTasks)\"\n      >\n        <CheckCircle2 :size=\"14\" />\n        <span class=\"chip-label\">{{ hideDoneTasks ? 'Hiding Done' : 'Show Done' }}</span>\n      </button>\n\n      <!-- Unscheduled Toggle -->\n      <button\n        class=\"filter-chip\"\n        :class=\"{ active: unscheduledOnly }\"\n        title=\"Show only unscheduled tasks (not on calendar)\"\n        @click=\"$emit('update:unscheduledOnly', !unscheduledOnly)\"\n      >\n        <CalendarOff :size=\"14\" />\n        <span class=\"chip-label\">Unscheduled</span>\n        <span v-if=\"unscheduledCount > 0\" class=\"chip-count\">{{ unscheduledCount }}</span>\n      </button>\n\n      <!-- TASK-1246: Priority Multi-Select Filter -->\n      <div ref=\"priorityDropdownRef\" class=\"filter-dropdown\">\n        <button\n          class=\"filter-chip\"\n          :class=\"{ active: selectedPriorities.size > 0 }\"\n          @click=\"showPriorityDropdown = !showPriorityDropdown\"\n        >\n          <Flag :size=\"14\" />\n          <span class=\"chip-label\">{{ priorityLabel }}</span>\n          <ChevronDown :size=\"12\" class=\"chevron\" :class=\"{ rotated: showPriorityDropdown }\" />\n        </button>\n        <div v-if=\"showPriorityDropdown\" class=\"dropdown-menu\">\n          <button\n            class=\"dropdown-item\"\n            @click=\"clearPriorities\"\n          >\n            All Priorities\n          </button>\n          <button\n            v-for=\"priority in priorities\"\n            :key=\"priority.value\"\n            class=\"dropdown-item\"\n            :class=\"{ selected: selectedPriorities.has(priority.value) }\"\n            @click.stop=\"togglePriority(priority.value)\"\n          >\n            <span class=\"checkbox-indicator\" :class=\"{ checked: selectedPriorities.has(priority.value) }\">\n              <Check v-if=\"selectedPriorities.has(priority.value)\" :size=\"10\" />\n            </span>\n            <span class=\"priority-dot\" :class=\"`priority-${priority.value}`\" />\n            {{ priority.label }}\n            <span class=\"item-count\">{{ getPriorityCount(priority.value) }}</span>\n          </button>\n        </div>\n      </div>\n\n      <!-- TASK-1246: Duration Multi-Select Filter -->\n      <div ref=\"durationDropdownRef\" class=\"filter-dropdown\">\n        <button\n          class=\"filter-chip\"\n          :class=\"{ active: selectedDurations.size > 0 }\"\n          @click=\"showDurationDropdown = !showDurationDropdown\"\n        >\n          <Clock :size=\"14\" />\n          <span class=\"chip-label\">{{ durationLabel }}</span>\n          <ChevronDown :size=\"12\" class=\"chevron\" :class=\"{ rotated: showDurationDropdown }\" />\n        </button>\n        <div v-if=\"showDurationDropdown\" class=\"dropdown-menu\">\n          <button\n            class=\"dropdown-item\"\n            @click=\"clearDurations\"\n          >\n            All Durations\n          </button>\n          <button\n            v-for=\"duration in durations\"\n            :key=\"duration.value\"\n            class=\"dropdown-item\"\n            :class=\"{ selected: selectedDurations.has(duration.value) }\"\n            @click.stop=\"toggleDuration(duration.value)\"\n          >\n            <span class=\"checkbox-indicator\" :class=\"{ checked: selectedDurations.has(duration.value) }\">\n              <Check v-if=\"selectedDurations.has(duration.value)\" :size=\"10\" />\n            </span>\n            <span class=\"duration-icon\">{{ duration.icon }}</span>\n            {{ duration.label }}\n            <span class=\"item-count\">{{ getDurationCount(duration.value) }}</span>\n          </button>\n        </div>\n      </div>\n\n      <!-- TASK-1246: Project Multi-Select Filter -->\n      <div ref=\"projectDropdownRef\" class=\"filter-dropdown\">\n        <button\n          class=\"filter-chip\"\n          :class=\"{ active: selectedProjects.size > 0 }\"\n          @click=\"showProjectDropdown = !showProjectDropdown\"\n        >\n          <FolderOpen :size=\"14\" />\n          <span class=\"chip-label\">{{ projectLabel }}</span>\n          <ChevronDown :size=\"12\" class=\"chevron\" :class=\"{ rotated: showProjectDropdown }\" />\n        </button>\n        <div v-if=\"showProjectDropdown\" class=\"dropdown-menu\">\n          <button\n            class=\"dropdown-item\"\n            @click=\"clearProjects\"\n          >\n            All Projects\n          </button>\n          <button\n            class=\"dropdown-item\"\n            :class=\"{ selected: selectedProjects.has('none') }\"\n            @click.stop=\"toggleProject('none')\"\n          >\n            <span class=\"checkbox-indicator\" :class=\"{ checked: selectedProjects.has('none') }\">\n              <Check v-if=\"selectedProjects.has('none')\" :size=\"10\" />\n            </span>\n            <span class=\"project-icon\">&#128229;</span>\n            No Project\n            <span class=\"item-count\">{{ getProjectCount(null) }}</span>\n          </button>\n          <button\n            v-for=\"project in projects\"\n            :key=\"project.id\"\n            class=\"dropdown-item\"\n            :class=\"{ selected: selectedProjects.has(project.id) }\"\n            @click.stop=\"toggleProject(project.id)\"\n          >\n            <span class=\"checkbox-indicator\" :class=\"{ checked: selectedProjects.has(project.id) }\">\n              <Check v-if=\"selectedProjects.has(project.id)\" :size=\"10\" />\n            </span>\n            <span class=\"project-icon\">{{ project.emoji || '&#128193;' }}</span>\n            {{ project.name }}\n            <span class=\"item-count\">{{ getProjectCount(project.id) }}</span>\n          </button>\n        </div>\n      </div>\n\n      <!-- Clear All Filters -->\n      <button\n        v-if=\"hasActiveFilters\"\n        class=\"clear-filters-btn\"\n        title=\"Clear all filters\"\n        @click=\"clearAllFilters\"\n      >\n        <X :size=\"14\" />\n      </button>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onBeforeUnmount } from 'vue'\nimport { CalendarOff, Flag, FolderOpen, ChevronDown, X, List, Clock, CheckCircle2, CalendarDays, Check, LayoutGrid } from 'lucide-vue-next'\nimport type { Task, Project } from '@/stores/tasks'\nimport type { SortByType } from '@/composables/inbox/useUnifiedInboxState'\n// TASK-144: Use centralized duration categories\nimport { type DurationCategory, DURATION_FILTER_OPTIONS, matchesDurationCategory } from '@/utils/durationCategories'\n\n\n// TASK-1246: Multi-select props (Set types)\ninterface Props {\n  tasks: Task[]\n  projects: Project[]\n  unscheduledOnly: boolean\n  selectedPriorities: Set<string>\n  selectedProjects: Set<string>\n  selectedDurations: Set<DurationCategory>\n  hideDoneTasks?: boolean // TASK-076: Separate done filter for each view\n  sortBy?: SortByType // TASK-1073: Sort option\n  context?: string // Hide canvas sort when inside canvas view\n}\n\nconst props = defineProps<Props>()\n\nconst emit = defineEmits<{\n  'update:unscheduledOnly': [value: boolean]\n  'update:selectedPriorities': [value: Set<string>]\n  'update:selectedProjects': [value: Set<string>]\n  'update:selectedDurations': [value: Set<DurationCategory>]\n  'update:hideDoneTasks': [value: boolean] // TASK-076\n  'update:sortBy': [value: SortByType] // TASK-1073\n  clearAll: []\n}>()\n\n// Dropdown visibility state\nconst showPriorityDropdown = ref(false)\nconst showProjectDropdown = ref(false)\nconst showDurationDropdown = ref(false)\nconst priorityDropdownRef = ref<HTMLElement>()\nconst projectDropdownRef = ref<HTMLElement>()\nconst durationDropdownRef = ref<HTMLElement>()\n\n// Priority options\nconst priorities = [\n  { value: 'high' as const, label: 'High' },\n  { value: 'medium' as const, label: 'Medium' },\n  { value: 'low' as const, label: 'Low' }\n]\n\n// TASK-144: Duration options from centralized source\nconst durations = DURATION_FILTER_OPTIONS\n\n// Computed: Check if task is scheduled on calendar (has instances with dates)\nconst isScheduledOnCalendar = (task: Task): boolean => {\n  if (!task.instances || task.instances.length === 0) return false\n  return task.instances.some(inst => inst.scheduledDate)\n}\n\n// Computed: Count of unscheduled tasks\nconst unscheduledCount = computed(() => {\n  return props.tasks.filter(task => !isScheduledOnCalendar(task)).length\n})\n\n// TASK-1246: Computed labels with count badges\nconst priorityLabel = computed(() => {\n  const count = props.selectedPriorities.size\n  if (count === 0) return 'Priority'\n  if (count === 1) return priorities.find(p => p.value === [...props.selectedPriorities][0])?.label || 'Priority'\n  return `Priority (${count})`\n})\n\nconst durationLabel = computed(() => {\n  const count = props.selectedDurations.size\n  if (count === 0) return 'Duration'\n  if (count === 1) return durations.find(d => d.value === [...props.selectedDurations][0])?.label.split(' ')[0] || 'Duration'\n  return `Duration (${count})`\n})\n\nconst projectLabel = computed(() => {\n  const count = props.selectedProjects.size\n  if (count === 0) return 'Project'\n  if (count === 1) {\n    const first = [...props.selectedProjects][0]\n    if (first === 'none') return 'No Project'\n    const project = props.projects.find(p => p.id === first)\n    return project?.name || 'Project'\n  }\n  return `Project (${count})`\n})\n\n// Computed: Check if any filters are active\nconst hasActiveFilters = computed(() => {\n  return props.unscheduledOnly || props.selectedPriorities.size > 0 || props.selectedProjects.size > 0 || props.selectedDurations.size > 0 || props.hideDoneTasks\n})\n\n// Get count of tasks with specific priority\nconst getPriorityCount = (priority: 'high' | 'medium' | 'low'): number => {\n  return props.tasks.filter(task => task.priority === priority).length\n}\n\n// Get count of tasks with specific project\nconst getProjectCount = (projectId: string | null): number => {\n  if (projectId === null) {\n    return props.tasks.filter(task => !task.projectId).length\n  }\n  return props.tasks.filter(task => task.projectId === projectId).length\n}\n\n// TASK-144: Get count of tasks with specific duration using centralized matching\nconst getDurationCount = (duration: DurationCategory): number => {\n  return props.tasks.filter(task =>\n    matchesDurationCategory(task.estimatedDuration, duration)\n  ).length\n}\n\n// TASK-1246: Toggle handlers (multi-select, don't close dropdown)\nconst togglePriority = (priority: 'high' | 'medium' | 'low') => {\n  const next = new Set(props.selectedPriorities)\n  next.has(priority) ? next.delete(priority) : next.add(priority)\n  emit('update:selectedPriorities', next)\n}\n\nconst clearPriorities = () => {\n  emit('update:selectedPriorities', new Set())\n  showPriorityDropdown.value = false\n}\n\nconst toggleProject = (projectId: string) => {\n  const next = new Set(props.selectedProjects)\n  next.has(projectId) ? next.delete(projectId) : next.add(projectId)\n  emit('update:selectedProjects', next)\n}\n\nconst clearProjects = () => {\n  emit('update:selectedProjects', new Set())\n  showProjectDropdown.value = false\n}\n\nconst toggleDuration = (duration: DurationCategory) => {\n  const next = new Set(props.selectedDurations)\n  next.has(duration) ? next.delete(duration) : next.add(duration)\n  emit('update:selectedDurations', next)\n}\n\nconst clearDurations = () => {\n  emit('update:selectedDurations', new Set())\n  showDurationDropdown.value = false\n}\n\n// Clear all filters\nconst clearAllFilters = () => {\n  emit('update:unscheduledOnly', false)\n  emit('update:selectedPriorities', new Set())\n  emit('update:selectedProjects', new Set())\n  emit('update:selectedDurations', new Set())\n  emit('update:hideDoneTasks', false) // TASK-076\n  emit('clearAll')\n}\n\n// Close dropdowns when clicking outside\nconst handleClickOutside = (event: MouseEvent) => {\n  const target = event.target as Node\n  if (priorityDropdownRef.value && !priorityDropdownRef.value.contains(target)) {\n    showPriorityDropdown.value = false\n  }\n  if (projectDropdownRef.value && !projectDropdownRef.value.contains(target)) {\n    showProjectDropdown.value = false\n  }\n  if (durationDropdownRef.value && !durationDropdownRef.value.contains(target)) {\n    showDurationDropdown.value = false\n  }\n}\n\nonMounted(() => {\n  document.addEventListener('click', handleClickOutside)\n})\n\nonBeforeUnmount(() => {\n  document.removeEventListener('click', handleClickOutside)\n})\n</script>\n\n<style scoped>\n.inbox-filters {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  border-bottom: 1px solid var(--border-subtle);\n}\n\n/* TASK-1073: Sort Row */\n.sort-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.sort-label {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  font-weight: 500;\n}\n\n.sort-buttons {\n  display: flex;\n  gap: var(--space-1);\n}\n\n.sort-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: transparent;\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n}\n\n.sort-btn:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.sort-btn.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--state-active-text);\n}\n\n.filter-divider {\n  height: 1px;\n  background: var(--border-subtle);\n  margin: var(--space-1) 0;\n}\n\n/* Filter chips row */\n.filter-chips-row {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--space-2);\n}\n\n.filter-chip {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: var(--glass-bg-light);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-full);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n  white-space: nowrap;\n}\n\n.filter-chip:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.filter-chip.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--state-active-text);\n}\n\n.chip-label {\n  max-width: 80px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.chip-count {\n  background: var(--accent-primary);\n  color: white;\n  font-size: var(--text-2xs);\n  font-weight: var(--font-semibold);\n  padding: 0 var(--space-1);\n  border-radius: var(--radius-full);\n  min-width: var(--space-3_5);\n  height: var(--space-3_5);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.filter-chip.active .chip-count {\n  background: var(--surface-primary);\n  color: var(--accent-primary);\n}\n\n.chevron {\n  transition: transform var(--duration-fast) var(--spring-smooth);\n}\n\n.chevron.rotated {\n  transform: rotate(180deg);\n}\n\n.filter-dropdown {\n  position: relative;\n}\n\n.dropdown-menu {\n  position: absolute;\n  top: calc(100% + var(--space-1));\n  left: 0;\n  z-index: 100;\n  min-width: 160px;\n  max-height: 240px;\n  overflow-y: auto;\n  background: var(--dropdown-bg);\n  backdrop-filter: blur(16px);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  box-shadow: var(--shadow-xl);\n  padding: var(--space-1);\n}\n\n.dropdown-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  width: 100%;\n  padding: var(--space-2) var(--space-3);\n  background: transparent;\n  border: none;\n  border-radius: var(--radius-md);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  text-align: left;\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n}\n\n.dropdown-item:hover {\n  background: var(--glass-bg-medium);\n  color: var(--text-primary);\n}\n\n.dropdown-item.selected {\n  background: var(--state-active-bg);\n  color: var(--state-active-text);\n}\n\n/* TASK-1246: Checkbox indicator for multi-select */\n.checkbox-indicator {\n  width: var(--space-3_5);\n  height: var(--space-3_5);\n  border: var(--space-px) solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n  transition: all var(--duration-fast) var(--spring-smooth);\n}\n\n.checkbox-indicator.checked {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--state-active-text);\n}\n\n.priority-dot {\n  width: var(--space-2);\n  height: var(--space-2);\n  border-radius: 50%;\n  flex-shrink: 0;\n}\n\n.priority-dot.priority-high {\n  background: var(--color-priority-high);\n}\n\n.priority-dot.priority-medium {\n  background: var(--color-priority-medium);\n}\n\n.priority-dot.priority-low {\n  background: var(--color-priority-low);\n}\n\n.project-icon, .duration-icon {\n  font-size: var(--text-sm);\n}\n\n.item-count {\n  margin-left: auto;\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n}\n\n.clear-filters-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 24px;\n  height: 24px;\n  background: var(--glass-bg-light);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-full);\n  color: var(--text-muted);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n}\n\n.clear-filters-btn:hover {\n  background: var(--danger-bg-light);\n  border-color: var(--danger-border-medium);\n  color: var(--color-danger);\n}\n\n/* Scrollbar for dropdown */\n.dropdown-menu::-webkit-scrollbar {\n  width: var(--space-1);\n}\n\n.dropdown-menu::-webkit-scrollbar-track {\n  background: transparent;\n}\n\n.dropdown-menu::-webkit-scrollbar-thumb {\n  background: var(--glass-border);\n  border-radius: var(--radius-full);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/InboxTimeFilters.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'today' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":95,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":95,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'todayStr' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":168,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":168,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"inbox-time-filters\">\n    <div class=\"filter-buttons\">\n      <button\n        v-for=\"filter in timeFilters\"\n        :key=\"filter.key\"\n        class=\"filter-btn\"\n        :class=\"{ active: activeFilter === filter.key }\"\n        :title=\"`${filter.description} (${filter.count} tasks)`\"\n        @click=\"$emit('filterChanged', filter.key)\"\n      >\n        <component :is=\"filter.icon\" :size=\"14\" />\n        <span v-if=\"filter.count > 0\" class=\"filter-count\">{{ filter.count }}</span>\n      </button>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, type Component } from 'vue'\nimport {\n  Inbox,\n  Clock,\n  Calendar,\n  CalendarDays,\n  CalendarRange,\n  CalendarPlus,\n  CalendarX\n} from 'lucide-vue-next'\nimport type { Task } from '@/stores/tasks'\n\ninterface TimeFilter {\n  key: 'all' | 'now' | 'today' | 'tomorrow' | 'next3days' | 'thisWeek' | 'noDate'\n  label: string\n  description: string\n  icon: Component\n  count: number\n}\n\ninterface Props {\n  tasks: Task[]\n  activeFilter: string\n}\n\nconst props = defineProps<Props>()\n\ndefineEmits<{\n  filterChanged: [filterKey: string]\n}>()\n\n// Helper functions for date calculations\nconst getToday = () => {\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  return today\n}\n\nconst getTomorrow = () => {\n  const tomorrow = new Date(getToday())\n  tomorrow.setDate(tomorrow.getDate() + 1)\n  return tomorrow\n}\n\n// TASK-1089: Use calendar week ending at Sunday 00:00 (exclusive)\nconst getWeekEnd = () => {\n  const today = getToday()\n  const dayOfWeek = today.getDay()\n  // When today is Sunday (0), we want NEXT Sunday (7 days away)\n  // When today is Monday (1), we want this Sunday (6 days away)\n  const daysUntilSunday = dayOfWeek === 0 ? 7 : (7 - dayOfWeek)\n  const weekEnd = new Date(today)\n  weekEnd.setDate(today.getDate() + daysUntilSunday)\n  return weekEnd\n}\n\nconst _isToday = (dateStr?: string) => {\n  if (!dateStr) return false\n  const today = getToday()\n  const date = new Date(dateStr)\n  date.setHours(0, 0, 0, 0)\n  return date.getTime() === today.getTime()\n}\n\nconst _isTomorrow = (dateStr?: string) => {\n  if (!dateStr) return false\n  const tomorrow = getTomorrow()\n  const date = new Date(dateStr)\n  date.setHours(0, 0, 0, 0)\n  return date.getTime() === tomorrow.getTime()\n}\n\n// TASK-1089: Use calendar week ending at Sunday 00:00 (exclusive)\nconst _isThisWeek = (dateStr?: string) => {\n  if (!dateStr) return false\n  const today = getToday()\n  const weekEnd = getWeekEnd()\n  const date = new Date(dateStr)\n  date.setHours(0, 0, 0, 0)\n  // Include overdue tasks (< today) and tasks due before Sunday\n  return date < weekEnd\n}\n\nconst hasDate = (task: Task) => {\n  // Check instances first (new format)\n  if (task.instances && task.instances.length > 0) {\n    return task.instances.some(inst => inst.scheduledDate)\n  }\n  // Fallback to legacy scheduledDate\n  return !!task.scheduledDate\n}\n\nconst filterTasks = (filterKey: string) => {\n  return props.tasks.filter(task => {\n    switch (filterKey) {\n      case 'all':\n        return true\n\n      case 'now': {\n        // Tasks due today, created today, currently in progress, or currently running (timer active)\n        const today = getToday().toISOString().split('T')[0]\n        const taskCreatedDate = new Date(task.createdAt)\n        taskCreatedDate.setHours(0, 0, 0, 0)\n\n        // Check instances for today scheduling\n        if (task.instances && task.instances.length > 0) {\n          if (task.instances.some(inst => inst.scheduledDate === today)) return true\n        }\n        // Fallback to legacy scheduledDate\n        if (task.scheduledDate === today) return true\n\n        // Tasks created today\n        if (taskCreatedDate.getTime() === getToday().getTime()) return true\n\n        // Tasks due today\n        if (task.dueDate === today) return true\n\n        // Tasks currently in progress\n        if (task.status === 'in_progress') return true\n\n        return false\n      }\n\n      case 'today': {\n        // Tasks scheduled for today\n        const todayStr = getToday().toISOString().split('T')[0]\n\n        // Check instances first\n        if (task.instances && task.instances.length > 0) {\n          return task.instances.some(inst => inst.scheduledDate === todayStr)\n        }\n        // Fallback to legacy scheduledDate\n        return task.scheduledDate === todayStr\n      }\n\n      case 'tomorrow': {\n        // Tasks scheduled for tomorrow\n        const tomorrowStr = getTomorrow().toISOString().split('T')[0]\n\n        // Check instances first\n        if (task.instances && task.instances.length > 0) {\n          return task.instances.some(inst => inst.scheduledDate === tomorrowStr)\n        }\n        // Fallback to legacy scheduledDate\n        return task.scheduledDate === tomorrowStr\n      }\n\n      case 'next3days': {\n        const todayStr = getToday().toISOString().split('T')[0]\n        const boundary = new Date(getToday())\n        boundary.setDate(boundary.getDate() + 3)\n        const boundaryStr = boundary.toISOString().split('T')[0]\n        // Check instances first (authoritative)\n        if (task.instances && task.instances.length > 0) {\n          return task.instances.some(inst =>\n            inst.scheduledDate && inst.scheduledDate < boundaryStr\n          )\n        }\n        // Fallback to legacy scheduledDate\n        if (!task.scheduledDate) return false\n        return task.scheduledDate < boundaryStr\n      }\n\n      case 'thisWeek': {\n        // TASK-1089: Tasks scheduled within calendar week (until Sunday 00:00, exclusive)\n        const weekEndStr = getWeekEnd().toISOString().split('T')[0]\n\n        // Check instances first - include overdue and tasks before Sunday\n        if (task.instances && task.instances.length > 0) {\n          return task.instances.some(inst =>\n            inst.scheduledDate && inst.scheduledDate < weekEndStr\n          )\n        }\n        // Fallback to legacy scheduledDate\n        if (!task.scheduledDate) return false\n        return task.scheduledDate < weekEndStr\n      }\n\n      case 'noDate':\n        // Tasks without any scheduled date\n        return !hasDate(task)\n\n      default:\n        return true\n    }\n  })\n}\n\n// Computed filter definitions with counts\nconst timeFilters = computed((): TimeFilter[] => [\n  {\n    key: 'all',\n    label: 'All',\n    description: 'Show all inbox tasks',\n    icon: Inbox,\n    count: props.tasks.length\n  },\n  {\n    key: 'now',\n    label: 'Now',\n    description: 'Tasks for right now (today, in progress, or created today)',\n    icon: Clock,\n    count: filterTasks('now').length\n  },\n  {\n    key: 'today',\n    label: 'Today',\n    description: 'Tasks scheduled for today',\n    icon: Calendar,\n    count: filterTasks('today').length\n  },\n  {\n    key: 'tomorrow',\n    label: 'Tomorrow',\n    description: 'Tasks scheduled for tomorrow',\n    icon: CalendarDays,\n    count: filterTasks('tomorrow').length\n  },\n  {\n    key: 'next3days',\n    label: 'Next 3 Days',\n    description: 'Tasks due in the next 3 days',\n    icon: CalendarRange,\n    count: filterTasks('next3days').length\n  },\n  {\n    key: 'thisWeek',\n    label: 'This Week',\n    description: 'Tasks scheduled until Sunday (calendar week)',\n    icon: CalendarPlus,\n    count: filterTasks('thisWeek').length\n  },\n  {\n    key: 'noDate',\n    label: 'No Date',\n    description: 'Tasks without a scheduled date',\n    icon: CalendarX,\n    count: filterTasks('noDate').length\n  }\n])\n</script>\n\n<style scoped>\n.inbox-time-filters {\n  padding: var(--space-3) var(--space-4) 0;\n}\n\n.filter-buttons {\n  display: flex;\n  gap: var(--space-0_5);\n}\n\n.filter-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  width: var(--space-8);\n  height: var(--space-8);\n  background: var(--glass-bg-light);\n  backdrop-filter: var(--overlay-component-backdrop);\n  border: var(--space-px) solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n  overflow: hidden;\n}\n\n.filter-btn:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n  transform: translateY(-1px) scale(1.05);\n  box-shadow: var(--state-hover-shadow);\n}\n\n.filter-btn.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  backdrop-filter: var(--state-active-glass);\n  color: var(--state-active-text);\n  box-shadow: var(--state-hover-shadow), var(--state-hover-glow);\n  transform: scale(1.05);\n}\n\n.filter-count {\n  position: absolute;\n  top: var(--space-neg-px);\n  right: var(--space-neg-px);\n  background: var(--accent-primary);\n  border: var(--space-px) solid var(--surface-primary);\n  border-radius: var(--radius-full);\n  font-size: var(--text-2xs);\n  font-weight: var(--font-semibold);\n  padding: 0 var(--space-0_5);\n  min-width: var(--space-3);\n  height: var(--space-3);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  line-height: 1;\n  box-shadow: var(--shadow-sm);\n}\n\n.filter-btn.active .filter-count {\n  background: var(--surface-primary);\n  color: var(--accent-primary);\n  border-color: var(--accent-primary);\n}\n\n/* Icon scaling for different screen sizes */\n@media (max-width: 320px) {\n  .filter-btn {\n    width: var(--space-7);\n    height: var(--space-7);\n  }\n\n  .filter-btn:hover,\n  .filter-btn.active {\n    transform: scale(1.02);\n  }\n}\n\n/* Smooth transitions for count badges */\n.filter-count {\n  transition: all var(--duration-fast) var(--spring-smooth);\n}\n\n/* Ensure icons are properly centered */\n.filter-btn > :first-child {\n  flex-shrink: 0;\n}\n</style>","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/MultiSelectionOverlay.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/ResizeHandle.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/SectionSelectionModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/SectionSelector.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3096,3099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3096,3099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div ref=\"selectRef\" class=\"section-selector\" :class=\"{ 'is-compact': compact }\">\n    <button\n      ref=\"triggerElement\"\n      type=\"button\"\n      class=\"select-trigger\"\n      :class=\"{ 'is-open': isOpen }\"\n      @click=\"toggleDropdown\"\n    >\n      <div v-if=\"selectedSection\" class=\"selected-info\">\n        <div\n          class=\"section-color-dot\"\n          :style=\"{ backgroundColor: selectedSection.color || 'var(--brand-primary)' }\"\n        />\n        <span class=\"select-value\">{{ selectedSection.name }}</span>\n      </div>\n      <span v-else class=\"select-value placeholder\">{{ placeholder }}</span>\n\n      <ChevronDown :size=\"compact ? 12 : 14\" class=\"select-icon\" :class=\"{ 'is-open': isOpen }\" />\n    </button>\n\n    <Teleport to=\"body\">\n      <Transition name=\"dropdown\">\n        <div\n          v-if=\"isOpen\"\n          :style=\"dropdownStyle\"\n          role=\"listbox\"\n        >\n          <!-- Special Option: None / Inbox -->\n          <div\n            class=\"select-option none-option\"\n            :class=\"{ 'is-selected': !modelValue }\"\n            role=\"option\"\n            @click=\"selectOption(null)\"\n          >\n            <Inbox :size=\"14\" />\n            <span>None (Move to Inbox)</span>\n          </div>\n\n          <!-- Section Groups -->\n          <div v-for=\"group in categorizedSections\" :key=\"group.type\" class=\"dropdown-group\">\n            <div class=\"group-header\">\n              {{ group.label }}\n            </div>\n            <div\n              v-for=\"section in group.sections\"\n              :key=\"section.id\"\n              class=\"select-option\"\n              :class=\"{ 'is-selected': section.id === modelValue }\"\n              role=\"option\"\n              @click=\"selectOption(section.id)\"\n            >\n              <div \n                class=\"section-color-dot\" \n                :style=\"{ backgroundColor: section.color || 'var(--brand-primary)' }\"\n              />\n              <span>{{ section.name }}</span>\n            </div>\n          </div>\n\n          <div v-if=\"canvasStore.sections.length === 0\" class=\"empty-state\">\n            No sections found on canvas\n          </div>\n        </div>\n      </Transition>\n    </Teleport>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onBeforeUnmount, nextTick } from 'vue'\nimport { ChevronDown, Inbox } from 'lucide-vue-next'\nimport { useCanvasStore } from '@/stores/canvas'\n\ninterface Props {\n  modelValue: string | null\n  placeholder?: string\n  compact?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  placeholder: 'Select a section...',\n  compact: false\n})\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string | null]\n  'change': [value: string | null]\n}>()\n\nconst canvasStore = useCanvasStore()\nconst selectRef = ref<HTMLElement>()\nconst triggerElement = ref<HTMLButtonElement>()\nconst isOpen = ref(false)\n\n// Unique ID for this dropdown instance (for global close coordination)\nconst dropdownId = Math.random().toString(36).substring(2, 9)\n\n// Dropdown positioning (copied from CustomSelect for consistency)\nconst dropdownStyle = ref<any>({\n  position: 'fixed',\n  top: '0px',\n  left: '0px',\n  width: '0px',\n  minWidth: '0px'\n})\n\nconst calculateDropdownPosition = () => {\n  if (!triggerElement.value) return\n\n  const rect = triggerElement.value.getBoundingClientRect()\n  const viewportHeight = window.innerHeight\n  const spaceBelow = viewportHeight - rect.bottom\n  const spaceAbove = rect.top\n  \n  // Estimate height: header (30) + options (8 options * 40 approx)\n  const dropdownHeight = Math.min(350, 48 + (canvasStore.sections.length + 1) * 40) \n\n  const positionAbove = spaceBelow < dropdownHeight && spaceAbove > spaceBelow\n\n  dropdownStyle.value = {\n    position: 'fixed',\n    top: positionAbove ? `${rect.top - dropdownHeight - 4}px` : `${rect.bottom + 4}px`,\n    left: `${rect.left}px`,\n    minWidth: '200px',\n    width: 'auto' as const // Explicitly cast 'auto' to ensure type compatibility\n  }\n}\n\nconst selectedSection = computed(() => {\n  if (!props.modelValue) return null\n  return canvasStore.sections.find(s => s.id === props.modelValue) || null\n})\n\nconst categorizedSections = computed(() => {\n  const sections = canvasStore.sections\n  const groups = [\n    { type: 'custom', label: 'Custom Groups', sections: sections.filter(s => s.type === 'custom') },\n    { type: 'status', label: 'Status Columns', sections: sections.filter(s => s.type === 'status') },\n    { type: 'priority', label: 'Priority Areas', sections: sections.filter(s => s.type === 'priority') },\n    { type: 'timeline', label: 'Timeline Sections', sections: sections.filter(s => s.type === 'timeline') },\n    { type: 'project', label: 'Project Containers', sections: sections.filter(s => s.type === 'project') }\n  ]\n  \n  return groups.filter(g => g.sections.length > 0)\n})\n\nconst toggleDropdown = async () => {\n  isOpen.value = !isOpen.value\n  if (isOpen.value) {\n    // Close any other open dropdowns\n    window.dispatchEvent(new CustomEvent('close-all-dropdowns', { detail: { except: dropdownId } }))\n    await nextTick()\n    calculateDropdownPosition()\n  }\n}\n\nconst closeDropdown = () => {\n  isOpen.value = false\n}\n\nconst selectOption = (sectionId: string | null) => {\n  emit('update:modelValue', sectionId)\n  emit('change', sectionId)\n  closeDropdown()\n}\n\nconst handleClickOutside = (event: MouseEvent) => {\n  if (selectRef.value && !selectRef.value.contains(event.target as Node)) {\n    closeDropdown()\n  }\n}\n\n// Handle global close event (when another dropdown opens)\nconst handleGlobalClose = (event: Event) => {\n  const customEvent = event as CustomEvent<{ except: string }>\n  if (customEvent.detail?.except !== dropdownId && isOpen.value) {\n    closeDropdown()\n  }\n}\n\nonMounted(() => {\n  document.addEventListener('click', handleClickOutside)\n  window.addEventListener('resize', calculateDropdownPosition)\n  window.addEventListener('scroll', closeDropdown, true)\n  window.addEventListener('close-all-dropdowns', handleGlobalClose)\n})\n\nonBeforeUnmount(() => {\n  document.removeEventListener('click', handleClickOutside)\n  window.removeEventListener('resize', calculateDropdownPosition)\n  window.removeEventListener('scroll', closeDropdown, true)\n  window.removeEventListener('close-all-dropdowns', handleGlobalClose)\n})\n</script>\n\n<style scoped>\n.section-selector {\n  position: relative;\n  width: 100%;\n}\n\n.select-trigger {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-medium);\n  backdrop-filter: var(--overlay-component-backdrop);\n  -webkit-backdrop-filter: var(--overlay-component-backdrop);\n  border: var(--space-px) solid var(--glass-border-hover);\n  border-radius: var(--radius-lg);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  cursor: pointer;\n  outline: none;\n  transition: all var(--duration-normal) var(--ease-out);\n  min-height: var(--space-10);\n}\n\n.select-trigger:hover {\n  border-color: var(--border-interactive);\n  background: var(--glass-bg-heavy);\n}\n\n.selected-info {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  flex: 1;\n}\n\n.section-color-dot {\n  width: var(--space-2_5);\n  height: var(--space-2_5);\n  border-radius: 50%;\n  flex-shrink: 0;\n}\n\n.select-value {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.select-value.placeholder {\n  color: var(--text-muted);\n}\n\n.select-icon {\n  color: var(--text-muted);\n  transition: transform var(--duration-normal) var(--ease-out);\n}\n\n.select-icon.is-open {\n  transform: rotate(180deg);\n}\n\n.select-dropdown {\n  /* Position is set via inline style from Teleport */\n  z-index: var(--z-tooltip);\n\n  /* Use design tokens for consistent overlay styling */\n  background: var(--overlay-component-bg);\n  backdrop-filter: var(--overlay-component-backdrop);\n  -webkit-backdrop-filter: var(--overlay-component-backdrop);\n  border: var(--overlay-component-border);\n  box-shadow: var(--overlay-component-shadow);\n  border-radius: var(--radius-xl);\n\n  max-height: 350px;\n  overflow-y: auto;\n  padding: var(--space-2);\n  min-width: 200px;\n\n  /* Ensure backdrop-filter works */\n  isolation: isolate;\n  transform: translateZ(0);\n}\n\n.select-option {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-2_5) var(--space-3);\n  border-radius: var(--radius-md);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n  white-space: nowrap;\n}\n\n.select-option:hover {\n  background: var(--glass-bg-heavy);\n}\n\n.select-option.is-selected {\n  background: var(--brand-primary-bg-medium);\n  color: var(--brand-primary);\n}\n\n.none-option {\n  border-bottom: 1px solid var(--glass-border);\n  margin-bottom: var(--space-2);\n  color: var(--text-muted);\n}\n\n.group-header {\n  padding: var(--space-2) var(--space-3) var(--space-1);\n  font-size: var(--text-xs);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n  color: var(--text-muted);\n  font-weight: var(--font-bold);\n}\n\n.empty-state {\n  padding: var(--space-4);\n  text-align: center;\n  color: var(--text-muted);\n  font-size: var(--text-sm);\n}\n\n/* Transitions */\n.dropdown-enter-active, .dropdown-leave-active {\n  transition: opacity var(--duration-normal) var(--var(--ease-out)-out), transform var(--duration-normal) ease;\n}\n.dropdown-enter-from, .dropdown-leave-to {\n  opacity: 0;\n  transform: translateY(-8px);\n}\n\n/* ============================================\n   COMPACT VARIANT - for use inside metadata bars\n   ============================================ */\n.section-selector.is-compact {\n  width: auto;\n}\n\n.section-selector.is-compact .select-trigger {\n  /* Remove glass morphism - parent provides container styling */\n  background: transparent;\n  backdrop-filter: none;\n  -webkit-backdrop-filter: none;\n  border: none;\n\n  /* Compact sizing */\n  padding: 0;\n  min-height: unset;\n  height: auto;\n  width: auto;\n}\n\n.section-selector.is-compact .select-trigger:hover {\n  background: transparent;\n  border: none;\n}\n\n.section-selector.is-compact .select-value {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n}\n\n.section-selector.is-compact .section-color-dot {\n  width: var(--space-2);\n  height: var(--space-2);\n}\n\n.section-selector.is-compact .select-icon {\n  color: var(--text-tertiary);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/TaskNode.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/UnifiedGroupModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/node/OverdueBadge.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/node/TaskNodeDescription.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/node/TaskNodeHeader.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/node/TaskNodeMeta.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2224,2227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2224,2227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"task-metadata\">\n    <!-- Status -->\n    <span v-if=\"showStatus\" class=\"status-badge\">{{ statusLabel }}</span>\n\n    <!-- \"Done for now\" Badge - shows when task was rescheduled via this feature -->\n    <span\n      v-if=\"isDoneForNow\"\n      class=\"done-for-now-badge clickable\"\n      title=\"Click to clear\"\n      @click.stop=\"$emit('clearDoneForNow')\"\n    >\n      <Clock :size=\"12\" />\n      Done for now\n    </span>\n\n    <!-- TASK-282: Overdue Badge (takes priority over regular due date display) -->\n    <OverdueBadge\n      v-if=\"isOverdue\"\n      :current-due-date=\"dueDate\"\n      @reschedule=\"(dateType) => $emit('reschedule', dateType)\"\n    />\n\n    <!-- Due Date (only show if not overdue) -->\n    <span v-else-if=\"dueDate\" class=\"due-date-badge\" title=\"Due Date\">\n      <Calendar :size=\"12\" />\n      {{ formattedDueDate }}\n    </span>\n\n    <!-- Schedule -->\n    <span v-if=\"showSchedule && hasSchedule\" class=\"schedule-badge\" title=\"Scheduled\">\n      📅\n    </span>\n\n    <!-- Duration -->\n    <span\n      v-if=\"showDuration && duration\"\n      class=\"duration-badge\"\n      :class=\"durationBadgeClass\"\n      :title=\"`Duration: ${formattedDuration}`\"\n    >\n      <component :is=\"durationIcon\" :size=\"12\" />\n      {{ formattedDuration }}\n    </span>\n\n    <!-- Subtasks -->\n    <span\n      v-if=\"subtaskCount && subtaskCount > 0\"\n      class=\"subtask-badge\"\n      :class=\"{ 'subtask-complete': completedSubtaskCount === subtaskCount }\"\n      :title=\"`Subtasks: ${completedSubtaskCount}/${subtaskCount}`\"\n    >\n      <ListChecks :size=\"12\" />\n      {{ completedSubtaskCount }}/{{ subtaskCount }}\n    </span>\n\n    <!-- Done Indicator -->\n    <span v-if=\"isDone\" class=\"done-badge\" title=\"Completed\">\n      <Check :size=\"12\" />\n      Done\n    </span>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Calendar, Check, Clock, ListChecks } from 'lucide-vue-next'\nimport OverdueBadge from './OverdueBadge.vue'\n\nconst props = defineProps<{\n  showStatus: boolean\n  statusLabel: string\n  dueDate?: string | null\n  formattedDueDate: string\n  showSchedule: boolean\n  hasSchedule: boolean\n  showDuration: boolean\n  duration?: number\n  durationBadgeClass: string\n  durationIcon: any // Component type\n  formattedDuration: string\n  isDone: boolean\n  isOverdue: boolean\n  doneForNowUntil?: string | null\n  subtaskCount?: number\n  completedSubtaskCount?: number\n}>()\n\ndefineEmits<{\n  reschedule: [dateType: string]\n  clearDoneForNow: []\n}>()\n\n// BUG-1187: Show \"Done for now\" badge when doneForNowUntil has a value\n// Badge only clears when user explicitly clicks it (clearDoneForNow event)\nconst isDoneForNow = computed(() => {\n  return !!props.doneForNowUntil\n})\n\n</script>\n\n<style scoped>\n.task-metadata {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--space-3);\n  align-items: center;\n}\n\n.status-badge, .due-date-badge, .schedule-badge, .duration-badge, .done-badge, .done-for-now-badge, .subtask-badge {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  color: var(--text-secondary);\n}\n\n.due-date-badge {\n  color: var(--text-primary);\n}\n\n.done-badge {\n  color: var(--color-success);\n  background: var(--green-bg-soft);\n  border: 1px solid var(--green-border);\n}\n\n/* \"Done for now\" badge - amber text to indicate rescheduled */\n.done-for-now-badge {\n  color: var(--color-amber);\n}\n\n/* Clickable badges */\n.clickable {\n  cursor: pointer;\n  transition: opacity var(--duration-fast) var(--ease-out);\n}\n\n.clickable:hover {\n  opacity: 0.7;\n}\n\n/* Duration Styles */\n.duration-quick { color: var(--color-success); border-color: var(--color-success-dim); }\n.duration-short { color: var(--color-info); border-color: var(--color-info-dim); }\n.duration-medium { color: var(--color-warning); border-color: var(--color-warning-dim); }\n.duration-long { color: var(--color-error); border-color: var(--color-error-dim); }\n\n/* Subtask Badge Styles */\n.subtask-badge {\n  color: var(--text-secondary);\n}\n\n.subtask-complete {\n  color: var(--color-success);\n  background: var(--green-bg-soft);\n  border: 1px solid var(--green-border);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/node/TaskNodePriority.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/canvas/node/TaskNodeSelection.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/ConfirmationModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/CustomSelect.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/EmojiPicker.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/ErrorBoundary.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/FaviconManager.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/GroupModal.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5044,5047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5044,5047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    v-if=\"isOpen\"\n    class=\"modal-overlay\"\n    @click=\"$emit('close')\"\n    @keydown=\"handleKeydown\"\n  >\n    <div class=\"modal-content\" @click.stop>\n      <div class=\"modal-header\">\n        <h2 class=\"modal-title\">\n          {{ isEditing ? 'Edit Group' : 'Create Custom Group' }}\n        </h2>\n        <button class=\"close-btn\" @click=\"$emit('close')\">\n          <X :size=\"16\" :stroke-width=\"1.5\" />\n        </button>\n      </div>\n\n      <div class=\"modal-body\">\n        <div class=\"form-group\">\n          <label class=\"form-label\">Group Name</label>\n          <BaseInput\n            ref=\"nameInput\"\n            v-model=\"groupData.name\"\n            placeholder=\"Enter group name...\"\n          />\n        </div>\n\n        <div class=\"form-group\">\n          <label class=\"form-label\">Group Color</label>\n\n          <!-- Color Presets -->\n          <div class=\"color-presets\">\n            <button\n              v-for=\"color in colorPresets\"\n              :key=\"color\"\n              class=\"color-preset\"\n              :class=\"[{ active: groupData.color === color }]\"\n              :style=\"{ backgroundColor: color }\"\n              type=\"button\"\n              :title=\"`Select ${color}`\"\n              @click=\"selectColor(color)\"\n            />\n          </div>\n\n          <!-- Custom Color Input -->\n          <div class=\"custom-color-section\">\n            <div class=\"custom-color-input\">\n              <label class=\"color-label\">Custom Color</label>\n              <div class=\"color-input-wrapper\">\n                <input\n                  v-model=\"customColor\"\n                  type=\"text\"\n                  placeholder=\"#3b82f6\"\n                  class=\"color-text-input\"\n                  @input=\"handleCustomColorInput\"\n                >\n                <input\n                  v-model=\"customColor\"\n                  type=\"color\"\n                  class=\"color-picker-input\"\n                  @input=\"handleColorPickerChange\"\n                >\n              </div>\n            </div>\n\n            <!-- Color Preview -->\n            <div class=\"color-preview\">\n              <div\n                class=\"preview-box\"\n                :style=\"{ backgroundColor: groupData.color }\"\n              />\n              <span class=\"color-value\">{{ groupData.color }}</span>\n            </div>\n          </div>\n        </div>\n\n        <!-- TASK-072: Parent Group Selector for Nested Groups -->\n        <div class=\"form-group\">\n          <label class=\"form-label\">Parent Group (Optional)</label>\n          <CustomSelect\n            :model-value=\"groupData.parentGroupId || ''\"\n            :options=\"parentGroupOptions\"\n            placeholder=\"Select parent group...\"\n            @update:model-value=\"(val) => groupData.parentGroupId = val === '' ? null : String(val)\"\n          />\n          <p class=\"form-hint\">\n            Nest this group inside another group for better organization.\n          </p>\n        </div>\n      </div>\n\n      <div class=\"modal-footer\">\n        <button class=\"btn btn-secondary\" @click=\"$emit('close')\">\n          Cancel\n        </button>\n        <button\n          class=\"btn btn-primary\"\n          :disabled=\"!groupData.name.trim()\"\n          @click=\"saveGroup\"\n        >\n          {{ isEditing ? 'Save Changes' : 'Create Group' }}\n        </button>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, watch, nextTick, computed } from 'vue'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { X } from 'lucide-vue-next'\nimport BaseInput from '@/components/base/BaseInput.vue'\nimport CustomSelect from '@/components/common/CustomSelect.vue'\nimport { isTextAreaOrContentEditable } from '@/utils/dom'\n\ninterface Props {\n  isOpen: boolean\n  group?: CanvasSection | null\n  position?: { x: number; y: number }\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  group: null,\n  position: () => ({ x: 100, y: 100 })\n})\n\nconst emit = defineEmits<{\n  close: []\n  created: [group: CanvasSection]\n  updated: [group: CanvasSection]\n}>()\n\n// Try to get canvas store, fallback to mock for Storybook environment\n// Try to get canvas store, fallback to mock for Storybook environment\nlet canvasStore: ReturnType<typeof useCanvasStore> | { \n  sections: CanvasSection[], \n  createSection: (section: Omit<CanvasSection, 'id'>) => CanvasSection, \n  updateSection: (id: string, updates: Partial<CanvasSection>) => void \n}\ntry {\n  canvasStore = useCanvasStore()\n} catch (error) {\n  console.warn('🔧 GroupModal: Canvas store not available, using mock for Storybook', error)\n  // Mock canvas store for Storybook environment\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  canvasStore = {\n    sections: [],\n    createSection: (section: Record<string, unknown>) => {\n      const newSection = {\n        ...section,\n        id: `section-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`\n      }\n      return newSection\n    },\n    updateSection: (_id: string, _updates: Record<string, unknown>) => {\n      // Storybook mock - no-op\n    }\n  } as any // Storybook mock doesn't need full type compliance\n}\nconst nameInput = ref()\n\nconst isEditing = computed(() => !!props.group)\n\nconst groupData = ref({\n  name: '',\n  color: '#3b82f6',\n  parentGroupId: null as string | null  // TASK-072: Parent group for nesting\n})\n\nconst customColor = ref('#3b82f6')\n\n// Color presets for quick selection\nconst colorPresets = [\n  '#ef4444', // red\n  '#f97316', // orange\n  '#f59e0b', // amber\n  '#eab308', // yellow\n  '#84cc16', // lime\n  '#22c55e', // green\n  '#10b981', // emerald\n  '#14b8a6', // teal\n  '#06b6d4', // cyan\n  '#0ea5e9', // sky\n  '#3b82f6', // blue\n  '#6366f1', // indigo\n  '#8b5cf6', // violet\n  '#a855f7', // purple\n  '#d946ef', // fuchsia\n  '#ec4899', // pink\n  '#f43f5e', // rose\n  '#64748b', // slate\n  '#475569', // zinc\n  '#71717a', // neutral\n]\n\n// TASK-072: Get available parent groups (exclude self and descendants to prevent cycles)\nconst availableParentGroups = computed(() => {\n  const allSections = canvasStore.sections || []\n\n  // If editing, exclude self and all descendants\n  if (props.group) {\n    const getDescendantIds = (parentId: string, visited = new Set<string>()): Set<string> => {\n      if (visited.has(parentId)) return visited\n      visited.add(parentId)\n\n      const children = allSections.filter((s: CanvasSection) => s.parentGroupId === parentId)\n      children.forEach((child: CanvasSection) => getDescendantIds(child.id, visited))\n      return visited\n    }\n\n    const excludeIds = getDescendantIds(props.group.id)\n    return allSections.filter((s: CanvasSection) => !excludeIds.has(s.id))\n  }\n\n  // For new groups, all existing groups are valid parents\n  return allSections\n})\n\n// Options for parent group CustomSelect\nconst parentGroupOptions = computed(() => [\n  { label: 'None (Top Level)', value: '' },\n  ...availableParentGroups.value.map((s: CanvasSection) => ({\n    label: s.name,\n    value: s.id\n  }))\n])\n\nconst selectColor = (color: string) => {\n  groupData.value.color = color\n  customColor.value = color\n}\n\nconst handleCustomColorInput = () => {\n  // Validate hex color input\n  const hexColor = customColor.value.trim()\n  if (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hexColor)) {\n    groupData.value.color = hexColor\n  }\n}\n\nconst handleColorPickerChange = () => {\n  groupData.value.color = customColor.value\n}\n\nconst saveGroup = async () => {\n  if (!groupData.value.name.trim()) return\n\n  if (isEditing.value && props.group) {\n    // Update existing group\n    await canvasStore.updateSection(props.group.id, {\n      name: groupData.value.name.trim(),\n      color: groupData.value.color,\n      parentGroupId: groupData.value.parentGroupId  // TASK-072: Update parent group\n    })\n\n    const updatedGroup = canvasStore.sections.find((s: { id: string }) => s.id === props.group!.id)\n    if (updatedGroup) {\n      emit('updated', updatedGroup)\n    }\n  } else {\n    // Create new group at specified position\n    const newGroup = await canvasStore.createSection({\n      name: groupData.value.name.trim(),\n      type: 'custom',\n      position: {\n        x: props.position.x,\n        y: props.position.y,\n        width: 300,\n        height: 200\n      },\n      color: groupData.value.color,\n      layout: 'grid',\n      isVisible: true,\n      isCollapsed: false,\n      parentGroupId: groupData.value.parentGroupId  // TASK-072: Set parent group\n    })\n\n    emit('created', newGroup)\n  }\n\n  emit('close')\n}\n\n// Keyboard handler for Enter/Escape\nconst handleKeydown = (event: KeyboardEvent) => {\n  // Enter - save (if valid)\n  if (event.key === 'Enter') {\n    // Don't submit if in textarea or contenteditable\n    if (isTextAreaOrContentEditable(event.target)) return\n\n    // Don't submit with Shift+Enter\n    if (event.shiftKey) return\n\n    // Submit if name is valid\n    if (groupData.value.name.trim()) {\n      event.preventDefault()\n      saveGroup()\n    }\n  }\n}\n\n// Watch for group changes (editing mode)\nwatch(() => props.group, (newGroup) => {\n  if (newGroup) {\n    groupData.value = {\n      name: newGroup.name,\n      color: newGroup.color,\n      parentGroupId: newGroup.parentGroupId || null  // TASK-072: Load parent group\n    }\n    customColor.value = newGroup.color\n  } else {\n    // Reset for new group creation\n    groupData.value = {\n      name: '',\n      color: '#3b82f6',\n      parentGroupId: null  // TASK-072: Default no parent\n    }\n    customColor.value = '#3b82f6'\n  }\n}, { immediate: true })\n\n// Focus input when modal opens\nwatch(() => props.isOpen, async (isOpen) => {\n  if (isOpen) {\n    await nextTick()\n    nameInput.value?.focus()\n  }\n})\n</script>\n\n<style scoped>\n.modal-overlay {\n  position: fixed;\n  inset: 0;\n  background: var(--overlay-darker);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: var(--z-popover);\n  backdrop-filter: blur(12px) saturate(100%);\n  animation: fadeIn var(--duration-normal) var(--spring-smooth);\n}\n\n.modal-content {\n  background: var(--glass-bg-solid);\n  backdrop-filter: blur(20px) saturate(100%);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  box-shadow: 0 24px 48px rgba(0, 0, 0, 0.5);\n  width: 90%;\n  max-width: 480px;\n  animation: slideUp var(--duration-normal) var(--spring-smooth);\n}\n\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n@keyframes slideUp {\n  from {\n    opacity: 0;\n    transform: translateY(16px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.modal-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--space-5) var(--space-6);\n  border-bottom: 1px solid var(--border-subtle);\n}\n\n.modal-title {\n  color: var(--text-primary);\n  font-size: var(--text-lg);\n  font-weight: var(--font-semibold);\n  margin: 0;\n}\n\n.close-btn {\n  background: transparent;\n  border: 1px solid var(--glass-border-hover);\n  color: var(--text-muted);\n  cursor: pointer;\n  padding: var(--space-2);\n  border-radius: var(--radius-md);\n  transition: all var(--duration-fast);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.close-btn:hover {\n  background: var(--glass-bg-soft);\n  border-color: var(--border-hover);\n  color: var(--text-primary);\n}\n\n.modal-body {\n  padding: var(--space-6);\n}\n\n.form-group {\n  margin-bottom: var(--space-6);\n}\n\n.form-label {\n  display: block;\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  margin-bottom: var(--space-3);\n}\n\n.color-presets {\n  display: grid;\n  grid-template-columns: repeat(10, 1fr);\n  gap: var(--space-2);\n  margin-bottom: var(--space-4);\n  padding: var(--space-3);\n  background: var(--glass-bg-light);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-subtle);\n}\n\n.color-preset {\n  width: 32px;\n  height: 32px;\n  border-radius: var(--radius-md);\n  border: 2px solid transparent;\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n  position: relative;\n}\n\n.color-preset:hover {\n  transform: scale(1.1);\n  border-color: rgba(255, 255, 255, 0.3);\n}\n\n.color-preset.active {\n  border-color: white;\n  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);\n  transform: scale(1.1);\n}\n\n.color-preset.active::after {\n  content: '✓';\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  color: white;\n  font-size: var(--text-sm);\n  font-weight: bold;\n  text-shadow: 0 1px 2px rgba(0,0,0,0.5);\n}\n\n.custom-color-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n  padding: var(--space-4);\n  background: var(--glass-bg-light);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-subtle);\n}\n\n.custom-color-input {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.color-label {\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n}\n\n.color-input-wrapper {\n  display: flex;\n  gap: var(--space-2);\n  align-items: center;\n}\n\n.color-text-input {\n  flex: 1;\n  padding: var(--space-2) var(--space-3);\n  background: var(--overlay-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  font-family: var(--font-mono);\n  transition: all var(--duration-fast);\n}\n\n.color-text-input:focus {\n  outline: none;\n  border-color: rgba(255, 255, 255, 0.3);\n  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.05);\n}\n\n.color-picker-input {\n  width: 40px;\n  height: 36px;\n  border: none;\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  background: transparent;\n}\n\n.color-preview {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3);\n  background: var(--overlay-medium);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n}\n\n.preview-box {\n  width: 24px;\n  height: 24px;\n  border-radius: var(--radius-sm);\n  border: 1px solid var(--glass-border-hover);\n}\n\n.color-value {\n  font-family: var(--font-mono);\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  font-weight: var(--font-medium);\n}\n\n.modal-footer {\n  display: flex;\n  justify-content: flex-end;\n  gap: var(--space-3);\n  padding: var(--space-5) var(--space-6) var(--space-6);\n  border-top: 1px solid var(--border-subtle);\n}\n\n.btn-primary {\n  background: var(--glass-border);\n  border: 1px solid var(--border-hover);\n  color: white;\n  padding: var(--space-3) var(--space-6);\n  border-radius: var(--radius-lg);\n  cursor: pointer;\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  transition: all var(--duration-fast);\n}\n\n.btn-primary:hover:not(:disabled) {\n  background: var(--glass-border-hover);\n  border-color: rgba(255, 255, 255, 0.3);\n}\n\n.btn-primary:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.btn-secondary {\n  background: transparent;\n  border: 1px solid var(--glass-border-hover);\n  color: var(--text-secondary);\n  padding: var(--space-3) var(--space-6);\n  border-radius: var(--radius-lg);\n  cursor: pointer;\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  transition: all var(--duration-fast);\n}\n\n.btn-secondary:hover {\n  background: var(--glass-bg-soft);\n  border-color: var(--border-hover);\n  color: var(--text-primary);\n}\n\n/* TASK-072: Parent group selector styling */\n.parent-select {\n  width: 100%;\n  padding: var(--space-3) var(--space-4);\n  background: var(--overlay-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n  appearance: none;\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E\");\n  background-repeat: no-repeat;\n  background-position: right var(--space-3) center;\n  padding-right: var(--space-8);\n}\n\n.parent-select:hover {\n  border-color: var(--border-hover);\n  background-color: var(--overlay-heavy);\n}\n\n.parent-select:focus {\n  outline: none;\n  border-color: rgba(255, 255, 255, 0.3);\n  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.05);\n}\n\n.parent-select option {\n  background: #1c1a2d;\n  color: var(--text-primary);\n  padding: var(--space-2);\n}\n\n.form-hint {\n  margin-top: var(--space-2);\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  line-height: 1.4;\n}\n</style>","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/IOSInstallPrompt.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[368,371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[368,371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":97,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":100,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[513,516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[513,516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, onMounted } from 'vue'\nimport { Share, PlusSquare, X } from 'lucide-vue-next'\nimport { NButton, NCard, NText } from 'naive-ui'\n\nconst isIOS = ref(false)\nconst isStandalone = ref(false)\nconst showTooltip = ref(false)\n\nonMounted(() => {\n  // Check if iOS\n  isIOS.value = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream\n  \n  // Check if already installed\n  isStandalone.value = window.matchMedia('(display-mode: standalone)').matches || (navigator as any).standalone\n  \n  // Show tooltip only for iOS users not in standalone mode\n  if (isIOS.value && !isStandalone.value) {\n    // Check if dismissed before\n    const dismissed = localStorage.getItem('flowstate-ios-install-prompt-dismissed')\n    if (!dismissed) {\n      showTooltip.value = true\n    }\n  }\n})\n\nconst dismiss = () => {\n  showTooltip.value = false\n  localStorage.setItem('flowstate-ios-install-prompt-dismissed', 'true')\n}\n</script>\n\n<template>\n  <Transition name=\"slide-up\">\n    <div v-if=\"showTooltip\" class=\"ios-install-tooltip\">\n      <NCard class=\"tooltip-card\" size=\"small\" :bordered=\"false\">\n        <div class=\"tooltip-header\">\n          <NText strong>\n            Install FlowState\n          </NText>\n          <NButton\n            quaternary\n            circle\n            size=\"tiny\"\n            @click=\"dismiss\"\n          >\n            <template #icon>\n              <X :size=\"14\" />\n            </template>\n          </NButton>\n        </div>\n        \n        <div class=\"tooltip-body\">\n          <NText depth=\"3\">\n            To install FlowState on your iPhone:\n          </NText>\n          <div class=\"instruction-steps\">\n            <div class=\"step\">\n              <span class=\"step-icon\"><Share :size=\"16\" /></span>\n              <span>Tap the <strong>Share</strong> button below</span>\n            </div>\n            <div class=\"step\">\n              <span class=\"step-icon\"><PlusSquare :size=\"16\" /></span>\n              <span>Select <strong>Add to Home Screen</strong></span>\n            </div>\n          </div>\n        </div>\n      </NCard>\n      <div class=\"tooltip-arrow\" />\n    </div>\n  </Transition>\n</template>\n\n<style scoped>\n.ios-install-tooltip {\n  position: fixed;\n  bottom: 24px;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: var(--z-tooltip);\n  width: calc(100% - 32px);\n  max-width: 300px;\n}\n\n.tooltip-card {\n  background: var(--bg-secondary) !important;\n  border: 1px solid var(--border-default) !important;\n  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4) !important;\n  border-radius: 16px !important;\n}\n\n.tooltip-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 8px;\n}\n\n.tooltip-body {\n  font-size: var(--text-meta);\n  line-height: 1.4;\n}\n\n.instruction-steps {\n  margin-top: 12px;\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.step {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n}\n\n.step-icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: var(--brand-primary);\n}\n\n.tooltip-arrow {\n  position: absolute;\n  bottom: -8px;\n  left: 50%;\n  transform: translateX(-50%);\n  width: 16px;\n  height: 16px;\n  background: var(--bg-secondary);\n  border-right: 1px solid var(--border-default);\n  border-bottom: 1px solid var(--border-default);\n  rotate: 45deg;\n}\n\n/* Transitions */\n.slide-up-enter-active,\n.slide-up-leave-active {\n  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);\n}\n\n.slide-up-enter-from,\n.slide-up-leave-to {\n  opacity: 0;\n  transform: translate(-50%, 40px) scale(0.9);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/MarkdownEditor.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/MarkdownRenderer.vue","messages":[{"ruleId":"vue/no-v-html","severity":1,"message":"'v-html' directive can lead to XSS attack.","line":7,"column":5,"nodeType":"VAttribute","messageId":"unexpected","endLine":7,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div \n    class=\"markdown-content\" \n    :class=\"{ 'rtl-aware': rtlAware }\"\n    :dir=\"calculatedDir\"\n    @click=\"handleClick\"\n    v-html=\"renderedHtml\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { parseMarkdown } from '@/utils/markdown'\n\ninterface Props {\n  content: string\n  rtlAware?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  content: '',\n  rtlAware: true\n})\n\nconst emit = defineEmits<{\n  checkboxClick: [index: number, isChecked: boolean]\n}>()\n\nconst renderedHtml = computed(() => parseMarkdown(props.content))\n\nconst calculatedDir = computed(() => {\n  if (!props.content.trim()) return 'auto'\n  // Look for first strong directional character in the first 100 characters\n  const sample = props.content.trim().substring(0, 100)\n  const rtlRegex = /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/\n  return rtlRegex.test(sample) ? 'rtl' : 'ltr'\n})\n\nconst handleClick = (event: MouseEvent) => {\n  const target = event.target as HTMLElement\n  if (target.tagName === 'INPUT' && target.classList.contains('md-checkbox')) {\n    event.stopPropagation()\n    event.preventDefault()\n    \n    // Find index of this checkbox among all checkboxes in this renderer\n    const allCheckboxes = (event.currentTarget as HTMLElement).querySelectorAll('.md-checkbox')\n    const index = Array.from(allCheckboxes).indexOf(target)\n    \n    if (index !== -1) {\n      emit('checkboxClick', index, (target as HTMLInputElement).checked)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.markdown-content {\n  line-height: 1.6;\n  font-size: var(--text-sm);\n  color: var(--text-primary);\n  overflow-wrap: break-word;\n  word-break: break-word;\n  overflow: hidden;\n}\n\n.markdown-content.rtl-aware {\n  width: 100%;\n}\n\n:deep(p), :deep(h1), :deep(h2), :deep(h3), :deep(h4), :deep(h5), :deep(h6) {\n  width: 100%;\n  margin-top: 0;\n  margin-bottom: var(--space-4);\n  line-height: var(--leading-relaxed);\n  /* Let dir=\"auto\" on the parent or the element itself handle alignment */\n}\n\n/* Markdown Styling */\n:deep(h1), :deep(h2), :deep(h3) {\n  margin-top: var(--space-4);\n  margin-bottom: var(--space-2);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n:deep(h1) { font-size: var(--text-xl); border-bottom: 1px solid var(--border-subtle); padding-bottom: 0.3rem; }\n:deep(h2) { font-size: var(--text-lg); }\n:deep(h3) { font-size: var(--text-base); }\n\n:deep(p) {\n  margin-bottom: var(--space-3);\n}\n\n:deep(ul), :deep(ol) {\n  padding-inline-start: var(--space-6);\n  margin-bottom: var(--space-3);\n}\n\n:deep(li) {\n  margin-bottom: var(--space-1);\n  position: relative;\n}\n\n/* GFM Task List Styling */\n:deep(li.task-list-item) {\n  list-style-type: none;\n  display: flex;\n  align-items: flex-start;\n  gap: var(--space-2);\n  margin-inline-start: -var(--space-6); /* Counteract parent padding for task items */\n  padding-inline-start: var(--space-2);\n}\n\n:deep(ul.task-list) {\n  list-style-type: none;\n  padding-inline-start: var(--space-6);\n}\n\n/* Custom Checkbox Styling */\n:deep(input.md-checkbox) {\n  appearance: none;\n  -webkit-appearance: none;\n  width: 16px;\n  height: 16px;\n  border: 1.5px solid var(--glass-border-heavy);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-soft);\n  cursor: pointer;\n  position: relative;\n  margin-top: var(--space-0_5); /* Center with text line height */\n  flex-shrink: 0;\n  transition: all var(--duration-normal) cubic-bezier(0.4, 0, 0.2, 1);\n  display: inline-block;\n  vertical-align: middle;\n}\n\n:deep(input.md-checkbox:checked) {\n  background: var(--brand-primary);\n  border-color: var(--brand-primary);\n}\n\n:deep(input.md-checkbox:checked::after) {\n  content: '';\n  position: absolute;\n  top: 1px;\n  left: var(--space-1);\n  width: 5px;\n  height: 9px;\n  border: solid white;\n  border-width: 0 2px 2px 0;\n  transform: rotate(45deg);\n}\n\n:deep(input.md-checkbox:hover) {\n  border-color: var(--brand-primary);\n  box-shadow: 0 0 8px var(--brand-primary-alpha-20);\n}\n\n:deep(code) {\n  background: var(--glass-bg-medium);\n  padding: 0.1rem 0.3rem;\n  border-radius: var(--radius-sm);\n  font-family: var(--font-mono, monospace);\n  font-size: 0.9em;\n}\n\n:deep(pre) {\n  background: var(--glass-bg-heavy);\n  padding: var(--space-3);\n  border-radius: var(--radius-md);\n  overflow-x: auto;\n  margin-bottom: var(--space-3);\n  border: 1px solid var(--glass-border);\n}\n\n:deep(pre code) {\n  background: transparent;\n  padding: 0;\n}\n\n:deep(blockquote) {\n  border-inline-start: 4px solid var(--brand-primary);\n  padding-inline-start: var(--space-3);\n  margin-inline: 0;\n  margin-bottom: var(--space-3);\n  color: var(--text-muted);\n  font-style: italic;\n}\n\n:deep(hr) {\n  border: 0;\n  border-top: 1px solid var(--border-subtle);\n  margin: var(--space-4) 0;\n}\n\n:deep(a) {\n  color: var(--brand-primary);\n  text-decoration: none;\n  display: inline-block;\n  max-width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  vertical-align: bottom;\n}\n\n:deep(a:hover) {\n  text-decoration: underline;\n}\n\n:deep(img) {\n  max-width: 100%;\n  border-radius: var(--radius-md);\n}\n\n/* Checkbox lists */\n:deep(ul li input[type=\"checkbox\"]) {\n  margin-inline-end: var(--space-2);\n  vertical-align: middle;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/MultiSelectToggle.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/ReloadPrompt.vue","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":14,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":14,"endColumn":61,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[490,548],"text":"// @ts-expect-error - Virtual module provided by vite-plugin-pwa"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":22,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":22,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":23,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":23,"endColumn":55}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\nimport { RefreshCw, X, CheckCircle2 } from 'lucide-vue-next'\nimport { NButton, NCard, NText } from 'naive-ui'\n\n// --- State ---\n// PWA registration - only available in web builds with PWA plugin\nconst offlineReady = ref(false)\nconst needRefresh = ref(false)\nlet updateServiceWorker = () => {}\n\n// Dynamically import PWA register only when available (web builds)\nif (typeof window !== 'undefined' && !('__TAURI__' in window)) {\n  // @ts-ignore - Virtual module provided by vite-plugin-pwa\n  import('virtual:pwa-register/vue').then(({ useRegisterSW }) => {\n    const sw = useRegisterSW()\n    offlineReady.value = sw.offlineReady.value\n    needRefresh.value = sw.needRefresh.value\n    updateServiceWorker = sw.updateServiceWorker\n\n    // Watch for changes\n    sw.offlineReady.value && (offlineReady.value = true)\n    sw.needRefresh.value && (needRefresh.value = true)\n  }).catch(() => {\n    // PWA plugin not available (Tauri build), ignore\n  })\n}\n\n// --- Computed ---\nconst showPrompt = computed(() => offlineReady.value || needRefresh.value)\n\n// --- Methods ---\nconst close = async () => {\n  offlineReady.value = false\n  needRefresh.value = false\n}\n\nconst handleReload = async () => {\n  updateServiceWorker()\n}\n</script>\n\n<template>\n  <Transition name=\"slide-up\">\n    <div v-if=\"showPrompt\" class=\"pwa-reload-prompt\">\n      <NCard class=\"prompt-card\" size=\"small\" :bordered=\"false\">\n        <div class=\"prompt-content\">\n          <!-- Update Available Mode -->\n          <div v-if=\"needRefresh\" class=\"state-update\">\n            <div class=\"icon-wrapper update\">\n              <RefreshCw class=\"icon-spin\" :size=\"20\" />\n            </div>\n            <div class=\"text-content\">\n              <NText strong class=\"title\">\n                Update Available\n              </NText>\n              <NText depth=\"3\" class=\"description\">\n                A new version of FlowState is available.\n              </NText>\n            </div>\n            <div class=\"actions\">\n              <NButton \n                secondary \n                type=\"primary\" \n                size=\"small\" \n                @click=\"handleReload\"\n              >\n                Reload\n              </NButton>\n\n              <NButton\n                quaternary\n                circle\n                size=\"small\"\n                @click=\"close\"\n              >\n                <template #icon>\n                  <X :size=\"16\" />\n                </template>\n              </NButton>\n            </div>\n          </div>\n\n          <!-- Offline Ready Mode -->\n          <div v-else-if=\"offlineReady\" class=\"state-offline\">\n            <div class=\"icon-wrapper offline\">\n              <CheckCircle2 :size=\"20\" />\n            </div>\n            <div class=\"text-content\">\n              <NText strong class=\"title\">\n                Ready for Offline\n              </NText>\n              <NText depth=\"3\" class=\"description\">\n                App ready to work offline.\n              </NText>\n            </div>\n            <div class=\"actions\">\n              <NButton\n                quaternary\n                circle\n                size=\"small\"\n                @click=\"close\"\n              >\n                <template #icon>\n                  <X :size=\"16\" />\n                </template>\n              </NButton>\n            </div>\n          </div>\n        </div>\n      </NCard>\n    </div>\n  </Transition>\n</template>\n\n<style scoped>\n.pwa-reload-prompt {\n  position: fixed;\n  bottom: 24px;\n  right: 24px;\n  z-index: var(--z-tooltip);\n  max-width: 400px;\n  width: calc(100% - 48px);\n}\n\n.prompt-card {\n  background: var(--bg-secondary) !important;\n  border: 1px solid var(--border-default) !important;\n  box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.2), \n              0 4px 6px -2px rgba(0, 0, 0, 0.1) !important;\n  backdrop-filter: blur(8px);\n}\n\n.prompt-content {\n  display: flex;\n  flex-direction: column;\n}\n\n.state-update, .state-offline {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n}\n\n.icon-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n  flex-shrink: 0;\n}\n\n.icon-wrapper.update {\n  background: rgba(99, 102, 241, 0.15); /* Indigo 500 alpha */\n  color: #818cf8; /* Indigo 400 */\n}\n\n.icon-wrapper.offline {\n  background: rgba(34, 197, 94, 0.15); /* Green 500 alpha */\n  color: #4ade80; /* Green 400 */\n}\n\n.text-content {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  line-height: 1.3;\n}\n\n.title {\n  font-size: var(--text-sm);\n}\n\n.description {\n  font-size: var(--text-xs);\n  margin-top: 2px;\n}\n\n.warning {\n  color: var(--warning-text);\n  font-weight: 600;\n}\n\n.actions {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n}\n\n.icon-spin {\n  animation: spin 2s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n/* Transitions */\n.slide-up-enter-active,\n.slide-up-leave-active {\n  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n}\n\n.slide-up-enter-from,\n.slide-up-leave-to {\n  opacity: 0;\n  transform: translateY(20px) scale(0.95);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/TauriUpdateNotification.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UpdateStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":44,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"UpdateStatus"},"fix":{"range":[522,541],"text":""},"desc":"Remove unused variable \"UpdateStatus\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'hasUpdate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":24,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isChecking' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isDownloading' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":26,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":16}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * TauriUpdateNotification.vue\n *\n * Shows a notification when a new version of the app is available.\n * Only renders in Tauri environment. Checks for updates on mount\n * and provides download + install functionality.\n *\n * TASK-1114: Tauri Auto-Update from GitHub Releases\n */\nimport { ref, onMounted, computed } from 'vue'\nimport { Download, X, RefreshCw, CheckCircle2, AlertCircle } from 'lucide-vue-next'\nimport { NButton, NCard, NText, NProgress } from 'naive-ui'\nimport { useTauriUpdater, type UpdateStatus } from '@/composables/useTauriUpdater'\nimport { isTauri } from '@/composables/useTauriStartup'\nimport { useSettingsStore } from '@/stores/settings'\n\n// --- State ---\nconst {\n  status,\n  updateInfo,\n  error,\n  downloadProgress,\n  hasUpdate,\n  isChecking,\n  isDownloading,\n  checkForUpdates,\n  downloadAndInstall,\n  restart\n} = useTauriUpdater()\n\nconst dismissed = ref(false)\n\n// --- Computed ---\nconst showNotification = computed(() => {\n  if (!isTauri() || dismissed.value) return false\n  // Show when: update available, downloading, ready to install, or error\n  return ['available', 'downloading', 'ready', 'error'].includes(status.value)\n})\n\nconst statusIcon = computed(() => {\n  switch (status.value) {\n    case 'available':\n      return Download\n    case 'downloading':\n      return RefreshCw\n    case 'ready':\n      return CheckCircle2\n    case 'error':\n      return AlertCircle\n    default:\n      return Download\n  }\n})\n\nconst statusColor = computed(() => {\n  switch (status.value) {\n    case 'available':\n    case 'downloading':\n      return 'indigo'\n    case 'ready':\n      return 'green'\n    case 'error':\n      return 'red'\n    default:\n      return 'indigo'\n  }\n})\n\nconst statusTitle = computed(() => {\n  switch (status.value) {\n    case 'available':\n      return 'Update Available'\n    case 'downloading':\n      return 'Downloading Update...'\n    case 'ready':\n      return 'Ready to Install'\n    case 'error':\n      return 'Update Failed'\n    default:\n      return 'Update'\n  }\n})\n\nconst statusDescription = computed(() => {\n  if (status.value === 'error') {\n    return error.value || 'An error occurred while checking for updates.'\n  }\n  if (status.value === 'ready') {\n    return `Version ${updateInfo.value?.version} is ready. Restart to apply.`\n  }\n  if (updateInfo.value) {\n    return `Version ${updateInfo.value.version} is available (current: ${updateInfo.value.currentVersion})`\n  }\n  return 'A new version of FlowState is available.'\n})\n\n// --- Methods ---\nconst handleDismiss = () => {\n  dismissed.value = true\n}\n\nconst handleDownload = async () => {\n  await downloadAndInstall()\n}\n\nconst handleRestart = async () => {\n  await restart()\n}\n\nconst handleRetry = async () => {\n  dismissed.value = false\n  await checkForUpdates()\n}\n\n// --- Lifecycle ---\nonMounted(async () => {\n  if (!isTauri()) return\n\n  // Check for updates after a short delay to not block startup\n  setTimeout(async () => {\n    console.log('[TauriUpdater] Checking for updates...')\n    const hasNewVersion = await checkForUpdates()\n    if (hasNewVersion) {\n      console.log('[TauriUpdater] Update available:', updateInfo.value?.version)\n      // FEATURE-1194: Auto-download if enabled in settings\n      const settingsStore = useSettingsStore()\n      if (settingsStore.autoUpdateEnabled) {\n        console.log('[TauriUpdater] Auto-update enabled, downloading...')\n        await downloadAndInstall()\n      }\n    } else if (status.value === 'error') {\n      // Don't show error notification for \"no releases yet\" - this is expected\n      // when there's no published release or latest.json doesn't exist\n      console.log('[TauriUpdater] No update manifest found (expected if no releases published)')\n      dismissed.value = true // Hide the error notification\n    } else {\n      console.log('[TauriUpdater] App is up to date')\n    }\n  }, 3000)\n})\n</script>\n\n<template>\n  <Transition name=\"slide-up\">\n    <div v-if=\"showNotification\" class=\"tauri-update-notification\">\n      <NCard class=\"notification-card\" size=\"small\" :bordered=\"false\">\n        <div class=\"notification-content\">\n          <!-- Icon -->\n          <div class=\"icon-wrapper\" :class=\"statusColor\">\n            <component\n              :is=\"statusIcon\"\n              :class=\"{ 'icon-spin': status === 'downloading' }\"\n              :size=\"20\"\n            />\n          </div>\n\n          <!-- Text Content -->\n          <div class=\"text-content\">\n            <NText strong class=\"title\">\n              {{ statusTitle }}\n            </NText>\n            <NText depth=\"3\" class=\"description\">\n              {{ statusDescription }}\n            </NText>\n\n            <!-- Progress bar for downloading -->\n            <NProgress\n              v-if=\"status === 'downloading'\"\n              type=\"line\"\n              :percentage=\"downloadProgress\"\n              :show-indicator=\"false\"\n              :height=\"4\"\n              class=\"download-progress\"\n            />\n          </div>\n\n          <!-- Actions -->\n          <div class=\"actions\">\n            <!-- Download button (when update available) -->\n            <NButton\n              v-if=\"status === 'available'\"\n              secondary\n              type=\"primary\"\n              size=\"small\"\n              @click=\"handleDownload\"\n            >\n              Download\n            </NButton>\n\n            <!-- Restart button (when ready to install) -->\n            <NButton\n              v-if=\"status === 'ready'\"\n              secondary\n              type=\"success\"\n              size=\"small\"\n              @click=\"handleRestart\"\n            >\n              Restart Now\n            </NButton>\n\n            <!-- Retry button (on error) -->\n            <NButton\n              v-if=\"status === 'error'\"\n              secondary\n              type=\"warning\"\n              size=\"small\"\n              @click=\"handleRetry\"\n            >\n              Retry\n            </NButton>\n\n            <!-- Dismiss button -->\n            <NButton\n              v-if=\"status !== 'downloading'\"\n              quaternary\n              circle\n              size=\"small\"\n              @click=\"handleDismiss\"\n            >\n              <template #icon>\n                <X :size=\"16\" />\n              </template>\n            </NButton>\n          </div>\n        </div>\n      </NCard>\n    </div>\n  </Transition>\n</template>\n\n<style scoped>\n.tauri-update-notification {\n  position: fixed;\n  bottom: var(--space-6);\n  right: var(--space-6);\n  z-index: var(--z-toast);\n  max-width: 420px;\n  width: calc(100% - calc(var(--space-6) * 2));\n}\n\n.notification-card {\n  background: var(--surface-primary) !important;\n  border: 1px solid var(--glass-border) !important;\n  box-shadow: var(--shadow-xl) !important;\n  backdrop-filter: blur(20px);\n  -webkit-backdrop-filter: blur(20px);\n}\n\n.notification-content {\n  display: flex;\n  align-items: flex-start;\n  gap: var(--space-3);\n}\n\n.icon-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: var(--space-9);\n  height: var(--space-9);\n  border-radius: var(--radius-full);\n  flex-shrink: 0;\n  margin-top: var(--space-0_5);\n}\n\n.icon-wrapper.indigo {\n  background: var(--purple-bg-subtle);\n  color: var(--color-info);\n}\n\n.icon-wrapper.green {\n  background: var(--success-bg-subtle);\n  color: var(--color-work);\n}\n\n.icon-wrapper.red {\n  background: var(--danger-bg-subtle);\n  color: var(--color-danger);\n}\n\n.text-content {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  line-height: var(--leading-tight);\n  min-width: 0;\n}\n\n.title {\n  font-size: var(--text-sm);\n  color: var(--text-primary);\n}\n\n.description {\n  font-size: var(--text-xs);\n  margin-top: var(--space-0_5);\n  word-break: break-word;\n  color: var(--text-secondary);\n}\n\n.download-progress {\n  margin-top: var(--space-2);\n}\n\n.actions {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  flex-shrink: 0;\n}\n\n.icon-spin {\n  animation: spin 2s linear infinite;\n}\n\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n/* Transitions */\n.slide-up-enter-active,\n.slide-up-leave-active {\n  transition: all var(--duration-slow) var(--spring-bounce);\n}\n\n.slide-up-enter-from,\n.slide-up-leave-to {\n  opacity: 0;\n  transform: translateY(var(--space-5)) scale(0.95);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/TimeDisplay.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/common/TiptapEditor.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/debug/KeyboardDeletionTest.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/debug/PerformanceTest.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/error/RouteErrorBoundary.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/ARIAMessage.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/AchievementBadge.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[807,810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[807,810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * Achievement Badge Component\n * FEATURE-1118: Displays an achievement with tier-based glow\n */\nimport { computed } from 'vue'\nimport type { AchievementWithProgress, AchievementTier } from '@/types/gamification'\nimport {\n  Rocket, Target, Award, Crown, Flame, Clock, Hourglass, Layers,\n  Calendar, Trophy, Star, RefreshCw, Shield, Timer, Brain,\n  Zap, Infinity, Activity, Layout, Columns, Smartphone, Palette,\n  Moon, Sunrise, CheckCircle, Database, Lock\n} from 'lucide-vue-next'\n\nconst props = withDefaults(defineProps<{\n  achievement: AchievementWithProgress\n  size?: 'sm' | 'md' | 'lg'\n  showProgress?: boolean\n  showDescription?: boolean\n}>(), {\n  size: 'md',\n  showProgress: true,\n  showDescription: false\n})\n\n// Map icon names to components\nconst iconMap: Record<string, any> = {\n  rocket: Rocket, target: Target, award: Award, crown: Crown, flame: Flame,\n  clock: Clock, hourglass: Hourglass, layers: Layers, fire: Flame,\n  calendar: Calendar, trophy: Trophy, star: Star, 'refresh-cw': RefreshCw,\n  shield: Shield, timer: Timer, brain: Brain, zap: Zap, infinity: Infinity,\n  activity: Activity, layout: Layout, columns: Columns, smartphone: Smartphone,\n  palette: Palette, moon: Moon, sunrise: Sunrise, 'check-circle': CheckCircle,\n  database: Database\n}\n\nconst IconComponent = computed(() => iconMap[props.achievement.icon] || Award)\n\nconst tierGlow = computed(() => {\n  const tierMap: Record<AchievementTier, string> = {\n    bronze: 'var(--tier-glow-bronze)',\n    silver: 'var(--tier-glow-silver)',\n    gold: 'var(--tier-glow-gold)',\n    platinum: 'var(--tier-glow-platinum)'\n  }\n  return tierMap[props.achievement.tier]\n})\n\nconst tierColor = computed(() => {\n  const tierMap: Record<AchievementTier, string> = {\n    bronze: 'rgb(var(--tier-bronze))',\n    silver: 'rgb(var(--tier-silver))',\n    gold: 'rgb(var(--tier-gold))',\n    platinum: 'rgb(var(--tier-platinum))'\n  }\n  return tierMap[props.achievement.tier]\n})\n\nconst progressPercent = computed(() => {\n  if (props.achievement.isEarned) return 100\n  return Math.min(100, Math.round(\n    (props.achievement.progress / props.achievement.conditionValue) * 100\n  ))\n})\n\nconst sizeClass = computed(() => `badge--${props.size}`)\n</script>\n\n<template>\n  <div\n    class=\"achievement-badge\"\n    :class=\"[\n      sizeClass,\n      `badge--${achievement.tier}`,\n      { 'badge--earned': achievement.isEarned, 'badge--secret': achievement.isSecret && !achievement.isEarned }\n    ]\"\n    :title=\"achievement.isEarned ? achievement.name : (achievement.isSecret ? '???' : achievement.name)\"\n  >\n    <div\n      class=\"badge-icon-wrapper\"\n      :style=\"{ boxShadow: achievement.isEarned ? tierGlow : 'none' }\"\n    >\n      <Lock\n        v-if=\"achievement.isSecret && !achievement.isEarned\"\n        class=\"badge-icon badge-icon--locked\"\n        :size=\"size === 'sm' ? 16 : size === 'lg' ? 32 : 24\"\n      />\n      <component\n        :is=\"IconComponent\"\n        v-else\n        class=\"badge-icon\"\n        :style=\"{ color: achievement.isEarned ? tierColor : undefined }\"\n        :size=\"size === 'sm' ? 16 : size === 'lg' ? 32 : 24\"\n      />\n    </div>\n\n    <div\n      v-if=\"showDescription || showProgress\"\n      class=\"badge-content\"\n    >\n      <span\n        v-if=\"showDescription\"\n        class=\"badge-name\"\n      >\n        {{ achievement.isSecret && !achievement.isEarned ? '???' : achievement.name }}\n      </span>\n\n      <div\n        v-if=\"showProgress && !achievement.isEarned && !achievement.isSecret\"\n        class=\"badge-progress\"\n      >\n        <div\n          class=\"badge-progress-bar\"\n          :style=\"{ width: `${progressPercent}%` }\"\n        />\n      </div>\n\n      <span\n        v-if=\"showProgress && !achievement.isEarned && !achievement.isSecret\"\n        class=\"badge-progress-text\"\n      >\n        {{ achievement.progress }}/{{ achievement.conditionValue }}\n      </span>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.achievement-badge {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2);\n  background: var(--gamification-card-bg);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--purple-border-medium);\n  transition: transform var(--duration-normal) ease, box-shadow var(--duration-normal) ease;\n}\n\n.achievement-badge:hover {\n  transform: translateY(calc(-1 * var(--space-0_5)));\n}\n\n.badge--earned:hover {\n  box-shadow: var(--tier-glow-bronze);\n}\n\n.badge--earned.badge--silver:hover {\n  box-shadow: var(--tier-glow-silver);\n}\n\n.badge--earned.badge--gold:hover {\n  box-shadow: var(--tier-glow-gold);\n}\n\n.badge--earned.badge--platinum:hover {\n  box-shadow: var(--tier-glow-platinum);\n}\n\n.badge--secret {\n  opacity: 0.5;\n}\n\n.badge--sm {\n  padding: var(--space-1);\n  gap: var(--space-1);\n}\n\n.badge--lg {\n  padding: var(--space-3);\n  gap: var(--space-3);\n}\n\n.badge-icon-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: var(--space-1);\n  background: var(--purple-bg-subtle);\n  border-radius: var(--radius-sm);\n  transition: box-shadow var(--duration-slow) ease;\n}\n\n.badge--sm .badge-icon-wrapper {\n  padding: var(--space-1);\n}\n\n.badge--lg .badge-icon-wrapper {\n  padding: var(--space-2);\n}\n\n.badge-icon {\n  color: var(--gamification-text-secondary);\n  transition: color var(--duration-slow) ease;\n}\n\n.badge--earned .badge-icon {\n  filter: drop-shadow(0 0 var(--space-1) currentColor);\n}\n\n.badge-icon--locked {\n  color: rgba(var(--color-slate-500), 0.5);\n}\n\n.badge-content {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  flex: 1;\n  min-width: 0;\n}\n\n.badge-name {\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--gamification-text-primary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.badge-progress {\n  height: var(--space-1);\n  background: var(--purple-bg-subtle);\n  border-radius: var(--space-0_5);\n  overflow: hidden;\n}\n\n.badge-progress-bar {\n  height: 100%;\n  background: rgba(var(--neon-cyan), 0.6);\n  border-radius: var(--space-0_5);\n  transition: width var(--duration-slow) ease;\n}\n\n.badge-progress-text {\n  font-size: var(--text-xs);\n  color: var(--gamification-text-secondary);\n}\n\n/* Tier-specific icon wrapper backgrounds */\n.badge--earned.badge--bronze .badge-icon-wrapper {\n  background: rgba(var(--tier-bronze), 0.15);\n}\n\n.badge--earned.badge--silver .badge-icon-wrapper {\n  background: rgba(var(--tier-silver), 0.15);\n}\n\n.badge--earned.badge--gold .badge-icon-wrapper {\n  background: rgba(var(--tier-gold), 0.15);\n}\n\n.badge--earned.badge--platinum .badge-icon-wrapper {\n  background: rgba(var(--tier-platinum), 0.15);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/AchievementToast.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[573,576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[573,576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * Achievement Toast Component\n * FEATURE-1118: Pop-up notification for XP gains, level ups, and achievements\n */\nimport { computed, onMounted, ref } from 'vue'\nimport type { GamificationToast, AchievementTier } from '@/types/gamification'\nimport { X, Zap, ArrowUp, Award, Flame, ShoppingBag, Shield, ShieldOff } from 'lucide-vue-next'\n\nconst props = defineProps<{\n  toast: GamificationToast\n}>()\n\nconst emit = defineEmits<{\n  dismiss: [id: string]\n}>()\n\nconst isVisible = ref(false)\nconst isExiting = ref(false)\n\nconst iconMap: Record<string, any> = {\n  xp: Zap,\n  level_up: ArrowUp,\n  achievement: Award,\n  streak: Flame,\n  purchase: ShoppingBag,\n  exposure: Shield,\n}\n\nconst IconComponent = computed(() => {\n  if (props.toast.type === 'exposure') {\n    return props.toast.title === 'SHIELDED' ? Shield : ShieldOff\n  }\n  return iconMap[props.toast.type] || Zap\n})\n\nconst tierClass = computed(() => {\n  if (props.toast.tier) {\n    return `toast--${props.toast.tier}`\n  }\n  return ''\n})\n\nconst borderColor = computed(() => {\n  if (props.toast.type === 'achievement' && props.toast.tier) {\n    const tierMap: Record<AchievementTier, string> = {\n      bronze: 'rgba(var(--tier-bronze), 0.5)',\n      silver: 'rgba(var(--tier-silver), 0.5)',\n      gold: 'rgba(var(--tier-gold), 0.6)',\n      platinum: 'rgba(var(--tier-platinum), 0.6)'\n    }\n    return tierMap[props.toast.tier]\n  }\n  if (props.toast.type === 'level_up') {\n    return 'rgba(var(--neon-magenta), 0.5)'\n  }\n  if (props.toast.type === 'exposure') {\n    return props.toast.title === 'SHIELDED'\n      ? 'rgba(var(--neon-cyan), 0.5)'\n      : 'rgba(var(--neon-magenta), 0.5)'\n  }\n  return 'var(--toast-xp-border)'\n})\n\nfunction dismiss() {\n  isExiting.value = true\n  setTimeout(() => {\n    emit('dismiss', props.toast.id)\n  }, 300)\n}\n\nonMounted(() => {\n  // Trigger enter animation\n  requestAnimationFrame(() => {\n    isVisible.value = true\n  })\n\n  // Auto-dismiss after duration\n  const duration = props.toast.duration || 3000\n  setTimeout(dismiss, duration)\n})\n</script>\n\n<template>\n  <div\n    class=\"achievement-toast\"\n    :class=\"[\n      tierClass,\n      `toast--${toast.type}`,\n      { 'toast--visible': isVisible, 'toast--exiting': isExiting,\n        'toast--shielded': toast.type === 'exposure' && toast.title === 'SHIELDED',\n        'toast--exposed': toast.type === 'exposure' && toast.title === 'EXPOSED' }\n    ]\"\n    :style=\"{ borderColor }\"\n    @click=\"dismiss\"\n  >\n    <div class=\"toast-icon\">\n      <component\n        :is=\"IconComponent\"\n        :size=\"24\"\n      />\n    </div>\n\n    <div class=\"toast-content\">\n      <span class=\"toast-title\">{{ toast.title }}</span>\n      <span\n        v-if=\"toast.description\"\n        class=\"toast-description\"\n      >{{ toast.description }}</span>\n    </div>\n\n    <div\n      v-if=\"toast.xpAmount\"\n      class=\"toast-xp\"\n    >\n      <Zap :size=\"14\" />\n      <span>+{{ toast.xpAmount }}</span>\n    </div>\n\n    <button\n      class=\"toast-close\"\n      @click.stop=\"dismiss\"\n    >\n      <X :size=\"14\" />\n    </button>\n  </div>\n</template>\n\n<style scoped>\n.achievement-toast {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3) var(--space-4);\n  background: var(--toast-xp-bg);\n  border: 1px solid var(--toast-xp-border);\n  border-radius: var(--radius-lg);\n  box-shadow: 0 var(--space-1) var(--space-5) rgba(0, 0, 0, 0.3);\n  backdrop-filter: blur(var(--space-2));\n  cursor: pointer;\n  transform: translateX(100%) scale(0.9);\n  opacity: 0;\n  transition: transform var(--toast-animation-duration) ease-out,\n              opacity var(--toast-animation-duration) ease-out;\n  min-width: 280px;\n  max-width: 400px;\n}\n\n.toast--visible {\n  transform: translateX(0) scale(1);\n  opacity: 1;\n}\n\n.toast--exiting {\n  transform: translateX(100%) scale(0.9);\n  opacity: 0;\n}\n\n.toast-icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: var(--space-2);\n  background: rgba(var(--neon-cyan), 0.15);\n  border-radius: var(--radius-md);\n  color: rgba(var(--neon-cyan), 1);\n}\n\n.toast--level_up .toast-icon {\n  background: rgba(var(--neon-magenta), 0.15);\n  color: rgba(var(--neon-magenta), 1);\n  animation: levelUpPulse 1s ease-in-out infinite;\n}\n\n.toast--achievement .toast-icon {\n  animation: achievementUnlock 0.6s ease-out;\n}\n\n.toast--bronze .toast-icon {\n  background: rgba(var(--tier-bronze), 0.15);\n  color: rgb(var(--tier-bronze));\n}\n\n.toast--silver .toast-icon {\n  background: rgba(var(--tier-silver), 0.15);\n  color: rgb(var(--tier-silver));\n}\n\n.toast--gold .toast-icon {\n  background: rgba(var(--tier-gold), 0.15);\n  color: rgb(var(--tier-gold));\n}\n\n.toast--platinum .toast-icon {\n  background: rgba(var(--tier-platinum), 0.15);\n  color: rgb(var(--tier-platinum));\n}\n\n.toast--streak .toast-icon {\n  background: var(--orange-bg-light);\n  color: var(--streak-flame-color);\n  animation: streakFlame 1s ease-in-out infinite;\n}\n\n.toast--exposed .toast-icon {\n  background: rgba(var(--neon-magenta), 0.15);\n  color: rgba(var(--neon-magenta), 1);\n}\n\n.toast--shielded .toast-icon {\n  background: rgba(var(--neon-cyan), 0.15);\n  color: rgba(var(--neon-cyan), 1);\n}\n\n.toast-content {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-0_5);\n  flex: 1;\n  min-width: 0;\n}\n\n.toast-title {\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  color: var(--gamification-text-primary);\n}\n\n.toast-description {\n  font-size: var(--text-sm);\n  color: var(--gamification-text-secondary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.toast-xp {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: rgba(var(--neon-cyan), 0.15);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: rgba(var(--neon-cyan), 1);\n  animation: xpPopIn 0.4s ease-out;\n}\n\n.toast-close {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: var(--space-1);\n  background: transparent;\n  border: none;\n  border-radius: var(--radius-sm);\n  color: var(--gamification-text-secondary);\n  cursor: pointer;\n  opacity: 0.6;\n  transition: opacity var(--duration-normal) ease, background var(--duration-normal) ease;\n}\n\n.toast-close:hover {\n  opacity: 1;\n  background: var(--purple-bg-subtle);\n}\n\n/* Hover glow effect */\n.achievement-toast:hover {\n  box-shadow: 0 var(--space-1) var(--space-6) rgba(0, 0, 0, 0.4),\n              0 0 var(--space-4) rgba(var(--neon-cyan), 0.1);\n}\n\n.toast--level_up:hover {\n  box-shadow: 0 var(--space-1) var(--space-6) rgba(0, 0, 0, 0.4),\n              0 0 var(--space-4) rgba(var(--neon-magenta), 0.2);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/AchievementsModal.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":12,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'emit' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":16,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[704,707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[704,707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * Achievements Modal Component\n * FEATURE-1118: Full achievements list with category filtering\n */\nimport { computed, ref } from 'vue'\nimport { useGamificationStore } from '@/stores/gamification'\nimport AchievementBadge from './AchievementBadge.vue'\nimport type { AchievementCategory } from '@/types/gamification'\nimport { X, Trophy, Target, Flame, Compass, Lock } from 'lucide-vue-next'\n\nconst props = defineProps<{\n  open: boolean\n}>()\n\nconst emit = defineEmits<{\n  close: []\n}>()\n\nconst gamificationStore = useGamificationStore()\n\nconst selectedCategory = ref<AchievementCategory | 'all'>('all')\n\nconst categories: { id: AchievementCategory | 'all'; label: string; icon: any }[] = [\n  { id: 'all', label: 'All', icon: Trophy },\n  { id: 'productivity', label: 'Productivity', icon: Target },\n  { id: 'consistency', label: 'Consistency', icon: Flame },\n  { id: 'mastery', label: 'Mastery', icon: Trophy },\n  { id: 'exploration', label: 'Exploration', icon: Compass },\n  { id: 'secret', label: 'Secret', icon: Lock }\n]\n\nconst filteredAchievements = computed(() => {\n  const all = gamificationStore.achievementsWithProgress\n\n  if (selectedCategory.value === 'all') {\n    // Sort: earned first, then by tier (platinum > gold > silver > bronze)\n    return [...all].sort((a, b) => {\n      if (a.isEarned !== b.isEarned) return a.isEarned ? -1 : 1\n      const tierOrder = { platinum: 0, gold: 1, silver: 2, bronze: 3 }\n      return tierOrder[a.tier] - tierOrder[b.tier]\n    })\n  }\n\n  return all\n    .filter(a => a.category === selectedCategory.value)\n    .sort((a, b) => {\n      if (a.isEarned !== b.isEarned) return a.isEarned ? -1 : 1\n      return 0\n    })\n})\n\nconst earnedCount = computed(() => gamificationStore.unlockedAchievementsCount)\nconst totalCount = computed(() => gamificationStore.achievements.length)\n\nconst categoryStats = computed(() => {\n  const stats: Record<string, { earned: number; total: number }> = {\n    all: { earned: earnedCount.value, total: totalCount.value }\n  }\n\n  for (const cat of categories.slice(1)) {\n    const inCategory = gamificationStore.achievementsWithProgress.filter(\n      a => a.category === cat.id\n    )\n    stats[cat.id] = {\n      earned: inCategory.filter(a => a.isEarned).length,\n      total: inCategory.length\n    }\n  }\n\n  return stats\n})\n</script>\n\n<template>\n  <Teleport to=\"body\">\n    <Transition name=\"modal\">\n      <div\n        v-if=\"open\"\n        class=\"modal-overlay\"\n        @click.self=\"$emit('close')\"\n      >\n        <div class=\"modal-container\">\n          <div class=\"modal-header\">\n            <div class=\"header-title\">\n              <Trophy\n                :size=\"24\"\n                class=\"header-icon\"\n              />\n              <h2>Achievements</h2>\n              <span class=\"header-count\">{{ earnedCount }}/{{ totalCount }}</span>\n            </div>\n            <button\n              class=\"close-btn\"\n              @click=\"$emit('close')\"\n            >\n              <X :size=\"20\" />\n            </button>\n          </div>\n\n          <div class=\"category-tabs\">\n            <button\n              v-for=\"cat in categories\"\n              :key=\"cat.id\"\n              class=\"category-tab\"\n              :class=\"{ active: selectedCategory === cat.id }\"\n              @click=\"selectedCategory = cat.id\"\n            >\n              <component\n                :is=\"cat.icon\"\n                :size=\"16\"\n              />\n              <span>{{ cat.label }}</span>\n              <span class=\"tab-count\">\n                {{ categoryStats[cat.id].earned }}/{{ categoryStats[cat.id].total }}\n              </span>\n            </button>\n          </div>\n\n          <div class=\"achievements-list\">\n            <AchievementBadge\n              v-for=\"achievement in filteredAchievements\"\n              :key=\"achievement.id\"\n              :achievement=\"achievement\"\n              size=\"md\"\n              show-progress\n              show-description\n            />\n\n            <div\n              v-if=\"filteredAchievements.length === 0\"\n              class=\"empty-state\"\n            >\n              <Lock :size=\"32\" />\n              <span>No achievements in this category yet</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </Transition>\n  </Teleport>\n</template>\n\n<style scoped>\n.modal-overlay {\n  position: fixed;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--overlay-bg);\n  backdrop-filter: blur(var(--space-1));\n  z-index: var(--z-modal);\n}\n\n.modal-container {\n  display: flex;\n  flex-direction: column;\n  width: 90%;\n  max-width: 600px;\n  max-height: 80vh;\n  background: var(--gamification-panel-bg);\n  border: 1px solid var(--gamification-panel-border);\n  border-radius: var(--radius-xl);\n  overflow: hidden;\n}\n\n.modal-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--space-4) var(--space-5);\n  border-bottom: 1px solid var(--purple-border-medium);\n}\n\n.header-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n}\n\n.header-icon {\n  color: rgba(var(--tier-gold), 0.9);\n}\n\n.header-title h2 {\n  font-size: var(--text-xl);\n  font-weight: var(--font-bold);\n  color: var(--gamification-text-primary);\n  margin: 0;\n}\n\n.header-count {\n  padding: var(--space-1) var(--space-2_5);\n  background: rgba(var(--tier-gold), 0.15);\n  border-radius: var(--radius-full);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: rgba(var(--tier-gold), 0.9);\n}\n\n.close-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: var(--space-2);\n  background: transparent;\n  border: none;\n  border-radius: var(--radius-md);\n  color: var(--gamification-text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.close-btn:hover {\n  background: var(--purple-bg-subtle);\n  color: var(--gamification-text-primary);\n}\n\n.category-tabs {\n  display: flex;\n  gap: var(--space-2);\n  padding: var(--space-3) var(--space-5);\n  overflow-x: auto;\n  border-bottom: 1px solid var(--border-medium);\n}\n\n.category-tab {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: transparent;\n  border: 1px solid var(--purple-border-medium);\n  border-radius: var(--radius-md);\n  color: var(--gamification-text-secondary);\n  font-size: var(--text-sm);\n  white-space: nowrap;\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.category-tab:hover {\n  background: var(--purple-bg-subtle);\n  border-color: var(--purple-border-strong);\n}\n\n.category-tab.active {\n  background: rgba(var(--neon-cyan), 0.15);\n  border-color: rgba(var(--neon-cyan), 0.4);\n  color: rgba(var(--neon-cyan), 1);\n}\n\n.tab-count {\n  font-size: var(--text-xs);\n  opacity: 0.7;\n}\n\n.achievements-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  padding: var(--space-4) var(--space-5);\n  overflow-y: auto;\n  flex: 1;\n}\n\n.empty-state {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-8);\n  color: var(--gamification-text-secondary);\n  text-align: center;\n}\n\n/* Modal transitions */\n.modal-enter-active,\n.modal-leave-active {\n  transition: opacity var(--duration-normal) ease;\n}\n\n.modal-enter-active .modal-container,\n.modal-leave-active .modal-container {\n  transition: transform var(--duration-normal) ease;\n}\n\n.modal-enter-from,\n.modal-leave-to {\n  opacity: 0;\n}\n\n.modal-enter-from .modal-container,\n.modal-leave-to .modal-container {\n  transform: scale(0.95) translateY(var(--space-2_5));\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/BossFightPanel.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":15,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'lastWeeklyGeneration' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":21,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":55}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * BossFightPanel Component\n * FEATURE-1132: Weekly boss fight display with HP bar and timer\n */\nimport { computed, ref, onMounted } from 'vue'\nimport { useChallengesStore } from '@/stores/challenges'\nimport { createAIRouter } from '@/services/ai/router'\nimport type { ChatMessage } from '@/services/ai/types'\nimport { storeToRefs } from 'pinia'\nimport ARIAMessage from './ARIAMessage.vue'\nimport { Skull, Swords, Clock, Zap, Trophy, RefreshCw, Sparkles } from 'lucide-vue-next'\n\n// Props\nconst props = defineProps<{\n  compact?: boolean\n}>()\n\n// Store\nconst challengesStore = useChallengesStore()\nconst { activeBoss, isGenerating, lastWeeklyGeneration } = storeToRefs(challengesStore)\n\n// AI Router for boss generation\nlet router: ReturnType<typeof createAIRouter> | null = null\nconst aiAvailable = ref(false)\n\n// Initialize router and check availability\nonMounted(async () => {\n  try {\n    router = createAIRouter({ debug: false })\n    await router.initialize()\n    const provider = await router.getActiveProvider()\n    aiAvailable.value = !!provider\n  } catch (e) {\n    console.warn('[BossFight] AI router init failed:', e)\n    aiAvailable.value = false\n  }\n})\n\n// Chat wrapper for gamemaster\nasync function chatWithAI(messages: ChatMessage[], options?: { taskType?: string }): Promise<{ content: string }> {\n  if (!router) {\n    return { content: '' }\n  }\n  try {\n    const response = await router.chat(messages, { taskType: options?.taskType as 'planning' })\n    return { content: response.content }\n  } catch (e) {\n    console.warn('[BossFight] AI chat failed:', e)\n    return { content: '' }\n  }\n}\n\n// Local state\nconst generationError = ref<string | null>(null)\n\n// Computed\nconst bossHp = computed(() => {\n  if (!activeBoss.value) return { current: 0, max: 0, percent: 0 }\n\n  const context = activeBoss.value.aiContext as { total_hp?: number } | undefined\n  const maxHp = context?.total_hp ?? activeBoss.value.objectiveTarget * 10\n  const damage = activeBoss.value.objectiveCurrent * 10\n  const currentHp = Math.max(0, maxHp - damage)\n  const percent = (currentHp / maxHp) * 100\n\n  return { current: currentHp, max: maxHp, percent }\n})\n\nconst damageDealt = computed(() => {\n  if (!activeBoss.value) return 0\n  return activeBoss.value.objectiveCurrent * 10\n})\n\nconst timeRemaining = computed(() => {\n  if (!activeBoss.value) return 'No active boss'\n\n  const now = new Date()\n  const expires = new Date(activeBoss.value.expiresAt)\n  const diff = expires.getTime() - now.getTime()\n\n  if (diff <= 0) return 'Time expired!'\n\n  const days = Math.floor(diff / (1000 * 60 * 60 * 24))\n  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))\n\n  return `${days}d ${hours}h remaining`\n})\n\nconst hpBarColor = computed(() => {\n  const percent = bossHp.value.percent\n  if (percent > 66) return 'bg-red-500'\n  if (percent > 33) return 'bg-orange-500'\n  return 'bg-green-500'\n})\n\nconst isDefeated = computed(() =>\n  activeBoss.value?.status === 'completed' || bossHp.value.percent <= 0\n)\n\nconst needsGeneration = computed(() => {\n  if (activeBoss.value) return false\n\n  // Only suggest generation on Monday or if explicitly requested\n  const now = new Date()\n  return now.getDay() === 1 // Monday\n})\n\nconst ariaMessage = computed(() => {\n  if (!activeBoss.value) {\n    return needsGeneration.value\n      ? 'Netrunner, a major threat has emerged in the Grid. Ready to engage?'\n      : 'No active threats detected. Weekly boss spawns on Monday.'\n  }\n\n  if (isDefeated.value) {\n    return 'Victory! The threat has been neutralized. The Grid thanks you.'\n  }\n\n  if (bossHp.value.percent < 25) {\n    return 'Critical damage! The boss is weakened. Finish it!'\n  }\n\n  if (bossHp.value.percent < 50) {\n    return 'Making progress. Keep the pressure on, netrunner.'\n  }\n\n  return `Engaging ${activeBoss.value.title}. Deal damage by completing tasks.`\n})\n\n// Actions\nasync function generateBoss() {\n  generationError.value = null\n\n  try {\n    await challengesStore.generateWeeklyBossAction({\n      aiAvailable: aiAvailable.value,\n      chat: chatWithAI,\n    })\n  } catch (error) {\n    generationError.value = error instanceof Error ? error.message : 'Failed to generate boss'\n    console.error('[BossFight] Generation failed:', error)\n  }\n}\n</script>\n\n<template>\n  <div class=\"boss-fight-panel\" :class=\"{ 'panel--compact': compact }\">\n    <!-- Header -->\n    <div class=\"panel-header\">\n      <div class=\"header-title\">\n        <Skull class=\"header-icon\" :size=\"18\" />\n        <h3>Weekly Boss</h3>\n      </div>\n      <div v-if=\"activeBoss && !isDefeated\" class=\"header-timer\">\n        <Clock :size=\"14\" />\n        <span>{{ timeRemaining }}</span>\n      </div>\n    </div>\n\n    <!-- Active Boss -->\n    <div v-if=\"activeBoss\" class=\"boss-content\">\n      <!-- Boss Info -->\n      <div class=\"boss-info\" :class=\"{ 'boss-info--defeated': isDefeated }\">\n        <h4 class=\"boss-name\">\n          {{ activeBoss.title }}\n        </h4>\n        <p v-if=\"!compact\" class=\"boss-description\">\n          {{ activeBoss.description }}\n        </p>\n      </div>\n\n      <!-- HP Bar -->\n      <div class=\"hp-section\">\n        <div class=\"hp-labels\">\n          <span class=\"hp-label\">HP</span>\n          <span class=\"hp-value\">{{ bossHp.current }} / {{ bossHp.max }}</span>\n        </div>\n        <div class=\"hp-bar-container\">\n          <div\n            class=\"hp-bar\"\n            :class=\"[hpBarColor, { 'hp-bar--empty': isDefeated }]\"\n            :style=\"{ width: `${bossHp.percent}%` }\"\n          />\n        </div>\n      </div>\n\n      <!-- Damage Stats -->\n      <div class=\"damage-stats\">\n        <div class=\"stat\">\n          <Swords :size=\"14\" />\n          <span>{{ damageDealt }} damage dealt</span>\n        </div>\n        <div class=\"stat\">\n          <Zap :size=\"14\" />\n          <span>{{ activeBoss.rewardXp }} XP reward</span>\n        </div>\n      </div>\n\n      <!-- Victory State -->\n      <div v-if=\"isDefeated\" class=\"victory-banner\">\n        <Trophy class=\"trophy-icon\" :size=\"24\" />\n        <span>VICTORY!</span>\n      </div>\n\n      <!-- ARIA Message -->\n      <ARIAMessage\n        v-if=\"!compact\"\n        :message=\"ariaMessage\"\n        :type=\"isDefeated ? 'success' : bossHp.percent < 25 ? 'warning' : 'info'\"\n        :show-avatar=\"false\"\n      />\n    </div>\n\n    <!-- No Boss State -->\n    <div v-else class=\"no-boss\">\n      <ARIAMessage\n        :message=\"ariaMessage\"\n        :type=\"needsGeneration ? 'warning' : 'info'\"\n        :show-avatar=\"!compact\"\n      />\n\n      <button\n        v-if=\"needsGeneration\"\n        class=\"generate-button\"\n        :disabled=\"isGenerating\"\n        @click=\"generateBoss\"\n      >\n        <RefreshCw\n          v-if=\"isGenerating\"\n          class=\"button-icon spinning\"\n          :size=\"16\"\n        />\n        <Sparkles v-else class=\"button-icon\" :size=\"16\" />\n        {{ isGenerating ? 'Summoning...' : 'Engage Boss' }}\n      </button>\n\n      <p v-if=\"generationError\" class=\"error-message\">\n        {{ generationError }}\n      </p>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.boss-fight-panel {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n  padding: var(--space-4);\n  background: linear-gradient(135deg, rgba(139, 0, 0, 0.1), var(--glass-bg-heavy));\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--danger-border-medium);\n}\n\n.panel--compact {\n  padding: var(--space-3);\n  gap: var(--space-2);\n}\n\n.panel-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.header-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.header-icon {\n  color: var(--color-error-400);\n}\n\n.header-title h3 {\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  margin: 0;\n}\n\n.header-timer {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  color: var(--color-warning-400);\n}\n\n.boss-content {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n}\n\n.boss-info {\n  text-align: center;\n}\n\n.boss-info--defeated {\n  opacity: 0.6;\n}\n\n.boss-name {\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  color: var(--color-error-400);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n  margin: 0 0 var(--space-1);\n  text-shadow: 0 0 var(--space-5) var(--color-error-500);\n}\n\n.boss-description {\n  font-size: var(--text-sm);\n  color: var(--text-tertiary);\n  margin: 0;\n  line-height: var(--leading-snug);\n}\n\n.hp-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.hp-labels {\n  display: flex;\n  justify-content: space-between;\n  font-size: var(--text-xs);\n}\n\n.hp-label {\n  font-weight: var(--font-semibold);\n  color: var(--text-tertiary);\n  text-transform: uppercase;\n}\n\n.hp-value {\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n}\n\n.hp-bar-container {\n  height: var(--space-3);\n  background: var(--glass-bg-tint);\n  border-radius: var(--radius-sm);\n  overflow: hidden;\n  position: relative;\n}\n\n.hp-bar {\n  height: 100%;\n  border-radius: var(--radius-sm);\n  transition: width var(--duration-slower) var(--ease-out), background-color var(--duration-slow) var(--ease-out);\n  box-shadow: 0 0 var(--space-2_5) currentColor;\n}\n\n.hp-bar--empty {\n  width: 0 !important;\n}\n\n.bg-red-500 { background: #ef4444; color: #ef4444; }\n.bg-orange-500 { background: #f97316; color: #f97316; }\n.bg-green-500 { background: #22c55e; color: #22c55e; }\n\n.damage-stats {\n  display: flex;\n  justify-content: center;\n  gap: var(--space-4);\n}\n\n.stat {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n}\n\n.stat svg {\n  color: var(--color-warning-400);\n}\n\n.victory-banner {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-3);\n  background: linear-gradient(135deg, var(--color-success-600), var(--color-success-500));\n  border-radius: var(--radius-md);\n  color: var(--text-primary);\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n  animation: victory-glow 1s var(--ease-in-out) infinite alternate;\n}\n\n@keyframes victory-glow {\n  from { box-shadow: 0 0 var(--space-2_5) var(--color-success-500); }\n  to { box-shadow: 0 0 var(--space-8) var(--color-success-400); }\n}\n\n.trophy-icon {\n  animation: trophy-bounce 0.5s ease-in-out infinite alternate;\n}\n\n@keyframes trophy-bounce {\n  from { transform: translateY(0); }\n  to { transform: translateY(calc(-1 * var(--space-1))); }\n}\n\n.no-boss {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-3);\n  text-align: center;\n}\n\n.generate-button {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-4);\n  background: linear-gradient(135deg, var(--color-error-600), var(--color-error-500));\n  color: var(--text-primary);\n  border: none;\n  border-radius: var(--radius-md);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n}\n\n.generate-button:hover:not(:disabled) {\n  transform: translateY(calc(-1 * var(--space-px) * 2));\n  box-shadow: 0 var(--space-1) var(--space-3) var(--danger-shadow-strong);\n}\n\n.generate-button:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.button-icon {\n  flex-shrink: 0;\n}\n\n.spinning {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n.error-message {\n  font-size: var(--text-xs);\n  color: var(--color-error-400);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/ChallengeCard.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/ChallengeComplete.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":12,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * ChallengeComplete Component\n * FEATURE-1132: Victory animation + rewards toast\n *\n * Displayed when a challenge is completed.\n */\nimport { ref, onMounted, onUnmounted } from 'vue'\nimport type { Challenge } from '@/types/challenges'\nimport { Trophy, Zap, TrendingDown, Sparkles } from 'lucide-vue-next'\n\nconst props = defineProps<{\n  challenge: Challenge\n  xpAwarded: number\n  corruptionReduction: number\n  narrative?: string\n}>()\n\nconst emit = defineEmits<{\n  (e: 'close'): void\n}>()\n\n// Animation state\nconst isVisible = ref(false)\nconst showContent = ref(false)\n\n// Auto-close timer\nlet closeTimeout: ReturnType<typeof setTimeout> | null = null\n\nonMounted(() => {\n  // Trigger entrance animation\n  requestAnimationFrame(() => {\n    isVisible.value = true\n    setTimeout(() => {\n      showContent.value = true\n    }, 200)\n  })\n\n  // Auto-close after 5 seconds\n  closeTimeout = setTimeout(() => {\n    handleClose()\n  }, 5000)\n})\n\nonUnmounted(() => {\n  if (closeTimeout) {\n    clearTimeout(closeTimeout)\n  }\n})\n\nfunction handleClose() {\n  showContent.value = false\n  setTimeout(() => {\n    isVisible.value = false\n    setTimeout(() => {\n      emit('close')\n    }, 300)\n  }, 200)\n}\n</script>\n\n<template>\n  <Teleport to=\"body\">\n    <Transition name=\"overlay\">\n      <div\n        v-if=\"isVisible\"\n        class=\"challenge-complete-overlay\"\n        @click.self=\"handleClose\"\n      >\n        <Transition name=\"content\">\n          <div v-if=\"showContent\" class=\"challenge-complete-card\">\n            <!-- Decorative sparkles -->\n            <div class=\"sparkles\">\n              <Sparkles\n                v-for=\"i in 5\"\n                :key=\"i\"\n                class=\"sparkle\"\n                :style=\"{\n                  '--delay': `${i * 0.1}s`,\n                  '--offset-x': `${(i - 3) * 30}px`,\n                }\"\n                :size=\"16\"\n              />\n            </div>\n\n            <!-- Trophy icon -->\n            <div class=\"trophy-container\">\n              <Trophy class=\"trophy-icon\" :size=\"48\" />\n            </div>\n\n            <!-- Title -->\n            <h2 class=\"complete-title\">\n              Mission Complete!\n            </h2>\n\n            <!-- Challenge name -->\n            <p class=\"challenge-name\">\n              {{ challenge.title }}\n            </p>\n\n            <!-- Rewards -->\n            <div class=\"rewards\">\n              <div class=\"reward reward--xp\">\n                <Zap :size=\"20\" />\n                <span class=\"reward-value\">+{{ xpAwarded }}</span>\n                <span class=\"reward-label\">XP</span>\n              </div>\n\n              <div\n                v-if=\"corruptionReduction > 0\"\n                class=\"reward reward--corruption\"\n              >\n                <TrendingDown :size=\"20\" />\n                <span class=\"reward-value\">-{{ corruptionReduction }}%</span>\n                <span class=\"reward-label\">Corruption</span>\n              </div>\n            </div>\n\n            <!-- ARIA narrative -->\n            <p v-if=\"narrative\" class=\"aria-narrative\">\n              \"{{ narrative }}\"\n            </p>\n\n            <!-- Close button -->\n            <button class=\"close-button\" @click=\"handleClose\">\n              Continue\n            </button>\n          </div>\n        </Transition>\n      </div>\n    </Transition>\n  </Teleport>\n</template>\n\n<style scoped>\n.challenge-complete-overlay {\n  position: fixed;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--overlay-bg);\n  backdrop-filter: blur(var(--space-1));\n  z-index: var(--z-tooltip);\n}\n\n.challenge-complete-card {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-4);\n  padding: var(--space-6);\n  background: linear-gradient(\n    135deg,\n    rgba(34, 197, 94, 0.2) 0%,\n    var(--glass-bg-solid) 50%,\n    rgba(0, 200, 255, 0.1) 100%\n  );\n  border: var(--space-px) solid var(--color-success-500);\n  border-radius: var(--radius-xl);\n  box-shadow:\n    0 0 var(--space-10) var(--success-shadow),\n    var(--shadow-dark-xl);\n  text-align: center;\n  max-width: 400px;\n  width: 90%;\n  overflow: hidden;\n}\n\n/* Decorative sparkles */\n.sparkles {\n  position: absolute;\n  top: calc(-1 * var(--space-5));\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  gap: var(--space-4);\n}\n\n.sparkle {\n  color: var(--color-warning-400);\n  animation: sparkle-float 1.5s ease-in-out infinite;\n  animation-delay: var(--delay, 0s);\n  transform: translateX(var(--offset-x, 0));\n}\n\n@keyframes sparkle-float {\n  0%, 100% {\n    transform: translateX(var(--offset-x, 0)) translateY(0) scale(1);\n    opacity: 0.5;\n  }\n  50% {\n    transform: translateX(var(--offset-x, 0)) translateY(calc(-1 * var(--space-2_5))) scale(1.2);\n    opacity: 1;\n  }\n}\n\n/* Trophy */\n.trophy-container {\n  width: var(--space-20);\n  height: var(--space-20);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: linear-gradient(135deg, var(--color-warning-500), var(--color-warning-400));\n  border-radius: var(--radius-full);\n  box-shadow: 0 0 var(--space-8) var(--color-warning-500/50);\n  animation: trophy-pulse 1s var(--ease-in-out) infinite alternate;\n}\n\n@keyframes trophy-pulse {\n  from {\n    box-shadow: 0 0 var(--space-5) var(--color-warning-500/30);\n    transform: scale(1);\n  }\n  to {\n    box-shadow: 0 0 var(--space-10) var(--color-warning-500/60);\n    transform: scale(1.05);\n  }\n}\n\n.trophy-icon {\n  color: var(--text-primary);\n  animation: trophy-bounce 0.6s var(--ease-in-out) infinite alternate;\n}\n\n@keyframes trophy-bounce {\n  from { transform: translateY(0) rotate(-5deg); }\n  to { transform: translateY(calc(-1 * var(--space-1))) rotate(5deg); }\n}\n\n/* Title */\n.complete-title {\n  margin: 0;\n  font-size: var(--text-2xl);\n  font-weight: var(--font-bold);\n  color: var(--color-success-400);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n  text-shadow: 0 0 var(--space-5) var(--success-shadow);\n}\n\n/* Challenge name */\n.challenge-name {\n  margin: 0;\n  font-size: var(--text-base);\n  color: var(--text-tertiary);\n  font-weight: var(--font-medium);\n}\n\n/* Rewards */\n.rewards {\n  display: flex;\n  gap: var(--space-6);\n  padding: var(--space-3) var(--space-4);\n  background: var(--glass-bg-weak);\n  border-radius: var(--radius-lg);\n}\n\n.reward {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-1);\n}\n\n.reward svg {\n  opacity: 0.8;\n}\n\n.reward--xp svg {\n  color: var(--color-warning-400);\n}\n\n.reward--corruption svg {\n  color: var(--color-success-400);\n}\n\n.reward-value {\n  font-size: var(--text-xl);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.reward-label {\n  font-size: var(--text-xs);\n  color: var(--color-gray-500);\n  text-transform: uppercase;\n}\n\n/* ARIA narrative */\n.aria-narrative {\n  margin: 0;\n  font-size: var(--text-sm);\n  font-style: italic;\n  color: var(--color-primary-300);\n  max-width: 300px;\n  line-height: var(--leading-normal);\n}\n\n/* Close button */\n.close-button {\n  padding: var(--space-2) var(--space-6);\n  background: linear-gradient(135deg, var(--color-success-600), var(--color-success-500));\n  color: var(--text-primary);\n  border: none;\n  border-radius: var(--radius-md);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n}\n\n.close-button:hover {\n  transform: translateY(calc(-1 * var(--space-px) * 2));\n  box-shadow: 0 var(--space-1) var(--space-3) var(--success-shadow);\n}\n\n/* Transitions */\n.overlay-enter-active,\n.overlay-leave-active {\n  transition: opacity var(--duration-slow) var(--ease-out);\n}\n\n.overlay-enter-from,\n.overlay-leave-to {\n  opacity: 0;\n}\n\n.content-enter-active,\n.content-leave-active {\n  transition: all var(--duration-slow) var(--ease-out);\n}\n\n.content-enter-from {\n  opacity: 0;\n  transform: scale(0.8) translateY(var(--space-5));\n}\n\n.content-leave-to {\n  opacity: 0;\n  transform: scale(0.9) translateY(calc(-1 * var(--space-2_5)));\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/ChallengePips.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/CorruptionOverlay.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/DailyChallengesPanel.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":17,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'lastDailyGeneration' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * DailyChallengesPanel Component\n * FEATURE-1132: Display 3 daily missions with generation trigger\n */\nimport { computed, ref, onMounted } from 'vue'\nimport { useChallengesStore } from '@/stores/challenges'\nimport { createAIRouter } from '@/services/ai/router'\nimport type { ChatMessage } from '@/services/ai/types'\nimport type { Challenge } from '@/types/challenges'\nimport { storeToRefs } from 'pinia'\nimport ChallengeCard from './ChallengeCard.vue'\nimport ARIAMessage from './ARIAMessage.vue'\nimport { RefreshCw, Sparkles, CheckCircle2, AlertCircle, Target } from 'lucide-vue-next'\n\n// Props\nconst props = defineProps<{\n  compact?: boolean\n}>()\n\nconst emit = defineEmits<{\n  pickChallenge: [challenge: Challenge]\n}>()\n\n// Store\nconst challengesStore = useChallengesStore()\nconst {\n  activeDailies,\n  allDailiesComplete,\n  isGenerating,\n  lastDailyGeneration,\n  completedTodayCount,\n  pickedChallengeId,\n  pickedChallenge,\n} = storeToRefs(challengesStore)\n\n// AI Router for challenge generation\nlet router: ReturnType<typeof createAIRouter> | null = null\nconst aiAvailable = ref(false)\n\n// Initialize router and check availability\nonMounted(async () => {\n  try {\n    router = createAIRouter({ debug: false })\n    await router.initialize()\n    const provider = await router.getActiveProvider()\n    aiAvailable.value = !!provider\n  } catch (e) {\n    console.warn('[DailyChallenges] AI router init failed:', e)\n    aiAvailable.value = false\n  }\n})\n\n// Chat wrapper for gamemaster\nasync function chatWithAI(messages: ChatMessage[], options?: { taskType?: string }): Promise<{ content: string }> {\n  if (!router) {\n    return { content: '' }\n  }\n  try {\n    const response = await router.chat(messages, { taskType: options?.taskType as 'planning' })\n    return { content: response.content }\n  } catch (e) {\n    console.warn('[DailyChallenges] AI chat failed:', e)\n    return { content: '' }\n  }\n}\n\n// Local state\nconst showGenerateConfirm = ref(false)\nconst generationError = ref<string | null>(null)\n\n// Computed\nconst needsGeneration = computed(() =>\n  activeDailies.value.length === 0 && !allDailiesComplete.value\n)\n\nconst statusMessage = computed(() => {\n  if (isGenerating.value) {\n    return 'ARIA is analyzing your patterns...'\n  }\n  if (allDailiesComplete.value) {\n    return 'All daily missions complete. Grid stability restored.'\n  }\n  if (activeDailies.value.length > 0) {\n    return `${3 - activeDailies.value.length} of 3 missions complete`\n  }\n  return 'Daily missions ready for deployment'\n})\n\n// Actions\nasync function generateChallenges() {\n  generationError.value = null\n\n  try {\n    await challengesStore.generateDailyChallengesAction({\n      aiAvailable: aiAvailable.value,\n      chat: chatWithAI,\n    })\n    showGenerateConfirm.value = false\n  } catch (error) {\n    generationError.value = error instanceof Error ? error.message : 'Failed to generate challenges'\n    console.error('[DailyChallenges] Generation failed:', error)\n  }\n}\n\nfunction handleChallengeClick(challenge: Challenge) {\n  // Toggle: click again to deselect\n  if (pickedChallengeId.value === challenge.id) {\n    challengesStore.pickChallengeById(null)\n    return\n  }\n  challengesStore.pickChallengeById(challenge.id)\n  emit('pickChallenge', challenge)\n}\n</script>\n\n<template>\n  <div class=\"daily-challenges-panel\" :class=\"{ 'panel--compact': compact }\">\n    <!-- Header -->\n    <div class=\"panel-header\">\n      <div class=\"header-title\">\n        <Sparkles class=\"header-icon\" :size=\"18\" />\n        <h3>Daily Missions</h3>\n      </div>\n      <div class=\"header-status\">\n        <span\n          class=\"status-indicator\"\n          :class=\"{\n            'status--complete': allDailiesComplete,\n            'status--active': activeDailies.length > 0,\n            'status--pending': needsGeneration,\n          }\"\n        />\n        <span class=\"status-text\">{{ completedTodayCount }}/3</span>\n      </div>\n    </div>\n\n    <!-- ARIA Message -->\n    <ARIAMessage\n      v-if=\"!compact\"\n      :message=\"statusMessage\"\n      :type=\"allDailiesComplete ? 'success' : isGenerating ? 'loading' : 'info'\"\n    />\n\n    <!-- Active Mission Banner -->\n    <div v-if=\"pickedChallenge\" class=\"active-mission-banner\">\n      <div class=\"mission-banner-indicator\" />\n      <Target :size=\"14\" class=\"mission-banner-icon\" />\n      <div class=\"mission-banner-content\">\n        <span class=\"mission-banner-label\">ACTIVE MISSION</span>\n        <span class=\"mission-banner-title\">{{ pickedChallenge.title }}</span>\n      </div>\n      <span class=\"mission-banner-progress\">{{ pickedChallenge.objectiveCurrent }}/{{ pickedChallenge.objectiveTarget }}</span>\n    </div>\n\n    <!-- Challenge Cards -->\n    <div v-if=\"activeDailies.length > 0\" class=\"challenges-list\">\n      <ChallengeCard\n        v-for=\"challenge in activeDailies\"\n        :key=\"challenge.id\"\n        :challenge=\"challenge\"\n        :compact=\"compact\"\n        :class=\"{\n          'card--picked': pickedChallengeId === challenge.id,\n          'card--other': pickedChallengeId && pickedChallengeId !== challenge.id\n        }\"\n        @click=\"handleChallengeClick(challenge)\"\n      />\n    </div>\n\n    <!-- All Complete State -->\n    <div v-else-if=\"allDailiesComplete\" class=\"all-complete\">\n      <CheckCircle2 class=\"complete-icon\" :size=\"32\" />\n      <p>Excellent work, netrunner.</p>\n      <p class=\"subtext\">\n        Return tomorrow for new missions.\n      </p>\n    </div>\n\n    <!-- Generate Button -->\n    <div v-else-if=\"needsGeneration\" class=\"generate-section\">\n      <p class=\"generate-prompt\">\n        ARIA has prepared your daily missions.\n        <br>\n        Ready to accept the challenge?\n      </p>\n\n      <button\n        class=\"generate-button\"\n        :disabled=\"isGenerating\"\n        @click=\"generateChallenges\"\n      >\n        <RefreshCw\n          v-if=\"isGenerating\"\n          class=\"button-icon spinning\"\n          :size=\"16\"\n        />\n        <Sparkles v-else class=\"button-icon\" :size=\"16\" />\n        {{ isGenerating ? 'Generating...' : 'Accept Missions' }}\n      </button>\n\n      <!-- Error message -->\n      <div v-if=\"generationError\" class=\"error-message\">\n        <AlertCircle :size=\"14\" />\n        {{ generationError }}\n      </div>\n    </div>\n\n    <!-- Loading State -->\n    <div v-else-if=\"isGenerating\" class=\"loading-state\">\n      <RefreshCw class=\"spinning\" :size=\"24\" />\n      <p>ARIA is analyzing the Grid...</p>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.daily-challenges-panel {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n  padding: var(--space-4);\n  background: var(--overlay-component-bg);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-color);\n}\n\n.panel--compact {\n  padding: var(--space-3);\n  gap: var(--space-2);\n}\n\n.panel-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.header-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.header-icon {\n  color: var(--color-accent-cyan);\n}\n\n.header-title h3 {\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  margin: 0;\n}\n\n.header-status {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.status-indicator {\n  width: var(--space-2);\n  height: var(--space-2);\n  border-radius: var(--radius-full);\n  background: var(--text-muted);\n}\n\n.status--complete {\n  background: var(--color-success-500);\n  box-shadow: 0 0 var(--space-2) var(--color-success-500);\n}\n\n.status--active {\n  background: var(--color-primary-500);\n  animation: pulse 2s ease-in-out infinite;\n}\n\n.status--pending {\n  background: var(--color-warning-500);\n}\n\n@keyframes pulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.5; }\n}\n\n.status-text {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-tertiary);\n}\n\n.challenges-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.all-complete {\n  text-align: center;\n  padding: var(--space-4);\n}\n\n.complete-icon {\n  color: var(--color-success-500);\n  margin-bottom: var(--space-2);\n}\n\n.all-complete p {\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n.all-complete .subtext {\n  font-size: var(--text-sm);\n  color: var(--color-gray-500);\n  margin-top: var(--space-1);\n}\n\n.generate-section {\n  text-align: center;\n  padding: var(--space-4);\n}\n\n.generate-prompt {\n  font-size: var(--text-sm);\n  color: var(--text-tertiary);\n  margin-bottom: var(--space-3);\n  line-height: var(--leading-normal);\n}\n\n.generate-button {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-4);\n  background: linear-gradient(135deg, var(--color-primary-600), var(--color-accent-cyan));\n  color: var(--text-primary);\n  border: none;\n  border-radius: var(--radius-md);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n}\n\n.generate-button:hover:not(:disabled) {\n  transform: translateY(calc(-1 * var(--space-px) * 2));\n  box-shadow: 0 var(--space-1) var(--space-3) rgba(0, 200, 255, 0.3);\n}\n\n.generate-button:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.button-icon {\n  flex-shrink: 0;\n}\n\n.spinning {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n.error-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  margin-top: var(--space-3);\n  padding: var(--space-2);\n  background: var(--danger-bg-medium);\n  border-radius: var(--radius-sm);\n  color: var(--color-error-400);\n  font-size: var(--text-xs);\n}\n\n.loading-state {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-4);\n  color: var(--text-tertiary);\n}\n\n.loading-state p {\n  margin: 0;\n  font-size: var(--text-sm);\n}\n\n/* ============================================\n   Active Mission Banner\n   ============================================ */\n.active-mission-banner {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(0, 240, 255, 0.06);\n  border: 1px solid rgba(0, 240, 255, 0.25);\n  border-radius: var(--radius-md);\n  animation: bannerAppear 0.4s ease-out;\n}\n\n.mission-banner-indicator {\n  width: 3px;\n  height: 24px;\n  background: var(--cf-cyan, #00f0ff);\n  border-radius: 2px;\n  flex-shrink: 0;\n  animation: indicatorPulse 2s ease-in-out infinite;\n}\n\n.mission-banner-icon {\n  color: var(--cf-cyan, #00f0ff);\n  flex-shrink: 0;\n}\n\n.mission-banner-content {\n  display: flex;\n  flex-direction: column;\n  gap: 1px;\n  flex: 1;\n  min-width: 0;\n}\n\n.mission-banner-label {\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: 9px;\n  font-weight: 700;\n  color: var(--cf-cyan, #00f0ff);\n  text-transform: uppercase;\n  letter-spacing: 0.12em;\n  line-height: 1;\n}\n\n.mission-banner-title {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  line-height: 1.3;\n}\n\n.mission-banner-progress {\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: var(--cf-cyan, #00f0ff);\n  flex-shrink: 0;\n}\n\n/* ============================================\n   Picked card: persistent cyan glow + pulse\n   ============================================ */\n.card--picked {\n  border-color: var(--cf-cyan, rgba(0, 240, 255, 0.8)) !important;\n  box-shadow:\n    0 0 8px rgba(0, 240, 255, 0.4),\n    0 0 20px rgba(0, 240, 255, 0.15) !important;\n  animation: pickedGlow 2.5s ease-in-out infinite;\n}\n\n/* Other cards: dimmed when one is picked */\n.card--other {\n  opacity: 0.5;\n  transition: opacity 0.3s ease;\n}\n\n.card--other:hover {\n  opacity: 0.8;\n}\n\n@keyframes pickedGlow {\n  0%, 100% {\n    box-shadow:\n      0 0 8px rgba(0, 240, 255, 0.4),\n      0 0 20px rgba(0, 240, 255, 0.15);\n  }\n  50% {\n    box-shadow:\n      0 0 12px rgba(0, 240, 255, 0.6),\n      0 0 28px rgba(0, 240, 255, 0.25);\n  }\n}\n\n@keyframes bannerAppear {\n  0% { opacity: 0; transform: translateY(-4px); }\n  100% { opacity: 1; transform: translateY(0); }\n}\n\n@keyframes indicatorPulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.5; }\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .card--picked {\n    animation: none;\n  }\n  .active-mission-banner {\n    animation: none;\n  }\n  .mission-banner-indicator {\n    animation: none;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/GamificationHUD.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * GamificationHUD - RPG-styled header HUD\n * Replaces inline gamification widgets with a unified, cyberflow-themed display.\n *\n * Adapts to intensity level:\n * - minimal: \"Lv.N\" text only (no container, no decoration)\n * - moderate: Corner-cut container with level + XP bar + streak + challenge pips\n * - intense: Same + always-on glow + XP shine animation + narrative micro-text\n *\n * Skill sources: cyberflow-design-system (container, glow, typography),\n * game-ui-components (XP gradient, streak flame), gamification-intensity-system (rendering tiers)\n */\nimport { computed } from 'vue'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useChallengesStore } from '@/stores/challenges'\nimport { useAuthStore } from '@/stores/auth'\nimport { useSettingsStore } from '@/stores/settings'\nimport { useUIStore } from '@/stores/ui'\nimport { useCyberflowTheme } from '@/composables/useCyberflowTheme'\nimport { useXpAnimations } from '@/composables/useXpAnimations'\nimport { getLevelNarrative } from '@/composables/useAriaTooltipNarrative'\nimport { GamificationTooltipWrapper, LevelBadge, ChallengePips } from '@/components/gamification'\nimport LevelTooltipContent from '@/components/gamification/tooltips/LevelTooltipContent.vue'\nimport XpTooltipContent from '@/components/gamification/tooltips/XpTooltipContent.vue'\nimport StreakTooltipContent from '@/components/gamification/tooltips/StreakTooltipContent.vue'\nimport ChallengeTooltipContent from '@/components/gamification/tooltips/ChallengeTooltipContent.vue'\nimport { Flame, ChevronDown, Target } from 'lucide-vue-next'\n\nconst props = defineProps<{\n  panelOpen: boolean\n}>()\n\nconst emit = defineEmits<{\n  togglePanel: []\n}>()\n\nconst gamificationStore = useGamificationStore()\nconst challengesStore = useChallengesStore()\nconst authStore = useAuthStore()\nconst settingsStore = useSettingsStore()\nconst uiStore = useUIStore()\n\nconst { showAtIntensity } = useCyberflowTheme()\nconst isMinimal = computed(() => !showAtIntensity('moderate'))\nconst isIntense = computed(() => showAtIntensity('intense'))\n\nconst { latestLevelEvent } = useXpAnimations()\n\n// Gamification data\nconst level = computed(() => gamificationStore.currentLevel)\nconst levelInfo = computed(() => gamificationStore.levelInfo)\nconst progressPercent = computed(() => levelInfo.value.progressPercent)\nconst xpText = computed(() => `${levelInfo.value.currentXp}/${levelInfo.value.xpForNextLevel}`)\nconst streakInfo = computed(() => gamificationStore.streakInfo)\nconst streak = computed(() => streakInfo.value.currentStreak)\nconst isActiveToday = computed(() => streakInfo.value.isActiveToday)\nconst hasChallenges = computed(() => challengesStore.hasActiveChallenges)\n\n// Active mission for HUD display — prefer picked challenge, fallback to first active\nconst activeMission = computed(() =>\n  challengesStore.pickedChallenge ?? challengesStore.activeDailies[0] ?? null\n)\nconst missionLabel = computed(() => {\n  const c = activeMission.value\n  if (!c) return null\n  const title = c.title.length > 15 ? c.title.slice(0, 14) + '…' : c.title\n  return `${title} ${c.objectiveCurrent}/${c.objectiveTarget}`\n})\n\n// Narrative (intense only)\nconst narrative = computed(() =>\n  getLevelNarrative(level.value, progressPercent.value)\n)\n\nfunction goToSignIn() {\n  uiStore.openAuthModal('login')\n}\n</script>\n\n<template>\n  <!-- Not authenticated: CTA -->\n  <div v-if=\"!authStore.isAuthenticated\" class=\"hud-connect\" @click=\"goToSignIn\">\n    <span class=\"hud-connect-label\">CONNECT TO THE GRID</span>\n  </div>\n\n  <!-- Authenticated: RPG HUD -->\n  <div\n    v-else-if=\"settingsStore.gamificationEnabled\"\n    class=\"gamification-hud\"\n    :class=\"[\n      { 'hud--minimal': isMinimal },\n      { 'hud--moderate': !isMinimal && !isIntense },\n      { 'hud--intense': isIntense },\n      { 'hud--active': panelOpen }\n    ]\"\n    role=\"group\"\n    tabindex=\"0\"\n    :aria-label=\"`Level ${level} netrunner. ${progressPercent}% to next level.`\"\n    @click=\"emit('togglePanel')\"\n    @keydown.enter=\"emit('togglePanel')\"\n  >\n    <!-- Minimal: text only (per intensity-system §4) -->\n    <span v-if=\"isMinimal\" class=\"hud-level-text\">Lv.{{ level }}</span>\n\n    <!-- Moderate+: full HUD bar -->\n    <template v-else>\n      <!-- Level section -->\n      <GamificationTooltipWrapper :panel-open=\"panelOpen\">\n        <div class=\"hud-section hud-level\">\n          <LevelBadge size=\"sm\" :level-event=\"latestLevelEvent\" />\n          <span class=\"hud-stat-label\">LV</span>\n          <span class=\"hud-stat-value\">{{ level }}</span>\n        </div>\n        <template #tooltip>\n          <LevelTooltipContent />\n        </template>\n      </GamificationTooltipWrapper>\n\n      <div class=\"hud-divider\" />\n\n      <!-- XP section -->\n      <GamificationTooltipWrapper :panel-open=\"panelOpen\">\n        <div class=\"hud-section hud-xp\">\n          <span class=\"hud-stat-label\">XP</span>\n          <div class=\"hud-xp-track\">\n            <div class=\"hud-xp-fill\" :style=\"{ width: progressPercent + '%' }\" />\n            <div v-if=\"isIntense\" class=\"hud-xp-shine\" :style=\"{ width: progressPercent + '%' }\" />\n          </div>\n          <span class=\"hud-stat-value hud-xp-text\">{{ isIntense ? xpText : progressPercent + '%' }}</span>\n        </div>\n        <template #tooltip>\n          <XpTooltipContent />\n        </template>\n      </GamificationTooltipWrapper>\n\n      <div class=\"hud-divider\" />\n\n      <!-- Streak section -->\n      <GamificationTooltipWrapper :panel-open=\"panelOpen\">\n        <div class=\"hud-section hud-streak\">\n          <Flame :size=\"14\" class=\"hud-flame\" :class=\"{ 'hud-flame--active': isActiveToday }\" />\n          <span class=\"hud-stat-value\">{{ streak }}d</span>\n        </div>\n        <template #tooltip>\n          <StreakTooltipContent />\n        </template>\n      </GamificationTooltipWrapper>\n\n      <!-- Mission indicator / Challenge pips -->\n      <GamificationTooltipWrapper v-if=\"hasChallenges\" :panel-open=\"panelOpen\">\n        <div v-if=\"activeMission\" class=\"hud-section hud-mission\">\n          <Target :size=\"12\" class=\"hud-mission-icon\" />\n          <span class=\"hud-mission-label\">{{ missionLabel }}</span>\n        </div>\n        <div v-else class=\"hud-section hud-challenges\">\n          <ChallengePips />\n        </div>\n        <template #tooltip>\n          <ChallengeTooltipContent />\n        </template>\n      </GamificationTooltipWrapper>\n\n      <!-- Expand chevron -->\n      <ChevronDown :size=\"12\" class=\"hud-chevron\" :class=\"{ 'hud-chevron--open': panelOpen }\" />\n    </template>\n\n    <!-- Intense: narrative micro-text row -->\n    <div v-if=\"isIntense && !panelOpen\" class=\"hud-narrative\">\n      \"{{ narrative }}\"\n    </div>\n  </div>\n</template>\n\n<style scoped>\n/* ============================================\n   HUD Container — uses corner-cut-sm from\n   cyberflow-design-system §6 (8px diagonal cuts)\n   ============================================ */\n.gamification-hud {\n  position: relative;\n  z-index: 2;\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-1-5, 6px) var(--space-3);\n  cursor: pointer;\n  user-select: none;\n  flex-wrap: wrap;\n}\n\n/* Pseudo-element for background + border + shape.\n   clip-path kills backdrop-filter, so we clip only the pseudo\n   and keep blur on the main element. */\n.gamification-hud::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  z-index: -1;\n  background: rgba(18, 18, 26, 0.85);\n  backdrop-filter: blur(12px);\n  -webkit-backdrop-filter: blur(12px);\n  border: 1px solid var(--cf-cyan-20, rgba(0, 240, 255, 0.2));\n  /* corner-cut-sm from cyberflow-design-system §6 */\n  clip-path: polygon(\n    8px 0, 100% 0,\n    100% calc(100% - 8px),\n    calc(100% - 8px) 100%,\n    0 100%, 0 8px\n  );\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n\n/* Moderate hover: neon-cyan--subtle from cyberflow-design-system §2 */\n.gamification-hud:hover::before {\n  border-color: var(--cf-cyan-50, rgba(0, 240, 255, 0.5));\n  box-shadow:\n    0 0 5px rgba(0, 240, 255, 0.5),\n    0 0 10px rgba(0, 240, 255, 0.2);\n}\n\n/* Active (panel open) */\n.gamification-hud.hud--active::before {\n  border-color: var(--cf-cyan, #00f0ff);\n  box-shadow:\n    0 0 5px rgba(0, 240, 255, 0.5),\n    0 0 10px rgba(0, 240, 255, 0.2);\n}\n\n/* Intense: always-on glow from cyberflow-design-system §2 */\n.gamification-hud.hud--intense::before {\n  border-color: var(--cf-cyan, #00f0ff);\n  box-shadow:\n    0 0 5px rgba(0, 240, 255, 0.5),\n    0 0 10px rgba(0, 240, 255, 0.2);\n}\n\n.gamification-hud.hud--intense:hover::before {\n  box-shadow:\n    0 0 5px #00f0ff,\n    0 0 10px #00f0ff,\n    0 0 20px #00f0ff,\n    0 0 40px #00f0ff;\n}\n\n/* ============================================\n   Minimal: per intensity-system §4\n   \"Just text, no decoration, monospace font\"\n   ============================================ */\n.hud--minimal {\n  padding: var(--space-1) var(--space-2);\n}\n\n.hud--minimal::before {\n  display: none;\n}\n\n.hud-level-text {\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: rgba(0, 240, 255, 0.7);\n  letter-spacing: 0.02em;\n}\n\n/* ============================================\n   Typography — from cyberflow-design-system §7\n   Space Mono for data, uppercase labels\n   ============================================ */\n.hud-stat-label {\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: 11px;\n  font-weight: 400;\n  color: var(--cf-cyan, #00f0ff);\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n  line-height: 1;\n}\n\n.hud-stat-value {\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: rgba(0, 240, 255, 0.9);\n  letter-spacing: 0.02em;\n  line-height: 1;\n}\n\n/* ============================================\n   HUD Sections & Dividers\n   ============================================ */\n.hud-section {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n}\n\n.hud-divider {\n  width: 1px;\n  height: 16px;\n  background: var(--cf-cyan-20, rgba(0, 240, 255, 0.2));\n  flex-shrink: 0;\n}\n\n/* ============================================\n   XP Bar — gradient from game-ui-components §2\n   Uses --xp-bar-gradient token\n   ============================================ */\n.hud-xp-track {\n  position: relative;\n  width: 80px;\n  height: 4px;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 2px;\n  overflow: hidden;\n}\n\n.hud-xp-fill {\n  position: absolute;\n  inset: 0;\n  width: 0;\n  background: var(--xp-bar-gradient, linear-gradient(90deg, rgba(0, 240, 255, 0.9), rgba(255, 0, 153, 0.9)));\n  border-radius: 2px;\n  transition: width 0.6s ease-out;\n}\n\n/* Intense: shine sweep from game-ui-components §2 */\n.hud-xp-shine {\n  position: absolute;\n  inset: 0;\n  background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);\n  background-size: 200% 100%;\n  animation: xp-shine 3s ease-in-out infinite;\n}\n\n.hud-xp-text {\n  white-space: nowrap;\n}\n\n/* ============================================\n   Streak — flame color from game-ui-components\n   Uses --streak-flame-color token\n   ============================================ */\n.hud-flame {\n  color: var(--text-muted, rgba(255, 255, 255, 0.4));\n  transition: color 0.2s ease;\n}\n\n.hud-flame--active {\n  color: var(--streak-flame-color, rgb(255, 107, 53));\n  filter: drop-shadow(0 0 4px rgba(255, 107, 53, 0.6));\n}\n\n/* ============================================\n   Mission indicator (active daily challenge)\n   ============================================ */\n.hud-mission-icon {\n  color: var(--cf-cyan, #00f0ff);\n  flex-shrink: 0;\n}\n\n.hud-mission-label {\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: 11px;\n  font-weight: 400;\n  color: var(--cf-cyan-50, rgba(0, 240, 255, 0.5));\n  white-space: nowrap;\n  letter-spacing: 0.02em;\n}\n\n/* ============================================\n   Chevron expand indicator\n   ============================================ */\n.hud-chevron {\n  color: var(--cf-cyan-50, rgba(0, 240, 255, 0.5));\n  transition: transform 0.2s ease, color 0.2s ease;\n  flex-shrink: 0;\n}\n\n.hud-chevron--open {\n  transform: rotate(180deg);\n  color: var(--cf-cyan, #00f0ff);\n}\n\n/* ============================================\n   Narrative micro-text (intense only)\n   Uses getLevelNarrative() from useAriaTooltipNarrative\n   ============================================ */\n.hud-narrative {\n  width: 100%;\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: 10px;\n  font-style: italic;\n  color: var(--cf-cyan-50, rgba(0, 240, 255, 0.5));\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 300px;\n  padding-top: 2px;\n  line-height: 1.2;\n}\n\n/* ============================================\n   Auth CTA\n   ============================================ */\n.hud-connect {\n  position: relative;\n  display: flex;\n  align-items: center;\n  padding: var(--space-1) var(--space-3);\n  cursor: pointer;\n}\n\n.hud-connect::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  z-index: -1;\n  background: rgba(26, 26, 37, 0.85);\n  backdrop-filter: blur(12px);\n  -webkit-backdrop-filter: blur(12px);\n  border: 1px solid var(--cf-cyan-20, rgba(0, 240, 255, 0.2));\n  clip-path: polygon(\n    8px 0, 100% 0,\n    100% calc(100% - 8px),\n    calc(100% - 8px) 100%,\n    0 100%, 0 8px\n  );\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n\n.hud-connect:hover::before {\n  border-color: var(--cf-cyan-50, rgba(0, 240, 255, 0.5));\n  box-shadow:\n    0 0 5px rgba(0, 240, 255, 0.3),\n    0 0 10px rgba(0, 240, 255, 0.1);\n}\n\n.hud-connect-label {\n  font-family: var(--font-cyber-data, 'Space Mono', monospace);\n  font-size: 11px;\n  color: var(--cf-cyan-50, rgba(0, 240, 255, 0.5));\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n}\n\n/* ============================================\n   Animations (with reduced-motion from\n   cyberflow-design-system §10)\n   ============================================ */\n@keyframes xp-shine {\n  0% { background-position: 200% 0; }\n  100% { background-position: -200% 0; }\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .gamification-hud,\n  .hud-connect {\n    transition: none;\n  }\n  .hud-xp-shine {\n    animation: none;\n    display: none;\n  }\n  .hud-xp-fill {\n    transition: none;\n  }\n  .hud-chevron {\n    transition: none;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/GamificationPanel.vue","messages":[{"ruleId":"vue/prefer-true-attribute-shorthand","severity":2,"message":"Boolean prop with 'true' value should be written in shorthand form.","line":86,"column":22,"nodeType":"VAttribute","messageId":"expectShort","endLine":86,"endColumn":42,"suggestions":[{"messageId":"rewriteIntoShort","fix":{"range":[2681,2701],"text":"show-freezes"},"desc":"Rewrite this prop into shorthand form."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * Gamification Panel Component\n * FEATURE-1118: Main stats overview panel showing XP, level, streak, and recent achievements\n */\nimport { computed, ref } from 'vue'\nimport { useRouter } from 'vue-router'\nimport { useGamificationStore } from '@/stores/gamification'\nimport XpBar from './XpBar.vue'\nimport LevelBadge from './LevelBadge.vue'\nimport StreakCounter from './StreakCounter.vue'\nimport AchievementBadge from './AchievementBadge.vue'\nimport DailyChallengesPanel from './DailyChallengesPanel.vue'\nimport { Trophy, ShoppingBag, ChevronRight, Sparkles, HelpCircle, ChevronDown } from 'lucide-vue-next'\n\nconst emit = defineEmits<{\n  openAchievements: []\n  openShop: []\n  close: []\n}>()\nconst showHelp = ref(false)\nconst router = useRouter()\n\nfunction goToCyberflow() {\n  router.push('/cyberflow')\n}\n\nconst gamificationStore = useGamificationStore()\n\nconst levelInfo = computed(() => gamificationStore.levelInfo)\nconst totalXp = computed(() => gamificationStore.totalXp)\nconst availableXp = computed(() => gamificationStore.availableXp)\n\n// Get 4 most recent earned achievements\nconst recentAchievements = computed(() => {\n  return [...gamificationStore.earnedAchievements]\n    .sort((a, b) => {\n      const aDate = a.earnedAt?.getTime() || 0\n      const bDate = b.earnedAt?.getTime() || 0\n      return bDate - aDate\n    })\n    .slice(0, 4)\n})\n\nconst earnedCount = computed(() => gamificationStore.unlockedAchievementsCount)\nconst totalCount = computed(() => gamificationStore.achievements.length)\n</script>\n\n<template>\n  <div class=\"gamification-panel\">\n    <!-- Cyberflow Command Center Link -->\n    <button class=\"cyberflow-link\" @click=\"goToCyberflow\">\n      <span class=\"cyberflow-link-label\">CYBERFLOW COMMAND CENTER</span>\n      <ChevronRight :size=\"16\" class=\"cyberflow-link-arrow\" />\n    </button>\n\n    <!-- Header with Level -->\n    <div class=\"panel-header\">\n      <div class=\"header-main\">\n        <LevelBadge size=\"lg\" />\n        <div class=\"header-info\">\n          <span class=\"header-title\">Level {{ levelInfo.level }}</span>\n          <span class=\"header-xp\">{{ totalXp.toLocaleString() }} Total XP</span>\n        </div>\n      </div>\n\n      <div class=\"header-actions\">\n        <button\n          class=\"action-btn action-btn--shop\"\n          title=\"Open Shop\"\n          @click=\"$emit('openShop')\"\n        >\n          <ShoppingBag :size=\"18\" />\n          <span class=\"action-xp\">{{ availableXp.toLocaleString() }} XP</span>\n        </button>\n      </div>\n    </div>\n\n    <!-- XP Progress -->\n    <div class=\"panel-section\">\n      <XpBar animated />\n    </div>\n\n    <!-- Streak -->\n    <div class=\"panel-section\">\n      <StreakCounter :show-freezes=\"true\" />\n    </div>\n\n    <!-- Daily Challenges (FEATURE-1132) -->\n    <div class=\"panel-section\">\n      <DailyChallengesPanel compact @pick-challenge=\"emit('close')\" />\n    </div>\n\n    <!-- Recent Achievements -->\n    <div class=\"panel-section\">\n      <div class=\"section-header\">\n        <div class=\"section-title\">\n          <Trophy\n            :size=\"16\"\n            class=\"section-icon\"\n          />\n          <span>Achievements</span>\n          <span class=\"achievement-count\">{{ earnedCount }}/{{ totalCount }}</span>\n        </div>\n        <button\n          class=\"see-all-btn\"\n          @click=\"$emit('openAchievements')\"\n        >\n          <span>See All</span>\n          <ChevronRight :size=\"14\" />\n        </button>\n      </div>\n\n      <div\n        v-if=\"recentAchievements.length > 0\"\n        class=\"achievements-grid\"\n      >\n        <AchievementBadge\n          v-for=\"achievement in recentAchievements\"\n          :key=\"achievement.id\"\n          :achievement=\"achievement\"\n          size=\"sm\"\n        />\n      </div>\n\n      <div\n        v-else\n        class=\"achievements-empty\"\n      >\n        <Sparkles\n          :size=\"24\"\n          class=\"empty-icon\"\n        />\n        <span>Complete tasks to earn achievements!</span>\n      </div>\n    </div>\n\n    <!-- How It Works Section -->\n    <div class=\"panel-section help-section\">\n      <button\n        class=\"help-toggle\"\n        @click=\"showHelp = !showHelp\"\n      >\n        <HelpCircle :size=\"16\" />\n        <span>How to Earn XP</span>\n        <ChevronDown\n          :size=\"14\"\n          class=\"help-chevron\"\n          :class=\"{ 'rotated': showHelp }\"\n        />\n      </button>\n\n      <div v-if=\"showHelp\" class=\"help-content\">\n        <div class=\"help-category\">\n          <span class=\"help-category-title\">🎯 Tasks</span>\n          <ul class=\"help-list\">\n            <li><span class=\"xp-badge\">+10 XP</span> Complete any task</li>\n            <li><span class=\"xp-badge bonus\">+50%</span> High priority tasks</li>\n            <li><span class=\"xp-badge bonus\">+25%</span> Medium priority tasks</li>\n            <li><span class=\"xp-badge penalty\">-10%</span> Overdue tasks</li>\n          </ul>\n        </div>\n\n        <div class=\"help-category\">\n          <span class=\"help-category-title\">🍅 Pomodoros</span>\n          <ul class=\"help-list\">\n            <li><span class=\"xp-badge\">+25 XP</span> Complete a Pomodoro</li>\n            <li><span class=\"xp-badge bonus\">+10%</span> Each consecutive session (max +50%)</li>\n          </ul>\n        </div>\n\n        <div class=\"help-category\">\n          <span class=\"help-category-title\">🔥 Streaks</span>\n          <ul class=\"help-list\">\n            <li><span class=\"xp-badge\">+50 XP</span> 7-day streak</li>\n            <li><span class=\"xp-badge\">+150 XP</span> 30-day streak</li>\n            <li><span class=\"xp-badge\">+300 XP</span> 100-day streak</li>\n            <li><span class=\"xp-badge\">+500 XP</span> 365-day streak</li>\n          </ul>\n        </div>\n\n        <div class=\"help-category\">\n          <span class=\"help-category-title\">🏆 Achievements</span>\n          <ul class=\"help-list\">\n            <li><span class=\"xp-badge bronze\">+50 XP</span> Bronze tier</li>\n            <li><span class=\"xp-badge silver\">+150 XP</span> Silver tier</li>\n            <li><span class=\"xp-badge gold\">+300 XP</span> Gold tier</li>\n            <li><span class=\"xp-badge platinum\">+500 XP</span> Platinum tier</li>\n          </ul>\n        </div>\n\n        <p class=\"help-tip\">\n          💡 Spend XP in the <strong>Shop</strong> to unlock themes and cosmetics!\n        </p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.gamification-panel {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n  padding: var(--space-4);\n  background: var(--gamification-panel-bg);\n  border: 1px solid var(--gamification-panel-border);\n  border-radius: var(--radius-lg);\n}\n\n/* Cyberflow Command Center Link */\n.cyberflow-link {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n  padding: var(--space-2) var(--space-3);\n  background: rgba(var(--neon-cyan), 0.08);\n  border: 1px solid rgba(var(--neon-cyan), 0.25);\n  border-radius: var(--radius-md);\n  color: rgba(var(--neon-cyan), 0.9);\n  font-family: var(--font-cyber-data, 'JetBrains Mono', monospace);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  letter-spacing: 0.1em;\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.cyberflow-link:hover {\n  background: rgba(var(--neon-cyan), 0.15);\n  border-color: rgba(var(--neon-cyan), 0.5);\n  box-shadow: 0 0 12px rgba(var(--neon-cyan), 0.2);\n  color: rgba(var(--neon-cyan), 1);\n}\n\n.cyberflow-link-arrow {\n  opacity: 0.6;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.cyberflow-link:hover .cyberflow-link-arrow {\n  opacity: 1;\n  transform: translateX(2px);\n}\n\n.panel-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n  gap: var(--space-4);\n}\n\n.header-main {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n}\n\n.header-info {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-0_5);\n}\n\n.header-title {\n  font-size: var(--text-xl);\n  font-weight: var(--font-bold);\n  color: var(--gamification-text-primary);\n  text-shadow: 0 0 12px rgba(var(--neon-cyan), 0.3);\n}\n\n.header-xp {\n  font-size: var(--text-sm);\n  color: var(--gamification-text-secondary);\n}\n\n.header-actions {\n  display: flex;\n  gap: var(--space-2);\n}\n\n.action-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(var(--color-slate-700), 0.5);\n  border: 1px solid rgba(var(--color-slate-600), 0.5);\n  border-radius: var(--radius-md);\n  color: var(--gamification-text-primary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.action-btn:hover {\n  background: rgba(var(--color-slate-600), 0.5);\n  border-color: rgba(var(--neon-cyan), 0.3);\n}\n\n.action-btn--shop:hover {\n  box-shadow: 0 0 12px rgba(var(--neon-cyan), 0.2);\n}\n\n.action-xp {\n  color: rgba(var(--neon-cyan), 0.9);\n}\n\n.panel-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.section-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.section-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--gamification-text-secondary);\n}\n\n.section-icon {\n  color: rgba(var(--tier-gold), 0.8);\n}\n\n.achievement-count {\n  padding: var(--space-0_5) var(--space-1_5);\n  background: rgba(var(--color-slate-700), 0.5);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n}\n\n.see-all-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: transparent;\n  border: none;\n  border-radius: var(--radius-sm);\n  color: rgba(var(--neon-cyan), 0.8);\n  font-size: var(--text-sm);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.see-all-btn:hover {\n  background: rgba(var(--neon-cyan), 0.1);\n  color: rgba(var(--neon-cyan), 1);\n}\n\n.achievements-grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-2);\n}\n\n.achievements-empty {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-4);\n  color: var(--gamification-text-secondary);\n  font-size: var(--text-sm);\n  text-align: center;\n}\n\n.empty-icon {\n  color: rgba(var(--neon-cyan), 0.4);\n}\n\n/* Help Section */\n.help-section {\n  border-top: 1px solid rgba(var(--color-slate-600), 0.3);\n  padding-top: var(--space-3);\n  margin-top: var(--space-2);\n}\n\n.help-toggle {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  width: 100%;\n  padding: var(--space-2);\n  background: transparent;\n  border: none;\n  border-radius: var(--radius-md);\n  color: var(--gamification-text-secondary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.help-toggle:hover {\n  background: rgba(var(--color-slate-700), 0.3);\n  color: var(--gamification-text-primary);\n}\n\n.help-chevron {\n  margin-left: auto;\n  transition: transform var(--duration-normal) var(--spring-smooth);\n}\n\n.help-chevron.rotated {\n  transform: rotate(180deg);\n}\n\n.help-content {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n  padding: var(--space-3);\n  background: rgba(var(--color-slate-800), 0.4);\n  border-radius: var(--radius-md);\n  animation: slideDown var(--duration-normal) var(--ease-out);\n}\n\n@keyframes slideDown {\n  from {\n    opacity: 0;\n    transform: translateY(-8px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.help-category {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.help-category-title {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--gamification-text-primary);\n}\n\n.help-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.help-list li {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  font-size: var(--text-xs);\n  color: var(--gamification-text-secondary);\n}\n\n.xp-badge {\n  display: inline-flex;\n  align-items: center;\n  padding: var(--space-0_5) var(--space-1_5);\n  background: rgba(var(--neon-cyan), 0.15);\n  border: 1px solid rgba(var(--neon-cyan), 0.3);\n  border-radius: var(--radius-sm);\n  color: rgba(var(--neon-cyan), 0.9);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  min-width: var(--space-12);\n  justify-content: center;\n}\n\n.xp-badge.bonus {\n  background: rgba(var(--neon-lime), 0.15);\n  border-color: rgba(var(--neon-lime), 0.3);\n  color: rgba(var(--neon-lime), 0.9);\n}\n\n.xp-badge.penalty {\n  background: rgba(255, 100, 100, 0.15);\n  border-color: rgba(255, 100, 100, 0.3);\n  color: rgba(255, 100, 100, 0.9);\n}\n\n.xp-badge.bronze {\n  background: rgba(var(--tier-bronze), 0.15);\n  border-color: rgba(var(--tier-bronze), 0.3);\n  color: rgb(var(--tier-bronze));\n}\n\n.xp-badge.silver {\n  background: rgba(var(--tier-silver), 0.15);\n  border-color: rgba(var(--tier-silver), 0.3);\n  color: rgb(var(--tier-silver));\n}\n\n.xp-badge.gold {\n  background: rgba(var(--tier-gold), 0.15);\n  border-color: rgba(var(--tier-gold), 0.3);\n  color: rgb(var(--tier-gold));\n}\n\n.xp-badge.platinum {\n  background: rgba(var(--tier-platinum), 0.15);\n  border-color: rgba(var(--tier-platinum), 0.3);\n  color: rgb(var(--tier-platinum));\n}\n\n.help-tip {\n  margin: 0;\n  padding: var(--space-2);\n  background: rgba(var(--neon-magenta), 0.1);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: var(--gamification-text-secondary);\n}\n\n.help-tip strong {\n  color: rgba(var(--neon-magenta), 0.9);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/GamificationToasts.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/GamificationTooltipWrapper.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/LevelBadge.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/ShopModal.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":11,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'emit' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":15,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[736,739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[736,739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2632,2635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2632,2635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * Shop Modal Component\n * FEATURE-1118: Purchase themes and cosmetics with XP\n */\nimport { computed, ref } from 'vue'\nimport { useGamificationStore } from '@/stores/gamification'\nimport type { ShopCategory, ShopItemWithOwnership } from '@/types/gamification'\nimport { X, ShoppingBag, Check, Lock, Palette, Award, Sparkles, Volume2 } from 'lucide-vue-next'\n\nconst props = defineProps<{\n  open: boolean\n}>()\n\nconst emit = defineEmits<{\n  close: []\n}>()\n\nconst gamificationStore = useGamificationStore()\n\nconst selectedCategory = ref<ShopCategory | 'all'>('all')\nconst previewingItem = ref<string | null>(null)\nconst purchasing = ref(false)\n\nconst categories: { id: ShopCategory | 'all'; label: string; icon: any }[] = [\n  { id: 'all', label: 'All', icon: ShoppingBag },\n  { id: 'theme', label: 'Themes', icon: Palette },\n  { id: 'badge_style', label: 'Badges', icon: Award },\n  { id: 'animation', label: 'Animations', icon: Sparkles },\n  { id: 'sound', label: 'Sounds', icon: Volume2 }\n]\n\nconst availableXp = computed(() => gamificationStore.availableXp)\nconst currentLevel = computed(() => gamificationStore.currentLevel)\nconst equippedTheme = computed(() => gamificationStore.equippedTheme)\n\nconst filteredItems = computed(() => {\n  const items = gamificationStore.shopItemsWithOwnership\n\n  if (selectedCategory.value === 'all') {\n    return items\n  }\n\n  return items.filter(item => item.category === selectedCategory.value)\n})\n\nfunction canAfford(item: ShopItemWithOwnership): boolean {\n  return availableXp.value >= item.priceXp\n}\n\nfunction canPurchase(item: ShopItemWithOwnership): boolean {\n  return !item.isOwned && canAfford(item) && currentLevel.value >= item.requiredLevel\n}\n\nfunction previewTheme(item: ShopItemWithOwnership) {\n  if (item.category !== 'theme') return\n\n  previewingItem.value = item.id\n  gamificationStore.applyTheme(item.id)\n}\n\nfunction cancelPreview() {\n  if (previewingItem.value) {\n    previewingItem.value = null\n    gamificationStore.applyTheme(equippedTheme.value)\n  }\n}\n\nasync function purchaseItem(item: ShopItemWithOwnership) {\n  if (!canPurchase(item)) return\n\n  purchasing.value = true\n  try {\n    const result = await gamificationStore.purchaseItem(item.id)\n    if (result.success && item.category === 'theme') {\n      // Auto-equip purchased theme\n      await gamificationStore.equipTheme(item.id)\n    }\n  } finally {\n    purchasing.value = false\n    previewingItem.value = null\n  }\n}\n\nasync function equipTheme(itemId: string) {\n  await gamificationStore.equipTheme(itemId)\n}\n\nfunction getCategoryIcon(category: ShopCategory) {\n  const map: Record<ShopCategory, any> = {\n    theme: Palette,\n    badge_style: Award,\n    animation: Sparkles,\n    sound: Volume2\n  }\n  return map[category] || ShoppingBag\n}\n</script>\n\n<template>\n  <Teleport to=\"body\">\n    <Transition name=\"modal\">\n      <div\n        v-if=\"open\"\n        class=\"modal-overlay\"\n        @click.self=\"cancelPreview(); $emit('close')\"\n      >\n        <div class=\"modal-container\">\n          <div class=\"modal-header\">\n            <div class=\"header-title\">\n              <ShoppingBag\n                :size=\"24\"\n                class=\"header-icon\"\n              />\n              <h2>Shop</h2>\n            </div>\n            <div class=\"header-balance\">\n              <span class=\"balance-label\">Available:</span>\n              <span class=\"balance-amount\">{{ availableXp.toLocaleString() }} XP</span>\n            </div>\n            <button\n              class=\"close-btn\"\n              @click=\"cancelPreview(); $emit('close')\"\n            >\n              <X :size=\"20\" />\n            </button>\n          </div>\n\n          <div class=\"category-tabs\">\n            <button\n              v-for=\"cat in categories\"\n              :key=\"cat.id\"\n              class=\"category-tab\"\n              :class=\"{ active: selectedCategory === cat.id }\"\n              @click=\"selectedCategory = cat.id\"\n            >\n              <component\n                :is=\"cat.icon\"\n                :size=\"16\"\n              />\n              <span>{{ cat.label }}</span>\n            </button>\n          </div>\n\n          <div class=\"shop-items\">\n            <div\n              v-for=\"item in filteredItems\"\n              :key=\"item.id\"\n              class=\"shop-item\"\n              :class=\"{\n                'shop-item--owned': item.isOwned,\n                'shop-item--equipped': item.isOwned && item.category === 'theme' && equippedTheme === item.id,\n                'shop-item--previewing': previewingItem === item.id,\n                'shop-item--locked': currentLevel < item.requiredLevel\n              }\"\n              @mouseenter=\"item.category === 'theme' && !item.isOwned ? previewTheme(item) : null\"\n              @mouseleave=\"cancelPreview\"\n            >\n              <div class=\"item-icon\">\n                <component\n                  :is=\"getCategoryIcon(item.category)\"\n                  :size=\"24\"\n                />\n              </div>\n\n              <div class=\"item-info\">\n                <span class=\"item-name\">{{ item.name }}</span>\n                <span class=\"item-description\">{{ item.description }}</span>\n\n                <div\n                  v-if=\"currentLevel < item.requiredLevel\"\n                  class=\"item-lock\"\n                >\n                  <Lock :size=\"12\" />\n                  <span>Requires Level {{ item.requiredLevel }}</span>\n                </div>\n              </div>\n\n              <div class=\"item-action\">\n                <template v-if=\"item.isOwned\">\n                  <button\n                    v-if=\"item.category === 'theme' && equippedTheme !== item.id\"\n                    class=\"equip-btn\"\n                    @click=\"equipTheme(item.id)\"\n                  >\n                    Equip\n                  </button>\n                  <span\n                    v-else\n                    class=\"owned-badge\"\n                  >\n                    <Check :size=\"14\" />\n                    {{ item.category === 'theme' && equippedTheme === item.id ? 'Equipped' : 'Owned' }}\n                  </span>\n                </template>\n                <template v-else>\n                  <button\n                    class=\"buy-btn\"\n                    :class=\"{ 'buy-btn--disabled': !canPurchase(item) }\"\n                    :disabled=\"!canPurchase(item) || purchasing\"\n                    @click=\"purchaseItem(item)\"\n                  >\n                    <span class=\"price\">{{ item.priceXp.toLocaleString() }} XP</span>\n                  </button>\n                </template>\n              </div>\n            </div>\n\n            <div\n              v-if=\"filteredItems.length === 0\"\n              class=\"empty-state\"\n            >\n              <ShoppingBag :size=\"32\" />\n              <span>No items in this category</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </Transition>\n  </Teleport>\n</template>\n\n<style scoped>\n.modal-overlay {\n  position: fixed;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--overlay-bg);\n  backdrop-filter: blur(var(--blur-xs));\n  z-index: var(--z-modal);\n}\n\n.modal-container {\n  display: flex;\n  flex-direction: column;\n  width: 90%;\n  max-width: 600px;\n  max-height: 80vh;\n  background: var(--gamification-panel-bg);\n  border: 1px solid var(--gamification-panel-border);\n  border-radius: var(--radius-xl);\n  overflow: hidden;\n}\n\n.modal-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-4);\n  padding: var(--space-4) var(--space-5);\n  border-bottom: 1px solid var(--purple-border-medium);\n}\n\n.header-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.header-icon {\n  color: rgba(var(--neon-cyan), 0.9);\n}\n\n.header-title h2 {\n  font-size: var(--text-xl);\n  font-weight: var(--font-bold);\n  color: var(--gamification-text-primary);\n  margin: 0;\n}\n\n.header-balance {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  margin-left: auto;\n  padding: var(--space-2) var(--space-3);\n  background: rgba(var(--neon-cyan), 0.1);\n  border-radius: var(--radius-md);\n}\n\n.balance-label {\n  font-size: var(--text-sm);\n  color: var(--gamification-text-secondary);\n}\n\n.balance-amount {\n  font-size: var(--text-base);\n  font-weight: var(--font-bold);\n  color: rgba(var(--neon-cyan), 1);\n}\n\n.close-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: var(--space-2);\n  background: transparent;\n  border: none;\n  border-radius: var(--radius-md);\n  color: var(--gamification-text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.close-btn:hover {\n  background: var(--purple-bg-subtle);\n  color: var(--gamification-text-primary);\n}\n\n.category-tabs {\n  display: flex;\n  gap: var(--space-2);\n  padding: var(--space-3) var(--space-5);\n  overflow-x: auto;\n  border-bottom: 1px solid var(--border-medium);\n}\n\n.category-tab {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: transparent;\n  border: 1px solid var(--purple-border-medium);\n  border-radius: var(--radius-md);\n  color: var(--gamification-text-secondary);\n  font-size: var(--text-sm);\n  white-space: nowrap;\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.category-tab:hover {\n  background: var(--purple-bg-subtle);\n  border-color: var(--purple-border-strong);\n}\n\n.category-tab.active {\n  background: rgba(var(--neon-cyan), 0.15);\n  border-color: rgba(var(--neon-cyan), 0.4);\n  color: rgba(var(--neon-cyan), 1);\n}\n\n.shop-items {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  padding: var(--space-4) var(--space-5);\n  overflow-y: auto;\n  flex: 1;\n}\n\n.shop-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3);\n  background: var(--gamification-card-bg);\n  border: 1px solid var(--purple-border-medium);\n  border-radius: var(--radius-md);\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.shop-item:hover {\n  border-color: var(--purple-border-medium);\n}\n\n.shop-item--owned {\n  border-color: var(--border-medium);\n  background: rgba(var(--neon-cyan), 0.05);\n}\n\n.shop-item--equipped {\n  border-color: rgba(var(--neon-cyan), 0.5);\n  box-shadow: 0 0 var(--space-3) rgba(var(--neon-cyan), 0.2);\n}\n\n.shop-item--previewing {\n  border-color: rgba(var(--neon-magenta), 0.5);\n  box-shadow: 0 0 var(--space-3) rgba(var(--neon-magenta), 0.2);\n}\n\n.shop-item--locked {\n  opacity: 0.6;\n}\n\n.item-icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: var(--space-12);\n  height: var(--space-12);\n  background: var(--purple-bg-subtle);\n  border-radius: var(--radius-md);\n  color: rgba(var(--neon-cyan), 0.8);\n}\n\n.item-info {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  flex: 1;\n  min-width: 0;\n}\n\n.item-name {\n  font-size: var(--text-base);\n  font-weight: var(--font-medium);\n  color: var(--gamification-text-primary);\n}\n\n.item-description {\n  font-size: var(--text-sm);\n  color: var(--gamification-text-secondary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.item-lock {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  color: var(--tier-rare);\n}\n\n.item-action {\n  display: flex;\n  align-items: center;\n}\n\n.buy-btn {\n  padding: var(--space-2) var(--space-3);\n  background: rgba(var(--neon-cyan), 0.15);\n  border: 1px solid rgba(var(--neon-cyan), 0.4);\n  border-radius: var(--radius-md);\n  color: rgba(var(--neon-cyan), 1);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.buy-btn:hover:not(:disabled) {\n  background: rgba(var(--neon-cyan), 0.25);\n  box-shadow: 0 0 var(--space-3) rgba(var(--neon-cyan), 0.3);\n}\n\n.buy-btn--disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.equip-btn {\n  padding: var(--space-2) var(--space-3);\n  background: rgba(var(--neon-magenta), 0.15);\n  border: 1px solid rgba(var(--neon-magenta), 0.4);\n  border-radius: var(--radius-md);\n  color: rgba(var(--neon-magenta), 1);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.equip-btn:hover {\n  background: rgba(var(--neon-magenta), 0.25);\n  box-shadow: 0 0 var(--space-3) rgba(var(--neon-magenta), 0.3);\n}\n\n.owned-badge {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(var(--neon-cyan), 0.1);\n  border-radius: var(--radius-md);\n  font-size: var(--text-sm);\n  color: rgba(var(--neon-cyan), 0.8);\n}\n\n.empty-state {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-8);\n  color: var(--gamification-text-secondary);\n  text-align: center;\n}\n\n/* Modal transitions */\n.modal-enter-active,\n.modal-leave-active {\n  transition: opacity var(--duration-normal) var(--ease-out);\n}\n\n.modal-enter-active .modal-container,\n.modal-leave-active .modal-container {\n  transition: transform var(--duration-normal) var(--spring-smooth);\n}\n\n.modal-enter-from,\n.modal-leave-to {\n  opacity: 0;\n}\n\n.modal-enter-from .modal-container,\n.modal-leave-to .modal-container {\n  transform: scale(0.95) translateY(var(--space-2_5));\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/StreakCounter.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/XpBar.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CorruptionMeter.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberAchievements.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Lock' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":45,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Lock"},"fix":{"range":[763,769],"text":""},"desc":"Remove unused variable \"Lock\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1101,1104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1101,1104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1682,1685],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1682,1685],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * CyberAchievements - Visual Novel Achievement Gallery\n * FEATURE-1118 Cyberflow RPG Hub: Bottom-left panel\n *\n * Icon-dominant grid with large 48px icons, tier glows, minimal text.\n * Visual novel aesthetic: show, don't tell.\n */\nimport { computed } from 'vue'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useCyberflowTheme } from '@/composables/useCyberflowTheme'\nimport type { AchievementWithProgress, AchievementTier, AchievementCategory } from '@/types/gamification'\nimport {\n  Rocket, Target, Award, Crown, Flame, Clock, Hourglass, Layers,\n  Calendar, Trophy, Star, RefreshCw, Shield, Timer, Brain,\n  Zap, Infinity, Activity, Layout, Columns, Smartphone, Palette,\n  Moon, Sunrise, CheckCircle, Database, Lock, ChevronRight\n} from 'lucide-vue-next'\n\nconst props = withDefaults(defineProps<{\n  showAll?: boolean\n}>(), {\n  showAll: false\n})\n\nconst emit = defineEmits<{\n  openAchievements: []\n}>()\n\nconst gamificationStore = useGamificationStore()\nconst { cyberflowClasses } = useCyberflowTheme()\n\n// Icon mapping\nconst iconMap: Record<string, any> = {\n  rocket: Rocket, target: Target, award: Award, crown: Crown, flame: Flame,\n  clock: Clock, hourglass: Hourglass, layers: Layers, fire: Flame,\n  calendar: Calendar, trophy: Trophy, star: Star, 'refresh-cw': RefreshCw,\n  shield: Shield, timer: Timer, brain: Brain, zap: Zap, infinity: Infinity,\n  activity: Activity, layout: Layout, columns: Columns, smartphone: Smartphone,\n  palette: Palette, moon: Moon, sunrise: Sunrise, 'check-circle': CheckCircle,\n  database: Database\n}\n\n// Category icon shapes (simple SVG fallback)\nconst categoryIcons: Record<AchievementCategory, any> = {\n  productivity: Rocket,\n  consistency: Flame,\n  mastery: Crown,\n  exploration: Layers,\n  secret: Shield\n}\n\nfunction getIconComponent(achievement: AchievementWithProgress) {\n  return iconMap[achievement.icon] || categoryIcons[achievement.category] || Award\n}\n\n// Get 6 achievements: earned first (most recent), then in-progress\nconst displayAchievements = computed((): AchievementWithProgress[] => {\n  const all = gamificationStore.achievementsWithProgress\n\n  const earned = all\n    .filter(a => a.isEarned)\n    .sort((a, b) => (b.earnedAt?.getTime() || 0) - (a.earnedAt?.getTime() || 0))\n\n  const inProgress = all\n    .filter(a => !a.isEarned && !a.isSecret && a.progress > 0)\n    .sort((a, b) => {\n      const aP = a.conditionValue > 0 ? a.progress / a.conditionValue : 0\n      const bP = b.conditionValue > 0 ? b.progress / b.conditionValue : 0\n      return bP - aP\n    })\n\n  const locked = all\n    .filter(a => !a.isEarned && !a.isSecret && a.progress === 0)\n    .slice(0, 6)\n\n  const combined = [...earned, ...inProgress, ...locked]\n  return props.showAll ? combined : combined.slice(0, 6)\n})\n\nconst earnedCount = computed(() => gamificationStore.unlockedAchievementsCount)\nconst totalCount = computed(() => gamificationStore.achievements.length)\nconst hasAchievements = computed(() => gamificationStore.achievements.length > 0)\n\n// Tier color mapping (for icon glow)\nconst tierColorMap: Record<AchievementTier, string> = {\n  bronze: 'rgba(205, 127, 50, 1)',\n  silver: 'rgba(192, 192, 192, 1)',\n  gold: 'rgba(255, 215, 0, 1)',\n  platinum: 'rgba(229, 228, 226, 1)'\n}\n\nfunction getTierColor(tier: AchievementTier): string {\n  return tierColorMap[tier]\n}\n\n// Tier glow for icon (drop-shadow filter)\nfunction getTierGlow(tier: AchievementTier): string {\n  const color = tierColorMap[tier]\n  return `drop-shadow(0 0 8px ${color}) drop-shadow(0 0 16px ${color})`\n}\n\nfunction getProgressPercent(achievement: AchievementWithProgress): number {\n  if (achievement.isEarned) return 100\n  if (achievement.conditionValue <= 0) return 0\n  return Math.min(100, Math.round((achievement.progress / achievement.conditionValue) * 100))\n}\n</script>\n\n<template>\n  <div\n    class=\"cyber-achievements\"\n    :class=\"cyberflowClasses\"\n    data-augmented-ui=\"tl-clip br-clip border\"\n  >\n    <!-- Panel Header -->\n    <div class=\"ca-header\">\n      <Trophy :size=\"16\" class=\"ca-header-icon\" />\n      <span class=\"ca-header-text\">ACHIEVEMENTS</span>\n      <span class=\"ca-header-count\">{{ earnedCount }}/{{ totalCount }}</span>\n    </div>\n\n    <!-- Achievement Grid: 4 cols full, 3 cols compact -->\n    <div\n      v-if=\"hasAchievements && displayAchievements.length > 0\"\n      class=\"ca-grid\"\n      :class=\"{ 'ca-grid--full': showAll }\"\n    >\n      <div\n        v-for=\"achievement in displayAchievements\"\n        :key=\"achievement.id\"\n        class=\"ca-item\"\n        :class=\"{\n          'ca-item--earned': achievement.isEarned,\n          'ca-item--locked': !achievement.isEarned && (achievement.isSecret || achievement.progress === 0)\n        }\"\n        :title=\"achievement.isSecret && !achievement.isEarned ? '???' : achievement.name\"\n      >\n        <!-- Large Icon with Tier Glow -->\n        <div class=\"ca-icon-wrap\">\n          <component\n            :is=\"achievement.isSecret && !achievement.isEarned ? Lock : getIconComponent(achievement)\"\n            :size=\"48\"\n            class=\"ca-icon\"\n            :class=\"{ 'ca-icon--locked': !achievement.isEarned && (achievement.isSecret || achievement.progress === 0) }\"\n            :style=\"{\n              color: achievement.isEarned ? getTierColor(achievement.tier) : undefined,\n              filter: achievement.isEarned ? getTierGlow(achievement.tier) : undefined\n            }\"\n          />\n\n          <!-- Earned Badge Overlay -->\n          <div v-if=\"achievement.isEarned\" class=\"ca-earned-badge\">\n            <CheckCircle :size=\"14\" />\n          </div>\n        </div>\n\n        <!-- Name (1 line max) -->\n        <span class=\"ca-name\">\n          {{ achievement.isSecret && !achievement.isEarned ? '???' : achievement.name }}\n        </span>\n\n        <!-- Progress Bar (in-progress only) -->\n        <div\n          v-if=\"!achievement.isEarned && !achievement.isSecret && achievement.progress > 0\"\n          class=\"ca-progress\"\n        >\n          <div\n            class=\"ca-progress-fill\"\n            :style=\"{ width: `${getProgressPercent(achievement)}%` }\"\n          />\n        </div>\n      </div>\n    </div>\n\n    <!-- Empty State -->\n    <div v-else class=\"ca-empty\">\n      <Trophy :size=\"32\" class=\"ca-empty-icon\" />\n      <span class=\"ca-empty-text\">NO ACHIEVEMENTS</span>\n      <span class=\"ca-empty-sub\">Complete tasks and challenges to earn achievements</span>\n    </div>\n\n    <!-- View All Button -->\n    <button\n      v-if=\"!showAll && hasAchievements\"\n      class=\"ca-view-all\"\n      @click=\"emit('openAchievements')\"\n    >\n      <span>VIEW ALL</span>\n      <ChevronRight :size=\"14\" />\n    </button>\n  </div>\n</template>\n\n<style scoped>\n.cyber-achievements {\n  --aug-border-all: 1px;\n  --aug-border-bg: var(--cf-cyan-50, rgba(0, 240, 255, 0.5));\n  --aug-tl1: 16px;\n  --aug-br1: 16px;\n  background: var(--cf-dark-2);\n  padding: var(--space-3);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n  height: 100%;\n}\n\n/* Header */\n.ca-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.ca-header-icon {\n  color: var(--cf-gold);\n  filter: drop-shadow(0 0 6px var(--cf-gold));\n}\n\n.ca-header-text {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: var(--cf-cyan);\n  letter-spacing: 0.1em;\n  flex: 1;\n}\n\n.ca-header-count {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  padding: var(--space-0_5) var(--space-2);\n  background: rgba(var(--color-slate-50), 0.05);\n  border-radius: var(--radius-sm);\n}\n\n/* Achievement Grid: 3 columns compact, 4 columns full */\n.ca-grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: var(--space-2);\n  flex: 1;\n  align-content: start;\n}\n\n.ca-grid--full {\n  grid-template-columns: repeat(4, 1fr);\n}\n\n/* Individual Achievement Item */\n.ca-item {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: flex-start;\n  gap: var(--space-2);\n  padding: var(--space-3);\n  background: var(--cf-dark-3);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-sm);\n  transition: transform 0.2s ease, border-color 0.2s ease;\n  cursor: pointer;\n  min-height: 120px;\n}\n\n.ca-item:hover {\n  border-color: rgba(var(--color-slate-50), 0.15);\n  transform: translateY(calc(-1 * var(--space-0_5)));\n}\n\n/* Locked state: reduced opacity */\n.ca-item--locked {\n  opacity: 0.4;\n  cursor: default;\n}\n\n.ca-item--locked:hover {\n  opacity: 0.5;\n  transform: translateY(calc(-0.5 * var(--space-0_5)));\n}\n\n/* Icon Wrapper */\n.ca-icon-wrap {\n  position: relative;\n  width: calc(var(--space-8) * 2);\n  height: calc(var(--space-8) * 2);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n/* Icon (48px) */\n.ca-icon {\n  color: var(--text-secondary);\n  transition: color 0.3s ease, filter 0.3s ease;\n}\n\n.ca-icon--locked {\n  color: rgba(var(--color-slate-50), 0.2);\n}\n\n/* Earned Badge Overlay */\n.ca-earned-badge {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: var(--space-5);\n  height: var(--space-5);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--cf-cyan);\n  border-radius: var(--radius-full);\n  color: var(--cf-dark-1);\n  box-shadow: 0 0 var(--space-2) var(--cf-cyan);\n}\n\n/* Achievement Name */\n.ca-name {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  color: var(--text-primary);\n  text-align: center;\n  line-height: 1.3;\n  max-width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  word-break: break-word;\n}\n\n.ca-item--locked .ca-name {\n  color: var(--text-muted);\n}\n\n/* Progress Bar */\n.ca-progress {\n  width: 100%;\n  height: calc(var(--space-0_5) * 1.5);\n  background: rgba(var(--color-slate-50), 0.1);\n  border-radius: var(--radius-xs);\n  overflow: hidden;\n  margin-top: auto;\n}\n\n.ca-progress-fill {\n  height: 100%;\n  background: var(--cf-cyan);\n  border-radius: var(--radius-xs);\n  transition: width 0.4s ease;\n  box-shadow: 0 0 var(--space-1) var(--cf-cyan);\n}\n\n/* Empty State */\n.ca-empty {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n}\n\n.ca-empty-icon {\n  color: var(--text-muted);\n  opacity: 0.3;\n}\n\n.ca-empty-text {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-sm);\n  color: var(--text-muted);\n  letter-spacing: 0.05em;\n}\n\n.ca-empty-sub {\n  font-family: var(--font-cyber-ui);\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  opacity: 0.6;\n  text-align: center;\n}\n\n/* View All Button */\n.ca-view-all {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(0, 240, 255, 0.05);\n  border: 1px solid rgba(0, 240, 255, 0.3);\n  border-radius: var(--radius-sm);\n  color: var(--cf-cyan);\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-xs);\n  font-weight: 600;\n  letter-spacing: 0.1em;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.ca-view-all:hover {\n  background: rgba(0, 240, 255, 0.1);\n  border-color: var(--cf-cyan);\n  box-shadow: 0 0 var(--space-3) rgba(0, 240, 255, 0.3);\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n  .ca-grid,\n  .ca-grid--full {\n    grid-template-columns: repeat(2, 1fr);\n  }\n}\n\n/* Reduced Motion */\n@media (prefers-reduced-motion: reduce) {\n  .ca-item {\n    transition: none;\n  }\n\n  .ca-icon {\n    transition: none;\n  }\n\n  .ca-progress-fill {\n    transition: none;\n  }\n\n  .ca-view-all {\n    transition: none;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberBossFight.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberCharacterDrawer.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberCharacterProfile.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberDashboardHub.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ariaVariant' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":267,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":267,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"cyber-dashboard-hub\">\n    <div class=\"cdh-grid\">\n      <!-- Card 1: CHARACTER -->\n      <CyberSummaryCard\n        title=\"CHARACTER\"\n        accent-color=\"var(--cf-cyan)\"\n        clickable\n        @click=\"emit('openCharacter')\"\n      >\n        <div class=\"cdh-character\">\n          <img\n            :src=\"avatarUrl\"\n            alt=\"Character Avatar\"\n            class=\"cdh-character-avatar\"\n          >\n          <div class=\"cdh-character-info\">\n            <div class=\"cdh-character-level\">\n              LEVEL {{ currentLevel }}\n            </div>\n            <div class=\"cdh-character-xp-bar\">\n              <div\n                class=\"cdh-character-xp-fill\"\n                :style=\"{ width: `${levelInfo.progressPercent}%` }\"\n              />\n            </div>\n            <div class=\"cdh-character-xp-text\">\n              {{ levelInfo.currentXp }} / {{ levelInfo.xpForNextLevel }} XP\n            </div>\n            <div class=\"cdh-character-streak\">\n              <span class=\"cdh-streak-icon\">🔥</span>\n              {{ streakInfo.currentStreak }} day streak\n            </div>\n            <div class=\"cdh-character-class\">\n              NETRUNNER\n            </div>\n          </div>\n        </div>\n      </CyberSummaryCard>\n\n      <!-- Card 2: MISSIONS -->\n      <CyberSummaryCard\n        title=\"DAILY BRIEFING\"\n        accent-color=\"var(--cf-cyan)\"\n        clickable\n        @click=\"emit('navigate', 'missions')\"\n      >\n        <div class=\"cdh-missions\">\n          <div class=\"cdh-missions-completion\">\n            {{ completedTodayCount }}/3 CLEARED\n          </div>\n          <div class=\"cdh-missions-progress-bar\">\n            <div\n              class=\"cdh-missions-progress-fill\"\n              :style=\"{ width: `${missionCompletionPercent}%` }\"\n            />\n          </div>\n          <div class=\"cdh-missions-expiry\">\n            {{ missionsStatus }}\n          </div>\n        </div>\n      </CyberSummaryCard>\n\n      <!-- Card 3: BOSS THREAT -->\n      <CyberSummaryCard\n        title=\"BOSS THREAT\"\n        accent-color=\"var(--cf-magenta)\"\n        clickable\n        @click=\"emit('navigate', 'boss')\"\n      >\n        <div class=\"cdh-boss\">\n          <template v-if=\"activeBoss\">\n            <div class=\"cdh-boss-name\">\n              {{ activeBoss.title }}\n            </div>\n            <div class=\"cdh-boss-hp-bar\">\n              <div\n                class=\"cdh-boss-hp-fill\"\n                :class=\"bossHpColorClass\"\n                :style=\"{ width: `${bossHpPercent}%` }\"\n              />\n            </div>\n            <div class=\"cdh-boss-hp-text\">\n              {{ bossHpPercent }}% HP\n            </div>\n            <div class=\"cdh-boss-phase\">\n              {{ activeBoss.difficulty.toUpperCase() }}\n            </div>\n            <div class=\"cdh-boss-time\">\n              {{ bossTimeLeft }}\n            </div>\n          </template>\n          <template v-else>\n            <div class=\"cdh-boss-empty-title\">\n              NO ACTIVE THREAT\n            </div>\n            <div class=\"cdh-boss-empty-subtitle\">\n              SYSTEMS NOMINAL\n            </div>\n          </template>\n        </div>\n      </CyberSummaryCard>\n\n      <!-- Card 4: UPGRADES -->\n      <CyberSummaryCard\n        title=\"UPGRADES\"\n        accent-color=\"var(--cf-gold)\"\n        clickable\n        @click=\"emit('navigate', 'upgrades')\"\n      >\n        <div class=\"cdh-upgrades\">\n          <div class=\"cdh-upgrades-achievements\">\n            {{ unlockedAchievementsCount }}/{{ totalAchievementsCount }} trophies\n          </div>\n          <div class=\"cdh-upgrades-credits\">\n            {{ availableXp }} XP\n          </div>\n          <div class=\"cdh-upgrades-featured\">\n            {{ featuredItemText }}\n          </div>\n        </div>\n      </CyberSummaryCard>\n    </div>\n\n    <!-- System Status Footer (Compact Single Line) -->\n    <div class=\"cdh-system-status\">\n      <div class=\"cdh-aria-message\">\n        <span class=\"cdh-aria-label\">ARIA:</span>\n        <span class=\"cdh-aria-text\">{{ ariaGreeting }}</span>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useChallengesStore } from '@/stores/challenges'\nimport { useAuthStore } from '@/stores/auth'\nimport CyberSummaryCard from './CyberSummaryCard.vue'\nimport { EXTERNAL_URLS } from '@/config/urls'\n\nconst emit = defineEmits<{\n  navigate: [section: 'missions' | 'boss' | 'upgrades' | 'achievements']\n  openCharacter: []\n}>()\n\nconst gamificationStore = useGamificationStore()\nconst challengesStore = useChallengesStore()\nconst authStore = useAuthStore()\n\nconst {\n  currentLevel,\n  levelInfo,\n  streakInfo,\n  availableXp,\n  achievements,\n  earnedAchievements,\n  shopItemsWithOwnership\n} = storeToRefs(gamificationStore)\n\nconst { activeDailies, activeBoss, completedTodayCount: storeCompletedToday } = storeToRefs(challengesStore)\n\n// Avatar URL from email seed\nconst avatarUrl = computed(() => {\n  const email = authStore.user?.email || 'default'\n  return `${EXTERNAL_URLS.DICEBEAR_API}?seed=${encodeURIComponent(email)}`\n})\n\n// Missions card data — use the store's computed directly\nconst completedTodayCount = storeCompletedToday\n\nconst missionCompletionPercent = computed(() => {\n  // Daily target is always 3\n  return Math.min(100, (completedTodayCount.value / 3) * 100)\n})\n\nconst missionsStatus = computed(() => {\n  const incomplete = activeDailies.value.filter(d => d.status === 'active')\n\n  if (completedTodayCount.value === 3) {\n    return 'ALL CLEAR'\n  }\n\n  if (incomplete.length === 0) {\n    return 'NO ACTIVE MISSIONS'\n  }\n\n  // Find earliest expiry\n  const earliestExpiry = incomplete.reduce((earliest, mission) => {\n    if (!mission.expiresAt) return earliest\n    const expiryTime = new Date(mission.expiresAt).getTime()\n    return !earliest || expiryTime < earliest ? expiryTime : earliest\n  }, 0 as number)\n\n  if (!earliestExpiry) return 'In progress'\n\n  const now = Date.now()\n  const timeLeft = earliestExpiry - now\n  const hours = Math.floor(timeLeft / (1000 * 60 * 60))\n  const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60))\n\n  return `Next expires: ${hours}h ${minutes}m`\n})\n\n// Boss card data\nconst bossHpPercent = computed(() => {\n  if (!activeBoss.value) return 0\n  const total = activeBoss.value.objectiveTarget\n  const current = total - activeBoss.value.objectiveCurrent\n  return total > 0 ? Math.round((current / total) * 100) : 0\n})\n\nconst bossHpColorClass = computed(() => {\n  const percent = bossHpPercent.value\n  if (percent > 50) return 'hp-high'\n  if (percent > 25) return 'hp-medium'\n  return 'hp-low'\n})\n\nconst bossTimeLeft = computed(() => {\n  if (!activeBoss.value?.expiresAt) return ''\n\n  const now = Date.now()\n  const expiry = new Date(activeBoss.value.expiresAt).getTime()\n  const timeLeft = expiry - now\n\n  const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24))\n  const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))\n\n  return `${days}d ${hours}h left`\n})\n\n// Upgrades card data\nconst unlockedAchievementsCount = computed(() => earnedAchievements.value.length)\nconst totalAchievementsCount = computed(() => achievements.value.length)\n\nconst featuredItemText = computed(() => {\n  const unowned = shopItemsWithOwnership.value.filter(item => !item.isOwned)\n  if (unowned.length === 0) return 'All items owned'\n\n  const featured = unowned[0]\n  return `${featured.name} - ${featured.priceXp} XP`\n})\n\n// ARIA greeting (same logic as CyberMissionBriefing)\nconst ariaGreeting = computed(() => {\n  const completedCount = completedTodayCount.value\n  const hasActiveBoss = !!activeBoss.value\n\n  if (completedCount === 3 && !hasActiveBoss) {\n    return 'All systems optimal. Standing by for new directives.'\n  }\n\n  if (hasActiveBoss) {\n    return `Boss threat detected. Mission completion: ${completedCount}/3.`\n  }\n\n  if (completedCount === 0) {\n    return 'Daily briefing ready. Mission protocol active.'\n  }\n\n  return `${completedCount} mission${completedCount > 1 ? 's' : ''} cleared. Proceed with remaining objectives.`\n})\n\nconst ariaVariant = computed<'info' | 'warning' | 'success' | 'danger'>(() => {\n  if (activeBoss.value && bossHpPercent.value < 30) return 'warning'\n  if (completedTodayCount.value === 3) return 'success'\n  return 'info'\n})\n</script>\n\n<style scoped>\n.cyber-dashboard-hub {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n}\n\n/* Grid Layout */\n.cdh-grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-3);\n}\n\n/* CHARACTER Card */\n.cdh-character {\n  display: flex;\n  gap: var(--space-2);\n  align-items: center;\n}\n\n.cdh-character-avatar {\n  width: var(--space-12);\n  height: var(--space-12);\n  border-radius: var(--radius-md);\n  border: 2px solid var(--cf-cyan);\n  flex-shrink: 0;\n}\n\n.cdh-character-info {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.cdh-character-level {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-lg);\n  color: var(--cf-cyan);\n  font-weight: 700;\n  line-height: 1;\n}\n\n.cdh-character-xp-bar {\n  height: var(--space-1_5);\n  background: var(--cf-dark-2);\n  border-radius: var(--radius-full);\n  overflow: hidden;\n  position: relative;\n}\n\n.cdh-character-xp-fill {\n  height: 100%;\n  background: linear-gradient(90deg, var(--cf-cyan), var(--cf-magenta));\n  transition: width 0.3s ease;\n}\n\n.cdh-character-xp-text {\n  font-size: var(--text-2xs);\n  color: var(--text-muted);\n  font-family: var(--font-cyber-data);\n}\n\n.cdh-character-streak {\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  font-family: var(--font-cyber-ui);\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n}\n\n.cdh-streak-icon {\n  font-size: var(--text-sm);\n  color: var(--cf-orange);\n}\n\n.cdh-character-class {\n  font-size: var(--text-2xs);\n  color: var(--cf-magenta);\n  font-family: var(--font-cyber-title);\n  font-weight: 700;\n  padding: var(--space-0_5) var(--space-2);\n  background: var(--cf-dark-2);\n  border: 1px solid var(--cf-magenta);\n  border-radius: var(--radius-sm);\n  width: fit-content;\n}\n\n/* MISSIONS Card */\n.cdh-missions {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.cdh-missions-completion {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-lg);\n  color: var(--cf-cyan);\n  font-weight: 700;\n}\n\n.cdh-missions-progress-bar {\n  height: var(--space-2);\n  background: var(--cf-dark-2);\n  border-radius: var(--radius-full);\n  overflow: hidden;\n  position: relative;\n}\n\n.cdh-missions-progress-fill {\n  height: 100%;\n  background: var(--cf-cyan);\n  transition: width 0.3s ease;\n}\n\n.cdh-missions-expiry {\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  font-family: var(--font-cyber-data);\n}\n\n/* BOSS Card */\n.cdh-boss {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.cdh-boss-name {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-xs);\n  color: var(--cf-magenta);\n  font-weight: 700;\n  text-transform: uppercase;\n}\n\n.cdh-boss-hp-bar {\n  height: var(--space-2);\n  background: var(--cf-dark-2);\n  border-radius: var(--radius-full);\n  overflow: hidden;\n  position: relative;\n}\n\n.cdh-boss-hp-fill {\n  height: 100%;\n  transition: width 0.3s ease;\n}\n\n.cdh-boss-hp-fill.hp-high {\n  background: var(--color-success);\n}\n\n.cdh-boss-hp-fill.hp-medium {\n  background: var(--cf-orange);\n}\n\n.cdh-boss-hp-fill.hp-low {\n  background: var(--color-danger);\n}\n\n.cdh-boss-hp-text {\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  font-family: var(--font-cyber-data);\n}\n\n.cdh-boss-phase {\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  font-family: var(--font-cyber-ui);\n}\n\n.cdh-boss-time {\n  font-size: var(--text-xs);\n  color: var(--cf-magenta);\n  font-family: var(--font-cyber-data);\n  font-weight: 600;\n}\n\n.cdh-boss-empty-title {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-base);\n  color: var(--text-muted);\n  font-weight: 700;\n}\n\n.cdh-boss-empty-subtitle {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  font-family: var(--font-cyber-data);\n}\n\n/* UPGRADES Card */\n.cdh-upgrades {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.cdh-upgrades-achievements {\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  font-family: var(--font-cyber-data);\n}\n\n.cdh-upgrades-credits {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-lg);\n  color: var(--cf-lime);\n  font-weight: 700;\n}\n\n.cdh-upgrades-featured {\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  font-family: var(--font-cyber-ui);\n}\n\n/* System Status Footer (Compact Single Line) */\n.cdh-system-status {\n  padding: var(--space-3) var(--space-4);\n  background: var(--cf-dark-3);\n  border-top: 1px solid var(--border-subtle);\n  border-radius: var(--radius-md);\n}\n\n.cdh-aria-message {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.cdh-aria-label {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-xs);\n  color: var(--cf-cyan);\n  font-weight: 700;\n}\n\n.cdh-aria-text {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n}\n\n/* Responsive: stack grid on mobile */\n@media (max-width: 768px) {\n  .cdh-grid {\n    grid-template-columns: 1fr;\n  }\n\n  .cdh-character-avatar {\n    width: var(--space-10);\n    height: var(--space-10);\n  }\n\n  .cdh-aria-message {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: var(--space-1);\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberMissionBriefing.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberMissionCard.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'current' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":98,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":98,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * CyberMissionCard Component\n * FEATURE-1132: Interactive, game-quality mission card\n *\n * Visual novel-styled with clear icons showing what to do in the app.\n * Clickable to activate (make it your focus mission).\n */\nimport { computed, ref, onMounted, onUnmounted } from 'vue'\nimport type { Challenge } from '@/types/challenges'\nimport {\n  CheckSquare,\n  Timer,\n  AlertTriangle,\n  Clock,\n  Flame,\n  Folder,\n  Sunrise,\n  Layers,\n  Zap,\n} from 'lucide-vue-next'\n\nconst props = defineProps<{\n  challenge: Challenge\n  isActive?: boolean\n}>()\n\nconst emit = defineEmits<{\n  activate: []\n}>()\n\n// Reactive time remaining (updates every 60s)\nconst now = ref(new Date())\nlet timer: ReturnType<typeof setInterval> | null = null\n\nonMounted(() => {\n  timer = setInterval(() => { now.value = new Date() }, 60_000)\n})\n\nonUnmounted(() => {\n  if (timer) clearInterval(timer)\n})\n\n// Progress\nconst progressPercent = computed(() =>\n  Math.min(100, Math.round((props.challenge.objectiveCurrent / props.challenge.objectiveTarget) * 100))\n)\n\n// Time remaining\nconst timeRemaining = computed(() => {\n  const ms = props.challenge.expiresAt.getTime() - now.value.getTime()\n  const hours = Math.floor(ms / (1000 * 60 * 60))\n  if (hours > 24) {\n    const days = Math.floor(hours / 24)\n    return `${days}d left`\n  }\n  return `${hours}h left`\n})\n\n// Difficulty color mapping\nconst difficultyColor = computed(() => {\n  switch (props.challenge.difficulty) {\n    case 'easy': return 'var(--cf-lime)'\n    case 'normal': return 'var(--cf-cyan)'\n    case 'hard': return 'var(--cf-orange)'\n    case 'boss': return 'var(--cf-magenta)'\n    default: return 'var(--cf-cyan)'\n  }\n})\n\nconst difficultyColorDim = computed(() => {\n  switch (props.challenge.difficulty) {\n    case 'easy': return 'var(--cf-lime-20)'\n    case 'normal': return 'var(--cf-cyan-20)'\n    case 'hard': return 'var(--cf-orange-20)'\n    case 'boss': return 'var(--cf-magenta-20)'\n    default: return 'var(--cf-cyan-20)'\n  }\n})\n\n// Objective icon mapping (CLEAR VISUAL LANGUAGE)\nconst objectiveIcon = computed(() => {\n  switch (props.challenge.objectiveType) {\n    case 'complete_tasks': return CheckSquare\n    case 'complete_pomodoros': return Timer\n    case 'clear_overdue': return AlertTriangle\n    case 'focus_time_minutes': return Clock\n    case 'complete_high_priority': return Flame\n    case 'complete_project_tasks': return Folder\n    case 'complete_before_hour': return Sunrise\n    case 'complete_variety': return Layers\n    default: return CheckSquare\n  }\n})\n\n// Objective text (CLEAR ACTION VERBS)\nconst objectiveText = computed(() => {\n  const current = props.challenge.objectiveCurrent\n  const target = props.challenge.objectiveTarget\n  const ctx = props.challenge.objectiveContext\n\n  switch (props.challenge.objectiveType) {\n    case 'complete_tasks':\n      return `Complete ${target} task${target > 1 ? 's' : ''}`\n    case 'complete_pomodoros':\n      return `Do ${target} pomodoro${target > 1 ? 's' : ''}`\n    case 'clear_overdue':\n      return `Clear ${target} overdue task${target > 1 ? 's' : ''}`\n    case 'focus_time_minutes':\n      return `Focus ${target} minutes`\n    case 'complete_high_priority':\n      return `Clear ${target} urgent task${target > 1 ? 's' : ''}`\n    case 'complete_project_tasks':\n      return `${target} task${target > 1 ? 's' : ''} in ${ctx?.projectName || 'project'}`\n    case 'complete_before_hour':\n      return `${target} task${target > 1 ? 's' : ''} before ${ctx?.hour}:00`\n    case 'complete_variety':\n      return `Tasks across ${target} projects`\n    default:\n      return props.challenge.description\n  }\n})\n\n// Status\nconst isCompleted = computed(() => props.challenge.status === 'completed')\nconst isFailed = computed(() => props.challenge.status === 'failed' || props.challenge.status === 'expired')\n\nfunction handleClick() {\n  if (!isCompleted.value && !isFailed.value) {\n    emit('activate')\n  }\n}\n</script>\n\n<template>\n  <div\n    class=\"mission-card\"\n    :class=\"{\n      'mission-card--active': isActive,\n      'mission-card--completed': isCompleted,\n      'mission-card--failed': isFailed,\n    }\"\n    :style=\"{\n      '--mission-accent': difficultyColor,\n      '--mission-accent-dim': difficultyColorDim,\n    }\"\n    @click=\"handleClick\"\n  >\n    <!-- Left: Objective Icon (BIG, CLEAR) -->\n    <div class=\"mission-card__icon-box\">\n      <component\n        :is=\"objectiveIcon\"\n        class=\"mission-card__icon\"\n        :size=\"40\"\n      />\n    </div>\n\n    <!-- Center: Objective + Progress -->\n    <div class=\"mission-card__content\">\n      <h3 class=\"mission-card__objective\">\n        {{ objectiveText }}\n      </h3>\n\n      <!-- Progress bar -->\n      <div class=\"mission-card__progress-row\">\n        <div class=\"mission-card__progress-track\">\n          <div\n            class=\"mission-card__progress-fill\"\n            :style=\"{ width: `${progressPercent}%` }\"\n          />\n        </div>\n        <span class=\"mission-card__progress-text\">{{ challenge.objectiveCurrent }}/{{ challenge.objectiveTarget }}</span>\n      </div>\n\n      <!-- Difficulty + Time -->\n      <div class=\"mission-card__meta\">\n        <span class=\"mission-card__difficulty\">{{ challenge.difficulty.toUpperCase() }}</span>\n        <span class=\"mission-card__time\">{{ timeRemaining }}</span>\n      </div>\n    </div>\n\n    <!-- Right: XP Badge + Activate Button -->\n    <div class=\"mission-card__right\">\n      <!-- XP Badge -->\n      <div class=\"mission-card__xp-badge\">\n        <Zap :size=\"14\" />\n        <span>+{{ challenge.rewardXp }}</span>\n      </div>\n\n      <!-- Activate Button (only visible when not active) -->\n      <button\n        v-if=\"!isActive && !isCompleted && !isFailed\"\n        class=\"mission-card__activate-btn\"\n        @click.stop=\"handleClick\"\n      >\n        ACTIVATE\n      </button>\n\n      <!-- Active indicator -->\n      <div v-if=\"isActive && !isCompleted && !isFailed\" class=\"mission-card__active-indicator\">\n        ACTIVE\n      </div>\n\n      <!-- Completed/Failed badge -->\n      <div v-if=\"isCompleted\" class=\"mission-card__status-badge mission-card__status-badge--completed\">\n        ✓ DONE\n      </div>\n      <div v-if=\"isFailed\" class=\"mission-card__status-badge mission-card__status-badge--failed\">\n        FAILED\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.mission-card {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  background: var(--cf-dark-3);\n  border: 2px solid var(--mission-accent-dim);\n  border-radius: var(--radius-md);\n  padding: var(--space-3);\n  min-height: 90px;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  cursor: pointer;\n  position: relative;\n  overflow: hidden;\n}\n\n/* Glow overlay on hover */\n.mission-card::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  background: radial-gradient(circle at 50% 50%, var(--mission-accent-dim), transparent 70%);\n  opacity: 0;\n  transition: opacity 0.3s ease;\n  pointer-events: none;\n}\n\n.mission-card:hover::before {\n  opacity: 0.2;\n}\n\n/* Active state */\n.mission-card--active {\n  border-color: var(--mission-accent);\n  transform: scale(1.02);\n  box-shadow: 0 0 var(--space-6) var(--mission-accent-dim), 0 var(--space-1) var(--space-3) rgba(var(--color-slate-900), 0.3);\n}\n\n.mission-card--active::before {\n  opacity: 0.25;\n}\n\n/* Inactive siblings when one is active */\n.mission-card:not(.mission-card--active) {\n  opacity: 0.6;\n}\n\n.mission-card--active:hover {\n  transform: scale(1.03);\n  box-shadow: 0 0 var(--space-8) var(--mission-accent-dim), 0 var(--space-1_5) var(--space-4) rgba(var(--color-slate-900), 0.4);\n}\n\n/* Completed state */\n.mission-card--completed {\n  border-color: var(--cf-lime);\n  opacity: 0.7;\n  cursor: default;\n}\n\n.mission-card--completed:hover::before {\n  opacity: 0;\n}\n\n/* Failed state */\n.mission-card--failed {\n  border-color: var(--cf-magenta);\n  opacity: 0.5;\n  cursor: default;\n}\n\n.mission-card--failed:hover::before {\n  opacity: 0;\n}\n\n/* Icon Box */\n.mission-card__icon-box {\n  flex-shrink: 0;\n  width: calc(var(--space-6) + var(--space-3));\n  height: calc(var(--space-6) + var(--space-3));\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--mission-accent-dim);\n  border: 2px solid var(--mission-accent);\n  border-radius: var(--radius-md);\n  box-shadow: 0 0 var(--space-4) var(--mission-accent-dim);\n  transition: all 0.3s ease;\n}\n\n.mission-card--active .mission-card__icon-box {\n  box-shadow: 0 0 var(--space-6) var(--mission-accent);\n}\n\n.mission-card__icon {\n  color: var(--mission-accent);\n  filter: drop-shadow(0 0 var(--space-1_5) var(--mission-accent));\n}\n\n/* Content */\n.mission-card__content {\n  flex: 1;\n  min-width: 0;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.mission-card__objective {\n  margin: 0;\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-base);\n  font-weight: 700;\n  color: var(--text-primary);\n  letter-spacing: 0.01em;\n  line-height: 1.3;\n}\n\n/* Progress Row */\n.mission-card__progress-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.mission-card__progress-track {\n  flex: 1;\n  height: var(--space-1_5);\n  background: var(--cf-dark-2);\n  border-radius: calc(var(--space-0_5) * 1.5);\n  overflow: hidden;\n  border: 1px solid var(--border-subtle);\n}\n\n.mission-card__progress-fill {\n  height: 100%;\n  background: linear-gradient(90deg, var(--mission-accent), var(--cf-cyan));\n  border-radius: calc(var(--space-0_5) * 1.5);\n  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);\n  box-shadow: 0 0 var(--space-2) var(--mission-accent);\n}\n\n.mission-card--active .mission-card__progress-fill {\n  box-shadow: 0 0 var(--space-3) var(--mission-accent);\n}\n\n.mission-card__progress-text {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: var(--text-secondary);\n  min-width: var(--space-10);\n  text-align: right;\n}\n\n/* Meta row */\n.mission-card__meta {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  letter-spacing: 0.06em;\n}\n\n.mission-card__difficulty {\n  font-weight: 700;\n  color: var(--mission-accent);\n  opacity: 0.9;\n}\n\n.mission-card__time {\n  font-weight: 600;\n  color: var(--text-muted);\n}\n\n/* Right section */\n.mission-card__right {\n  flex-shrink: 0;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n  gap: var(--space-2);\n}\n\n/* XP Badge */\n.mission-card__xp-badge {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: var(--cf-dark-2);\n  border: 1px solid var(--cf-gold);\n  border-radius: var(--radius-sm);\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: var(--cf-gold);\n  box-shadow: 0 0 var(--space-2_5) rgba(255, 193, 7, 0.2);\n}\n\n.mission-card__xp-badge svg {\n  color: var(--cf-gold);\n}\n\n/* Activate Button */\n.mission-card__activate-btn {\n  padding: var(--space-1) var(--space-3);\n  background: var(--cf-dark-2);\n  border: 1px solid var(--mission-accent);\n  border-radius: var(--radius-sm);\n  color: var(--mission-accent);\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  font-weight: 700;\n  letter-spacing: 0.08em;\n  cursor: pointer;\n  transition: all 0.3s ease;\n}\n\n.mission-card__activate-btn:hover {\n  background: var(--mission-accent-dim);\n  border-color: var(--mission-accent);\n  box-shadow: 0 0 var(--space-3) var(--mission-accent-dim);\n  transform: translateY(calc(-0.5 * var(--space-0_5)));\n}\n\n/* Active indicator */\n.mission-card__active-indicator {\n  padding: var(--space-1) var(--space-3);\n  background: var(--mission-accent);\n  border: 1px solid var(--mission-accent);\n  border-radius: var(--radius-sm);\n  color: var(--cf-dark-1);\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  font-weight: 700;\n  letter-spacing: 0.08em;\n  box-shadow: 0 0 var(--space-4) var(--mission-accent);\n  animation: pulse-glow 2s ease-in-out infinite;\n}\n\n@keyframes pulse-glow {\n  0%, 100% {\n    box-shadow: 0 0 var(--space-4) var(--mission-accent);\n  }\n  50% {\n    box-shadow: 0 0 var(--space-6) var(--mission-accent);\n  }\n}\n\n/* Status badges */\n.mission-card__status-badge {\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-sm);\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  font-weight: 700;\n  letter-spacing: 0.08em;\n}\n\n.mission-card__status-badge--completed {\n  background: var(--cf-lime);\n  color: var(--cf-dark-1);\n  border: 1px solid var(--cf-lime);\n  box-shadow: 0 0 var(--space-3) var(--cf-lime-20);\n}\n\n.mission-card__status-badge--failed {\n  background: var(--cf-magenta);\n  color: var(--cf-dark-1);\n  border: 1px solid var(--cf-magenta);\n  box-shadow: 0 0 var(--space-3) var(--cf-magenta-20);\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .mission-card,\n  .mission-card::before,\n  .mission-card__progress-fill,\n  .mission-card__activate-btn,\n  .mission-card__icon-box {\n    transition: none;\n  }\n\n  .mission-card__active-indicator {\n    animation: none;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberSectionNav.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberShop.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2162,2165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2162,2165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * CyberShop - Visual Novel Shop Catalog\n * FEATURE-1118 Cyberflow RPG Hub: Bottom-right panel\n *\n * Icon-dominant item cards with big category icons, rarity glow borders,\n * compact layout. Visual novel aesthetic: show, don't tell.\n */\nimport { computed, ref } from 'vue'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useCyberflowTheme } from '@/composables/useCyberflowTheme'\nimport type { ShopItemWithOwnership, ShopCategory } from '@/types/gamification'\nimport { ChevronRight, ShoppingBag, Check, Lock, Palette, Hexagon, Sparkles, Radio } from 'lucide-vue-next'\n\nconst props = withDefaults(defineProps<{\n  showAll?: boolean\n}>(), {\n  showAll: false\n})\n\nconst emit = defineEmits<{\n  openShop: []\n}>()\n\nconst gamificationStore = useGamificationStore()\nconst { cyberflowClasses } = useCyberflowTheme()\n\n// Purchase state tracking\nconst purchasingId = ref<string | null>(null)\n\n// XP balance\nconst availableXp = computed(() => gamificationStore.availableXp)\nconst currentLevel = computed(() => gamificationStore.currentLevel)\n\n// Get 3 featured items (available, not owned, sorted by price)\nconst featuredItems = computed((): ShopItemWithOwnership[] => {\n  const all = gamificationStore.shopItemsWithOwnership\n\n  // Prioritize: available + affordable + not owned, then available + not owned\n  const available = all\n    .filter(item => item.isAvailable)\n    .sort((a, b) => {\n      // Owned items last\n      if (a.isOwned !== b.isOwned) return a.isOwned ? 1 : -1\n      // Then by price ascending\n      return a.priceXp - b.priceXp\n    })\n\n  return props.showAll ? available : available.slice(0, 3)\n})\n\nconst hasItems = computed(() => gamificationStore.shopItems.length > 0)\n\n// Rarity color mapping based on price tiers\nfunction getItemRarity(item: ShopItemWithOwnership): 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary' {\n  if (item.priceXp >= 2000) return 'legendary'\n  if (item.priceXp >= 1000) return 'epic'\n  if (item.priceXp >= 500) return 'rare'\n  if (item.priceXp >= 200) return 'uncommon'\n  return 'common'\n}\n\n// Category icon components (Lucide icons)\nconst categoryIcons: Record<ShopCategory, any> = {\n  theme: Palette,\n  badge_style: Hexagon,\n  animation: Sparkles,\n  sound: Radio\n}\n\nfunction getCategoryIcon(category: ShopCategory) {\n  return categoryIcons[category] || Palette\n}\n\nfunction canAfford(item: ShopItemWithOwnership): boolean {\n  return availableXp.value >= item.priceXp\n}\n\nfunction meetsLevel(item: ShopItemWithOwnership): boolean {\n  return currentLevel.value >= item.requiredLevel\n}\n\nasync function handlePurchase(item: ShopItemWithOwnership) {\n  if (item.isOwned || !canAfford(item) || !meetsLevel(item) || purchasingId.value) return\n\n  purchasingId.value = item.id\n  try {\n    await gamificationStore.purchaseItem(item.id)\n  } finally {\n    purchasingId.value = null\n  }\n}\n</script>\n\n<template>\n  <div\n    class=\"cyber-shop\"\n    :class=\"cyberflowClasses\"\n    data-augmented-ui=\"tl-clip br-clip border\"\n  >\n    <!-- Panel Header with XP Balance -->\n    <div class=\"cs-header\">\n      <ShoppingBag :size=\"16\" class=\"cs-header-icon\" />\n      <span class=\"cs-header-text\">SHOP</span>\n      <div class=\"cs-credits\">\n        <span class=\"cs-credits-value\">{{ availableXp.toLocaleString() }}</span>\n        <span class=\"cs-credits-label\">XP</span>\n      </div>\n    </div>\n\n    <!-- Featured Items -->\n    <div\n      v-if=\"hasItems && featuredItems.length > 0\"\n      class=\"cs-items\"\n    >\n      <div\n        v-for=\"item in featuredItems\"\n        :key=\"item.id\"\n        class=\"cs-item\"\n        :class=\"[\n          `cs-item--${getItemRarity(item)}`,\n          {\n            'cs-item--owned': item.isOwned,\n            'cs-item--locked': !meetsLevel(item)\n          }\n        ]\"\n      >\n        <!-- Large Category Icon -->\n        <div class=\"cs-icon-wrap\">\n          <component\n            :is=\"getCategoryIcon(item.category)\"\n            :size=\"40\"\n            class=\"cs-icon\"\n          />\n\n          <!-- Owned Badge Overlay -->\n          <div v-if=\"item.isOwned\" class=\"cs-owned-badge\">\n            <Check :size=\"14\" />\n          </div>\n        </div>\n\n        <!-- Item Info -->\n        <div class=\"cs-info\">\n          <span class=\"cs-name\">{{ item.name }}</span>\n          <span class=\"cs-desc\">{{ item.description }}</span>\n        </div>\n\n        <!-- Price / Status -->\n        <div class=\"cs-footer\">\n          <template v-if=\"item.isOwned\">\n            <div class=\"cs-status cs-status--owned\">\n              <Check :size=\"12\" />\n            </div>\n          </template>\n          <template v-else-if=\"!meetsLevel(item)\">\n            <div class=\"cs-status cs-status--locked\">\n              <Lock :size=\"12\" />\n              <span>LVL {{ item.requiredLevel }}</span>\n            </div>\n          </template>\n          <template v-else>\n            <div class=\"cs-price\" :class=\"{ 'cs-price--cant-afford': !canAfford(item) }\">\n              <span class=\"cs-price-value\">{{ item.priceXp.toLocaleString() }}</span>\n              <span class=\"cs-price-label\">XP</span>\n            </div>\n            <button\n              class=\"cs-buy\"\n              :disabled=\"!canAfford(item) || purchasingId === item.id\"\n              @click=\"handlePurchase(item)\"\n            >\n              {{ purchasingId === item.id ? '...' : 'BUY' }}\n            </button>\n          </template>\n        </div>\n      </div>\n    </div>\n\n    <!-- Empty State -->\n    <div v-else class=\"cs-empty\">\n      <ShoppingBag :size=\"32\" class=\"cs-empty-icon\" />\n      <span class=\"cs-empty-text\">SHOP OFFLINE</span>\n      <span class=\"cs-empty-sub\">Connect to sync to browse available items</span>\n    </div>\n\n    <!-- Browse Shop Button -->\n    <button\n      v-if=\"!showAll && hasItems\"\n      class=\"cs-browse\"\n      @click=\"emit('openShop')\"\n    >\n      <span>BROWSE SHOP</span>\n      <ChevronRight :size=\"14\" />\n    </button>\n  </div>\n</template>\n\n<style scoped>\n.cyber-shop {\n  --aug-border-all: 1px;\n  --aug-border-bg: var(--cf-magenta-50, rgba(255, 0, 153, 0.5));\n  --aug-tl1: 16px;\n  --aug-br1: 16px;\n  background: var(--cf-dark-2);\n  padding: var(--space-3);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n  height: 100%;\n}\n\n/* Header */\n.cs-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.cs-header-icon {\n  color: var(--cf-magenta);\n  filter: drop-shadow(0 0 6px var(--cf-magenta));\n}\n\n.cs-header-text {\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: var(--cf-cyan);\n  letter-spacing: 0.1em;\n  flex: 1;\n}\n\n.cs-credits {\n  display: flex;\n  align-items: baseline;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2_5);\n  background: rgba(57, 255, 20, 0.05);\n  border-radius: var(--radius-sm);\n  border: var(--space-0_5) solid rgba(57, 255, 20, 0.2);\n}\n\n.cs-credits-value {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: var(--cf-lime);\n  text-shadow: 0 0 var(--space-2) var(--cf-lime);\n}\n\n.cs-credits-label {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  color: rgba(57, 255, 20, 0.5);\n}\n\n/* Items Container */\n.cs-items {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  flex: 1;\n  overflow-y: auto;\n}\n\n/* Individual Item Card (~60px tall) */\n.cs-item {\n  background: var(--cf-dark-3);\n  padding: var(--space-2);\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  border-radius: var(--radius-lg);\n  border: var(--space-0_5) solid var(--border-subtle);\n  transition: all 0.2s ease;\n  min-height: var(--space-15);\n}\n\n.cs-item:hover {\n  transform: translateY(calc(-1 * var(--space-0_5)));\n  border-color: rgba(255, 255, 255, 0.15);\n}\n\n/* Rarity border glow */\n.cs-item--common {\n  border-color: rgba(255, 255, 255, 0.15);\n}\n\n.cs-item--uncommon {\n  border-color: var(--cf-lime);\n  box-shadow: 0 0 var(--space-2) rgba(57, 255, 20, 0.2);\n}\n\n.cs-item--rare {\n  border-color: rgba(0, 150, 255, 1);\n  box-shadow: 0 0 var(--space-3) rgba(0, 150, 255, 0.3);\n}\n\n.cs-item--epic {\n  border-color: rgba(147, 51, 234, 1);\n  box-shadow: 0 0 var(--space-3) rgba(147, 51, 234, 0.4);\n}\n\n.cs-item--legendary {\n  border-color: var(--cf-gold);\n  box-shadow: 0 0 var(--space-4) rgba(255, 215, 0, 0.4);\n}\n\n/* Owned state */\n.cs-item--owned {\n  border-color: var(--cf-cyan);\n  opacity: 0.7;\n}\n\n/* Locked state */\n.cs-item--locked {\n  opacity: 0.5;\n}\n\n/* Icon Wrapper */\n.cs-icon-wrap {\n  position: relative;\n  width: var(--space-12);\n  height: var(--space-12);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n  background: rgba(255, 255, 255, 0.03);\n  border-radius: var(--radius-sm);\n}\n\n/* Icon (40px) */\n.cs-icon {\n  color: var(--text-secondary);\n}\n\n.cs-item--uncommon .cs-icon { color: var(--cf-lime); }\n.cs-item--rare .cs-icon { color: rgba(0, 150, 255, 1); }\n.cs-item--epic .cs-icon { color: rgba(147, 51, 234, 1); }\n.cs-item--legendary .cs-icon { color: var(--cf-gold); }\n\n/* Owned Badge Overlay */\n.cs-owned-badge {\n  position: absolute;\n  top: calc(-1 * var(--space-1));\n  right: calc(-1 * var(--space-1));\n  width: var(--space-5);\n  height: var(--space-5);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--cf-cyan);\n  border-radius: var(--radius-full);\n  color: var(--cf-dark-1);\n  box-shadow: 0 0 var(--space-2) var(--cf-cyan);\n}\n\n/* Item Info */\n.cs-info {\n  flex: 1;\n  min-width: 0;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-0_5);\n}\n\n.cs-name {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-sm);\n  font-weight: 600;\n  color: var(--text-primary);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.cs-desc {\n  font-family: var(--font-cyber-ui);\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n/* Footer: Price + Buy */\n.cs-footer {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  flex-shrink: 0;\n}\n\n/* Price Badge */\n.cs-price {\n  display: flex;\n  align-items: baseline;\n  gap: var(--space-0_75);\n  padding: var(--space-1) var(--space-2);\n  background: rgba(57, 255, 20, 0.1);\n  border-radius: var(--radius-sm);\n  border: var(--space-0_5) solid rgba(57, 255, 20, 0.3);\n}\n\n.cs-price-value {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-sm);\n  font-weight: 700;\n  color: var(--cf-lime);\n}\n\n.cs-price-label {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  color: rgba(57, 255, 20, 0.6);\n}\n\n.cs-price--cant-afford {\n  background: rgba(255, 0, 153, 0.1);\n  border-color: rgba(255, 0, 153, 0.3);\n}\n\n.cs-price--cant-afford .cs-price-value {\n  color: var(--cf-magenta);\n}\n\n.cs-price--cant-afford .cs-price-label {\n  color: rgba(255, 0, 153, 0.6);\n}\n\n/* Buy Button */\n.cs-buy {\n  padding: var(--space-1_5) var(--space-3);\n  background: rgba(0, 240, 255, 0.1);\n  border: var(--space-0_5) solid rgba(0, 240, 255, 0.4);\n  border-radius: var(--radius-sm);\n  color: var(--cf-cyan);\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-xs);\n  font-weight: 700;\n  letter-spacing: 0.1em;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.cs-buy:hover:not(:disabled) {\n  background: rgba(0, 240, 255, 0.2);\n  border-color: var(--cf-cyan);\n  box-shadow: 0 0 var(--space-3) rgba(0, 240, 255, 0.3);\n}\n\n.cs-buy:disabled {\n  opacity: 0.3;\n  cursor: not-allowed;\n}\n\n/* Status badges (owned / locked) */\n.cs-status {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-xs);\n  font-weight: 600;\n}\n\n.cs-status--owned {\n  color: var(--cf-cyan);\n}\n\n.cs-status--locked {\n  color: var(--cf-orange);\n}\n\n/* Empty State */\n.cs-empty {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n}\n\n.cs-empty-icon {\n  color: var(--text-muted);\n  opacity: 0.3;\n}\n\n.cs-empty-text {\n  font-family: var(--font-cyber-data);\n  font-size: var(--text-sm);\n  color: var(--text-muted);\n  letter-spacing: 0.05em;\n}\n\n.cs-empty-sub {\n  font-family: var(--font-cyber-ui);\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  opacity: 0.6;\n  text-align: center;\n}\n\n/* Browse Shop Button */\n.cs-browse {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(255, 0, 153, 0.05);\n  border: var(--space-0_5) solid rgba(255, 0, 153, 0.3);\n  border-radius: var(--radius-sm);\n  color: var(--cf-magenta);\n  font-family: var(--font-cyber-title);\n  font-size: var(--text-xs);\n  font-weight: 600;\n  letter-spacing: 0.1em;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.cs-browse:hover {\n  background: rgba(255, 0, 153, 0.1);\n  border-color: var(--cf-magenta);\n  box-shadow: 0 0 var(--space-3) rgba(255, 0, 153, 0.3);\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n  .cs-item {\n    flex-wrap: wrap;\n  }\n\n  .cs-footer {\n    width: 100%;\n    justify-content: flex-end;\n  }\n}\n\n/* Reduced Motion */\n@media (prefers-reduced-motion: reduce) {\n  .cs-item {\n    transition: none;\n  }\n\n  .cs-buy {\n    transition: none;\n  }\n\n  .cs-browse {\n    transition: none;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberSkillTree.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/CyberSummaryCard.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/cyber/StatsRadar.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/tooltips/ChallengeTooltipContent.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dailies' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":12,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * ChallengeTooltipContent - Rich tooltip for ChallengePips\n * TASK-1287: Shows daily challenge list, boss status, and narrative\n */\nimport { computed } from 'vue'\nimport { useChallengesStore } from '@/stores/challenges'\nimport { getChallengeNarrative } from '@/composables/useAriaTooltipNarrative'\n\nconst challengesStore = useChallengesStore()\n\nconst dailies = computed(() => challengesStore.activeDailies)\nconst boss = computed(() => challengesStore.activeBoss)\nconst completedToday = computed(() => challengesStore.completedTodayCount)\n\n// All challenges for display (active + completed today)\nconst displayChallenges = computed(() => {\n  return challengesStore.activeChallenges.filter(\n    c => c.challengeType === 'daily'\n  )\n})\n\nconst totalDailies = computed(() => displayChallenges.value.length)\n\nconst narrative = computed(() =>\n  getChallengeNarrative(\n    completedToday.value,\n    totalDailies.value,\n    boss.value != null\n  )\n)\n\nfunction progressText(current: number, target: number): string {\n  return `${current}/${target}`\n}\n\nfunction bossHpPercent(b: typeof boss.value): number {\n  if (!b) return 0\n  return Math.round((b.objectiveCurrent / b.objectiveTarget) * 100)\n}\n</script>\n\n<template>\n  <div class=\"challenge-tooltip\">\n    <div class=\"tooltip-title\">\n      DAILY MISSIONS: {{ completedToday }}/{{ totalDailies }} Complete\n    </div>\n\n    <div v-if=\"displayChallenges.length > 0\" class=\"challenge-list\">\n      <div\n        v-for=\"challenge in displayChallenges\"\n        :key=\"challenge.id\"\n        class=\"challenge-entry\"\n        :class=\"{ 'challenge-entry--done': challenge.status === 'completed' }\"\n      >\n        <span class=\"challenge-marker\">\n          {{ challenge.status === 'completed' ? '&#10003;' : '&#9679;' }}\n        </span>\n        <span class=\"challenge-name\">{{ challenge.title }}</span>\n        <span v-if=\"challenge.status !== 'completed'\" class=\"challenge-progress\">\n          ({{ progressText(challenge.objectiveCurrent, challenge.objectiveTarget) }})\n        </span>\n      </div>\n    </div>\n\n    <div v-if=\"boss\" class=\"boss-section\">\n      <div class=\"boss-header\">\n        <span class=\"boss-label\">BOSS: {{ boss.title.toUpperCase() }}</span>\n        <span class=\"boss-hp\">[HP: {{ 100 - bossHpPercent(boss) }}%]</span>\n      </div>\n    </div>\n\n    <div class=\"tooltip-narrative\">\n      \"{{ narrative }}\"\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.challenge-tooltip {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  min-width: 220px;\n}\n\n.tooltip-title {\n  font-weight: var(--font-bold);\n  color: rgba(var(--neon-cyan), 1);\n  font-size: var(--text-sm);\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n}\n\n.challenge-list {\n  display: flex;\n  flex-direction: column;\n  gap: 3px;\n}\n\n.challenge-entry {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n}\n\n.challenge-entry--done {\n  color: var(--cf-lime, #a3e635);\n}\n\n.challenge-marker {\n  font-size: 10px;\n  min-width: 12px;\n}\n\n.challenge-entry--done .challenge-marker {\n  color: var(--cf-lime, #a3e635);\n}\n\n.challenge-name {\n  flex: 1;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.challenge-progress {\n  color: var(--text-muted);\n  white-space: nowrap;\n}\n\n.boss-section {\n  padding-top: var(--space-1);\n  border-top: 1px solid rgba(255, 255, 255, 0.06);\n}\n\n.boss-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  font-size: var(--text-xs);\n}\n\n.boss-label {\n  color: var(--cf-magenta, #ff00ff);\n  font-weight: var(--font-bold);\n  letter-spacing: 0.03em;\n}\n\n.boss-hp {\n  color: var(--cf-magenta, #ff00ff);\n  font-weight: var(--font-semibold);\n}\n\n.tooltip-narrative {\n  font-size: var(--text-xs);\n  color: rgba(var(--neon-cyan), 0.6);\n  font-style: italic;\n  padding-top: var(--space-1);\n  border-top: 1px solid rgba(255, 255, 255, 0.06);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/tooltips/LevelTooltipContent.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/tooltips/StreakTooltipContent.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/gamification/tooltips/XpTooltipContent.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/CalendarInboxPanel.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/UnifiedInboxPanel.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/calendar/CalendarInboxHeader.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5105,5108],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5105,5108],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5375,5378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5375,5378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"inbox-header\">\n    <button\n      class=\"collapse-btn\"\n      :title=\"isCollapsed ? 'Expand Inbox' : 'Collapse Inbox'\"\n      @click=\"$emit('update:isCollapsed', !isCollapsed)\"\n    >\n      <ChevronLeft v-if=\"!isCollapsed\" :size=\"16\" />\n      <ChevronRight v-else :size=\"16\" />\n    </button>\n    <h3 v-if=\"!isCollapsed\" class=\"inbox-title\">\n      Inbox\n    </h3>\n\n    <!-- Expanded state count -->\n    <NBadge v-if=\"!isCollapsed\" :value=\"inboxCount\" type=\"info\" />\n\n    <!-- Quick Today Filter -->\n    <button\n      v-if=\"!isCollapsed\"\n      class=\"today-quick-filter\"\n      :class=\"{ active: showTodayOnly }\"\n      :title=\"`Show tasks due today (${todayCount})`\"\n      @click=\"$emit('update:showTodayOnly', !showTodayOnly)\"\n    >\n      <CalendarDays :size=\"14\" />\n      <span>Today</span>\n      <span v-if=\"todayCount > 0\" class=\"count-badge\">{{ todayCount }}</span>\n    </button>\n\n    <!-- TASK-1075: Search Toggle Button -->\n    <button\n      v-if=\"!isCollapsed\"\n      class=\"search-toggle-btn\"\n      :class=\"{ active: isSearchExpanded || searchQuery }\"\n      title=\"Search tasks\"\n      @click=\"toggleSearch\"\n    >\n      <Search :size=\"14\" />\n    </button>\n  </div>\n\n  <!-- TASK-1075: Search Input Row -->\n  <Transition name=\"slide-down\">\n    <div v-if=\"!isCollapsed && isSearchExpanded\" class=\"search-input-row\">\n      <div class=\"search-input-wrapper\">\n        <Search :size=\"14\" class=\"search-icon\" />\n        <input\n          ref=\"searchInputRef\"\n          type=\"text\"\n          class=\"search-input\"\n          :value=\"searchQuery\"\n          placeholder=\"Search tasks...\"\n          @input=\"handleSearchInput\"\n          @keydown.escape=\"toggleSearch\"\n        >\n        <button\n          v-if=\"searchQuery\"\n          class=\"clear-search-btn\"\n          title=\"Clear search\"\n          @click=\"clearSearch\"\n        >\n          <X :size=\"12\" />\n        </button>\n      </div>\n    </div>\n  </Transition>\n\n  <!-- Collapsed state task count indicators -->\n  <div v-if=\"isCollapsed\" class=\"collapsed-badges-container\">\n    <BaseBadge\n      v-if=\"!hasActiveFilters\"\n      variant=\"count\"\n      size=\"sm\"\n      rounded\n    >\n      {{ baseCount }}\n    </BaseBadge>\n    <div v-else class=\"dual-badges\">\n      <BaseBadge\n        variant=\"count\"\n        size=\"sm\"\n        rounded\n        class=\"total-count\"\n      >\n        {{ baseCount }}\n      </BaseBadge>\n      <BaseBadge\n        variant=\"info\"\n        size=\"sm\"\n        rounded\n        class=\"filtered-count\"\n      >\n        {{ inboxCount }}\n      </BaseBadge>\n    </div>\n  </div>\n\n  <!-- Canvas Group Filter -->\n  <div v-if=\"!isCollapsed && canvasGroupOptions.length > 1\" class=\"canvas-group-filter\">\n    <CustomSelect\n      :model-value=\"Array.from(selectedCanvasGroups)[0] || ''\"\n      :options=\"canvasGroupOptions\"\n      placeholder=\"Show from: All Tasks\"\n      @update:model-value=\"$emit('update:selectedCanvasGroups', new Set($event ? [String($event)] : []))\"\n    />\n  </div>\n\n  <!-- Additional Filters -->\n  <div v-if=\"!isCollapsed\" class=\"advanced-filters-section\">\n    <button\n      class=\"toggle-filters-btn\"\n      :class=\"{ active: showAdvancedFilters }\"\n      @click=\"$emit('update:showAdvancedFilters', !showAdvancedFilters)\"\n    >\n      <Filter :size=\"14\" />\n      <span>{{ showAdvancedFilters ? 'Hide filters' : 'More filters' }}</span>\n      <ChevronDown :size=\"14\" class=\"toggle-icon\" :class=\"{ rotated: showAdvancedFilters }\" />\n    </button>\n\n    <Transition name=\"slide-down\">\n      <InboxFilters\n        v-if=\"showAdvancedFilters\"\n        :unscheduled-only=\"unscheduledOnly\"\n        :selected-priorities=\"selectedPriorities\"\n        :selected-projects=\"selectedProjects\"\n        :selected-durations=\"selectedDurations\"\n        :hide-done-tasks=\"hideDoneTasks\"\n        :sort-by=\"sortBy\"\n        :tasks=\"baseTasks\"\n        :projects=\"rootProjects\"\n        @update:unscheduled-only=\"$emit('update:unscheduledOnly', $event)\"\n        @update:selected-priorities=\"$emit('update:selectedPriorities', $event)\"\n        @update:selected-projects=\"$emit('update:selectedProjects', $event)\"\n        @update:selected-durations=\"$emit('update:selectedDurations', $event)\"\n        @update:hide-done-tasks=\"$emit('toggleHideDoneTasks')\"\n        @update:sort-by=\"$emit('update:sortBy', $event)\"\n        @clear-all=\"$emit('clearAllFilters')\"\n      />\n    </Transition>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, nextTick } from 'vue'\nimport { ChevronLeft, ChevronRight, CalendarDays, Filter, ChevronDown, Search, X } from 'lucide-vue-next'\nimport { NBadge } from 'naive-ui'\nimport BaseBadge from '@/components/base/BaseBadge.vue'\nimport CustomSelect from '@/components/common/CustomSelect.vue'\nimport InboxFilters from '@/components/canvas/InboxFilters.vue'\nimport { type Task } from '@/stores/tasks'\nimport { type DurationCategory } from '@/utils/durationCategories'\nimport type { SortByType } from '@/composables/inbox/useUnifiedInboxState'\n\ndefineProps<{\n  isCollapsed: boolean\n  inboxCount: number\n  showTodayOnly: boolean\n  todayCount: number\n  hasActiveFilters: boolean\n  baseCount: number\n  canvasGroupOptions: any[]\n  selectedCanvasGroups: Set<string>\n  showAdvancedFilters: boolean\n  unscheduledOnly: boolean\n  selectedPriorities: Set<string>\n  selectedProjects: Set<string>\n  selectedDurations: Set<DurationCategory>\n  hideDoneTasks: boolean\n  baseTasks: Task[]\n  rootProjects: any[]\n  searchQuery: string // TASK-1075\n  sortBy?: SortByType // TASK-1303\n}>()\n\nconst emit = defineEmits<{\n  (e: 'update:isCollapsed', value: boolean): void\n  (e: 'update:showTodayOnly', value: boolean): void\n  (e: 'update:selectedCanvasGroups', value: Set<string>): void\n  (e: 'update:showAdvancedFilters', value: boolean): void\n  (e: 'update:unscheduledOnly', value: boolean): void\n  (e: 'update:selectedPriorities', value: Set<string>): void\n  (e: 'update:selectedProjects', value: Set<string>): void\n  (e: 'update:selectedDurations', value: Set<DurationCategory>): void\n  (e: 'update:searchQuery', value: string): void // TASK-1075\n  (e: 'update:sortBy', value: SortByType): void // TASK-1303\n  (e: 'toggleHideDoneTasks'): void\n  (e: 'clearAllFilters'): void\n}>()\n// TASK-1075: Search state\nconst isSearchExpanded = ref(false)\nconst searchInputRef = ref<HTMLInputElement | null>(null)\n\nconst toggleSearch = async () => {\n  isSearchExpanded.value = !isSearchExpanded.value\n  if (isSearchExpanded.value) {\n    await nextTick()\n    searchInputRef.value?.focus()\n  } else {\n    emit('update:searchQuery', '')\n  }\n}\n\nconst handleSearchInput = (event: Event) => {\n  const target = event.target as HTMLInputElement\n  emit('update:searchQuery', target.value)\n}\n\nconst clearSearch = () => {\n  emit('update:searchQuery', '')\n  searchInputRef.value?.focus()\n}\n\n</script>\n\n<style scoped>\n.inbox-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding-bottom: var(--space-3);\n  border-bottom: 1px solid var(--border-subtle);\n  min-width: 0;\n}\n\n.collapse-btn {\n  background: transparent;\n  border: 1px solid var(--border-medium);\n  color: var(--text-muted);\n  padding: var(--space-1);\n  cursor: pointer;\n  border-radius: var(--radius-md);\n  transition: all var(--duration-normal) var(--spring-smooth);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-shrink: 0;\n}\n\n.collapse-btn:hover {\n  background: var(--state-hover-bg);\n  color: var(--text-primary);\n}\n\n.inbox-title {\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  margin: 0;\n  flex: 1;\n  min-width: 0;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.today-quick-filter {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: var(--glass-bg-light);\n  backdrop-filter: blur(8px);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-full);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n  white-space: nowrap;\n  flex-shrink: 0;\n}\n\n.today-quick-filter:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.today-quick-filter.active {\n  background: var(--brand-bg-subtle);\n  border-color: var(--brand-border-subtle);\n  color: var(--brand-primary);\n}\n\n.today-quick-filter .count-badge {\n  background: var(--brand-primary);\n  color: white;\n  font-size: var(--text-xs);\n  padding: 0 var(--space-1);\n  border-radius: var(--radius-full);\n  min-width: 16px;\n  text-align: center;\n}\n\n.collapsed-badges-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-1);\n  margin-top: var(--space-2);\n}\n\n.dual-badges {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-1);\n}\n\n.toggle-filters-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  background: none;\n  border: none;\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  padding: var(--space-1) 0;\n  width: 100%;\n}\n\n.toggle-filters-btn:hover {\n  color: var(--text-primary);\n}\n\n.toggle-icon {\n  transition: transform var(--duration-normal);\n  margin-left: auto;\n}\n\n.toggle-icon.rotated {\n  transform: rotate(180deg);\n}\n\n/* TASK-1075: Search Styles */\n.search-toggle-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 28px;\n  height: 28px;\n  padding: var(--space-1);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n  background: transparent;\n  color: var(--text-tertiary);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n  flex-shrink: 0;\n}\n\n.search-toggle-btn:hover {\n  background: var(--surface-hover);\n  color: var(--text-secondary);\n  border-color: var(--border-hover);\n}\n\n.search-toggle-btn.active {\n  background: var(--brand-primary-subtle);\n  color: var(--brand-primary);\n  border-color: var(--brand-primary-dim);\n}\n\n.search-input-row {\n  padding: var(--space-2) 0;\n  border-bottom: 1px solid var(--border-light);\n}\n\n.search-input-wrapper {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-1_5) var(--space-2);\n  background: var(--surface-1);\n  border: 1px solid var(--border-color);\n  border-radius: var(--radius-md);\n  transition: all var(--duration-normal) var(--ease-out);\n}\n\n.search-input-wrapper:focus-within {\n  border-color: var(--brand-primary);\n  background: var(--surface-2);\n  box-shadow: 0 0 0 2px var(--brand-primary-subtle);\n}\n\n.search-icon {\n  color: var(--text-tertiary);\n  flex-shrink: 0;\n}\n\n.search-input {\n  flex: 1;\n  border: none;\n  background: transparent;\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  outline: none;\n  min-width: 0;\n}\n\n.search-input::placeholder {\n  color: var(--text-muted);\n}\n\n.clear-search-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 18px;\n  height: 18px;\n  padding: 0;\n  border: none;\n  border-radius: var(--radius-sm);\n  background: var(--surface-hover);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--ease-out);\n  flex-shrink: 0;\n}\n\n.clear-search-btn:hover {\n  background: var(--surface-active);\n  color: var(--text-primary);\n}\n\n/* Slide-down animation */\n.slide-down-enter-active,\n.slide-down-leave-active {\n  transition: all var(--duration-normal) var(--ease-out);\n  overflow: hidden;\n}\n\n.slide-down-enter-from,\n.slide-down-leave-to {\n  opacity: 0;\n  max-height: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\n.slide-down-enter-to,\n.slide-down-leave-from {\n  opacity: 1;\n  max-height: 60px;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/calendar/CalendarInboxInput.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/calendar/CalendarInboxList.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/calendar/CalendarTaskCard.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/unified/UnifiedInboxHeader.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":196,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6499,6502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6499,6502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"inbox-header\" :class=\"{ 'is-collapsed': isCollapsed }\">\n    <button \n      class=\"collapse-btn\" \n      :class=\"{ 'is-collapsed': isCollapsed }\" \n      :title=\"isCollapsed ? 'Expand Inbox' : 'Collapse Inbox'\" \n      @click=\"$emit('toggleCollapse')\"\n    >\n      <template v-if=\"context === 'canvas'\">\n        <ChevronRight v-if=\"!isCollapsed\" :size=\"16\" />\n        <ChevronLeft v-else :size=\"14\" />\n      </template>\n      <template v-else>\n        <ChevronLeft v-if=\"!isCollapsed\" :size=\"16\" />\n        <ChevronRight v-else :size=\"14\" />\n      </template>\n    </button>\n    <h3 v-if=\"!isCollapsed\" class=\"inbox-title\">\n      Inbox\n    </h3>\n\n    <!-- Count Badge -->\n    <NBadge v-if=\"!isCollapsed\" :value=\"taskCount\" type=\"info\" />\n\n    <!-- Done Tasks Filter - Shows ONLY done tasks when active -->\n    <button\n      v-if=\"!isCollapsed\"\n      key=\"done-toggle\"\n      class=\"done-toggle-btn\"\n      :class=\"{ active: !hideDoneTasks }\"\n      :title=\"hideDoneTasks ? `Show only done tasks (${doneTaskCount})` : 'Show active tasks'\"\n      @click=\"$emit('update:hide-done-tasks', !hideDoneTasks)\"\n    >\n      <CheckCircle2 :size=\"14\" />\n      <span class=\"done-count\">{{ doneTaskCount }}</span>\n    </button>\n\n    <!-- Time Filter Dropdown -->\n    <NDropdown\n      v-if=\"!isCollapsed\"\n      :options=\"timeFilterOptions\"\n      trigger=\"click\"\n      @select=\"handleTimeFilterSelect\"\n    >\n      <button class=\"time-filter-dropdown\" :class=\"{ active: activeTimeFilter !== 'all' }\">\n        <CalendarDays :size=\"14\" />\n        <span>{{ timeFilterLabel }}</span>\n        <ChevronDown :size=\"12\" />\n      </button>\n    </NDropdown>\n\n    <!-- TASK-1246: Group Filter Dropdown -->\n    <NPopover\n      v-if=\"!isCollapsed && showGroupChips\"\n      trigger=\"click\"\n      placement=\"bottom-start\"\n      :show-arrow=\"false\"\n      raw\n    >\n      <template #trigger>\n        <button\n          class=\"icon-filter-btn\"\n          :class=\"{ active: selectedCanvasGroups.size > 0 }\"\n          :title=\"groupFilterLabel\"\n        >\n          <Layers :size=\"14\" />\n          <span v-if=\"selectedCanvasGroups.size > 0\" class=\"filter-active-dot\" />\n        </button>\n      </template>\n      <div class=\"group-filter-chips\">\n        <button\n          v-for=\"group in groupOptions\"\n          :key=\"group.value\"\n          class=\"group-chip\"\n          :class=\"{ active: isChipActive(group) }\"\n          :style=\"getChipStyle(group)\"\n          :title=\"group.value === '' ? 'Show all tasks' : `Filter by ${group.label} (Ctrl+click for multi-select)`\"\n          @click=\"handleChipClick($event, group)\"\n        >\n          <span v-if=\"group.color\" class=\"chip-dot\" :style=\"{ backgroundColor: group.color }\" />\n          <span class=\"chip-label\">{{ group.label }}</span>\n          <span v-if=\"group.count !== undefined\" class=\"chip-count\">{{ group.count }}</span>\n        </button>\n      </div>\n    </NPopover>\n\n    <!-- TASK-1075: Search Toggle Button -->\n    <button\n      v-if=\"!isCollapsed\"\n      class=\"search-toggle-btn\"\n      :class=\"{ active: isSearchExpanded || searchQuery }\"\n      title=\"Search tasks\"\n      @click=\"toggleSearch\"\n    >\n      <Search :size=\"14\" />\n    </button>\n  </div>\n\n  <!-- TASK-1075: Search Input Row -->\n  <Transition name=\"slide-down\">\n    <div v-if=\"!isCollapsed && isSearchExpanded\" class=\"search-input-row\">\n      <div class=\"search-input-wrapper\">\n        <Search :size=\"14\" class=\"search-icon\" />\n        <input\n          ref=\"searchInputRef\"\n          type=\"text\"\n          class=\"search-input\"\n          :value=\"searchQuery\"\n          placeholder=\"Search tasks...\"\n          @input=\"handleSearchInput\"\n          @keydown.escape=\"toggleSearch\"\n        >\n        <button\n          v-if=\"searchQuery\"\n          class=\"clear-search-btn\"\n          title=\"Clear search\"\n          @click=\"clearSearch\"\n        >\n          <X :size=\"12\" />\n        </button>\n      </div>\n    </div>\n  </Transition>\n\n  <!-- Advanced Filters Toggle -->\n  <div v-if=\"!isCollapsed\" class=\"advanced-filters-section\">\n    <button\n      class=\"toggle-filters-btn\"\n      :class=\"{ active: showAdvancedFilters }\"\n      @click=\"$emit('toggleAdvancedFilters')\"\n    >\n      <Filter :size=\"14\" />\n      <span>{{ showAdvancedFilters ? 'Hide filters & sort' : 'Filters & Sort' }}</span>\n      <ChevronDown :size=\"14\" class=\"toggle-icon\" :class=\"{ rotated: showAdvancedFilters }\" />\n    </button>\n\n    <Transition name=\"slide-down\">\n      <InboxFilters\n        v-if=\"showAdvancedFilters\"\n        :context=\"context\"\n        :unscheduled-only=\"unscheduledOnly\"\n        :selected-priorities=\"selectedPriorities\"\n        :selected-projects=\"selectedProjects\"\n        :selected-durations=\"selectedDurations\"\n        :hide-done-tasks=\"hideDoneTasks\"\n        :sort-by=\"sortBy\"\n        :tasks=\"baseTasks\"\n        :projects=\"rootProjects\"\n        @update:unscheduled-only=\"$emit('update:unscheduled-only', $event)\"\n        @update:selected-priorities=\"$emit('update:selected-priorities', $event)\"\n        @update:selected-projects=\"$emit('update:selected-projects', $event)\"\n        @update:selected-durations=\"$emit('update:selected-durations', $event)\"\n        @update:hide-done-tasks=\"$emit('update:hide-done-tasks', $event)\"\n        @update:sort-by=\"$emit('update:sortBy', $event)\"\n        @clear-all=\"$emit('clearAll')\"\n      />\n    </Transition>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, ref, nextTick } from 'vue'\nimport { ChevronLeft, ChevronRight, CalendarDays, Filter, ChevronDown, CheckCircle2, Search, X, Layers } from 'lucide-vue-next'\nimport { NBadge, NDropdown, NPopover } from 'naive-ui'\nimport InboxFilters from '@/components/canvas/InboxFilters.vue'\nimport type { Task } from '@/types/tasks'\nimport type { DurationCategory } from '@/utils/durationCategories'\nimport type { TimeFilterType, SortByType } from '@/composables/inbox/useUnifiedInboxState'\n\ninterface GroupOption {\n  label: string\n  value: string\n  color?: string\n  count?: number\n}\n\nconst props = defineProps<{\n  isCollapsed: boolean\n  taskCount: number\n  activeTimeFilter: TimeFilterType\n  todayCount: number\n  next3DaysCount: number\n  weekCount: number\n  monthCount: number\n  showGroupChips: boolean\n  groupOptions: GroupOption[]\n  selectedCanvasGroups: Set<string>\n  showAdvancedFilters: boolean\n  unscheduledOnly: boolean\n  selectedPriorities: Set<string>\n  selectedProjects: Set<string>\n  selectedDurations: Set<DurationCategory>\n  hideDoneTasks: boolean\n  doneTaskCount: number\n  baseTasks: Task[]\n  rootProjects: any[]\n  context: string\n  sortBy: SortByType // TASK-1073\n  searchQuery: string // TASK-1075\n}>()\n\nconst emit = defineEmits<{\n  (e: 'toggleCollapse'): void\n  (e: 'update:activeTimeFilter', value: TimeFilterType): void\n  (e: 'toggleAdvancedFilters'): void\n  (e: 'update:selected-canvas-groups', groups: Set<string>): void\n  (e: 'update:unscheduled-only', value: boolean): void\n  (e: 'update:selected-priorities', value: Set<string>): void\n  (e: 'update:selected-projects', value: Set<string>): void\n  (e: 'update:selected-durations', value: Set<DurationCategory>): void\n  (e: 'update:hide-done-tasks', value: boolean): void\n  (e: 'update:sortBy', value: SortByType): void // TASK-1073\n  (e: 'update:searchQuery', value: string): void // TASK-1075\n  (e: 'clearAll'): void\n}>()\n// TASK-1075: Search state\nconst isSearchExpanded = ref(false)\nconst searchInputRef = ref<HTMLInputElement | null>(null)\n\nconst toggleSearch = async () => {\n  isSearchExpanded.value = !isSearchExpanded.value\n  if (isSearchExpanded.value) {\n    await nextTick()\n    searchInputRef.value?.focus()\n  } else {\n    emit('update:searchQuery', '')\n  }\n}\n\nconst handleSearchInput = (event: Event) => {\n  const target = event.target as HTMLInputElement\n  emit('update:searchQuery', target.value)\n}\n\nconst clearSearch = () => {\n  emit('update:searchQuery', '')\n  searchInputRef.value?.focus()\n}\n\n// TASK-1246: Group Filter Label\nconst groupFilterLabel = computed(() => {\n  if (props.selectedCanvasGroups.size === 0) return 'Groups'\n  if (props.selectedCanvasGroups.size === 1) {\n    const activeId = Array.from(props.selectedCanvasGroups)[0]\n    const group = props.groupOptions.find(g => g.value === activeId)\n    return group?.label || 'Groups'\n  }\n  return `${props.selectedCanvasGroups.size} Groups`\n})\n\n// Chip Logic\nconst isChipActive = (group: GroupOption) => {\n  return group.value === ''\n    ? props.selectedCanvasGroups.size === 0\n    : props.selectedCanvasGroups.has(group.value)\n}\n\nconst getChipStyle = (group: GroupOption) => {\n  if (!isChipActive(group) || !group.color) return {}\n  return {\n    '--chip-color': group.color,\n    backgroundColor: `${group.color}20`,\n    borderColor: group.color,\n    color: group.color\n  }\n}\n\nconst handleChipClick = (event: MouseEvent, group: GroupOption) => {\n  const currentSelection = new Set(props.selectedCanvasGroups)\n\n  // 1. \"All\" Chip\n  if (group.value === '') {\n    emit('update:selected-canvas-groups', new Set())\n    return\n  }\n\n  // 2. Multi-select (Ctrl/Cmd)\n  if (event.ctrlKey || event.metaKey) {\n    if (currentSelection.has(group.value)) {\n      currentSelection.delete(group.value)\n    } else {\n      currentSelection.add(group.value)\n    }\n    emit('update:selected-canvas-groups', currentSelection)\n    return\n  }\n\n  // 3. Single Select (Toggle)\n  if (currentSelection.size === 1 && currentSelection.has(group.value)) {\n    // Deselect if already active -> Go to \"All\"\n    emit('update:selected-canvas-groups', new Set())\n  } else {\n    emit('update:selected-canvas-groups', new Set([group.value]))\n  }\n}\n\n// Time Filter Dropdown Options\nconst timeFilterOptions = computed(() => [\n  { label: 'All', key: 'all' },\n  { label: `Today (${props.todayCount})`, key: 'today' },\n  { label: `Next 3 Days (${props.next3DaysCount})`, key: 'next3days' },\n  { label: `This Week (${props.weekCount})`, key: 'week' },\n  { label: `This Month (${props.monthCount})`, key: 'month' }\n])\n\nconst timeFilterLabel = computed(() => {\n  const labels: Record<TimeFilterType, string> = {\n    all: 'All',\n    today: 'Today',\n    next3days: '3 Days',\n    week: 'Week',\n    month: 'Month'\n  }\n  return labels[props.activeTimeFilter]\n})\n\nconst handleTimeFilterSelect = (key: string) => {\n  emit('update:activeTimeFilter', key as TimeFilterType)\n}\n</script>\n\n<style scoped>\n/* Inheriting styles from UnifiedInboxPanel to keep consistency */\n.inbox-header {\n  display: flex;\n  align-items: center;\n  padding: var(--space-2) var(--space-3);\n  border-bottom: 1px solid var(--glass-border);\n  background: transparent;\n  gap: var(--space-2);\n  height: 44px;\n  flex-shrink: 0;\n  /* BUG-1078: Fill parent width; flex children use flex-shrink: 0 to prevent squishing */\n  width: 100%;\n}\n\n/* BUG-1078: Prevent NBadge from shrinking */\n.inbox-header :deep(.n-badge) {\n  flex-shrink: 0;\n}\n\n.inbox-header.is-collapsed {\n  padding: var(--space-1);\n  justify-content: center;\n  height: auto;\n  min-height: 32px;\n  border-bottom: none;\n  width: 100%; /* BUG-1079: Take full width of collapsed container */\n}\n\n.inbox-title {\n  margin: 0;\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  flex: 0 0 auto; /* BUG-1078: Don't grow, don't shrink, use natural width */\n}\n\n.collapse-btn {\n  background: none;\n  border: 1px solid var(--border-subtle);\n  cursor: pointer;\n  color: var(--text-secondary);\n  padding: var(--space-1);\n  border-radius: var(--radius-sm);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 28px;\n  height: 28px;\n  flex-shrink: 0;\n}\n\n.collapse-btn.is-collapsed {\n  width: 24px;\n  height: 24px;\n  padding: var(--space-0_5);\n}\n\n.collapse-btn:hover {\n  background: var(--surface-hover);\n  color: var(--text-primary);\n}\n\n.time-filter-dropdown {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-md);\n  border: 1px solid transparent;\n  background: transparent;\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n  white-space: nowrap;\n  flex-shrink: 0;\n}\n\n.time-filter-dropdown:hover {\n  background: var(--surface-hover);\n  color: var(--text-primary);\n}\n\n.time-filter-dropdown.active {\n  background: var(--brand-primary-subtle);\n  color: var(--brand-primary);\n  border-color: var(--brand-primary-dim);\n  font-weight: var(--font-medium);\n}\n\n/* Icon-only filter button (Groups) */\n.icon-filter-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  width: 28px;\n  height: 28px;\n  padding: var(--space-1);\n  border-radius: var(--radius-md);\n  border: 1px solid transparent;\n  background: transparent;\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n  flex-shrink: 0;\n}\n\n.icon-filter-btn:hover {\n  background: var(--surface-hover);\n  color: var(--text-primary);\n}\n\n.icon-filter-btn.active {\n  background: var(--brand-primary-subtle);\n  color: var(--brand-primary);\n  border-color: var(--brand-primary-dim);\n}\n\n.filter-active-dot {\n  position: absolute;\n  top: 3px;\n  right: 3px;\n  width: 6px;\n  height: 6px;\n  border-radius: var(--radius-full);\n  background: var(--brand-primary);\n}\n\n/* TASK-1246: Filter Chips (now inside popover) */\n.group-filter-chips {\n  padding: var(--space-2);\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--space-2);\n  background: var(--surface-elevated);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n  max-width: 400px;\n  max-height: 300px;\n  overflow-y: auto;\n  box-shadow: var(--shadow-lg);\n}\n\n.group-chip {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-color);\n  background: var(--surface-1);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n}\n\n.group-chip:hover {\n  background: var(--surface-hover);\n  border-color: var(--border-hover);\n}\n\n.group-chip.active {\n  background: var(--brand-primary-subtle);\n  color: var(--brand-primary);\n  border-color: var(--brand-primary);\n}\n\n.chip-dot {\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n}\n\n.chip-count {\n  opacity: 0.6;\n  font-size: var(--text-xs);\n  padding-left: var(--space-1);\n  border-left: 1px solid currentColor;\n  margin-left: var(--space-1);\n}\n\n/* Advanced Filters Toggle */\n.advanced-filters-section {\n  border-bottom: 1px solid var(--border-light);\n  background: var(--surface-ground);\n}\n\n.toggle-filters-btn {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-2);\n  border: none;\n  background: transparent;\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.toggle-filters-btn:hover {\n  color: var(--text-primary);\n  background: var(--surface-hover);\n}\n\n.toggle-filters-btn.active {\n  color: var(--brand-primary);\n  background: var(--brand-primary-subtle);\n}\n\n.toggle-icon {\n  transition: transform var(--duration-normal) var(--ease-out);\n}\n\n.toggle-icon.rotated {\n  transform: rotate(180deg);\n}\n\n/* Done Tasks Toggle Button */\n/* Inactive state - subtle/muted (showing active tasks, hideDoneTasks=true) */\n.done-toggle-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n  background: transparent;\n  color: var(--text-tertiary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n  flex-shrink: 0;\n  min-width: 28px;\n  min-height: 28px;\n}\n\n.done-toggle-btn:hover {\n  background: var(--surface-hover);\n  color: var(--text-secondary);\n  border: 1px solid var(--border-hover);\n}\n\n/* Active state - green to indicate filtering for completed tasks */\n.done-toggle-btn.active {\n  border: 1px solid #22c55e;\n  background: rgba(34, 197, 94, 0.15);\n  color: #22c55e;\n}\n\n.done-toggle-btn.active:hover {\n  background: rgba(34, 197, 94, 0.25);\n}\n\n.done-count {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-width: 16px;\n  height: 16px;\n  padding: 0 var(--space-1);\n  border-radius: var(--radius-full);\n  background: var(--surface-elevated);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: 600;\n}\n\n.done-toggle-btn.active .done-count {\n  background: #22c55e;\n  color: white;\n}\n\n/* TASK-1075: Search Styles */\n.search-toggle-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 28px;\n  height: 28px;\n  padding: var(--space-1);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n  background: transparent;\n  color: var(--text-tertiary);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n  flex-shrink: 0;\n}\n\n.search-toggle-btn:hover {\n  background: var(--surface-hover);\n  color: var(--text-secondary);\n  border-color: var(--border-hover);\n}\n\n.search-toggle-btn.active {\n  background: var(--brand-primary-subtle);\n  color: var(--brand-primary);\n  border-color: var(--brand-primary-dim);\n}\n\n.search-input-row {\n  padding: var(--space-2) var(--space-3);\n  border-bottom: 1px solid var(--border-light);\n  background: var(--surface-ground);\n}\n\n.search-input-wrapper {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-1_5) var(--space-2);\n  background: var(--surface-1);\n  border: 1px solid var(--border-color);\n  border-radius: var(--radius-md);\n  transition: all var(--duration-normal) var(--ease-out);\n}\n\n.search-input-wrapper:focus-within {\n  border-color: var(--brand-primary);\n  background: var(--surface-2);\n  box-shadow: 0 0 0 2px var(--brand-primary-subtle);\n}\n\n.search-icon {\n  color: var(--text-tertiary);\n  flex-shrink: 0;\n}\n\n.search-input {\n  flex: 1;\n  border: none;\n  background: transparent;\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  outline: none;\n  min-width: 0;\n}\n\n.search-input::placeholder {\n  color: var(--text-muted);\n}\n\n.clear-search-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 18px;\n  height: 18px;\n  padding: 0;\n  border: none;\n  border-radius: var(--radius-sm);\n  background: var(--surface-hover);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--ease-out);\n  flex-shrink: 0;\n}\n\n.clear-search-btn:hover {\n  background: var(--surface-active);\n  color: var(--text-primary);\n}\n\n/* Slide-down animation */\n.slide-down-enter-active,\n.slide-down-leave-active {\n  transition: all var(--duration-normal) var(--ease-out);\n  overflow: hidden;\n}\n\n.slide-down-enter-from,\n.slide-down-leave-to {\n  opacity: 0;\n  max-height: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\n.slide-down-enter-to,\n.slide-down-leave-from {\n  opacity: 1;\n  max-height: 60px;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/unified/UnifiedInboxInput.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":99,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":99,"endColumn":30,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"watch"},"fix":{"range":[3039,3046],"text":""},"desc":"Remove unused variable \"watch\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"quick-add\">\n    <div class=\"quick-add-row\">\n      <input\n        v-model=\"newTaskTitle\"\n        :dir=\"quickAddDirection\"\n        :placeholder=\"isListening ? 'Listening...' : (isProcessingVoice ? 'Processing...' : 'Quick add task (Enter)...')\"\n        class=\"quick-add-input\"\n        :class=\"[{ 'voice-active': isListening || isProcessingVoice }]\"\n        @keydown.enter=\"handleAddTask\"\n      >\n\n      <!-- Mic button (TASK-1024) -->\n      <button\n        v-if=\"isVoiceSupported\"\n        class=\"mic-btn\"\n        :class=\"[{ recording: isListening, processing: isProcessingVoice }]\"\n        :title=\"isListening ? 'Stop recording' : (isProcessingVoice ? 'Processing...' : 'Voice input')\"\n        :disabled=\"isProcessingVoice\"\n        @click=\"toggleVoiceInput\"\n      >\n        <Loader2 v-if=\"isProcessingVoice\" :size=\"18\" class=\"spin\" />\n        <Mic v-else-if=\"!isListening\" :size=\"18\" />\n        <MicOff v-else :size=\"18\" />\n      </button>\n    </div>\n\n    <!-- Voice feedback (when recording) -->\n    <div v-if=\"isListening || isProcessingVoice\" class=\"voice-feedback\">\n      <div class=\"voice-waveform\">\n        <span class=\"wave-bar\" />\n        <span class=\"wave-bar\" />\n        <span class=\"wave-bar\" />\n        <span class=\"wave-bar\" />\n        <span class=\"wave-bar\" />\n      </div>\n      <span class=\"voice-status\">\n        {{ isProcessingVoice ? 'Processing audio...' : (displayTranscript || 'Speak now...') }}\n      </span>\n      <button class=\"voice-cancel\" @click=\"cancelVoice\">\n        <X :size=\"14\" />\n      </button>\n    </div>\n\n    <!-- Voice error message -->\n    <div v-if=\"voiceError && !isListening && !isProcessingVoice\" class=\"voice-error\">\n      {{ voiceError }}\n    </div>\n\n    <!-- Voice Task Confirmation (TASK-1028) with Re-record support (TASK-1110) -->\n    <VoiceTaskConfirmation\n      :is-open=\"showVoiceConfirmation\"\n      :parsed-task=\"parsedVoiceTask\"\n      :is-recording=\"isListening\"\n      :is-processing=\"isProcessingVoice\"\n      :can-re-record=\"isVoiceSupported\"\n      @confirm=\"handleVoiceTaskConfirm\"\n      @cancel=\"handleVoiceTaskCancel\"\n      @re-record=\"handleVoiceReRecord\"\n    />\n  </div>\n\n  <!-- Brain Dump Mode -->\n  <div v-if=\"showBrainDump\" class=\"brain-dump-section\">\n    <NButton\n      secondary\n      block\n      size=\"small\"\n      class=\"brain-dump-toggle\"\n      @click=\"brainDumpMode = !brainDumpMode\"\n    >\n      {{ brainDumpMode ? 'Quick Add Mode' : 'Brain Dump Mode' }}\n    </NButton>\n\n    <div v-if=\"brainDumpMode\" class=\"brain-dump-container\">\n      <textarea\n        v-model=\"brainDumpText\"\n        placeholder=\"Paste or type tasks (one per line):\nWrite proposal !!!\nReview code 2h\nCall client\"\n        :dir=\"textDirection\"\n        class=\"brain-dump-textarea\"\n        rows=\"5\"\n      />\n      <NButton\n        type=\"primary\"\n        block\n        :disabled=\"parsedTaskCount === 0\"\n        @click=\"processBrainDump\"\n      >\n        Add {{ parsedTaskCount }} Tasks\n      </NButton>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch } from 'vue'\nimport { NButton } from 'naive-ui'\nimport { Mic, MicOff, X, Loader2 } from 'lucide-vue-next'\nimport { useBrainDump } from '@/composables/useBrainDump'\nimport { useWhisperSpeech } from '@/composables/useWhisperSpeech'\nimport { useVoiceTaskParser, type ParsedVoiceTask } from '@/composables/useVoiceTaskParser'\nimport VoiceTaskConfirmation from '@/mobile/components/VoiceTaskConfirmation.vue'\n\ndefineProps<{\n  showBrainDump: boolean\n}>()\n\nconst emit = defineEmits<{\n  (e: 'addTask', title: string, options?: { priority?: string; dueDate?: Date }): void\n}>()\n\nconst newTaskTitle = ref('')\nconst { parseTranscript } = useVoiceTaskParser()\n\n// Voice confirmation state (TASK-1028)\nconst parsedVoiceTask = ref<ParsedVoiceTask | null>(null)\nconst showVoiceConfirmation = ref(false)\n\n// TASK-1322: Whisper-only voice input (browser speech recognition removed)\nconst {\n  isRecording: isWhisperRecording,\n  isProcessing: isWhisperProcessing,\n  isSupported: isWhisperSupported,\n  hasApiKey: hasWhisperApiKey,\n  transcript: whisperTranscript,\n  error: whisperError,\n  start: startWhisper,\n  stop: stopWhisper,\n  cancel: cancelWhisper\n} = useWhisperSpeech({\n  onResult: (result) => {\n    console.log('[Whisper] Result:', result)\n    if (result.transcript.trim()) {\n      // Auto-detect language from Whisper response\n      const lang = result.language === 'he' ? 'he-IL' : 'en-US'\n      const parsed = parseTranscript(result.transcript.trim(), lang)\n      parsedVoiceTask.value = parsed\n      showVoiceConfirmation.value = true\n    }\n  },\n  onError: (err) => {\n    console.warn('[Whisper] Error:', err)\n  }\n})\n\n// Voice state\nconst isListening = computed(() => isWhisperRecording.value)\nconst isProcessingVoice = computed(() => isWhisperProcessing.value)\nconst isVoiceSupported = computed(() => isWhisperSupported.value && hasWhisperApiKey.value)\nconst displayTranscript = computed(() => whisperTranscript.value)\nconst voiceError = computed(() => whisperError.value)\n\n// Toggle voice recording\nconst toggleVoiceInput = async () => {\n  if (isListening.value) {\n    stopWhisper()\n  } else {\n    parsedVoiceTask.value = null\n    showVoiceConfirmation.value = false\n    await startWhisper()\n  }\n}\n\n// Cancel voice recording\nconst cancelVoice = () => {\n  cancelWhisper()\n  resetVoiceState()\n}\n\n// Voice task confirmation handlers (TASK-1028)\nconst handleVoiceTaskConfirm = (task: { title: string; priority: 'high' | 'medium' | 'low' | null; dueDate: Date | null }) => {\n  emit('addTask', task.title, {\n    ...(task.priority && { priority: task.priority }),\n    ...(task.dueDate && { dueDate: task.dueDate })\n  })\n  resetVoiceState()\n}\n\nconst handleVoiceTaskCancel = () => {\n  resetVoiceState()\n}\n\n// TASK-1110: Handle re-record request from confirmation modal\nconst handleVoiceReRecord = async () => {\n  // If already recording, stop it\n  if (isListening.value) {\n    stopWhisper()\n    return\n  }\n\n  // Start new recording (keep modal open, will update parsedVoiceTask on result)\n  await startWhisper()\n}\n\nconst resetVoiceState = () => {\n  parsedVoiceTask.value = null\n  showVoiceConfirmation.value = false\n}\n\nconst {\n  brainDumpMode,\n  brainDumpText,\n  textDirection,\n  parsedTaskCount,\n  processBrainDump\n} = useBrainDump()\n\nconst quickAddDirection = computed(() => {\n  if (!newTaskTitle.value.trim()) return 'ltr'\n  const firstChar = newTaskTitle.value.trim()[0]\n  const rtlRegex = /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/\n  return rtlRegex.test(firstChar) ? 'rtl' : 'ltr'\n})\n\nconst handleAddTask = () => {\n  if (!newTaskTitle.value.trim()) return\n  emit('addTask', newTaskTitle.value)\n  newTaskTitle.value = ''\n}\n</script>\n\n<style scoped>\n.quick-add {\n  padding: var(--space-3) var(--space-4);\n  border-bottom: 1px solid var(--glass-border);\n  background: transparent;\n}\n\n.quick-add-row {\n  display: flex;\n  gap: var(--space-2);\n  align-items: center;\n}\n\n.quick-add-input {\n  flex: 1;\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--glass-border);\n  background: var(--glass-bg-soft);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  transition: all var(--duration-normal);\n}\n\n.quick-add-input:focus {\n  outline: none;\n  border-color: var(--brand-primary);\n  box-shadow: 0 0 0 2px var(--brand-primary-subtle);\n}\n\n.quick-add-input.voice-active {\n  border-color: var(--danger-text, #ef4444);\n  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);\n}\n\n/* Mic Button (TASK-1024) */\n.mic-btn {\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n  border: none;\n  background: var(--glass-bg-soft);\n  color: var(--text-secondary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n  transition: all 0.2s ease;\n}\n\n.mic-btn:hover:not(:disabled) {\n  background: var(--glass-bg);\n  color: var(--text-primary);\n}\n\n.mic-btn:active:not(:disabled) {\n  transform: scale(0.95);\n}\n\n.mic-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.mic-btn.recording {\n  background: var(--danger-text, #ef4444);\n  color: white;\n  animation: pulse-recording 1.5s ease-in-out infinite;\n}\n\n.mic-btn.processing {\n  background: var(--brand-primary, #3b82f6);\n  color: white;\n}\n\n.spin {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n@keyframes pulse-recording {\n  0%, 100% {\n    box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);\n  }\n  50% {\n    box-shadow: 0 0 0 8px rgba(239, 68, 68, 0);\n  }\n}\n\n/* Voice feedback panel */\n.voice-feedback {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-2) var(--space-3);\n  margin-top: var(--space-2);\n  background: var(--glass-bg-soft);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--glass-border);\n}\n\n.voice-waveform {\n  display: flex;\n  align-items: center;\n  gap: 2px;\n  height: 20px;\n}\n\n.wave-bar {\n  width: 3px;\n  height: 6px;\n  background: var(--danger-text, #ef4444);\n  border-radius: 2px;\n  animation: wave 0.8s ease-in-out infinite;\n}\n\n.wave-bar:nth-child(1) { animation-delay: 0s; }\n.wave-bar:nth-child(2) { animation-delay: 0.1s; }\n.wave-bar:nth-child(3) { animation-delay: 0.3s; }\n.wave-bar:nth-child(4) { animation-delay: 0.3s; }\n.wave-bar:nth-child(5) { animation-delay: 0.4s; }\n\n@keyframes wave {\n  0%, 100% { height: 6px; }\n  50% { height: 16px; }\n}\n\n.voice-status {\n  flex: 1;\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.voice-cancel {\n  width: 24px;\n  height: 24px;\n  border-radius: 50%;\n  border: none;\n  background: transparent;\n  color: var(--text-tertiary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.voice-cancel:hover {\n  background: var(--glass-bg);\n  color: var(--danger-text, #ef4444);\n}\n\n/* Voice error message */\n.voice-error {\n  margin-top: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(239, 68, 68, 0.1);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: var(--danger-text, #ef4444);\n}\n\n.brain-dump-section {\n  padding: var(--space-3) var(--space-4);\n  border-bottom: 1px solid var(--glass-border);\n  background: transparent;\n}\n\n.brain-dump-container {\n  margin-top: var(--space-3);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.brain-dump-textarea {\n  width: 100%;\n  padding: var(--space-2);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--glass-border);\n  background: var(--glass-bg-soft);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  resize: vertical;\n  min-height: 100px;\n}\n\n.brain-dump-textarea:focus {\n  outline: none;\n  border-color: var(--brand-primary);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/unified/UnifiedInboxList.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/inbox/unified/UnifiedInboxTaskCard.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/kanban/KanbanColumn.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5123,5126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5123,5126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5365,5368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5365,5368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5521,5524],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5521,5524],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"kanban-column\" :class=\"wipStatusClass\">\n    <div class=\"column-header\">\n      <div class=\"header-left\">\n        <span\n          v-if=\"priorityColor\"\n          class=\"column-priority-dot\"\n          :style=\"{ background: priorityColor }\"\n        />\n        <span class=\"column-title\">{{ title }}</span>\n        <span class=\"task-count\">{{ taskCount }}</span>\n      </div>\n      <button class=\"add-task-btn\" @click=\"$emit('addTask', status)\">\n        <Plus :size=\"12\" />\n      </button>\n    </div>\n\n    <div class=\"tasks-container\">\n      <draggable\n        v-model=\"localTasks\"\n        :group=\"dragGroup\"\n        item-key=\"id\"\n        class=\"drag-area\"\n        :animation=\"200\"\n        ghost-class=\"ghost-card\"\n        chosen-class=\"chosen-card\"\n        drag-class=\"drag-card\"\n        force-fallback\n        fallback-class=\"sortable-fallback\"\n        :fallback-tolerance=\"3\"\n        :scroll-sensitivity=\"100\"\n        :scroll-speed=\"20\"\n        bubble-scroll\n        :delay=\"100\"\n        delay-on-touch-only\n        :touch-start-threshold=\"5\"\n        :disabled=\"false\"\n        easing=\"cubic-bezier(0.25, 0.46, 0.45, 0.94)\"\n        tag=\"div\"\n        @start=\"onDragStart\"\n        @end=\"onDragEnd\"\n        @change=\"handleDragChange\"\n      >\n        <template #item=\"{ element: task }\">\n          <TaskCard\n            :key=\"task.id\"\n            :task=\"task\"\n            class=\"task-item\"\n            @select=\"$emit('selectTask', $event)\"\n            @start-timer=\"$emit('startTimer', $event)\"\n            @edit=\"$emit('editTask', $event)\"\n            @delete=\"$emit('deleteTask', $event)\"\n            @context-menu=\"(event, task) => $emit('contextMenu', event, task)\"\n          />\n        </template>\n\n        <template #footer>\n          <div v-if=\"tasks.length === 0\" class=\"empty-column\">\n            <span class=\"empty-message\">No {{ title.toLowerCase() }} tasks</span>\n            <button class=\"add-first-task\" @click=\"$emit('addTask', status)\">\n              <Plus :size=\"16\" />\n              Add {{ title.toLowerCase() }} task\n            </button>\n          </div>\n        </template>\n      </draggable>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, nextTick } from 'vue'\nimport draggable from 'vuedraggable'\nimport TaskCard from './TaskCard.vue'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { Plus } from 'lucide-vue-next'\n\nimport './KanbanColumn.css'\n\ninterface Props {\n  title: string\n  status: Task['status']\n  tasks: Task[]\n  wipLimit?: number\n  columnType?: 'status' | 'priority' | 'date'\n  swimlaneId?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  wipLimit: 10,\n  columnType: 'status',\n  swimlaneId: 'default'\n})\n\ndefineEmits<{\n  addTask: [status: Task['status']]\n  selectTask: [taskId: string]\n  startTimer: [taskId: string]\n  editTask: [taskId: string]\n  deleteTask: [taskId: string]\n  contextMenu: [event: MouseEvent, task: Task]\n}>()\n\n// BUG-1193: Track drag state to prevent reactive overwrites during drag\nconst isDragActive = ref(false)\n\nconst localTasks = ref([...props.tasks])\nwatch(() => props.tasks, (newTasks) => {\n  // BUG-1193: Don't overwrite localTasks during active drag operation\n  // vuedraggable manages the array during drag - reactive updates cause desync\n  // where the wrong task element gets associated with the drag ghost\n  if (!isDragActive.value) {\n    localTasks.value = [...newTasks]\n  }\n})\n\n// BUG-1193: Scope drag group per swimlane to prevent cross-project drag confusion\n// Without this, all columns across all swimlanes share group=\"tasks\" and\n// vuedraggable can move tasks between unrelated projects\nconst dragGroup = computed(() => ({\n  name: `tasks-${props.swimlaneId}`,\n  pull: true,\n  put: true\n}))\n\nconst onDragStart = () => {\n  isDragActive.value = true\n}\n\nconst onDragEnd = () => {\n  isDragActive.value = false\n  // Sync localTasks with store state after drag completes\n  nextTick(() => {\n    localTasks.value = [...props.tasks]\n  })\n}\n\nconst taskCount = computed(() => props.tasks.length)\n\n// Priority column color indicator\nconst priorityColor = computed(() => {\n  const priorityColors: Record<string, string> = {\n    'high': 'var(--color-priority-high, #ef4444)',\n    'medium': 'var(--color-priority-medium, #f59e0b)',\n    'low': 'var(--color-priority-low, #3b82f6)',\n    'no_priority': 'rgba(255, 255, 255, 0.2)'\n  }\n  return priorityColors[props.status] || null\n})\n\nconst wipStatusClass = computed(() => {\n  if (!props.wipLimit) return ''\n  const count = taskCount.value\n  const limit = props.wipLimit\n  if (count >= limit) return 'wip-exceeded'\n  if (count >= Math.floor(limit * 0.8)) return 'wip-warning'\n  return ''\n})\n\nconst taskStore = useTaskStore()\n\n/**\n * Recalculate order values for all tasks in localTasks based on their current array position.\n * Uses simple integer indexing (0, 1, 2, ...) and persists via updateTask.\n */\nconst persistOrderForColumn = () => {\n  localTasks.value.forEach((task, index) => {\n    if (task.order !== index) {\n      taskStore.updateTask(task.id, { order: index })\n    }\n  })\n}\n\nconst handleDragChange = async (event: any) => {\n  if (event.added) {\n    try {\n      const taskId = event.added.element.id\n\n      if (props.columnType === 'priority') {\n        // Priority columns: update task priority\n        taskStore.moveTaskToPriority(taskId, props.status as any)\n      } else if (props.columnType === 'date') {\n        // Date columns: update task due date\n        taskStore.moveTaskToDate(taskId, props.status as any)\n      } else {\n        // Status columns (default): update task status\n        await taskStore.moveTaskWithUndo(taskId, props.status)\n      }\n\n      // Persist order for all tasks in this column after cross-column move\n      persistOrderForColumn()\n    } catch (error) {\n      console.error('Failed to move task:', error)\n      window.dispatchEvent(new CustomEvent('flowstate:error', {\n        detail: { message: 'Failed to move task. Please try again.' }\n      }))\n    }\n  }\n\n  if (event.moved) {\n    // Within-column reorder: persist new order values\n    persistOrderForColumn()\n  }\n}\n</script>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/kanban/KanbanSwimlane.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/kanban/TaskCard.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3694,3697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3694,3697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <article\n    ref=\"cardRef\"\n    class=\"task-card\"\n    :class=\"[\n      { 'collapsed': progressiveDisclosureEnabled && !isExpanded },\n      { 'completed': task.status === 'done' },\n      { 'focused': isFocused },\n      { 'selected': isSelected },\n      { 'timer-active': isTimerActive },\n      { 'is-flashing': isFlashing },\n      density ? `task-card--${density}` : ''\n    ]\"\n    :tabindex=\"disabled ? -1 : 0\"\n    role=\"button\"\n    :aria-label=\"taskAriaLabel\"\n    :aria-describedby=\"`task-meta-${task.id}`\"\n    :aria-pressed=\"isPressed\"\n    :aria-expanded=\"progressiveDisclosureEnabled ? isExpanded : undefined\"\n    :aria-disabled=\"disabled\"\n    data-draggable=\"true\"\n    :data-status=\"task.status\"\n    :data-priority=\"task.priority || 'none'\"\n    @click=\"handleCardClick\"\n    @keydown=\"handleKeydown\"\n    @contextmenu.prevent=\"handleRightClick\"\n    @focus=\"handleFocus\"\n    @blur=\"handleBlur\"\n  >\n    <!-- Status icon and title row -->\n    <div class=\"card-header\" :dir=\"isRtl ? 'rtl' : undefined\">\n      <!-- Priority Dot -->\n      <TaskCardStatus\n        :priority=\"task.priority\"\n        :status=\"task.status\"\n        @cycle=\"cycleStatus\"\n      />\n\n      <!-- Title and metadata in flex layout -->\n      <div class=\"title-section\">\n        <h3\n          :id=\"`task-title-${task.id}`\"\n          class=\"task-title\"\n          :class=\"[titleAlignmentClasses, { 'completed-title': task.status === 'done' }]\"\n          :dir=\"isRtl ? 'rtl' : 'ltr'\"\n        >\n          {{ truncateUrlsInText(task.title) }}\n        </h3>\n\n        <!-- Metadata Badges -->\n        <TaskCardBadges\n          v-if=\"!progressiveDisclosureEnabled || isExpanded\"\n          v-bind=\"{\n            task,\n            density,\n            formattedDueDate,\n            formattedDuration,\n            completedSubtasks,\n            hasDependencies,\n            durationBadgeClass,\n            projectVisual\n          }\"\n        />\n      </div>\n\n      <!-- Action Buttons -->\n      <TaskCardActions\n        @focus-mode=\"enterFocusMode\"\n        @start-timer=\"$emit('startTimer', task.id)\"\n        @edit=\"$emit('edit', task.id)\"\n      />\n    </div>\n\n    <!-- Progressive Disclosure Content (only when expanded) -->\n    <Transition name=\"expand\">\n      <div v-show=\"!progressiveDisclosureEnabled || isExpanded\" class=\"card-details\">\n        <!-- No additional details needed currently -->\n      </div>\n    </Transition>\n  </article>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, ref, onMounted, onUnmounted } from 'vue'\nimport { useRouter } from 'vue-router'\nimport type { Task } from '@/stores/tasks'\nimport { useTaskCardState } from '@/composables/tasks/card/useTaskCardState'\nimport { useTaskCardActions } from '@/composables/tasks/card/useTaskCardActions'\nimport { useTimerStore } from '@/stores/timer'\nimport { truncateUrlsInText } from '@/utils/urlTruncate'\n\n// Sub-components\nimport TaskCardStatus from './card/TaskCardStatus.vue'\nimport TaskCardBadges from './card/TaskCardBadges.vue'\nimport TaskCardActions from './card/TaskCardActions.vue'\n\nimport './TaskCard.css'\n\ninterface Props {\n  task: Task\n  density?: 'ultrathin' | 'compact' | 'comfortable' | 'spacious'\n  disabled?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  density: 'comfortable',\n  disabled: false\n})\n\nconst emit = defineEmits<{\n  select: [taskId: string]\n  startTimer: [taskId: string]\n  edit: [taskId: string]\n  delete: [taskId: string]\n  contextMenu: [event: MouseEvent, task: Task]\n  focus: [event: FocusEvent]\n  blur: [event: FocusEvent]\n}>()\n\n// --- Logic ---\nconst router = useRouter()\nconst timerStore = useTimerStore()\nconst state = useTaskCardState(props)\nconst actions = useTaskCardActions(props, emit as any, state)\n\n// Timer active state\nconst isTimerActive = computed(() => {\n  return timerStore.isTimerActive && timerStore.currentTaskId === props.task.id\n})\n\nconst {\n  isExpanded, isFocused, isPressed, cardRef,\n  isSelected, hasDependencies, completedSubtasks,\n  formattedDueDate, formattedDuration, durationBadgeClass,\n  titleAlignmentClasses, isRtl, projectVisual, taskAriaLabel,\n  progressiveDisclosureEnabled\n} = state\n\nconst {\n  handleCardClick, handleKeydown, handleFocus,\n  handleBlur, handleRightClick, cycleStatus\n} = actions\n\n// Focus mode navigation\nconst enterFocusMode = () => {\n  router.push(`/focus/${props.task.id}`)\n}\n\n// TASK-1074: Flash animation when date is set via context menu\nconst isFlashing = ref(false)\nconst handleTaskFlash = (event: Event) => {\n  const customEvent = event as CustomEvent<{ taskId: string }>\n  if (customEvent.detail.taskId === props.task?.id) {\n    isFlashing.value = true\n    setTimeout(() => { isFlashing.value = false }, 600)\n  }\n}\nonMounted(() => {\n  window.addEventListener('task-action-flash', handleTaskFlash)\n})\nonUnmounted(() => {\n  window.removeEventListener('task-action-flash', handleTaskFlash)\n})\n</script>\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/kanban/card/TaskCardActions.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/kanban/card/TaskCardBadges.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1523,1526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1523,1526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    class=\"task-card-badges\"\n    role=\"group\"\n    aria-label=\"Task metadata\"\n  >\n    <!-- Due Date -->\n    <span\n      v-if=\"task.dueDate\"\n      class=\"meta-badge\"\n      :class=\"dueDateClass\"\n      :title=\"`Due: ${formattedDueDate}`\"\n    >\n      {{ formattedDueDate }}\n    </span>\n\n    <!-- Dot separator -->\n    <span v-if=\"task.dueDate && task.subtasks?.length\" class=\"badge-separator\">·</span>\n\n    <!-- Subtasks -->\n    <span\n      v-if=\"task.subtasks?.length\"\n      class=\"meta-badge\"\n      :title=\"`Subtasks: ${completedSubtasks}/${task.subtasks.length}`\"\n    >\n      {{ completedSubtasks }}/{{ task.subtasks.length }}\n    </span>\n\n    <!-- Dot separator for pomodoros -->\n    <span v-if=\"(task.dueDate || task.subtasks?.length) && task.completedPomodoros > 0\" class=\"badge-separator\">·</span>\n\n    <!-- Pomodoros (if any) -->\n    <span\n      v-if=\"task.completedPomodoros > 0\"\n      class=\"meta-badge pomodoro-badge\"\n      :title=\"`Pomodoro sessions: ${task.completedPomodoros}`\"\n    >\n      {{ task.completedPomodoros }}\n    </span>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { reactiveToday, ensureDateTimer } from '@/composables/useReactiveDate'\n\nconst props = defineProps<{\n  task: Task\n  density?: 'ultrathin' | 'compact' | 'comfortable' | 'spacious'\n  formattedDueDate: string\n  formattedDuration: string\n  completedSubtasks: number\n  hasDependencies?: boolean\n  durationBadgeClass: string\n  projectVisual: any\n}>()\n\n// BUG-1191: Ensure date timer is running for reactive overdue detection\nensureDateTimer()\n\n// BUG-1191: Highlight overdue or today's tasks (reactive to date changes)\nconst dueDateClass = computed(() => {\n  if (!props.task.dueDate) return ''\n  // BUG-1191: Reactive dependency - ensures re-evaluation at midnight\n  const _todayTrigger = reactiveToday.value\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  const due = new Date(props.task.dueDate)\n  due.setHours(0, 0, 0, 0)\n\n  if (due < today) return 'due-overdue'\n  if (due.getTime() === today.getTime()) return 'due-today'\n  return ''\n})\n</script>\n\n<style scoped>\n.task-card-badges {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--space-1);\n  align-items: center;\n  justify-content: flex-start;\n  min-height: 18px;\n  margin-top: var(--space-1);\n}\n\n/* Base Badge - Clean, minimal text style */\n.meta-badge {\n  display: inline-flex;\n  align-items: center;\n  font-size: var(--text-meta);\n  font-weight: 400;\n  color: var(--text-tertiary);\n  white-space: nowrap;\n}\n\n/* Dot separator between badges */\n.badge-separator {\n  color: var(--text-subtle);\n  font-size: var(--text-meta);\n  margin: 0 var(--space-1);\n  user-select: none;\n}\n\n/* Due date highlighting */\n.due-today {\n  color: var(--color-work, #22c55e);\n  font-weight: 500;\n}\n\n.due-overdue {\n  color: var(--color-priority-high, #ef4444);\n  font-weight: 500;\n}\n\n/* Pomodoro badge - subtle tomato indicator */\n.pomodoro-badge {\n  color: rgba(239, 68, 68, 0.6);\n}\n\n.pomodoro-badge::before {\n  content: '';\n  display: inline-block;\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  background: currentColor;\n  margin-inline-end: 4px;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/kanban/card/TaskCardStatus.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/layout/CategorySelector.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/layout/CommandPalette.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/layout/KeyboardShortcutsPanel.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/layout/SearchModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/layout/SettingsModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/layout/SidebarSmartItem.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2348,2351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2348,2351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4170,4173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4170,4173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4193,4196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4193,4196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    class=\"sidebar-smart-item\"\n    :class=\"[\n      `color-${color}`,\n      {\n        'is-active': active,\n        'is-compact': compact,\n        'is-drag-target': isDragTarget,\n        'is-drag-valid': isDragValid,\n        'is-drag-invalid': isDragTarget && !isDragValid && isDragging,\n        'is-empty': count === 0\n      }\n    ]\"\n    @click=\"$emit('click', $event)\"\n    @dragenter=\"handleDragEnter\"\n    @dragover=\"handleDragOver\"\n    @dragleave=\"handleDragLeave\"\n    @drop=\"handleDrop\"\n  >\n    <!-- Icon slot -->\n    <div v-if=\"$slots.icon\" class=\"item-icon\">\n      <slot name=\"icon\" />\n    </div>\n\n    <!-- Label -->\n    <span class=\"item-label\">\n      <slot />\n    </span>\n\n    <!-- Count badge -->\n    <BaseBadge\n      v-if=\"count !== undefined\"\n      variant=\"count\"\n      size=\"sm\"\n      rounded\n      class=\"item-badge\"\n    >\n      {{ count }}\n    </BaseBadge>\n\n    <!-- Drop target indicator -->\n    <div v-if=\"isDragTarget && isDragValid\" class=\"drop-indicator\">\n      <component :is=\"dropIcon\" :size=\"14\" />\n      <span>{{ dropLabel }}</span>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue'\nimport { Calendar, Clock } from 'lucide-vue-next'\nimport BaseBadge from '@/components/base/BaseBadge.vue'\nimport { useDragAndDrop } from '@/composables/useDragAndDrop'\nimport { useTaskStore } from '@/stores/tasks'\n\ninterface Props {\n  active?: boolean\n  count?: number\n  compact?: boolean\n  color?: 'azure' | 'azure-dark' | 'blue' | 'orange' | 'teal' | 'green' | 'purple' | 'gray'\n  dropType?: 'date' | 'duration' | 'none'\n  dropValue?: string | number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  active: false,\n  count: undefined,\n  compact: false,\n  color: 'teal',\n  dropType: 'none',\n  dropValue: undefined\n})\n\nconst _emit = defineEmits<{\n  click: [event: MouseEvent]\n}>()\n\nconst { isDragging, dragData, isValidDrop, setDropTarget, startDrag: _startDrag, endDrag: _endDrag } = useDragAndDrop()\nconst taskStore = useTaskStore()\n\nconst isDragTarget = ref(false)\n\nconst isDragValid = computed(() => {\n  if (!dragData.value) return false\n\n  // Only accept task drops\n  if (dragData.value.type === 'task' && dragData.value.taskId) {\n    const targetType = props.dropType === 'date' ? 'date-target' : 'duration-target'\n    return isValidDrop(dragData.value, targetType as any)\n  }\n\n  return false\n})\n\nconst dropIcon = computed(() => props.dropType === 'date' ? Calendar : Clock)\n\nconst dropLabel = computed(() => {\n  if (props.dropType === 'date') {\n    switch (props.dropValue) {\n      case 'today': return 'Set for Today'\n      case 'tomorrow': return 'Set for Tomorrow'\n      case 'weekend': return 'Set for Weekend'\n      case 'nodate': return 'Clear Date'\n      default: return 'Schedule'\n    }\n  } else if (props.dropType === 'duration') {\n    switch (props.dropValue) {\n      case 15: return 'Set 15 min'\n      case 30: return 'Set 30 min'\n      case 60: return 'Set 1 hour'\n      case 120: return 'Set 2 hours'\n      case -1: return 'Clear Estimate'\n      default: return 'Set Duration'\n    }\n  }\n  return 'Drop here'\n})\n\nconst handleDragEnter = (event: DragEvent) => {\n  event.preventDefault()\n  isDragTarget.value = true\n  const dropId = props.dropType === 'date' ? props.dropValue : `duration-${props.dropValue}`\n  setDropTarget(dropId as string)\n}\n\nconst handleDragOver = (event: DragEvent) => {\n  event.preventDefault()\n  if (isDragValid.value) {\n    event.dataTransfer!.dropEffect = 'move'\n  } else {\n    event.dataTransfer!.dropEffect = 'none'\n  }\n}\n\nconst handleDragLeave = (event: DragEvent) => {\n  event.preventDefault()\n  const rect = (event.currentTarget as HTMLElement).getBoundingClientRect()\n  const x = event.clientX\n  const y = event.clientY\n\n  if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n    isDragTarget.value = false\n    setDropTarget(null)\n  }\n}\n\nconst handleDrop = async (event: DragEvent) => {\n  event.preventDefault()\n  event.stopPropagation()\n\n  isDragTarget.value = false\n  setDropTarget(null)\n\n  if (dragData.value && isDragValid.value && dragData.value.type === 'task' && dragData.value.taskId) {\n    const store = taskStore as any\n    const updates: any = {}\n\n    if (props.dropType === 'date') {\n      updates.dueDate = calculateTargetDate()\n    } else if (props.dropType === 'duration') {\n      updates.estimatedDuration = props.dropValue === -1 ? null : props.dropValue\n    }\n\n    if (store.updateTaskWithUndo) {\n      await store.updateTaskWithUndo(dragData.value.taskId, updates)\n    } else {\n      await taskStore.updateTask(dragData.value.taskId, updates) // BUG-1051: AWAIT to ensure persistence\n    }\n  }\n}\n\nconst calculateTargetDate = (): string => {\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n\n  switch (props.dropValue) {\n    case 'today':\n      return today.toISOString().split('T')[0]\n    case 'tomorrow': {\n      const tomorrow = new Date(today)\n      tomorrow.setDate(tomorrow.getDate() + 1)\n      return tomorrow.toISOString().split('T')[0]\n    }\n    case 'weekend': {\n      const saturday = new Date(today)\n      const daysUntilSaturday = (6 - today.getDay() + 7) % 7 || 7\n      saturday.setDate(today.getDate() + daysUntilSaturday)\n      return saturday.toISOString().split('T')[0]\n    }\n    case 'nodate':\n    default:\n      return ''\n  }\n}\n</script>\n\n<style scoped>\n.sidebar-smart-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3) var(--space-4);\n  border-radius: var(--radius-lg);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n  position: relative;\n  min-height: 40px;\n  user-select: none;\n  border: 1px solid transparent;\n}\n\n.sidebar-smart-item.is-compact {\n  padding: var(--space-1_5) var(--space-2);\n  gap: var(--space-2);\n  min-height: 32px;\n  border-radius: var(--radius-md);\n}\n\n.sidebar-smart-item:hover {\n  background: var(--surface-hover);\n}\n\n/* ADHD-friendly: Dim zero-count items to reduce visual noise */\n.sidebar-smart-item.is-empty {\n  opacity: 0.5;\n}\n\n.sidebar-smart-item.is-empty:hover {\n  opacity: 0.8;\n}\n\n/* Active Glassmorphism States */\n.sidebar-smart-item.is-active {\n  backdrop-filter: var(--state-active-glass);\n  -webkit-backdrop-filter: var(--state-active-glass);\n  color: var(--state-active-text);\n  font-weight: var(--font-semibold);\n}\n\n/* Color Mapping for Active State */\n.sidebar-smart-item.color-azure.is-active {\n  background: var(--filter-today-bg);\n  border-color: var(--filter-today-border);\n  box-shadow: var(--filter-today-glow);\n}\n\n.sidebar-smart-item.color-azure-dark.is-active {\n  background: var(--filter-week-bg);\n  border-color: var(--filter-week-border);\n  box-shadow: var(--filter-week-glow);\n}\n\n.sidebar-smart-item.color-blue.is-active {\n  background: var(--filter-tasks-bg);\n  border-color: var(--filter-tasks-border);\n  box-shadow: var(--filter-tasks-glow);\n}\n\n.sidebar-smart-item.color-orange.is-active {\n  background: var(--filter-uncategorized-bg);\n  border-color: var(--filter-uncategorized-border);\n  box-shadow: var(--filter-uncategorized-glow);\n}\n\n.sidebar-smart-item.color-teal.is-active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  box-shadow: var(--state-hover-glow);\n}\n\n/* Duration Specific Colors (New Unified System) */\n.sidebar-smart-item.color-green.is-active {\n  background: var(--success-bg-subtle);\n  border-color: var(--success-border-medium);\n  box-shadow: var(--success-glow);\n}\n\n.sidebar-smart-item.color-purple.is-active {\n  background: var(--purple-bg-subtle);\n  border-color: var(--purple-border-medium);\n  box-shadow: var(--purple-shadow-medium);\n}\n\n.sidebar-smart-item.color-gray.is-active {\n  background: var(--glass-bg-heavy);\n  border-color: var(--glass-border-hover);\n  box-shadow: var(--shadow-sm);\n}\n\n.item-icon {\n  color: var(--text-muted);\n  display: flex;\n  align-items: center;\n  flex-shrink: 0;\n  transition: color var(--duration-normal) var(--spring-smooth);\n}\n\n.is-active .item-icon {\n  color: var(--text-primary);\n}\n\n.sidebar-smart-item:hover .item-icon {\n  color: var(--text-secondary);\n}\n\n.item-label {\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  flex: 1;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  transition: color var(--duration-fast);\n}\n\n.is-compact .item-label {\n  font-size: var(--text-xs);\n}\n\n.is-active .item-label {\n  color: var(--text-primary);\n}\n\n.sidebar-smart-item:hover .item-label {\n  color: var(--text-primary);\n}\n\n/* Drag states */\n.sidebar-smart-item.is-drag-target.is-drag-valid {\n  background: color-mix(in srgb, var(--brand-primary) 15%, transparent) !important;\n  border-color: var(--brand-primary) !important;\n  box-shadow: 0 0 0 2px color-mix(in srgb, var(--brand-primary) 20%, transparent) !important;\n  animation: pulseValid 1.5s ease-in-out infinite;\n}\n\n.sidebar-smart-item.is-drag-target.is-drag-invalid {\n  background: var(--color-danger-bg-light) !important;\n  border-color: rgba(255, 107, 107, 0.3) !important;\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n/* Drop indicator */\n.drop-indicator {\n  position: absolute;\n  left: 100%;\n  top: 50%;\n  transform: translateY(-50%);\n  margin-left: var(--space-3);\n  padding: var(--space-2) var(--space-3);\n  background: linear-gradient(\n    135deg,\n    color-mix(in srgb, var(--brand-primary) 95%, transparent) 0%,\n    color-mix(in srgb, var(--brand-primary) 85%, transparent) 100%\n  );\n  backdrop-filter: blur(12px);\n  -webkit-backdrop-filter: blur(12px);\n  border: 1px solid var(--brand-primary);\n  border-radius: var(--radius-md);\n  color: #0a0a0a;\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  white-space: nowrap;\n  pointer-events: none;\n  box-shadow:\n    0 4px 12px color-mix(in srgb, var(--brand-primary) 30%, transparent),\n    0 0 0 2px color-mix(in srgb, var(--brand-primary) 20%, transparent);\n  z-index: 1000;\n  animation: slideInIndicator 0.2s var(--spring-smooth);\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n@keyframes pulseValid {\n  0%, 100% {\n    box-shadow: 0 0 0 2px color-mix(in srgb, var(--brand-primary) 20%, transparent) !important;\n  }\n  50% {\n    box-shadow: 0 0 0 4px color-mix(in srgb, var(--brand-primary) 30%, transparent) !important;\n  }\n}\n\n@keyframes slideInIndicator {\n  from {\n    opacity: 0;\n    transform: translateY(-50%) translateX(-8px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(-50%) translateX(0);\n  }\n}\n\n:global(body.dragging-active) .sidebar-smart-item:not(.is-drag-target) {\n  opacity: 0.7;\n  transition: opacity var(--duration-fast);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/layout/ViewControls.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/notifications/NotificationPreferences.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/projects/ProjectDropZone.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/projects/ProjectFilterDropdown.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/projects/ProjectModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/projects/ProjectTreeItem.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2690,2693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2690,2693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    :id=\"`project-${project.id}`\"\n    class=\"project-tree-item\"\n    :class=\"{ 'is-selected': isSelected }\"\n    :style=\"{ '--nesting-depth': nestingDepth }\"\n    role=\"treeitem\"\n    :aria-expanded=\"hasChildren ? isExpanded : undefined\"\n    :aria-level=\"level\"\n    :aria-selected=\"taskStore.activeProjectId === project.id || isSelected\"\n    :aria-label=\"project.name\"\n    tabindex=\"-1\"\n  >\n    <!-- The project itself -->\n    <BaseNavItem\n      :active=\"taskStore.activeProjectId === project.id\"\n      :selected=\"isSelected\"\n      :project-id=\"project.id\"\n      :has-children=\"hasChildren\"\n      :expanded=\"isExpanded\"\n      :color-dot=\"Array.isArray(project.color) ? project.color[0] : project.color\"\n      :color-type=\"project.colorType\"\n      :emoji=\"project.emoji\"\n      :count=\"getProjectTaskCount(project.id)\"\n      :nested=\"nested\"\n      :style=\"{ '--nesting-indent': `${nestingDepth * 14}px` }\"\n      :aria-expanded=\"hasChildren ? isExpanded : undefined\"\n      :aria-level=\"level\"\n      :tabindex=\"taskStore.activeProjectId === project.id ? 0 : -1\"\n      @click=\"handleProjectClick\"\n      @toggle-expand=\"toggleExpand\"\n      @contextmenu.prevent=\"$emit('contextmenu', $event, project)\"\n      @project-drop=\"$emit('projectDrop', $event)\"\n    >\n      {{ project.name }}\n    </BaseNavItem>\n\n    <!-- Recursively render children if expanded -->\n    <Transition\n      name=\"nested-projects\"\n      tag=\"div\"\n      class=\"nested-children-transition\"\n    >\n      <div\n        v-if=\"hasChildren && isExpanded\"\n        class=\"nested-children\"\n        role=\"group\"\n        :style=\"{ '--nesting-indent': `${(nestingDepth + 1) * 14}px` }\"\n      >\n        <ProjectTreeItem\n          v-for=\"child in children\"\n          :key=\"child.id\"\n          :project=\"child\"\n          :expanded-projects=\"expandedProjects\"\n          :selected-project-ids=\"selectedProjectIds\"\n          nested\n          :nesting-depth=\"nestingDepth + 1\"\n          :level=\"level + 1\"\n          @click=\"(event, project) => $emit('click', event, project)\"\n          @toggle-expand=\"(projectId) => $emit('toggleExpand', projectId)\"\n          @contextmenu=\"(event, project) => $emit('contextmenu', event, project)\"\n          @project-drop=\"(data) => $emit('projectDrop', data)\"\n        />\n      </div>\n    </Transition>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { useTaskStore, type Project } from '@/stores/tasks'\nimport BaseNavItem from '@/components/base/BaseNavItem.vue'\n\ninterface Props {\n  project: Project\n  expandedProjects: string[]\n  // Allow Set, Array, or Object (for cross-tab sync compatibility)\n  selectedProjectIds?: Set<string> | string[] | Record<string, any>\n  nested?: boolean\n  nestingDepth?: number\n  level?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  nested: false,\n  nestingDepth: 0,\n  level: 1,\n  selectedProjectIds: () => new Set()\n})\n\nconst emit = defineEmits<{\n  click: [event: MouseEvent, project: Project]\n  toggleExpand: [projectId: string]\n  contextmenu: [event: MouseEvent, project: Project]\n  projectDrop: [data: unknown]\n}>()\n\nconst taskStore = useTaskStore()\n\n// Safely convert selectedProjectIds to Set (handles cross-tab sync serialization)\n// PiniaSharedState serializes Sets as plain objects, so we need to handle that\nconst selectedIds = computed<Set<string>>(() => {\n  const raw = props.selectedProjectIds\n  if (raw instanceof Set) return raw\n  if (Array.isArray(raw)) return new Set(raw)\n  if (raw && typeof raw === 'object') {\n    // Object from JSON serialization - use keys or values\n    return new Set(Object.keys(raw))\n  }\n  return new Set()\n})\n\n// Check if this project is selected\nconst isSelected = computed(() => {\n  return selectedIds.value.has(props.project.id)\n})\n\n// Check if this project has children\nconst hasChildren = computed(() => {\n  return taskStore.projects.some(p => p.parentId === props.project.id)\n})\n\n// Check if this project is expanded\nconst isExpanded = computed(() => {\n  return Array.isArray(props.expandedProjects) && props.expandedProjects.includes(props.project.id)\n})\n\n// Get children of this project\nconst children = computed(() => {\n  return taskStore.projects.filter(p => p.parentId === props.project.id)\n})\n\n// Toggle expansion\nconst toggleExpand = () => {\n  emit('toggleExpand', props.project.id)\n}\n\n// Handle project click - pass event and project to parent for selection handling\nconst handleProjectClick = (event: MouseEvent) => {\n  emit('click', event, props.project)\n}\n\n// Recursively count tasks in this project and all descendants\n// TASK-243: Uses raw tasks to show accurate counts regardless of active smart view filter\nconst getProjectTaskCount = (projectId: string): number => {\n  // Get all child projects (same logic as filteredTasks) with cycle detection\n  const getChildProjectIds = (pid: string, visited = new Set<string>()): string[] => {\n    if (visited.has(pid)) return []\n    visited.add(pid)\n\n    const ids = [pid]\n    const children = taskStore.projects.filter(p => p.parentId === pid)\n    children.forEach(child => {\n      ids.push(...getChildProjectIds(child.id, visited))\n    })\n    return ids\n  }\n\n  // Get all child project IDs for this project tree\n  const allChildProjectIds = getChildProjectIds(projectId)\n\n  // Count tasks using raw tasks (bypasses smart view filters for accurate counts)\n  const projectTasks = taskStore.rawTasks.filter(task => {\n    // Only count tasks that belong to this project tree\n    if (!allChildProjectIds.includes(task.projectId)) return false\n\n    // Exclude soft-deleted tasks\n    if (task._soft_deleted) return false\n\n    // Respect hideDoneTasks setting for consistency with sidebar counts\n    if (taskStore.hideDoneTasks && task.status === 'done') return false\n\n    return true\n  })\n\n  return projectTasks.length\n}\n</script>\n\n<style scoped>\n.project-tree-item {\n  display: flex;\n  flex-direction: column;\n}\n\n.project-tree-item.is-selected :deep(.nav-item) {\n  background: var(--brand-primary-alpha-15, rgba(78, 205, 196, 0.15));\n  border-color: var(--brand-primary-alpha-30, rgba(78, 205, 196, 0.3));\n}\n\n.nested-children {\n  /* Dynamic indentation based on nesting level */\n  padding-left: calc(var(--nesting-indent, 20px) + var(--space-2));\n  margin-top: var(--space-1);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  position: relative;\n}\n\n/* Visual connection lines removed for cleaner Todoist-style appearance */\n\n/* Smooth expand/collapse animations for nested children */\n.nested-children {\n  overflow: hidden;\n  transition:\n    max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1),\n    opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),\n    transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n/* Animation states handled by Vue's Transition component will override these */\n\n/* Vue Transition for nested projects expand/collapse */\n.nested-projects-enter-active,\n.nested-projects-leave-active {\n  transition: all var(--duration-slow) cubic-bezier(0.4, 0, 0.2, 1);\n  overflow: hidden;\n}\n\n.nested-projects-enter-from {\n  opacity: 0;\n  max-height: 0;\n  transform: scaleY(0) translateY(-8px);\n}\n\n.nested-projects-leave-to {\n  opacity: 0;\n  max-height: 0;\n  transform: scaleY(0) translateY(-8px);\n}\n\n.nested-projects-enter-to,\n.nested-projects-leave-from {\n  opacity: 1;\n  max-height: 500px; /* Sufficient height for typical nested projects */\n  transform: scaleY(1) translateY(0);\n}\n\n/* Container for the transition to ensure proper layout */\n.nested-children-transition {\n  display: contents;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/quicksort/QuickCaptureTab.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isProcessingVoice' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":238,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":238,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isVoiceSupported' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":257,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":257,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"quick-capture-tab\">\n    <!-- Task Input Form -->\n    <div class=\"capture-form\">\n      <!-- Title Input -->\n      <div class=\"input-group title-group\">\n        <div class=\"title-input-row\">\n          <input\n            ref=\"titleInputRef\"\n            v-model=\"newTask.title\"\n            type=\"text\"\n            class=\"capture-input title-input\"\n            :class=\"{ 'voice-active': isListening }\"\n            :placeholder=\"isListening ? 'Listening...' : 'What needs to be done?'\"\n            maxlength=\"200\"\n            @keydown=\"handleTitleKeydown\"\n          >\n          <!-- Mic button (TASK-1024) - ALWAYS SHOW FOR DEBUG -->\n          <button\n            class=\"mic-btn\"\n            :class=\"[{ recording: isListening }]\"\n            :title=\"isListening ? 'Stop recording' : 'Voice input'\"\n            @click=\"toggleVoiceInput\"\n          >\n            <Mic v-if=\"!isListening\" :size=\"18\" />\n            <MicOff v-else :size=\"18\" />\n          </button>\n        </div>\n        <!-- Voice feedback (when recording) -->\n        <div v-if=\"isListening\" class=\"voice-feedback\">\n          <div class=\"voice-waveform\">\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n          </div>\n          <span class=\"voice-status\">{{ displayTranscript || 'Speak now...' }}</span>\n          <button class=\"voice-cancel\" @click=\"cancelVoice\">\n            <X :size=\"14\" />\n          </button>\n        </div>\n        <!-- Voice error message -->\n        <div v-if=\"voiceError && !isListening\" class=\"voice-error\">\n          {{ voiceError }}\n        </div>\n      </div>\n\n      <!-- Description Input -->\n      <div class=\"input-group description-group\">\n        <textarea\n          v-model=\"newTask.description\"\n          class=\"capture-input description-input\"\n          placeholder=\"Description (optional, supports markdown)...\"\n          rows=\"3\"\n          maxlength=\"2000\"\n          @keydown=\"handleDescriptionKeydown\"\n        />\n      </div>\n\n      <!-- Priority & Due Date Row -->\n      <div class=\"metadata-row\">\n        <!-- Priority -->\n        <div class=\"metadata-group\">\n          <label class=\"metadata-label\">Priority:</label>\n          <div class=\"priority-buttons\">\n            <button\n              class=\"priority-btn\"\n              :class=\"{ active: newTask.priority === undefined }\"\n              @click=\"newTask.priority = undefined\"\n            >\n              None\n            </button>\n            <button\n              class=\"priority-btn low\"\n              :class=\"{ active: newTask.priority === 'low' }\"\n              @click=\"newTask.priority = 'low'\"\n            >\n              Low\n            </button>\n            <button\n              class=\"priority-btn medium\"\n              :class=\"{ active: newTask.priority === 'medium' }\"\n              @click=\"newTask.priority = 'medium'\"\n            >\n              Med\n            </button>\n            <button\n              class=\"priority-btn high\"\n              :class=\"{ active: newTask.priority === 'high' }\"\n              @click=\"newTask.priority = 'high'\"\n            >\n              High\n            </button>\n          </div>\n        </div>\n\n        <!-- Due Date -->\n        <div class=\"metadata-group\">\n          <label class=\"metadata-label\">Due:</label>\n          <div class=\"date-shortcuts\">\n            <button\n              class=\"date-btn\"\n              :class=\"{ active: isDueDateToday }\"\n              @click=\"setDueDate('today')\"\n            >\n              Today\n            </button>\n            <button\n              class=\"date-btn\"\n              :class=\"{ active: isDueDateTomorrow }\"\n              @click=\"setDueDate('tomorrow')\"\n            >\n              Tomorrow\n            </button>\n            <button\n              class=\"date-btn\"\n              :class=\"{ active: isDueDateWeekend }\"\n              @click=\"setDueDate('weekend')\"\n            >\n              Weekend\n            </button>\n            <button\n              v-if=\"newTask.dueDate\"\n              class=\"date-btn clear\"\n              @click=\"newTask.dueDate = undefined\"\n            >\n              <X :size=\"14\" />\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <!-- Add Task Button -->\n      <div class=\"action-row\">\n        <button\n          class=\"add-task-btn\"\n          :disabled=\"!canAddTask\"\n          @click=\"handleAddTask\"\n        >\n          <Plus :size=\"18\" />\n          <span>Add Task</span>\n          <kbd>Enter</kbd>\n        </button>\n      </div>\n    </div>\n\n    <!-- Pending Tasks List -->\n    <div class=\"pending-section\">\n      <div class=\"pending-header\">\n        <h3 class=\"pending-title\">\n          <Inbox :size=\"18\" />\n          Pending Tasks\n          <span v-if=\"quickCapture.pendingTasks.value.length > 0\" class=\"pending-count\">\n            ({{ quickCapture.pendingTasks.value.length }})\n          </span>\n        </h3>\n        <button\n          v-if=\"quickCapture.pendingTasks.value.length > 0\"\n          class=\"sort-all-btn\"\n          @click=\"handleSortAll\"\n        >\n          <Zap :size=\"16\" />\n          <span>Sort All</span>\n          <kbd>Tab</kbd>\n        </button>\n      </div>\n\n      <!-- Task List -->\n      <div v-if=\"quickCapture.pendingTasks.value.length > 0\" class=\"pending-list\">\n        <TransitionGroup name=\"task-list\" tag=\"div\" class=\"task-list-container\">\n          <div\n            v-for=\"task in quickCapture.pendingTasks.value\"\n            :key=\"task.id\"\n            class=\"pending-task-card\"\n          >\n            <div class=\"task-content\">\n              <span class=\"task-title\">{{ task.title }}</span>\n              <div v-if=\"task.description || task.priority || task.dueDate\" class=\"task-meta\">\n                <span v-if=\"task.priority\" class=\"meta-badge\" :class=\"`priority-${task.priority}`\">\n                  <Flag :size=\"12\" />\n                  {{ task.priority }}\n                </span>\n                <span v-if=\"task.dueDate\" class=\"meta-badge due-date\">\n                  <Calendar :size=\"12\" />\n                  {{ formatDueDate(task.dueDate) }}\n                </span>\n              </div>\n              <p v-if=\"task.description\" class=\"task-description-preview\">\n                {{ truncateDescription(task.description) }}\n              </p>\n            </div>\n            <button\n              class=\"remove-btn\"\n              title=\"Remove task\"\n              @click=\"quickCapture.removeTask(task.id)\"\n            >\n              <X :size=\"16\" />\n            </button>\n          </div>\n        </TransitionGroup>\n      </div>\n\n      <!-- Empty State -->\n      <div v-else class=\"empty-state\">\n        <div class=\"empty-icon\">\n          <Inbox :size=\"48\" />\n        </div>\n        <p class=\"empty-text\">\n          No tasks captured yet\n        </p>\n        <p class=\"empty-hint\">\n          Type a task title above and press Enter to add\n        </p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, nextTick, onMounted, reactive } from 'vue'\nimport { X, Plus, Inbox, Flag, Calendar, Zap, Mic, MicOff } from 'lucide-vue-next'\nimport { useWhisperSpeech } from '@/composables/useWhisperSpeech'\nimport { useQuickCapture, type PendingTask } from '@/composables/useQuickCapture'\n\nconst emit = defineEmits<{\n  switchToSort: []\n}>()\n\nconst quickCapture = useQuickCapture()\n\n// Template refs\nconst titleInputRef = ref<HTMLInputElement>()\n\n// TASK-1322: Whisper-only voice input (browser speech recognition removed)\nconst {\n  isRecording: isListening,\n  isProcessing: isProcessingVoice,\n  isSupported: isWhisperSupported,\n  hasApiKey: hasWhisperApiKey,\n  transcript: whisperTranscript,\n  error: voiceError,\n  start: startVoice,\n  stop: stopVoice,\n  cancel: cancelVoice\n} = useWhisperSpeech({\n  onResult: (result) => {\n    if (result.transcript.trim()) {\n      newTask.title = result.transcript.trim()\n    }\n  },\n  onError: (err) => {\n    console.warn('[Voice QuickCapture] Error:', err)\n  }\n})\n\nconst isVoiceSupported = computed(() => isWhisperSupported.value && hasWhisperApiKey.value)\nconst displayTranscript = computed(() => whisperTranscript.value)\n\n// Toggle voice recording\nconst toggleVoiceInput = async () => {\n  if (isListening.value) {\n    stopVoice()\n  } else {\n    newTask.title = ''\n    await startVoice()\n  }\n}\n\n// Form state\nconst newTask = reactive<Omit<PendingTask, 'id'>>({\n  title: '',\n  description: undefined,\n  priority: undefined,\n  dueDate: undefined\n})\n\n// Computed\nconst canAddTask = computed(() => newTask.title.trim().length > 0)\n\nconst isDueDateToday = computed(() => {\n  if (!newTask.dueDate) return false\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  const dueDate = new Date(newTask.dueDate)\n  dueDate.setHours(0, 0, 0, 0)\n  return today.getTime() === dueDate.getTime()\n})\n\nconst isDueDateTomorrow = computed(() => {\n  if (!newTask.dueDate) return false\n  const tomorrow = new Date()\n  tomorrow.setDate(tomorrow.getDate() + 1)\n  tomorrow.setHours(0, 0, 0, 0)\n  const dueDate = new Date(newTask.dueDate)\n  dueDate.setHours(0, 0, 0, 0)\n  return tomorrow.getTime() === dueDate.getTime()\n})\n\nconst isDueDateWeekend = computed(() => {\n  if (!newTask.dueDate) return false\n  const today = new Date()\n  const dayOfWeek = today.getDay()\n  const daysUntilSaturday = dayOfWeek === 6 ? 7 : (6 - dayOfWeek + 7) % 7\n  const saturday = new Date()\n  saturday.setDate(today.getDate() + daysUntilSaturday)\n  saturday.setHours(0, 0, 0, 0)\n  const dueDate = new Date(newTask.dueDate)\n  dueDate.setHours(0, 0, 0, 0)\n  return saturday.getTime() === dueDate.getTime()\n})\n\n// Actions\nfunction handleAddTask() {\n  if (!canAddTask.value) return\n\n  quickCapture.addTask({\n    title: newTask.title,\n    description: newTask.description?.trim() || undefined,\n    priority: newTask.priority,\n    dueDate: newTask.dueDate\n  })\n\n  // Reset form but keep priority/dueDate for convenience\n  newTask.title = ''\n  newTask.description = undefined\n\n  // Re-focus title input\n  nextTick(() => {\n    titleInputRef.value?.focus()\n  })\n}\n\nfunction handleSortAll() {\n  if (quickCapture.pendingTasks.value.length > 0) {\n    quickCapture.startSorting()\n    emit('switchToSort')\n  }\n}\n\nfunction handleTitleKeydown(event: KeyboardEvent) {\n  if (event.key === 'Enter' && !event.shiftKey) {\n    event.preventDefault()\n    if (canAddTask.value) {\n      handleAddTask()\n    }\n  } else if (event.key === 'Tab' && quickCapture.pendingTasks.value.length > 0) {\n    event.preventDefault()\n    handleSortAll()\n  }\n}\n\nfunction handleDescriptionKeydown(event: KeyboardEvent) {\n  // Shift+Enter to add task from description\n  if (event.key === 'Enter' && event.shiftKey) {\n    event.preventDefault()\n    if (canAddTask.value) {\n      handleAddTask()\n    }\n  } else if (event.key === 'Tab' && quickCapture.pendingTasks.value.length > 0 && !event.shiftKey) {\n    event.preventDefault()\n    handleSortAll()\n  }\n}\n\nfunction setDueDate(preset: 'today' | 'tomorrow' | 'weekend') {\n  const date = new Date()\n  date.setHours(0, 0, 0, 0)\n\n  switch (preset) {\n    case 'today':\n      // Already set to today\n      break\n    case 'tomorrow':\n      date.setDate(date.getDate() + 1)\n      break\n    case 'weekend': {\n      const dayOfWeek = date.getDay()\n      const daysUntilSaturday = dayOfWeek === 6 ? 7 : (6 - dayOfWeek + 7) % 7\n      date.setDate(date.getDate() + daysUntilSaturday)\n      break\n    }\n  }\n\n  newTask.dueDate = date.toISOString()\n}\n\nfunction formatDueDate(dateStr: string): string {\n  const date = new Date(dateStr)\n  if (isNaN(date.getTime())) return ''\n\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  date.setHours(0, 0, 0, 0)\n\n  const diffDays = Math.round((date.getTime() - today.getTime()) / (1000 * 60 * 60 * 24))\n\n  if (diffDays === 0) return 'Today'\n  if (diffDays === 1) return 'Tomorrow'\n  if (diffDays === -1) return 'Yesterday'\n\n  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })\n}\n\nfunction truncateDescription(desc: string): string {\n  const maxLength = 80\n  if (desc.length <= maxLength) return desc\n  return desc.substring(0, maxLength).trim() + '...'\n}\n\n// Focus title input on mount\nonMounted(() => {\n  nextTick(() => {\n    titleInputRef.value?.focus()\n  })\n})\n\n// Expose focus method for parent\ndefineExpose({\n  focus: () => titleInputRef.value?.focus()\n})\n</script>\n\n<style scoped>\n.quick-capture-tab {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-6);\n  height: 100%;\n}\n\n/* Capture Form */\n.capture-form {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n  padding: var(--space-5);\n  background: var(--glass-bg-light);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n}\n\n.input-group {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.title-input-row {\n  display: flex;\n  gap: var(--space-2);\n  align-items: center;\n}\n\n.capture-input {\n  width: 100%;\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text-primary);\n  font-size: var(--text-base);\n  transition: all var(--duration-normal);\n}\n\n.capture-input:focus {\n  outline: none;\n  border-color: var(--brand-primary);\n  box-shadow: 0 0 0 3px var(--brand-primary-alpha-20);\n}\n\n.capture-input::placeholder {\n  color: var(--text-muted);\n}\n\n.title-input {\n  flex: 1;\n  padding: var(--space-3) var(--space-4);\n  font-weight: var(--font-medium);\n}\n\n.title-input.voice-active {\n  border-color: var(--danger-text, #ef4444);\n  box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);\n}\n\n/* Mic Button (TASK-1024) */\n.mic-btn {\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  border: none;\n  background: var(--glass-bg-soft);\n  color: var(--text-secondary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n  transition: all 0.2s ease;\n}\n\n.mic-btn:hover {\n  background: var(--glass-bg-medium);\n  color: var(--text-primary);\n}\n\n.mic-btn:active {\n  transform: scale(0.95);\n}\n\n.mic-btn.recording {\n  background: var(--danger-text, #ef4444);\n  color: white;\n  animation: pulse-recording 1.5s ease-in-out infinite;\n}\n\n@keyframes pulse-recording {\n  0%, 100% {\n    box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);\n  }\n  50% {\n    box-shadow: 0 0 0 8px rgba(239, 68, 68, 0);\n  }\n}\n\n/* Voice feedback panel */\n.voice-feedback {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-2) var(--space-3);\n  margin-top: var(--space-2);\n  background: var(--glass-bg-soft);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--glass-border);\n}\n\n.voice-waveform {\n  display: flex;\n  align-items: center;\n  gap: 2px;\n  height: 20px;\n}\n\n.wave-bar {\n  width: 3px;\n  height: 6px;\n  background: var(--danger-text, #ef4444);\n  border-radius: 2px;\n  animation: wave 0.8s ease-in-out infinite;\n}\n\n.wave-bar:nth-child(1) { animation-delay: 0s; }\n.wave-bar:nth-child(2) { animation-delay: 0.1s; }\n.wave-bar:nth-child(3) { animation-delay: 0.2s; }\n.wave-bar:nth-child(4) { animation-delay: 0.3s; }\n.wave-bar:nth-child(5) { animation-delay: 0.4s; }\n\n@keyframes wave {\n  0%, 100% { height: 6px; }\n  50% { height: 16px; }\n}\n\n.voice-status {\n  flex: 1;\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.voice-cancel {\n  width: 24px;\n  height: 24px;\n  border-radius: 50%;\n  border: none;\n  background: transparent;\n  color: var(--text-tertiary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.voice-cancel:hover {\n  background: var(--glass-bg);\n  color: var(--danger-text, #ef4444);\n}\n\n/* Voice error message */\n.voice-error {\n  margin-top: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(239, 68, 68, 0.1);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: var(--danger-text, #ef4444);\n}\n\n.description-input {\n  padding: var(--space-3) var(--space-4);\n  font-size: var(--text-sm);\n  resize: vertical;\n  min-height: 80px;\n  max-height: 200px;\n  line-height: var(--leading-relaxed);\n}\n\n/* Metadata Row */\n.metadata-row {\n  display: flex;\n  gap: var(--space-6);\n  flex-wrap: wrap;\n}\n\n.metadata-group {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.metadata-label {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.priority-buttons,\n.date-shortcuts {\n  display: flex;\n  gap: var(--space-1);\n}\n\n.priority-btn,\n.date-btn {\n  padding: var(--space-1_5) var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.priority-btn:hover,\n.date-btn:hover {\n  background: var(--glass-bg-medium);\n  color: var(--text-primary);\n}\n\n.priority-btn.active {\n  background: transparent;\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n  font-weight: var(--font-semibold);\n}\n\n.priority-btn.low.active {\n  background: transparent;\n  border-color: var(--success);\n  color: var(--success);\n}\n\n.priority-btn.medium.active {\n  background: transparent;\n  border-color: var(--warning);\n  color: var(--warning);\n}\n\n.priority-btn.high.active {\n  background: transparent;\n  border-color: var(--danger);\n  color: var(--danger);\n}\n\n.date-btn.active {\n  background: transparent;\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.date-btn.clear {\n  padding: var(--space-1_5);\n  color: var(--danger);\n  border-color: var(--danger-muted);\n}\n\n.date-btn.clear:hover {\n  background: var(--danger-bg);\n  border-color: var(--danger);\n}\n\n/* Action Row */\n.action-row {\n  display: flex;\n  justify-content: flex-end;\n  padding-top: var(--space-2);\n}\n\n.add-task-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2_5) var(--space-5);\n  background: transparent;\n  border: 1px solid var(--brand-primary);\n  border-radius: var(--radius-lg);\n  color: var(--brand-primary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.add-task-btn:hover:not(:disabled) {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px var(--brand-primary-alpha-20);\n}\n\n.add-task-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.add-task-btn kbd {\n  padding: var(--space-0_5) var(--space-1_5);\n  background: var(--glass-bg-heavy);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-family: var(--font-mono);\n}\n\n/* Pending Section */\n.pending-section {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n}\n\n.pending-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--space-3) 0;\n  border-bottom: 1px solid var(--border-subtle);\n  margin-bottom: var(--space-4);\n}\n\n.pending-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n.pending-count {\n  color: var(--brand-primary);\n}\n\n.sort-all-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-2) var(--space-4);\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--brand-primary);\n  border-radius: var(--radius-md);\n  color: var(--brand-primary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.sort-all-btn:hover {\n  background: rgba(78, 205, 196, 0.08);\n  color: var(--brand-hover);\n  border-color: var(--brand-hover);\n  transform: translateY(-1px);\n}\n\n.sort-all-btn kbd {\n  padding: var(--space-0_5) var(--space-1);\n  background: var(--overlay-light);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-family: var(--font-mono);\n}\n\n/* Pending List */\n.pending-list {\n  flex: 1;\n  overflow-y: auto;\n}\n\n.task-list-container {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.pending-task-card {\n  display: flex;\n  align-items: flex-start;\n  gap: var(--space-3);\n  padding: var(--space-3) var(--space-4);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  transition: all var(--duration-normal);\n}\n\n.pending-task-card:hover {\n  background: var(--glass-bg-light);\n  border-color: var(--glass-border-hover);\n}\n\n.task-content {\n  flex: 1;\n  min-width: 0;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.task-title {\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--text-primary);\n  word-wrap: break-word;\n}\n\n.task-meta {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--space-2);\n}\n\n.meta-badge {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-0_5) var(--space-2);\n  background: var(--glass-bg-medium);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  text-transform: capitalize;\n}\n\n.meta-badge.priority-low {\n  color: var(--success);\n  background: rgba(16, 185, 129, 0.1);\n}\n\n.meta-badge.priority-medium {\n  color: var(--warning);\n  background: rgba(245, 158, 11, 0.1);\n}\n\n.meta-badge.priority-high {\n  color: var(--danger);\n  background: rgba(239, 68, 68, 0.1);\n}\n\n.meta-badge.due-date {\n  color: var(--info);\n  background: rgba(59, 130, 246, 0.1);\n}\n\n.task-description-preview {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: 0;\n  line-height: var(--leading-relaxed);\n}\n\n.remove-btn {\n  flex-shrink: 0;\n  padding: var(--space-1_5);\n  background: transparent;\n  border: 1px solid transparent;\n  border-radius: var(--radius-sm);\n  color: var(--text-muted);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.remove-btn:hover {\n  background: var(--danger-bg);\n  border-color: var(--danger);\n  color: var(--danger);\n}\n\n/* Empty State */\n.empty-state {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-3);\n  padding: var(--space-12);\n  text-align: center;\n}\n\n.empty-icon {\n  color: var(--text-muted);\n  opacity: 0.5;\n}\n\n.empty-text {\n  font-size: var(--text-base);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n.empty-hint {\n  font-size: var(--text-sm);\n  color: var(--text-muted);\n  margin: 0;\n}\n\n/* Task List Transitions */\n.task-list-enter-active,\n.task-list-leave-active {\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.task-list-enter-from {\n  opacity: 0;\n  transform: translateY(-10px);\n}\n\n.task-list-leave-to {\n  opacity: 0;\n  transform: translateX(-20px);\n}\n\n/* Responsive */\n@media (max-width: 640px) {\n  .metadata-row {\n    flex-direction: column;\n    gap: var(--space-4);\n  }\n\n  .priority-buttons,\n  .date-shortcuts {\n    flex-wrap: wrap;\n  }\n\n  .action-row {\n    justify-content: stretch;\n  }\n\n  .add-task-btn {\n    width: 100%;\n    justify-content: center;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/LanguageSettings.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/SettingsDurationPicker.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/SettingsOptionPicker.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[237,240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[237,240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\ninterface Option {\n  value: string | number\n  label: string\n}\n\ndefineProps<{\n  label: string\n  description?: string\n  options: Option[]\n  value: string | number\n}>()\n\nconst emit = defineEmits<{\n  update: [value: any]\n}>()\n</script>\n\n<template>\n  <div class=\"setting-group\">\n    <div class=\"setting-header\">\n      <label class=\"setting-label\">{{ label }}</label>\n      <p v-if=\"description\" class=\"setting-description\">\n        {{ description }}\n      </p>\n    </div>\n    \n    <div class=\"option-picker\">\n      <button\n        v-for=\"option in options\"\n        :key=\"option.value\"\n        class=\"option-btn\"\n        :class=\"{ active: value === option.value }\"\n        @click=\"emit('update', option.value)\"\n      >\n        {{ option.label }}\n      </button>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.setting-group {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n}\n\n.setting-header {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.setting-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n}\n\n.setting-description {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  line-height: 1.4;\n}\n\n.option-picker {\n  display: flex;\n  gap: var(--space-2);\n  flex-wrap: wrap;\n}\n\n.option-btn {\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  color: var(--text-secondary);\n  padding: var(--space-2) var(--space-4);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  transition: all var(--duration-normal) var(--spring-smooth);\n  flex: 1;\n  min-width: 100px;\n  text-align: center;\n}\n\n.option-btn:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--glass-border-medium);\n  color: var(--text-primary);\n  transform: translateY(-1px);\n}\n\n.option-btn.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--text-primary);\n  box-shadow: var(--shadow-sm);\n}\n\n@media (max-width: 480px) {\n  .option-btn {\n    flex: 1 0 100%;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/SettingsSection.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/SettingsToggle.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/AISettingsTab.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'aiChatStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":13,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7490,7493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7490,7493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"vue/singleline-html-element-content-newline","severity":1,"message":"Expected 1 line break after opening tag (`<option>`), but no line breaks found.","line":269,"column":30,"nodeType":"HTMLTagClose","messageId":"unexpectedAfterClosingBracket","endLine":269,"endColumn":30,"fix":{"range":[8690,8690],"text":"\n"}},{"ruleId":"vue/singleline-html-element-content-newline","severity":1,"message":"Expected 1 line break before closing tag (`</option>`), but no line breaks found.","line":269,"column":37,"nodeType":"HTMLEndTagOpen","messageId":"unexpectedBeforeOpeningBracket","endLine":269,"endColumn":37,"fix":{"range":[8697,8697],"text":"\n"}},{"ruleId":"vue/attributes-order","severity":1,"message":"Attribute \"title\" should go before \"@click\".","line":283,"column":11,"nodeType":"VAttribute","messageId":"expectedOrder","endLine":283,"endColumn":39,"fix":{"range":[9037,9106],"text":"title=\"Refresh local models\"\n          @click=\"refreshOllamaModels()\""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":3,"source":"<script setup lang=\"ts\">\nimport { ref, computed, onMounted } from 'vue'\nimport { Bot, DollarSign, MessageSquare, Zap, Trash2, Tag, RefreshCw } from 'lucide-vue-next'\nimport { useAIUsageTracking, type UsagePeriod, type UsageSummary } from '@/composables/useAIUsageTracking'\nimport { useAIChat } from '@/composables/useAIChat'\nimport { useAIChatStore } from '@/stores/aiChat'\nimport { useWorkProfile } from '@/composables/useWorkProfile'\nimport { useSettingsStore } from '@/stores/settings'\nimport SettingsSection from '../SettingsSection.vue'\nimport SettingsToggle from '../SettingsToggle.vue'\n\nconst { usageSummary, weekUsage, monthUsage, hasUsageData, pricingCatalog, clearUsageData } = useAIUsageTracking()\nconst aiChatStore = useAIChatStore()\nconst settingsStore = useSettingsStore()\nconst { profile, loadProfile, savePreferences, computeCapacityMetrics, resetLearnedData } = useWorkProfile()\n\n// ── Default Provider/Model ──\nconst {\n  selectedProvider,\n  selectedModel,\n  availableOllamaModels,\n  setProvider,\n  setModel,\n  refreshOllamaModels,\n} = useAIChat()\n\ntype ProviderOption = 'auto' | 'ollama' | 'groq' | 'openrouter'\n\nconst providerOptions: { key: ProviderOption; label: string; desc: string }[] = [\n  { key: 'auto', label: 'Auto', desc: 'Prefers local, falls back to cloud' },\n  { key: 'ollama', label: 'Local (Ollama)', desc: 'Free, private, runs on your machine' },\n  { key: 'groq', label: 'Groq', desc: 'Fast cloud inference' },\n  { key: 'openrouter', label: 'OpenRouter', desc: 'Premium models (Claude, GPT-4, Kimi)' },\n]\n\nconst groqModels = [\n  { id: 'llama-3.3-70b-versatile', label: 'Llama 3.3 70B' },\n  { id: 'llama-3.1-8b-instant', label: 'Llama 3.1 8B Instant' },\n  { id: 'mixtral-8x7b-32768', label: 'Mixtral 8x7B' },\n  { id: 'gemma2-9b-it', label: 'Gemma 2 9B' },\n]\n\nconst openrouterModels = [\n  { id: 'anthropic/claude-3.5-sonnet', label: 'Claude 3.5 Sonnet' },\n  { id: 'anthropic/claude-opus-4-6', label: 'Claude Opus 4.6' },\n  { id: 'openai/gpt-4o', label: 'GPT-4o' },\n  { id: 'moonshotai/kimi-k2-instruct-0905', label: 'Kimi K2' },\n  { id: 'meta-llama/llama-3.3-70b-instruct', label: 'Llama 3.3 70B' },\n  { id: 'mistralai/mistral-large', label: 'Mistral Large' },\n  { id: 'google/gemini-2.0-flash', label: 'Gemini 2.0 Flash' },\n]\n\nconst currentModelOptions = computed(() => {\n  switch (selectedProvider.value) {\n    case 'ollama':\n      return availableOllamaModels.value.map(m => ({ id: m, label: m }))\n    case 'groq':\n      return groqModels\n    case 'openrouter':\n      return openrouterModels\n    default:\n      return []\n  }\n})\n\nfunction onProviderChange(provider: ProviderOption) {\n  setProvider(provider)\n}\n\nfunction onModelChange(event: Event) {\n  const value = (event.target as HTMLSelectElement).value\n  setModel(value || null)\n}\n\n/** Currently selected time period */\nconst selectedPeriod = ref<UsagePeriod>('all')\n\nconst periods: { id: UsagePeriod; label: string }[] = [\n  { id: 'week', label: 'This Week' },\n  { id: 'month', label: 'This Month' },\n  { id: 'all', label: 'All Time' }\n]\n\n/** Get the usage data for the selected period */\nconst currentUsage = computed<UsageSummary>(() => {\n  switch (selectedPeriod.value) {\n    case 'week': return weekUsage.value\n    case 'month': return monthUsage.value\n    default: return usageSummary.value\n  }\n})\n\n/** Format large numbers with commas */\nfunction formatNumber(num: number): string {\n  return num.toLocaleString('en-US')\n}\n\n/** Format cost as USD currency */\nfunction formatCost(cost: number): string {\n  if (cost === 0) return 'Free'\n  if (cost < 0.01) return `$${cost.toFixed(6)}`\n  return `$${cost.toFixed(4)}`\n}\n\n/** Format pricing rate (per 1M tokens) */\nfunction formatRate(rate: number): string {\n  if (rate === 0) return 'Free'\n  return `$${rate.toFixed(2)}`\n}\n\n/** Format context window size */\nfunction formatContext(tokens: number): string {\n  if (tokens >= 1_000_000) return `${(tokens / 1_000_000).toFixed(0)}M`\n  return `${(tokens / 1_000).toFixed(0)}K`\n}\n\n/** Get color indicator for provider */\nfunction getProviderColor(provider: string): string {\n  switch (provider) {\n    case 'ollama': return 'var(--color-success)'\n    case 'groq': return 'var(--color-info)'\n    case 'openrouter': return 'var(--color-warning)'\n    default: return 'var(--text-muted)'\n  }\n}\n\n/** Clear all usage data */\nfunction handleClearUsageData() {\n  if (!confirm('This will clear all AI usage tracking data. Continue?')) return\n  clearUsageData()\n}\n\n/** Summary stats for the selected period */\nconst summaryStats = computed(() => [\n  { label: 'Total Tokens', value: formatNumber(currentUsage.value.totalTokens), icon: Zap },\n  { label: 'Requests', value: formatNumber(currentUsage.value.totalRequests), icon: MessageSquare },\n  { label: 'Est. Cost', value: formatCost(currentUsage.value.totalCostUSD), icon: DollarSign }\n])\n\n// ── Weekly Plan Settings ──\nconst isSaving = ref(false)\nconst isRecalculating = ref(false)\nconst isResetting = ref(false)\nconst saveMessage = ref('')\nconst isClearingMemories = ref(false)\n\nconst form = ref({\n  workDays: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'] as string[],\n  daysOff: [] as string[],\n  heavyMeetingDays: [] as string[],\n  maxTasksPerDay: 6,\n  preferredWorkStyle: 'balanced' as 'frontload' | 'balanced' | 'backload',\n})\n\nconst dayOptions = [\n  { key: 'monday', label: 'Mon' },\n  { key: 'tuesday', label: 'Tue' },\n  { key: 'wednesday', label: 'Wed' },\n  { key: 'thursday', label: 'Thu' },\n  { key: 'friday', label: 'Fri' },\n  { key: 'saturday', label: 'Sat' },\n  { key: 'sunday', label: 'Sun' },\n]\n\nconst workStyleOptions = [\n  { key: 'frontload' as const, label: 'Front-load', desc: 'Heavy Mon-Tue, lighter Thu-Fri' },\n  { key: 'balanced' as const, label: 'Balanced', desc: 'Even distribution across days' },\n  { key: 'backload' as const, label: 'Back-load', desc: 'Lighter Mon-Tue, heavier Thu-Fri' },\n]\n\nonMounted(async () => {\n  const p = await loadProfile()\n  if (p) {\n    form.value.workDays = [...p.workDays]\n    form.value.daysOff = [...p.daysOff]\n    form.value.heavyMeetingDays = [...p.heavyMeetingDays]\n    form.value.maxTasksPerDay = p.maxTasksPerDay\n    form.value.preferredWorkStyle = p.preferredWorkStyle\n  }\n})\n\nfunction toggleDay(list: string[], key: string) {\n  const idx = list.indexOf(key)\n  if (idx === -1) list.push(key)\n  else list.splice(idx, 1)\n}\n\nasync function onSave() {\n  isSaving.value = true\n  saveMessage.value = ''\n  try {\n    await savePreferences({\n      workDays: [...form.value.workDays],\n      daysOff: [...form.value.daysOff],\n      heavyMeetingDays: [...form.value.heavyMeetingDays],\n      maxTasksPerDay: form.value.maxTasksPerDay,\n      preferredWorkStyle: form.value.preferredWorkStyle,\n    })\n    saveMessage.value = 'Preferences saved!'\n    setTimeout(() => { saveMessage.value = '' }, 3000)\n  } catch {\n    saveMessage.value = 'Failed to save'\n  } finally {\n    isSaving.value = false\n  }\n}\n\nasync function onRecalculate() {\n  isRecalculating.value = true\n  try {\n    await computeCapacityMetrics()\n  } finally {\n    isRecalculating.value = false\n  }\n}\n\nasync function onReset() {\n  if (!confirm('Reset all learned patterns? This cannot be undone.')) return\n  isResetting.value = true\n  try {\n    await resetLearnedData()\n  } finally {\n    isResetting.value = false\n  }\n}\n\nasync function onClearMemories() {\n  if (!confirm('Clear all memory observations? The AI will need to re-learn patterns.')) return\n  isClearingMemories.value = true\n  try {\n    await savePreferences({ memoryGraph: [] } as any)\n  } finally {\n    isClearingMemories.value = false\n  }\n}\n</script>\n\n<template>\n  <div class=\"ai-settings-tab\">\n    <!-- Default Provider & Model -->\n    <SettingsSection title=\"Default Provider & Model\">\n      <p class=\"section-desc\">\n        Choose which AI provider and model to use by default. This applies to all new chat sessions.\n      </p>\n\n      <!-- Provider selector -->\n      <div class=\"provider-chips\">\n        <button\n          v-for=\"opt in providerOptions\"\n          :key=\"opt.key\"\n          class=\"provider-chip\"\n          :class=\"{ active: selectedProvider === opt.key }\"\n          @click=\"onProviderChange(opt.key)\"\n        >\n          <span class=\"provider-chip-label\">{{ opt.label }}</span>\n          <span class=\"provider-chip-desc\">{{ opt.desc }}</span>\n        </button>\n      </div>\n\n      <!-- Model selector (when not auto) -->\n      <div v-if=\"selectedProvider !== 'auto'\" class=\"model-selector\">\n        <label class=\"model-selector-label\">Model</label>\n        <div class=\"model-select-wrapper\">\n          <select\n            class=\"model-select\"\n            :value=\"selectedModel || ''\"\n            @change=\"onModelChange\"\n          >\n            <option value=\"\">Default</option>\n            <option\n              v-for=\"m in currentModelOptions\"\n              :key=\"m.id\"\n              :value=\"m.id\"\n            >\n              {{ m.label }}\n            </option>\n          </select>\n        </div>\n        <button\n          v-if=\"selectedProvider === 'ollama'\"\n          class=\"refresh-models-btn\"\n          @click=\"refreshOllamaModels()\"\n          title=\"Refresh local models\"\n        >\n          <RefreshCw :size=\"14\" />\n        </button>\n      </div>\n    </SettingsSection>\n\n    <!-- Your Usage (top) -->\n    <SettingsSection title=\"Your Usage\">\n      <!-- Period selector -->\n      <div class=\"period-selector\">\n        <button\n          v-for=\"period in periods\"\n          :key=\"period.id\"\n          class=\"period-btn\"\n          :class=\"{ active: selectedPeriod === period.id }\"\n          @click=\"selectedPeriod = period.id\"\n        >\n          {{ period.label }}\n        </button>\n      </div>\n\n      <div v-if=\"hasUsageData\" class=\"usage-content\">\n        <!-- Summary cards -->\n        <div class=\"summary-cards\">\n          <div\n            v-for=\"stat in summaryStats\"\n            :key=\"stat.label\"\n            class=\"summary-card\"\n          >\n            <div class=\"summary-icon\">\n              <component :is=\"stat.icon\" :size=\"18\" />\n            </div>\n            <div class=\"summary-info\">\n              <span class=\"summary-label\">{{ stat.label }}</span>\n              <span class=\"summary-value\">{{ stat.value }}</span>\n            </div>\n          </div>\n        </div>\n\n        <!-- Provider breakdown -->\n        <div v-if=\"currentUsage.providers.length > 0\" class=\"provider-list\">\n          <div\n            v-for=\"provider in currentUsage.providers\"\n            :key=\"provider.provider\"\n            class=\"provider-row\"\n          >\n            <div class=\"provider-header\">\n              <div\n                class=\"provider-indicator\"\n                :style=\"{ backgroundColor: getProviderColor(provider.provider) }\"\n              />\n              <span class=\"provider-name\">{{ provider.displayName }}</span>\n              <span class=\"provider-cost\">{{ formatCost(provider.estimatedCostUSD) }}</span>\n            </div>\n            <div class=\"provider-stats\">\n              <div class=\"provider-stat\">\n                <span class=\"stat-label\">Tokens</span>\n                <span class=\"stat-value\">{{ formatNumber(provider.totalTokens) }}</span>\n              </div>\n              <div class=\"provider-stat\">\n                <span class=\"stat-label\">Requests</span>\n                <span class=\"stat-value\">{{ formatNumber(provider.totalRequests) }}</span>\n              </div>\n            </div>\n\n            <!-- Model breakdown within provider -->\n            <div v-if=\"provider.models.length > 1\" class=\"model-breakdown\">\n              <div\n                v-for=\"model in provider.models\"\n                :key=\"model.model\"\n                class=\"model-row\"\n              >\n                <span class=\"model-name\">{{ model.model }}</span>\n                <span class=\"model-tokens\">{{ formatNumber(model.tokens) }} tok</span>\n              </div>\n            </div>\n          </div>\n        </div>\n        <p v-else class=\"no-period-data\">\n          No usage in {{ currentUsage.periodLabel.toLowerCase() }}.\n        </p>\n\n        <!-- Clear button -->\n        <button class=\"clear-btn\" @click=\"handleClearUsageData\">\n          <Trash2 :size=\"14\" />\n          <span>Clear Usage Data</span>\n        </button>\n      </div>\n\n      <div v-else class=\"no-usage\">\n        <Bot :size=\"28\" />\n        <p>No usage data yet. Start chatting with AI to track spending.</p>\n      </div>\n    </SettingsSection>\n\n    <!-- Model Pricing Reference (always visible) -->\n    <SettingsSection title=\"Model Pricing\">\n      <p class=\"section-desc\">\n        Rates per 1M tokens. Ollama runs locally (free). Cloud providers charge per token.\n      </p>\n      <div class=\"pricing-groups\">\n        <div\n          v-for=\"group in pricingCatalog\"\n          :key=\"group.provider\"\n          class=\"pricing-group\"\n        >\n          <div class=\"pricing-group-header\">\n            <div\n              class=\"provider-indicator\"\n              :style=\"{ backgroundColor: getProviderColor(group.provider) }\"\n            />\n            <span class=\"pricing-group-name\">{{ group.displayName }}</span>\n          </div>\n\n          <table class=\"pricing-table\">\n            <thead>\n              <tr>\n                <th class=\"th-model\">\n                  Model\n                </th>\n                <th class=\"th-rate\">\n                  Input\n                </th>\n                <th class=\"th-rate\">\n                  Output\n                </th>\n                <th class=\"th-ctx\">\n                  Context\n                </th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr\n                v-for=\"model in group.models\"\n                :key=\"model.model\"\n                :class=\"{ 'is-default': model.isDefault }\"\n              >\n                <td class=\"td-model\">\n                  {{ model.displayName }}\n                  <Tag v-if=\"model.isDefault\" :size=\"10\" class=\"default-tag\" />\n                </td>\n                <td class=\"td-rate\">\n                  {{ formatRate(model.inputPer1M) }}\n                </td>\n                <td class=\"td-rate\">\n                  {{ formatRate(model.outputPer1M) }}\n                </td>\n                <td class=\"td-ctx\">\n                  {{ formatContext(model.contextWindow) }}\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </SettingsSection>\n\n    <!-- Weekly Plan Settings (merged from WeeklyPlanSettingsTab) -->\n    <SettingsSection title=\"AI Learning\">\n      <SettingsToggle\n        label=\"Enable AI work profile learning\"\n        :value=\"settingsStore.aiLearningEnabled\"\n        @update=\"(v: boolean) => settingsStore.updateSetting('aiLearningEnabled', v)\"\n      />\n      <p class=\"learning-hint\">\n        When enabled, FlowState tracks your work patterns to make weekly plans smarter over time.\n      </p>\n    </SettingsSection>\n\n    <SettingsSection title=\"Planning Preferences\">\n      <div class=\"wp-setting-row\">\n        <label class=\"wp-setting-label\">Work days</label>\n        <div class=\"day-chips\">\n          <button\n            v-for=\"d in dayOptions\"\n            :key=\"d.key\"\n            class=\"day-chip\"\n            :class=\"{ active: form.workDays.includes(d.key) }\"\n            @click=\"toggleDay(form.workDays, d.key)\"\n          >\n            {{ d.label }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"wp-setting-row\">\n        <label class=\"wp-setting-label\">Days off</label>\n        <div class=\"day-chips\">\n          <button\n            v-for=\"d in dayOptions\"\n            :key=\"d.key\"\n            class=\"day-chip off\"\n            :class=\"{ active: form.daysOff.includes(d.key) }\"\n            @click=\"toggleDay(form.daysOff, d.key)\"\n          >\n            {{ d.label }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"wp-setting-row\">\n        <label class=\"wp-setting-label\">Heavy meeting days</label>\n        <div class=\"day-chips\">\n          <button\n            v-for=\"d in dayOptions\"\n            :key=\"d.key\"\n            class=\"day-chip meeting\"\n            :class=\"{ active: form.heavyMeetingDays.includes(d.key) }\"\n            @click=\"toggleDay(form.heavyMeetingDays, d.key)\"\n          >\n            {{ d.label }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"wp-setting-row\">\n        <label class=\"wp-setting-label\">Max tasks per day</label>\n        <div class=\"number-chips\">\n          <button\n            v-for=\"n in [3, 5, 6, 8, 10]\"\n            :key=\"n\"\n            class=\"number-chip\"\n            :class=\"{ active: form.maxTasksPerDay === n }\"\n            @click=\"form.maxTasksPerDay = n\"\n          >\n            {{ n }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"wp-setting-row\">\n        <label class=\"wp-setting-label\">Work style</label>\n        <div class=\"style-chips\">\n          <button\n            v-for=\"ws in workStyleOptions\"\n            :key=\"ws.key\"\n            class=\"style-chip\"\n            :class=\"{ active: form.preferredWorkStyle === ws.key }\"\n            @click=\"form.preferredWorkStyle = ws.key\"\n          >\n            <span class=\"style-label\">{{ ws.label }}</span>\n            <span class=\"style-desc\">{{ ws.desc }}</span>\n          </button>\n        </div>\n      </div>\n\n      <div class=\"save-row\">\n        <button class=\"save-btn\" :disabled=\"isSaving\" @click=\"onSave\">\n          {{ isSaving ? 'Saving...' : 'Save Preferences' }}\n        </button>\n        <span v-if=\"saveMessage\" class=\"save-message\">{{ saveMessage }}</span>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"Learned Patterns\">\n      <div class=\"metrics-grid\">\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.avgWorkMinutesPerDay ? Math.round(profile.avgWorkMinutesPerDay) + ' min' : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Avg work/day\n          </div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.avgTasksCompletedPerDay ? profile.avgTasksCompletedPerDay.toFixed(1) : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Avg tasks/day\n          </div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.avgPlanAccuracy ? profile.avgPlanAccuracy.toFixed(0) + '%' : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Plan accuracy\n          </div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.peakProductivityDays?.length ? profile.peakProductivityDays.map(d => d.charAt(0).toUpperCase() + d.slice(1, 3)).join(', ') : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Peak days\n          </div>\n        </div>\n      </div>\n\n      <div class=\"wp-action-row\">\n        <button class=\"wp-action-btn\" :disabled=\"isRecalculating\" @click=\"onRecalculate\">\n          <RefreshCw :size=\"14\" :class=\"{ spinning: isRecalculating }\" />\n          {{ isRecalculating ? 'Recalculating...' : 'Recalculate' }}\n        </button>\n        <button class=\"wp-action-btn danger\" :disabled=\"isResetting\" @click=\"onReset\">\n          <Trash2 :size=\"14\" />\n          {{ isResetting ? 'Resetting...' : 'Reset Profile' }}\n        </button>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"Memory Observations\">\n      <p class=\"obs-hint\">\n        {{ profile?.memoryGraph?.length || 0 }} observations from your work patterns\n      </p>\n\n      <div v-if=\"profile?.memoryGraph?.length\" class=\"obs-list\">\n        <div\n          v-for=\"(obs, idx) in profile.memoryGraph\"\n          :key=\"idx\"\n          class=\"obs-card\"\n        >\n          <div class=\"obs-header\">\n            <span class=\"obs-entity\">{{ obs.entity }}</span>\n            <span class=\"obs-relation\">{{ obs.relation }}</span>\n          </div>\n          <div class=\"obs-value\">\n            {{ obs.value }}\n          </div>\n          <div class=\"obs-meta\">\n            <div class=\"confidence-bar\">\n              <div class=\"confidence-fill\" :style=\"{ width: (obs.confidence * 100) + '%' }\" />\n            </div>\n            <span class=\"obs-confidence\">{{ (obs.confidence * 100).toFixed(0) }}%</span>\n            <span class=\"obs-source\">{{ obs.source }}</span>\n          </div>\n        </div>\n      </div>\n      <p v-else class=\"obs-empty\">\n        No observations yet. They'll appear as FlowState learns your patterns.\n      </p>\n\n      <div v-if=\"profile?.memoryGraph?.length\" class=\"wp-action-row\">\n        <button class=\"wp-action-btn danger\" :disabled=\"isClearingMemories\" @click=\"onClearMemories\">\n          <Trash2 :size=\"14\" />\n          {{ isClearingMemories ? 'Clearing...' : 'Clear Memories' }}\n        </button>\n      </div>\n    </SettingsSection>\n  </div>\n</template>\n\n<style scoped>\n.ai-settings-tab {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-6);\n}\n\n.section-desc {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: 0 0 var(--space-3) 0;\n}\n\n/* ── Provider & Model Selector ── */\n.provider-chips {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-2);\n  margin-bottom: var(--space-3);\n}\n\n.provider-chip {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  gap: var(--space-0_5);\n  padding: var(--space-2_5) var(--space-3);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  background: var(--glass-bg-soft);\n  backdrop-filter: blur(8px);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n  text-align: left;\n}\n\n.provider-chip:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.provider-chip.active {\n  background: rgba(78, 205, 196, 0.1);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.provider-chip-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n}\n\n.provider-chip-desc {\n  font-size: var(--text-xs);\n  opacity: 0.7;\n}\n\n.model-selector {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.model-selector-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n  white-space: nowrap;\n}\n\n.model-select-wrapper {\n  flex: 1;\n}\n\n.model-select {\n  width: 100%;\n  padding: var(--space-2) var(--space-3);\n  font-size: var(--text-sm);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-primary);\n  cursor: pointer;\n  backdrop-filter: blur(8px);\n  appearance: auto;\n}\n\n.model-select:focus {\n  outline: none;\n  border-color: var(--brand-primary);\n}\n\n.refresh-models-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 32px;\n  height: 32px;\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-muted);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n  flex-shrink: 0;\n}\n\n.refresh-models-btn:hover {\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n/* ── Pricing Reference ── */\n.pricing-groups {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n}\n\n.pricing-group {\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  backdrop-filter: blur(8px);\n  overflow: hidden;\n}\n\n.pricing-group-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-3) var(--space-4);\n  border-bottom: 1px solid var(--glass-border);\n}\n\n.pricing-group-name {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n}\n\n.pricing-table {\n  width: 100%;\n  border-collapse: collapse;\n  font-size: var(--text-xs);\n}\n\n.pricing-table th {\n  text-align: left;\n  padding: var(--space-2) var(--space-3);\n  color: var(--text-muted);\n  font-weight: var(--font-medium);\n  border-bottom: 1px solid var(--glass-border);\n}\n\n.th-rate, .th-ctx {\n  text-align: right;\n}\n\n.pricing-table td {\n  padding: var(--space-2) var(--space-3);\n  color: var(--text-secondary);\n  border-bottom: 1px solid var(--glass-border);\n}\n\n.pricing-table tr:last-child td {\n  border-bottom: none;\n}\n\n.pricing-table tr.is-default td {\n  color: var(--text-primary);\n  font-weight: var(--font-medium);\n}\n\n.td-model {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n}\n\n.td-rate, .td-ctx {\n  text-align: right;\n  font-family: var(--font-mono, monospace);\n}\n\n.default-tag {\n  color: var(--brand-primary);\n  flex-shrink: 0;\n}\n\n/* ── Period Selector ── */\n.period-selector {\n  display: flex;\n  gap: var(--space-1);\n  background: var(--glass-bg-soft);\n  border-radius: var(--radius-lg);\n  padding: var(--space-1);\n  border: 1px solid var(--glass-border);\n}\n\n.period-btn {\n  flex: 1;\n  padding: var(--space-1_5) var(--space-2);\n  background: transparent;\n  border: 1px solid transparent;\n  border-radius: var(--radius-md);\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.period-btn:hover {\n  color: var(--text-secondary);\n  background: var(--glass-bg-medium);\n}\n\n.period-btn.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--text-primary);\n}\n\n/* ── Usage Content ── */\n.usage-content {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n}\n\n.summary-cards {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: var(--space-2);\n}\n\n.summary-card {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  backdrop-filter: blur(8px);\n}\n\n.summary-icon {\n  width: 32px;\n  height: 32px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--glass-bg-medium);\n  border-radius: var(--radius-md);\n  color: var(--brand-primary);\n  flex-shrink: 0;\n}\n\n.summary-info {\n  display: flex;\n  flex-direction: column;\n  min-width: 0;\n}\n\n.summary-label {\n  font-size: 10px;\n  color: var(--text-muted);\n  font-weight: var(--font-medium);\n}\n\n.summary-value {\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n/* ── Provider List ── */\n.provider-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.provider-row {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  padding: var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  backdrop-filter: blur(8px);\n}\n\n.provider-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.provider-indicator {\n  width: 10px;\n  height: 10px;\n  border-radius: var(--radius-full);\n  flex-shrink: 0;\n}\n\n.provider-name {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  flex: 1;\n}\n\n.provider-cost {\n  font-size: var(--text-xs);\n  font-weight: var(--font-bold);\n  color: var(--brand-primary);\n  font-family: var(--font-mono, monospace);\n}\n\n.provider-stats {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-2);\n}\n\n.provider-stat {\n  display: flex;\n  flex-direction: column;\n  gap: 2px;\n}\n\n.stat-label {\n  font-size: 10px;\n  color: var(--text-muted);\n  font-weight: var(--font-medium);\n}\n\n.stat-value {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n}\n\n/* ── Model Breakdown ── */\n.model-breakdown {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  padding-top: var(--space-2);\n  border-top: 1px solid var(--glass-border);\n}\n\n.model-row {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--space-1) var(--space-2);\n  background: var(--glass-bg-medium);\n  border-radius: var(--radius-sm);\n}\n\n.model-name {\n  font-size: 10px;\n  color: var(--text-secondary);\n  font-family: var(--font-mono, monospace);\n}\n\n.model-tokens {\n  font-size: 10px;\n  color: var(--text-muted);\n  font-family: var(--font-mono, monospace);\n}\n\n.no-period-data {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  text-align: center;\n  padding: var(--space-4);\n  margin: 0;\n}\n\n/* ── No Usage State ── */\n.no-usage {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-6);\n  color: var(--text-muted);\n  text-align: center;\n}\n\n.no-usage p {\n  margin: 0;\n  font-size: var(--text-xs);\n}\n\n/* ── Clear Button ── */\n.clear-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--color-danger);\n  border-radius: var(--radius-md);\n  color: var(--color-danger);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n  backdrop-filter: blur(8px);\n  align-self: flex-start;\n}\n\n.clear-btn:hover {\n  background: var(--danger-bg-subtle);\n}\n\n/* ── Weekly Plan Settings ── */\n.wp-setting-row {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  padding: var(--space-2) 0;\n}\n\n.wp-setting-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n}\n\n.day-chips,\n.number-chips {\n  display: flex;\n  gap: var(--space-1_5);\n  flex-wrap: wrap;\n}\n\n.day-chip,\n.number-chip {\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-soft);\n  backdrop-filter: blur(8px);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.day-chip:hover,\n.number-chip:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.day-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.day-chip.off.active {\n  background: rgba(239, 68, 68, 0.12);\n  border-color: var(--color-danger);\n  color: var(--color-danger);\n}\n\n.day-chip.meeting.active {\n  background: rgba(245, 158, 11, 0.12);\n  border-color: var(--color-warning);\n  color: var(--color-warning);\n}\n\n.number-chip {\n  width: 40px;\n  height: 36px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.number-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.style-chips {\n  display: flex;\n  gap: var(--space-2);\n}\n\n.style-chip {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-0_5);\n  padding: var(--space-2) var(--space-3);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-soft);\n  backdrop-filter: blur(8px);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.style-chip:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.style-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.style-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n}\n\n.style-desc {\n  font-size: var(--text-xs);\n  opacity: 0.7;\n}\n\n.save-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding-top: var(--space-3);\n}\n\n.save-btn {\n  padding: var(--space-2) var(--space-4);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--brand-primary);\n  border-radius: var(--radius-lg);\n  color: var(--brand-primary);\n  cursor: pointer;\n  backdrop-filter: blur(8px);\n  transition: all var(--duration-fast);\n}\n\n.save-btn:hover:not(:disabled) {\n  background: rgba(78, 205, 196, 0.08);\n}\n\n.save-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.save-message {\n  font-size: var(--text-sm);\n  color: var(--brand-primary);\n}\n\n.metrics-grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-3);\n}\n\n.metric-card {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n}\n\n.metric-value {\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.metric-label {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.wp-action-row {\n  display: flex;\n  gap: var(--space-3);\n  padding-top: var(--space-2);\n}\n\n.wp-action-btn {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.wp-action-btn:hover:not(:disabled) {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.wp-action-btn.danger:hover:not(:disabled) {\n  border-color: var(--color-danger);\n  color: var(--color-danger);\n}\n\n.wp-action-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.spinning {\n  animation: wp-spin 1s linear infinite;\n}\n\n@keyframes wp-spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n.learning-hint {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: 0;\n  line-height: var(--leading-relaxed);\n}\n\n.obs-hint {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: 0 0 var(--space-3) 0;\n}\n\n.obs-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.obs-card {\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n}\n\n.obs-header {\n  display: flex;\n  gap: var(--space-2);\n  align-items: center;\n  margin-bottom: var(--space-1);\n}\n\n.obs-entity {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--brand-primary);\n  background: rgba(78, 205, 196, 0.08);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-xs);\n}\n\n.obs-relation {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.obs-value {\n  font-size: var(--text-sm);\n  color: var(--text-primary);\n  margin-bottom: var(--space-1_5);\n}\n\n.obs-meta {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.confidence-bar {\n  flex: 1;\n  max-width: 80px;\n  height: 4px;\n  background: var(--glass-bg);\n  border-radius: 2px;\n  overflow: hidden;\n}\n\n.confidence-fill {\n  height: 100%;\n  background: var(--brand-primary);\n  border-radius: 2px;\n  transition: width var(--duration-normal);\n}\n\n.obs-confidence {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n  min-width: 32px;\n}\n\n.obs-source {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.obs-empty {\n  font-size: var(--text-sm);\n  color: var(--text-muted);\n  font-style: italic;\n  margin: 0;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/AboutSettingsTab.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/AccountSettingsTab.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/AppearanceSettingsTab.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/IntegrationsSettingsTab.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/NotificationsSettingsTab.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/StorageSettingsTab.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1033,1036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1033,1036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1071,1074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1071,1074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1179,1182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1179,1182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'confirmGoldenRestore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":93,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":93,"endColumn":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, onMounted, computed } from 'vue'\nimport {\n  Database,\n  Download,\n  Upload,\n  ShieldCheck,\n  AlertTriangle,\n  RotateCcw,\n  Clock,\n  History,\n  CloudLightning,\n  RefreshCw,\n  Cloud,\n  HardDrive\n} from 'lucide-vue-next'\nimport useBackupSystem from '@/composables/useBackupSystem'\nimport SettingsSection from '../SettingsSection.vue'\nimport SettingsToggle from '../SettingsToggle.vue'\nimport SettingsOptionPicker from '../SettingsOptionPicker.vue'\nimport { isTauri, getTauriMode, setTauriMode } from '@/composables/useTauriStartup'\nimport { useTaskStore } from '@/stores/tasks'\nimport { clearAll as clearAllOperations } from '@/services/offline/writeQueueDB'\n\nconst {\n  config,\n  backupHistory,\n  createBackup,\n  downloadBackup,\n  restoreFromFile,\n  restoreFromGoldenBackup,\n  restoreFromGoldenBackupByIndex,\n  getGoldenBackupValidation,\n  getGoldenBackups,\n  fetchShadowBackup,\n  restoreFromShadow,\n  restoreBackup\n} = useBackupSystem()\n\nconst isRestoring = ref(false)\nconst validationInfo = ref<any>(null)\nconst shadowSnapshot = ref<any>(null)\nconst showValidation = ref(false)\nconst isScanningShadow = ref(false)\nconst goldenRotation = ref<any[]>([])\n\n// Tauri mode state (only shown in Tauri desktop app)\nconst showTauriMode = computed(() => isTauri())\nconst currentTauriMode = ref<'cloud' | 'local'>(getTauriMode())\n\nconst backupIntervals = [\n  { value: 60000, label: '1 min' },\n  { value: 300000, label: '5 min' },\n  { value: 900000, label: '15 min' },\n  { value: 3600000, label: '1 hour' }\n]\n\nconst historySizes = [\n  { value: 5, label: '5' },\n  { value: 10, label: '10' },\n  { value: 25, label: '25' },\n  { value: 50, label: '50' }\n]\n\nconst handleModeChange = (mode: 'cloud' | 'local') => {\n  currentTauriMode.value = mode\n  setTauriMode(mode)\n\n  // Warn user they need to restart the app\n  alert(`Mode changed to ${mode === 'cloud' ? 'Cloud' : 'Local'}. Please restart the app for changes to take effect.`)\n}\n\nconst handleCreateBackup = async () => {\n  await createBackup('manual')\n}\n\nconst handleDownloadLatest = async () => {\n  await downloadBackup()\n}\n\nconst handleFileUpload = async (event: Event) => {\n  const file = (event.target as HTMLInputElement).files?.[0]\n  if (file) {\n    const success = await restoreFromFile(file)\n    if (success) {\n      alert('Backup restored successfully!')\n    }\n  }\n}\n\n\n\nconst confirmGoldenRestore = async () => {\n  isRestoring.value = true\n  const success = await restoreFromGoldenBackup(true) // skip validation since we just did it\n  isRestoring.value = false\n  if (success) {\n    alert('Golden backup restored!')\n    showValidation.value = false\n  }\n}\n\nconst checkShadowHub = async () => {\n  isScanningShadow.value = true\n  shadowSnapshot.value = await fetchShadowBackup()\n  isScanningShadow.value = false\n}\n\nconst handleShadowRestore = async () => {\n  if (!shadowSnapshot.value) return\n  if (!confirm('This will overwrite all local data with the latest cloud snapshot. Continue?')) return\n  \n  isRestoring.value = true\n  const success = await restoreFromShadow(shadowSnapshot.value)\n  isRestoring.value = false\n  if (success) {\n    alert('Restored from Shadow Hub successfully!')\n  }\n}\n\nconst handleGoldenRestore = async (index: number) => {\n  isRestoring.value = true\n  const success = await restoreFromGoldenBackupByIndex(index, true)\n  isRestoring.value = false\n  if (success) {\n    alert(`Golden backup #${index + 1} restored!`)\n  }\n}\n\n// TASK-1183: Data cleanup handlers\nconst taskStore = useTaskStore()\nconst isCleaningUp = ref(false)\nconst isClearingSyncQueue = ref(false)\nconst cleanupResult = ref<{ success: boolean; message: string } | null>(null)\n\nconst handleCleanupTasks = async () => {\n  isCleaningUp.value = true\n  cleanupResult.value = null\n  try {\n    const fixed = await taskStore.cleanupCorruptedTasks()\n    cleanupResult.value = {\n      success: true,\n      message: fixed > 0 ? `Fixed ${fixed} corrupted task(s)` : 'No corrupted tasks found'\n    }\n  } catch (e) {\n    cleanupResult.value = {\n      success: false,\n      message: `Error: ${e instanceof Error ? e.message : 'Unknown error'}`\n    }\n  } finally {\n    isCleaningUp.value = false\n  }\n}\n\nconst handleClearSyncQueue = async () => {\n  if (!confirm('This will clear all pending sync operations. Continue?')) return\n\n  isClearingSyncQueue.value = true\n  cleanupResult.value = null\n  try {\n    await clearAllOperations()\n    cleanupResult.value = {\n      success: true,\n      message: 'Sync queue cleared successfully'\n    }\n  } catch (e) {\n    cleanupResult.value = {\n      success: false,\n      message: `Error: ${e instanceof Error ? e.message : 'Unknown error'}`\n    }\n  } finally {\n    isClearingSyncQueue.value = false\n  }\n}\n\nonMounted(async () => {\n    // Initial checks\n    validationInfo.value = await getGoldenBackupValidation()\n    goldenRotation.value = getGoldenBackups()\n    checkShadowHub()\n})\n</script>\n\n<template>\n  <div class=\"storage-settings-tab\">\n    <!-- Tauri Desktop Mode Selector (only shown in desktop app) -->\n    <SettingsSection v-if=\"showTauriMode\" title=\"💻 Desktop Connection Mode\">\n      <div class=\"mode-selector-panel\">\n        <p class=\"mode-description\">\n          Choose how your desktop app connects to your data\n        </p>\n\n        <div class=\"mode-options\">\n          <button\n            class=\"mode-option\"\n            :class=\"{ active: currentTauriMode === 'cloud' }\"\n            @click=\"handleModeChange('cloud')\"\n          >\n            <div class=\"mode-option-icon\">\n              <Cloud :size=\"24\" />\n            </div>\n            <div class=\"mode-option-content\">\n              <h4 class=\"mode-option-title\">\n                Cloud Mode\n                <span v-if=\"currentTauriMode === 'cloud'\" class=\"mode-badge\">Active</span>\n              </h4>\n              <p class=\"mode-option-desc\">\n                Connect to in-theflow.com (VPS)\n              </p>\n              <ul class=\"mode-option-features\">\n                <li>✓ Sync across devices</li>\n                <li>✓ No local setup required</li>\n                <li>✓ Automatic backups</li>\n              </ul>\n            </div>\n          </button>\n\n          <button\n            class=\"mode-option\"\n            :class=\"{ active: currentTauriMode === 'local' }\"\n            @click=\"handleModeChange('local')\"\n          >\n            <div class=\"mode-option-icon\">\n              <HardDrive :size=\"24\" />\n            </div>\n            <div class=\"mode-option-content\">\n              <h4 class=\"mode-option-title\">\n                Local Mode\n                <span v-if=\"currentTauriMode === 'local'\" class=\"mode-badge\">Active</span>\n              </h4>\n              <p class=\"mode-option-desc\">\n                Run your own database (Docker)\n              </p>\n              <ul class=\"mode-option-features\">\n                <li>✓ Full data control</li>\n                <li>✓ Works offline</li>\n                <li>⚠️ Requires Docker setup</li>\n              </ul>\n            </div>\n          </button>\n        </div>\n\n        <p class=\"mode-help-text\">\n          <AlertTriangle :size=\"14\" />\n          Changing modes requires an app restart. Your data will not be lost.\n        </p>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"🛡️ Backup Strategy\">\n      <SettingsToggle\n        label=\"Auto-Backup Enabled\"\n        description=\"Automatically save your data locally every few minutes.\"\n        :value=\"config.enabled\"\n        @update=\"val => config.enabled = val\"\n      />\n      \n      <SettingsOptionPicker\n        label=\"Backup Interval\"\n        description=\"How often to perform automatic snapshots.\"\n        :options=\"backupIntervals\"\n        :value=\"config.autoSaveInterval\"\n        @update=\"val => config.autoSaveInterval = val\"\n      />\n\n      <SettingsOptionPicker\n        label=\"History Retention\"\n        description=\"Maximum number of historical snapshots to keep.\"\n        :options=\"historySizes\"\n        :value=\"config.maxHistorySize\"\n        @update=\"val => config.maxHistorySize = val\"\n      />\n\n      <SettingsToggle\n        label=\"Filter Test Data\"\n        description=\"Exclude mock/test tasks from backups.\"\n        :value=\"config.filterMockTasks\"\n        @update=\"val => config.filterMockTasks = val\"\n      />\n    </SettingsSection>\n\n    <SettingsSection title=\"💾 Manual Actions\">\n      <div class=\"action-grid\">\n        <button class=\"action-card\" @click=\"handleCreateBackup\">\n          <Database :size=\"20\" />\n          <div class=\"action-info\">\n            <span class=\"action-title\">Snapshot Now</span>\n            <span class=\"action-desc\">Save current state to local history</span>\n          </div>\n        </button>\n\n        <button class=\"action-card\" @click=\"handleDownloadLatest\">\n          <Download :size=\"20\" />\n          <div class=\"action-info\">\n            <span class=\"action-title\">Download Backup</span>\n            <span class=\"action-desc\">Save latest backup as a .json file</span>\n          </div>\n        </button>\n\n        <label class=\"action-card upload-card\">\n          <Upload :size=\"20\" />\n          <div class=\"action-info\">\n            <span class=\"action-title\">Import File</span>\n            <span class=\"action-desc\">Restore from a previously saved file</span>\n          </div>\n          <input\n            type=\"file\"\n            hidden\n            accept=\".json\"\n            @change=\"handleFileUpload\"\n          >\n        </label>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"☁️ Shadow Hub (Always-On Sync)\">\n      <div class=\"shadow-panel\" :class=\"{ 'is-loading': isScanningShadow }\">\n        <div class=\"shadow-header\">\n          <div class=\"hub-icon\">\n            <CloudLightning :size=\"24\" />\n          </div>\n          <div class=\"shadow-meta\">\n            <span class=\"shadow-title\">System 3: Mirror Daemon</span>\n            <span v-if=\"shadowSnapshot\" class=\"shadow-active\">Connected • Monitoring Database</span>\n            <span v-else class=\"shadow-idle\">Connecting to local daemon...</span>\n          </div>\n          <button class=\"refresh-btn\" :disabled=\"isScanningShadow\" @click=\"checkShadowHub\">\n            <RefreshCw :size=\"14\" :class=\"{ 'spinning': isScanningShadow }\" />\n          </button>\n        </div>\n\n        <div v-if=\"shadowSnapshot\" class=\"shadow-stats\">\n          <div class=\"shadow-stat\">\n            <span class=\"stat-label\">Last Sync</span>\n            <span class=\"stat-value\">{{ new Date(shadowSnapshot.meta.timestamp).toLocaleTimeString() }}</span>\n          </div>\n          <div class=\"shadow-stat\">\n            <span class=\"stat-label\">Tasks</span>\n            <span class=\"stat-value\">{{ shadowSnapshot.meta.counts.tasks }}</span>\n          </div>\n        </div>\n\n        <div v-if=\"shadowSnapshot\" class=\"shadow-actions\">\n          <button class=\"shadow-restore-btn\" :disabled=\"isRestoring\" @click=\"handleShadowRestore\">\n            <RotateCcw :size=\"16\" />\n            <span>{{ isRestoring ? 'Restoring...' : 'Restore Latest Cloud Snapshot' }}</span>\n          </button>\n          <p class=\"shadow-help\">\n            Best for: Recovering from sync errors or data loss on other devices.\n          </p>\n        </div>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"🌟 Disaster Recovery (Golden Backup Rotation)\">\n      <div v-if=\"goldenRotation.length > 0\" class=\"golden-panel\">\n        <div class=\"golden-header\">\n          <ShieldCheck class=\"icon-success\" :size=\"32\" />\n          <div class=\"golden-meta\">\n            <span class=\"golden-title\">Peak Task Snapshots</span>\n            <span class=\"golden-status\">{{ goldenRotation.length }} recovery point{{ goldenRotation.length > 1 ? 's' : '' }} available</span>\n          </div>\n        </div>\n\n        <div v-if=\"validationInfo?.ageWarning\" class=\"warning-box\">\n          <AlertTriangle :size=\"16\" />\n          <span>{{ validationInfo.ageWarning }}</span>\n        </div>\n\n        <!-- TASK-332: Show all golden backups in rotation -->\n        <div class=\"golden-rotation-list\">\n          <div\n            v-for=\"(backup, index) in goldenRotation\"\n            :key=\"backup.id\"\n            class=\"golden-rotation-item\"\n            :class=\"{ 'is-primary': index === 0 }\"\n          >\n            <div class=\"rotation-rank\">\n              <span class=\"rank-badge\">{{ index === 0 ? '🥇' : index === 1 ? '🥈' : '🥉' }}</span>\n            </div>\n            <div class=\"rotation-info\">\n              <span class=\"rotation-tasks\">{{ backup.metadata?.taskCount || 0 }} tasks</span>\n              <span class=\"rotation-date\">{{ new Date(backup.timestamp).toLocaleDateString() }}</span>\n            </div>\n            <button\n              class=\"rotation-restore-btn\"\n              :disabled=\"isRestoring\"\n              @click=\"handleGoldenRestore(index)\"\n            >\n              <RotateCcw :size=\"14\" />\n              <span>Restore</span>\n            </button>\n          </div>\n        </div>\n\n        <div v-if=\"validationInfo?.warnings?.length > 0\" class=\"detailed-warnings\">\n          <p class=\"warning-title\">\n            Smart Filtering (for top peak):\n          </p>\n          <ul>\n            <li v-for=\"(warn, i) in validationInfo.warnings\" :key=\"i\">\n              {{ warn }}\n            </li>\n          </ul>\n        </div>\n\n        <p class=\"golden-help\">\n          Golden backups capture your highest task counts. The system keeps up to 3 peaks for flexible recovery.\n        </p>\n      </div>\n      <div v-else class=\"no-golden\">\n        <History :size=\"32\" />\n        <p>No Golden Backup found yet. Keep working to create one!</p>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"🕒 Local History\">\n      <div class=\"history-list\">\n        <div v-for=\"item in backupHistory\" :key=\"item.id\" class=\"history-item\">\n          <div class=\"item-icon\">\n            <Clock :size=\"14\" />\n          </div>\n          <div class=\"item-details\">\n            <span class=\"item-time\">{{ new Date(item.timestamp).toLocaleString() }}</span>\n            <span class=\"item-meta\">{{ item.metadata?.taskCount }} tasks • {{ item.type }}</span>\n          </div>\n          <button class=\"item-restore\" @click=\"restoreBackup(item)\">\n            Restore\n          </button>\n        </div>\n      </div>\n    </SettingsSection>\n\n    <!-- TASK-1183: Data Cleanup Section -->\n    <SettingsSection title=\"🧹 Data Cleanup\">\n      <div class=\"cleanup-section\">\n        <p class=\"cleanup-description\">\n          Fix corrupted data that may cause sync errors. Run this if you see sync errors about invalid UUIDs.\n        </p>\n        <div class=\"cleanup-actions\">\n          <button class=\"cleanup-btn\" :disabled=\"isCleaningUp\" @click=\"handleCleanupTasks\">\n            <RefreshCw :size=\"16\" :class=\"{ spinning: isCleaningUp }\" />\n            {{ isCleaningUp ? 'Cleaning...' : 'Fix Corrupted Tasks' }}\n          </button>\n          <button class=\"cleanup-btn secondary\" :disabled=\"isClearingSyncQueue\" @click=\"handleClearSyncQueue\">\n            <RotateCcw :size=\"16\" />\n            {{ isClearingSyncQueue ? 'Clearing...' : 'Clear Sync Queue' }}\n          </button>\n        </div>\n        <p v-if=\"cleanupResult\" class=\"cleanup-result\" :class=\"{ success: cleanupResult.success }\">\n          {{ cleanupResult.message }}\n        </p>\n      </div>\n    </SettingsSection>\n  </div>\n</template>\n\n<style scoped>\n.storage-settings-tab {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n}\n\n/* Tauri Mode Selector */\n.mode-selector-panel {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n}\n\n.mode-description {\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n.mode-options {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: var(--space-3);\n}\n\n.mode-option {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n  padding: var(--space-4);\n  background: var(--glass-bg-soft);\n  border: 2px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n  text-align: left;\n}\n\n.mode-option:hover {\n  border-color: var(--glass-border-strong);\n  background: var(--glass-bg-medium);\n  transform: translateY(-1px);\n}\n\n.mode-option.active {\n  border-color: var(--color-success);\n  background: rgba(var(--color-success-rgb, 16, 185, 129), 0.1);\n}\n\n.mode-option-icon {\n  width: 48px;\n  height: 48px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--glass-bg-medium);\n  border-radius: var(--radius-lg);\n  color: var(--text-primary);\n}\n\n.mode-option.active .mode-option-icon {\n  background: var(--color-success);\n  color: white;\n}\n\n.mode-option-content {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.mode-option-title {\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  margin: 0;\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.mode-badge {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  color: var(--color-success);\n  background: rgba(var(--color-success-rgb, 16, 185, 129), 0.2);\n  padding: 2px 8px;\n  border-radius: var(--radius-full);\n}\n\n.mode-option-desc {\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n.mode-option-features {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.mode-option-features li {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.mode-help-text {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  font-size: var(--text-xs);\n  color: var(--color-warning);\n  background: rgba(var(--color-warning-rgb, 245, 158, 11), 0.1);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-lg);\n  margin: 0;\n}\n\n.action-grid {\n  display: grid;\n  grid-template-columns: 1fr;\n  gap: var(--space-2);\n}\n\n.action-card {\n  display: flex;\n  align-items: center;\n  gap: var(--space-4);\n  padding: var(--space-4);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  color: var(--text-primary);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n  text-align: left;\n  width: 100%;\n}\n\n.shadow-panel {\n  background: linear-gradient(135deg, rgba(var(--color-primary-rgb), 0.05) 0%, rgba(var(--color-primary-rgb), 0.1) 100%);\n  border: 1px solid var(--glass-border-strong);\n  border-radius: var(--radius-2xl);\n  padding: var(--space-4);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n  transition: all var(--duration-slow) var(--ease-out);\n}\n\n.shadow-panel.is-loading {\n  opacity: 0.7;\n}\n\n.shadow-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-4);\n}\n\n.hub-icon {\n  width: 48px;\n  height: 48px;\n  background: var(--state-active-bg);\n  border-radius: var(--radius-xl);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: var(--color-primary);\n}\n\n.shadow-meta {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.shadow-title {\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.shadow-active {\n  font-size: var(--text-xs);\n  color: var(--color-success);\n}\n\n.shadow-idle {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.refresh-btn {\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  color: var(--text-muted);\n  padding: var(--space-2);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n}\n\n.shadow-stats {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: var(--space-3);\n}\n\n.shadow-stat {\n  background: var(--glass-bg-soft);\n  padding: var(--space-3);\n  border-radius: var(--radius-xl);\n  display: flex;\n  flex-direction: column;\n}\n\n.shadow-actions {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.shadow-restore-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  background: var(--state-active-bg);\n  color: var(--text-primary);\n  border: 1px solid var(--state-active-border);\n  padding: var(--space-3);\n  border-radius: var(--radius-xl);\n  font-weight: var(--font-bold);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.shadow-restore-btn:hover:not(:disabled) {\n  background: var(--state-active-border);\n  transform: translateY(-1px);\n}\n\n.shadow-help {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  text-align: center;\n}\n\n.spinning {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n.action-card:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--glass-border-strong);\n  transform: translateY(-2px);\n}\n\n.action-info {\n  display: flex;\n  flex-direction: column;\n}\n\n.action-title {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n}\n\n.action-desc {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.upload-card {\n  margin-bottom: 0;\n}\n\n.golden-panel {\n  background: linear-gradient(135deg, rgba(var(--primary-rgb), 0.05) 0%, rgba(var(--primary-rgb), 0.1) 100%);\n  border: 1px solid var(--state-active-border);\n  border-radius: var(--radius-2xl);\n  padding: var(--space-5);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n}\n\n.golden-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-4);\n}\n\n.icon-success {\n  color: var(--color-success);\n}\n\n.golden-meta {\n  display: flex;\n  flex-direction: column;\n}\n\n.golden-title {\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.golden-status {\n  font-size: var(--text-xs);\n  color: var(--color-success);\n}\n\n.warning-box {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  background: rgba(var(--color-warning-rgb), 0.1);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-lg);\n  color: var(--color-warning);\n  font-size: var(--text-xs);\n}\n\n.stats-preview {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: var(--space-3);\n}\n\n.stat-item {\n  background: var(--glass-bg-soft);\n  padding: var(--space-3);\n  border-radius: var(--radius-xl);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.stat-label {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.stat-value {\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.stat-sub {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.detailed-warnings {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  background: var(--glass-bg-soft);\n  padding: var(--space-3);\n  border-radius: var(--radius-lg);\n}\n\n.warning-title {\n  font-weight: var(--font-bold);\n  margin-bottom: var(--space-1);\n}\n\n.detailed-warnings ul {\n  padding-left: var(--space-4);\n  margin: 0;\n}\n\n/* TASK-332: Golden backup rotation styles */\n.golden-rotation-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.golden-rotation-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-xl);\n  transition: all var(--duration-normal);\n}\n\n.golden-rotation-item.is-primary {\n  background: linear-gradient(135deg, rgba(var(--color-success-rgb), 0.1) 0%, rgba(var(--color-success-rgb), 0.05) 100%);\n  border-color: var(--color-success);\n}\n\n.rotation-rank {\n  width: 32px;\n  height: 32px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.rank-badge {\n  font-size: var(--text-lg);\n}\n\n.rotation-info {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.rotation-tasks {\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.rotation-date {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.rotation-restore-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.rotation-restore-btn:hover:not(:disabled) {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--text-primary);\n}\n\n.rotation-restore-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.golden-help {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  text-align: center;\n  margin-top: var(--space-2);\n}\n\n.restore-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  background: var(--text-primary);\n  color: var(--bg-primary);\n  border: none;\n  padding: var(--space-3);\n  border-radius: var(--radius-xl);\n  font-weight: var(--font-bold);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.restore-btn:hover:not(:disabled) {\n  transform: translateY(-2px);\n  filter: brightness(1.1);\n}\n\n.restore-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.history-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.history-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-soft);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--glass-border);\n}\n\n.item-icon {\n  color: var(--text-muted);\n}\n\n.item-details {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.item-time {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  color: var(--text-primary);\n}\n\n.item-meta {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.item-restore {\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-border);\n  color: var(--text-secondary);\n  padding: var(--space-1) var(--space-3);\n  border-radius: var(--radius-md);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.item-restore:hover {\n  background: var(--glass-border);\n  color: var(--text-primary);\n}\n\n.no-golden {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-8);\n  color: var(--text-muted);\n  text-align: center;\n}\n\n.loader {\n  width: 18px;\n  height: 18px;\n  border: 2px solid currentColor;\n  border-bottom-color: transparent;\n  border-radius: 50%;\n  animation: rotation 1s linear infinite;\n}\n\n@keyframes rotation {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* TASK-1183: Data Cleanup Section */\n.cleanup-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n}\n\n.cleanup-description {\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n.cleanup-actions {\n  display: flex;\n  gap: var(--space-3);\n  flex-wrap: wrap;\n}\n\n.cleanup-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2_5) var(--space-4);\n  background: var(--color-warning);\n  color: white;\n  border: none;\n  border-radius: var(--radius-md);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.cleanup-btn:hover:not(:disabled) {\n  background: var(--color-warning-hover, #d97706);\n  transform: translateY(-1px);\n}\n\n.cleanup-btn:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.cleanup-btn.secondary {\n  background: var(--glass-bg-medium);\n  color: var(--text-secondary);\n  border: 1px solid var(--glass-border);\n}\n\n.cleanup-btn.secondary:hover:not(:disabled) {\n  background: var(--glass-bg-strong);\n  border-color: var(--glass-border-strong);\n}\n\n.cleanup-result {\n  font-size: var(--text-sm);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-md);\n  background: var(--danger-bg-subtle);\n  color: var(--color-danger);\n}\n\n.cleanup-result.success {\n  background: var(--success-bg-subtle, rgba(16, 185, 129, 0.1));\n  color: var(--color-success, #10b981);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/TimerSettingsTab.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/WeeklyPlanSettingsTab.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"computed"},"fix":{"range":[37,47],"text":""},"desc":"Remove unused variable \"computed\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'addMemoryObservation' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":10,"column":90,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":110},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":73,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":73,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3226,3229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3226,3229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, computed, onMounted } from 'vue'\nimport { useWorkProfile } from '@/composables/useWorkProfile'\nimport { useSettingsStore } from '@/stores/settings'\nimport SettingsSection from '../SettingsSection.vue'\nimport SettingsToggle from '../SettingsToggle.vue'\nimport { RefreshCw, Trash2 } from 'lucide-vue-next'\n\nconst settingsStore = useSettingsStore()\nconst { profile, loadProfile, savePreferences, computeCapacityMetrics, resetLearnedData, addMemoryObservation } = useWorkProfile()\n\nconst isSaving = ref(false)\nconst isRecalculating = ref(false)\nconst isResetting = ref(false)\nconst saveMessage = ref('')\nconst isClearingMemories = ref(false)\n\n// Local editable form state\nconst form = ref({\n  workDays: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'] as string[],\n  daysOff: [] as string[],\n  heavyMeetingDays: [] as string[],\n  maxTasksPerDay: 6,\n  preferredWorkStyle: 'balanced' as 'frontload' | 'balanced' | 'backload',\n})\n\nconst dayOptions = [\n  { key: 'monday', label: 'Mon' },\n  { key: 'tuesday', label: 'Tue' },\n  { key: 'wednesday', label: 'Wed' },\n  { key: 'thursday', label: 'Thu' },\n  { key: 'friday', label: 'Fri' },\n  { key: 'saturday', label: 'Sat' },\n  { key: 'sunday', label: 'Sun' },\n]\n\nconst workStyleOptions = [\n  { key: 'frontload' as const, label: 'Front-load', desc: 'Heavy Mon-Tue, lighter Thu-Fri' },\n  { key: 'balanced' as const, label: 'Balanced', desc: 'Even distribution across days' },\n  { key: 'backload' as const, label: 'Back-load', desc: 'Lighter Mon-Tue, heavier Thu-Fri' },\n]\n\nonMounted(async () => {\n  const p = await loadProfile()\n  if (p) {\n    form.value.workDays = [...p.workDays]\n    form.value.daysOff = [...p.daysOff]\n    form.value.heavyMeetingDays = [...p.heavyMeetingDays]\n    form.value.maxTasksPerDay = p.maxTasksPerDay\n    form.value.preferredWorkStyle = p.preferredWorkStyle\n  }\n})\n\nfunction toggleDay(list: string[], key: string) {\n  const idx = list.indexOf(key)\n  if (idx === -1) list.push(key)\n  else list.splice(idx, 1)\n}\n\nasync function onSave() {\n  isSaving.value = true\n  saveMessage.value = ''\n  try {\n    await savePreferences({\n      workDays: [...form.value.workDays],\n      daysOff: [...form.value.daysOff],\n      heavyMeetingDays: [...form.value.heavyMeetingDays],\n      maxTasksPerDay: form.value.maxTasksPerDay,\n      preferredWorkStyle: form.value.preferredWorkStyle,\n    })\n    saveMessage.value = 'Preferences saved!'\n    setTimeout(() => { saveMessage.value = '' }, 3000)\n  } catch (err) {\n    saveMessage.value = 'Failed to save'\n  } finally {\n    isSaving.value = false\n  }\n}\n\nasync function onRecalculate() {\n  isRecalculating.value = true\n  try {\n    await computeCapacityMetrics()\n  } finally {\n    isRecalculating.value = false\n  }\n}\n\nasync function onReset() {\n  if (!confirm('Reset all learned patterns? This cannot be undone.')) return\n  isResetting.value = true\n  try {\n    await resetLearnedData()\n  } finally {\n    isResetting.value = false\n  }\n}\n\nasync function onClearMemories() {\n  if (!confirm('Clear all memory observations? The AI will need to re-learn patterns.')) return\n  isClearingMemories.value = true\n  try {\n    // Save empty memoryGraph\n    await savePreferences({ memoryGraph: [] } as any)\n  } finally {\n    isClearingMemories.value = false\n  }\n}\n</script>\n\n<template>\n  <div class=\"weekly-plan-settings-tab\">\n    <SettingsSection title=\"AI Learning\">\n      <SettingsToggle\n        label=\"Enable AI work profile learning\"\n        :value=\"settingsStore.aiLearningEnabled\"\n        @update=\"(v: boolean) => settingsStore.updateSetting('aiLearningEnabled', v)\"\n      />\n      <p class=\"learning-hint\">\n        When enabled, FlowState tracks your work patterns to make weekly plans smarter over time.\n      </p>\n    </SettingsSection>\n\n    <SettingsSection title=\"Planning Preferences\">\n      <div class=\"setting-row\">\n        <label class=\"setting-label\">Work days</label>\n        <div class=\"day-chips\">\n          <button\n            v-for=\"d in dayOptions\"\n            :key=\"d.key\"\n            class=\"day-chip\"\n            :class=\"{ active: form.workDays.includes(d.key) }\"\n            @click=\"toggleDay(form.workDays, d.key)\"\n          >\n            {{ d.label }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"setting-row\">\n        <label class=\"setting-label\">Days off</label>\n        <div class=\"day-chips\">\n          <button\n            v-for=\"d in dayOptions\"\n            :key=\"d.key\"\n            class=\"day-chip off\"\n            :class=\"{ active: form.daysOff.includes(d.key) }\"\n            @click=\"toggleDay(form.daysOff, d.key)\"\n          >\n            {{ d.label }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"setting-row\">\n        <label class=\"setting-label\">Heavy meeting days</label>\n        <div class=\"day-chips\">\n          <button\n            v-for=\"d in dayOptions\"\n            :key=\"d.key\"\n            class=\"day-chip meeting\"\n            :class=\"{ active: form.heavyMeetingDays.includes(d.key) }\"\n            @click=\"toggleDay(form.heavyMeetingDays, d.key)\"\n          >\n            {{ d.label }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"setting-row\">\n        <label class=\"setting-label\">Max tasks per day</label>\n        <div class=\"number-chips\">\n          <button\n            v-for=\"n in [3, 5, 6, 8, 10]\"\n            :key=\"n\"\n            class=\"number-chip\"\n            :class=\"{ active: form.maxTasksPerDay === n }\"\n            @click=\"form.maxTasksPerDay = n\"\n          >\n            {{ n }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"setting-row\">\n        <label class=\"setting-label\">Work style</label>\n        <div class=\"style-chips\">\n          <button\n            v-for=\"ws in workStyleOptions\"\n            :key=\"ws.key\"\n            class=\"style-chip\"\n            :class=\"{ active: form.preferredWorkStyle === ws.key }\"\n            @click=\"form.preferredWorkStyle = ws.key\"\n          >\n            <span class=\"style-label\">{{ ws.label }}</span>\n            <span class=\"style-desc\">{{ ws.desc }}</span>\n          </button>\n        </div>\n      </div>\n\n      <div class=\"save-row\">\n        <button class=\"save-btn\" :disabled=\"isSaving\" @click=\"onSave\">\n          {{ isSaving ? 'Saving...' : 'Save Preferences' }}\n        </button>\n        <span v-if=\"saveMessage\" class=\"save-message\">{{ saveMessage }}</span>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"Learned Patterns\">\n      <div class=\"metrics-grid\">\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.avgWorkMinutesPerDay ? Math.round(profile.avgWorkMinutesPerDay) + ' min' : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Avg work/day\n          </div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.avgTasksCompletedPerDay ? profile.avgTasksCompletedPerDay.toFixed(1) : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Avg tasks/day\n          </div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.avgPlanAccuracy ? profile.avgPlanAccuracy.toFixed(0) + '%' : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Plan accuracy\n          </div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-value\">\n            {{ profile?.peakProductivityDays?.length ? profile.peakProductivityDays.map(d => d.charAt(0).toUpperCase() + d.slice(1, 3)).join(', ') : '—' }}\n          </div>\n          <div class=\"metric-label\">\n            Peak days\n          </div>\n        </div>\n      </div>\n\n      <div class=\"action-row\">\n        <button class=\"action-btn\" :disabled=\"isRecalculating\" @click=\"onRecalculate\">\n          <RefreshCw :size=\"14\" :class=\"{ spinning: isRecalculating }\" />\n          {{ isRecalculating ? 'Recalculating...' : 'Recalculate' }}\n        </button>\n        <button class=\"action-btn danger\" :disabled=\"isResetting\" @click=\"onReset\">\n          <Trash2 :size=\"14\" />\n          {{ isResetting ? 'Resetting...' : 'Reset Profile' }}\n        </button>\n      </div>\n    </SettingsSection>\n\n    <SettingsSection title=\"Memory Observations\">\n      <p class=\"obs-hint\">\n        {{ profile?.memoryGraph?.length || 0 }} observations from your work patterns\n      </p>\n\n      <div v-if=\"profile?.memoryGraph?.length\" class=\"obs-list\">\n        <div\n          v-for=\"(obs, idx) in profile.memoryGraph\"\n          :key=\"idx\"\n          class=\"obs-card\"\n        >\n          <div class=\"obs-header\">\n            <span class=\"obs-entity\">{{ obs.entity }}</span>\n            <span class=\"obs-relation\">{{ obs.relation }}</span>\n          </div>\n          <div class=\"obs-value\">\n            {{ obs.value }}\n          </div>\n          <div class=\"obs-meta\">\n            <div class=\"confidence-bar\">\n              <div class=\"confidence-fill\" :style=\"{ width: (obs.confidence * 100) + '%' }\" />\n            </div>\n            <span class=\"obs-confidence\">{{ (obs.confidence * 100).toFixed(0) }}%</span>\n            <span class=\"obs-source\">{{ obs.source }}</span>\n          </div>\n        </div>\n      </div>\n      <p v-else class=\"obs-empty\">\n        No observations yet. They'll appear as FlowState learns your patterns.\n      </p>\n\n      <div v-if=\"profile?.memoryGraph?.length\" class=\"action-row\">\n        <button class=\"action-btn danger\" :disabled=\"isClearingMemories\" @click=\"onClearMemories\">\n          <Trash2 :size=\"14\" />\n          {{ isClearingMemories ? 'Clearing...' : 'Clear Memories' }}\n        </button>\n      </div>\n    </SettingsSection>\n  </div>\n</template>\n\n<style scoped>\n.weekly-plan-settings-tab {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-6);\n}\n\n.setting-row {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  padding: var(--space-2) 0;\n}\n\n.setting-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n}\n\n.day-chips,\n.number-chips {\n  display: flex;\n  gap: var(--space-1_5);\n  flex-wrap: wrap;\n}\n\n.day-chip,\n.number-chip {\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-soft);\n  backdrop-filter: blur(8px);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.day-chip:hover,\n.number-chip:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.day-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.day-chip.off.active {\n  background: rgba(239, 68, 68, 0.12);\n  border-color: var(--color-danger);\n  color: var(--color-danger);\n}\n\n.day-chip.meeting.active {\n  background: rgba(245, 158, 11, 0.12);\n  border-color: var(--color-warning);\n  color: var(--color-warning);\n}\n\n.number-chip {\n  width: 40px;\n  height: 36px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.number-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.style-chips {\n  display: flex;\n  gap: var(--space-2);\n}\n\n.style-chip {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-0_5);\n  padding: var(--space-2) var(--space-3);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-soft);\n  backdrop-filter: blur(8px);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.style-chip:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.style-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.style-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n}\n\n.style-desc {\n  font-size: var(--text-xs);\n  opacity: 0.7;\n}\n\n.save-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding-top: var(--space-3);\n}\n\n.save-btn {\n  padding: var(--space-2) var(--space-4);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--brand-primary);\n  border-radius: var(--radius-lg);\n  color: var(--brand-primary);\n  cursor: pointer;\n  backdrop-filter: blur(8px);\n  transition: all var(--duration-fast);\n}\n\n.save-btn:hover:not(:disabled) {\n  background: rgba(78, 205, 196, 0.08);\n}\n\n.save-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.save-message {\n  font-size: var(--text-sm);\n  color: var(--brand-primary);\n}\n\n.metrics-grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-3);\n}\n\n.metric-card {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n}\n\n.metric-value {\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n}\n\n.metric-label {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.action-row {\n  display: flex;\n  gap: var(--space-3);\n  padding-top: var(--space-2);\n}\n\n.action-btn {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.action-btn:hover:not(:disabled) {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.action-btn.danger:hover:not(:disabled) {\n  border-color: var(--color-danger);\n  color: var(--color-danger);\n}\n\n.action-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.spinning {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n.learning-hint {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: 0;\n  line-height: var(--leading-relaxed);\n}\n\n.obs-hint {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: 0 0 var(--space-3) 0;\n}\n\n.obs-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.obs-card {\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n}\n\n.obs-header {\n  display: flex;\n  gap: var(--space-2);\n  align-items: center;\n  margin-bottom: var(--space-1);\n}\n\n.obs-entity {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--brand-primary);\n  background: rgba(78, 205, 196, 0.08);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-xs);\n}\n\n.obs-relation {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.obs-value {\n  font-size: var(--text-sm);\n  color: var(--text-primary);\n  margin-bottom: var(--space-1_5);\n}\n\n.obs-meta {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.confidence-bar {\n  flex: 1;\n  max-width: 80px;\n  height: 4px;\n  background: var(--glass-bg);\n  border-radius: 2px;\n  overflow: hidden;\n}\n\n.confidence-fill {\n  height: 100%;\n  background: var(--brand-primary);\n  border-radius: 2px;\n  transition: width var(--duration-normal);\n}\n\n.obs-confidence {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n  min-width: 32px;\n}\n\n.obs-source {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n}\n\n.obs-empty {\n  font-size: var(--text-sm);\n  color: var(--text-muted);\n  font-style: italic;\n  margin: 0;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/settings/tabs/WorkflowSettingsTab.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/startup/TauriModeSelector.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/startup/TauriStartupScreen.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/sync/SyncErrorPopover.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/sync/SyncStatusIndicator.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/sync/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/BatchEditModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/DoneToggle.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/DragHandle.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/HierarchicalTaskRow.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/HierarchicalTaskRowContent.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4539,4542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4539,4542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4560,4563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4560,4563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    class=\"task-row\"\n    :class=\"{\n      'task-row--selected': selected,\n      'task-row--has-children': hasSubtasks,\n      'task-row--dragging': isDragging,\n      'task-row--drop-target': isDropTarget,\n      'task-row--mobile': isMobile,\n      'task-row--hovered': isHovered,\n      'task-row--focused': isFocused,\n      'task-row--completed': task.status === 'done',\n      'task-row--overdue': isOverdue,\n      'task-row--high-priority': task.priority === 'high',\n      'task-row--timer-active': isTimerActive\n    }\"\n    :data-status=\"task.status\"\n    :style=\"{\n      paddingLeft: `${indentLevel * 20 + 40}px`,\n      '--indent-level': indentLevel\n    }\"\n    draggable=\"true\"\n    @dragstart=\"$emit('dragstart', $event)\"\n    @dragend=\"$emit('dragend', $event)\"\n    @dragover.prevent=\"$emit('dragover', $event)\"\n    @drop.prevent=\"$emit('drop', $event)\"\n    @dragleave=\"$emit('dragleave', $event)\"\n    @click=\"$emit('rowClick', $event)\"\n    @contextmenu.prevent=\"$emit('contextMenu', $event)\"\n    @focusin=\"$emit('focusin', $event)\"\n    @focusout=\"$emit('focusout', $event)\"\n    @mouseenter=\"$emit('mouseenter', $event)\"\n    @mouseleave=\"$emit('mouseleave', $event)\"\n    @keydown=\"$emit('keydown', $event)\"\n    @touchstart=\"$emit('touchstart', $event)\"\n    @touchend=\"$emit('touchend', $event)\"\n  >\n    <!-- Done Toggle (Checkbox column) -->\n    <div class=\"task-row__done-toggle\" @click.stop>\n      <DoneToggle\n        :completed=\"task.status === 'done'\"\n        size=\"sm\"\n        variant=\"simple\"\n        :title=\"`Mark ${task.title} as ${task.status === 'done' ? 'incomplete' : 'complete'}`\"\n        :aria-label=\"`Toggle completion for ${task.title}`\"\n        @toggle=\"$emit('toggleComplete')\"\n      />\n    </div>\n\n    <!-- Title Cell -->\n    <TaskRowTitle\n      :title=\"task.title\"\n      :is-completed=\"task.status === 'done'\"\n      :is-hovered=\"isHovered\"\n      :is-selected=\"selected\"\n      :title-alignment-classes=\"titleAlignmentClasses\"\n      :has-subtasks=\"hasSubtasks\"\n      :completed-subtask-count=\"completedSubtaskCount\"\n      :total-subtasks=\"totalSubtasks\"\n      :is-all-subtasks-completed=\"isAllSubtasksCompleted\"\n    />\n\n    <!-- Project Indicator -->\n    <TaskRowProject\n      :visual=\"projectVisual\"\n      :project-display-name=\"projectDisplayName\"\n      :current-project-id=\"task.projectId\"\n      @update:project-id=\"(val) => $emit('updateProjectId', val)\"\n    />\n\n    <!-- Status Cell -->\n    <div class=\"task-row__status table-cell status-cell\" @click.stop>\n      <CustomSelect\n        :model-value=\"task.status || 'planned'\"\n        :options=\"statusOptions\"\n        placeholder=\"Select status...\"\n        @update:model-value=\"(val) => $emit('updateStatus', String(val))\"\n      />\n    </div>\n\n    <!-- Priority Badge -->\n    <TaskRowPriority\n      :priority=\"task.priority\"\n      @update:priority=\"(val) => $emit('updatePriority', val)\"\n    />\n\n    <!-- Due Date Cell -->\n    <TaskRowDueDate\n      :due-date=\"task.dueDate\"\n      @update:due-date=\"(val) => $emit('updateDueDate', val)\"\n    />\n\n    <!-- Progress Bar -->\n    <div class=\"task-row__progress\">\n      <div v-if=\"task.progress && task.progress > 0\" class=\"task-row__progress-bar\" :style=\"{ '--progress': `${task.progress}%` }\">\n        <div class=\"task-row__progress-bg\" />\n        <div class=\"task-row__progress-fill\" />\n        <span class=\"task-row__progress-text\">{{ task.progress }}%</span>\n      </div>\n      <span v-else class=\"task-row__no-progress\">-</span>\n    </div>\n\n    <!-- Action Buttons -->\n    <TaskRowActions\n      @start-timer=\"$emit('startTimer')\"\n      @edit=\"$emit('edit')\"\n      @duplicate=\"$emit('duplicate')\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport DoneToggle from '@/components/tasks/DoneToggle.vue'\nimport CustomSelect from '@/components/common/CustomSelect.vue'\nimport TaskRowTitle from './row/TaskRowTitle.vue'\nimport TaskRowProject from './row/TaskRowProject.vue'\nimport TaskRowPriority from './row/TaskRowPriority.vue'\nimport TaskRowDueDate from './row/TaskRowDueDate.vue'\nimport TaskRowActions from './row/TaskRowActions.vue'\n\ninterface Props {\n  task: Task\n  indentLevel: number\n  selected: boolean\n  isMobile: boolean\n  isFocused: boolean\n  isHovered: boolean\n  isDragging: boolean\n  isDropTarget: boolean\n  isOverdue: boolean\n  hasSubtasks: boolean\n  completedSubtaskCount: number\n  totalSubtasks: number\n  isAllSubtasksCompleted: boolean\n  titleAlignmentClasses: any\n  projectVisual: any\n  projectDisplayName: string\n  statusOptions: Array<{ label: string, value: string }>\n}\n\nconst props = defineProps<Props>()\n\ndefineEmits<{\n  dragstart: [event: DragEvent]\n  dragend: [event: DragEvent]\n  dragover: [event: DragEvent]\n  drop: [event: DragEvent]\n  dragleave: [event: DragEvent]\n  rowClick: [event: MouseEvent]\n  contextMenu: [event: MouseEvent]\n  focusin: [event: FocusEvent]\n  focusout: [event: FocusEvent]\n  mouseenter: [event: MouseEvent]\n  mouseleave: [event: MouseEvent]\n  keydown: [event: KeyboardEvent]\n  touchstart: [event: TouchEvent]\n  touchend: [event: TouchEvent]\n  toggleComplete: []\n  updateStatus: [val: string]\n  updateProjectId: [val: string | null]\n  updatePriority: [val: string]\n  updateDueDate: [val: string | null]\n  startTimer: []\n  edit: []\n  duplicate: []\n}>()\n\nconst timerStore = useTimerStore()\n\n// Timer active state\nconst isTimerActive = computed(() => {\n  return timerStore.isTimerActive && timerStore.currentTaskId === props.task.id\n})\n\n</script>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/QuickTaskCreate.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/QuickTaskCreateModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/SortProgress.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/TaskContextMenu.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":387,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12733,12736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12733,12736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":470,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":470,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div\n    v-if=\"isVisible\"\n    ref=\"menuRef\"\n    class=\"context-menu\"\n    :style=\"menuPosition\"\n  >\n    <!-- Header for inbox/batch operations -->\n    <div v-if=\"showInboxHeader\" class=\"context-menu-header\">\n      {{ displayHeaderText }}\n    </div>\n\n    <!-- Edit Task (only show for single task, not batch) -->\n    <button v-if=\"!isBatchOperation\" class=\"menu-item\" @click=\"handleEdit\">\n      <Pencil :size=\"16\" class=\"menu-icon\" />\n      <span class=\"menu-text\">Edit</span>\n      <span class=\"menu-shortcut\">Ctrl+E</span>\n    </button>\n\n    <div v-if=\"!isBatchOperation\" class=\"menu-divider\" />\n\n    <!-- AI Assist -->\n    <button class=\"menu-item menu-item--ai\" @click=\"openAIAssist\">\n      <Sparkles :size=\"16\" class=\"menu-icon menu-icon--ai\" />\n      <span class=\"menu-text\">AI Assist</span>\n    </button>\n\n    <!-- Date Section - Compact Pills -->\n    <div class=\"menu-section menu-section--tight\">\n      <div class=\"section-header section-header--inline\">\n        <Calendar :size=\"12\" class=\"section-icon\" />\n        <span class=\"section-title\">Date</span>\n      </div>\n      <div class=\"pill-row\">\n        <button class=\"pill-btn pill-btn--sm\" @click=\"setDueDate('today')\">\n          Today\n        </button>\n        <button class=\"pill-btn pill-btn--sm\" @click=\"setDueDate('tomorrow')\">\n          Tmrw\n        </button>\n        <button class=\"pill-btn pill-btn--sm\" @click=\"setDueDate('weekend')\">\n          Wknd\n        </button>\n        <button class=\"pill-btn pill-btn--sm\" @click=\"setDueDate('nextweek')\">\n          +1wk\n        </button>\n        <NPopover\n          trigger=\"click\"\n          placement=\"right-start\"\n          :show=\"showDatePicker\"\n          @update:show=\"showDatePicker = $event\"\n        >\n          <template #trigger>\n            <button class=\"pill-btn pill-btn--sm pill-btn--icon\" title=\"Pick date\">\n              <CalendarPlus :size=\"12\" />\n            </button>\n          </template>\n          <div class=\"date-picker-popover\" @click.stop>\n            <NDatePicker\n              panel\n              type=\"date\"\n              :value=\"currentDueDateTimestamp\"\n              :actions=\"null\"\n              @update:value=\"handleDatePickerSelect\"\n            />\n            <div class=\"date-picker-footer\">\n              <button class=\"footer-btn\" @click=\"setDueDate('nextmonth'); showDatePicker = false\">\n                +1mo\n              </button>\n              <button class=\"footer-btn\" @click=\"setDueDate('twomonths'); showDatePicker = false\">\n                +2mo\n              </button>\n              <button class=\"footer-btn\" @click=\"setDueDate('nextquarter'); showDatePicker = false\">\n                +3mo\n              </button>\n              <button class=\"footer-btn\" @click=\"setDueDate('halfyear'); showDatePicker = false\">\n                +6mo\n              </button>\n              <button class=\"footer-btn footer-btn--now\" @click=\"setDueDate('today'); showDatePicker = false\">\n                Now\n              </button>\n            </div>\n          </div>\n        </NPopover>\n      </div>\n    </div>\n\n    <!-- Done for now - prominent action -->\n    <button class=\"menu-item menu-item--highlight\" @click=\"handleDoneForNow\">\n      <Clock :size=\"16\" class=\"menu-icon\" />\n      <span class=\"menu-text\">Done for now</span>\n      <span class=\"menu-hint\">→ Tomorrow</span>\n    </button>\n\n    <div class=\"menu-divider\" />\n\n    <!-- Priority Section - Compact Pills -->\n    <div class=\"menu-section menu-section--tight\">\n      <div class=\"section-header section-header--inline\">\n        <Flag :size=\"12\" class=\"section-icon\" />\n        <span class=\"section-title\">Priority</span>\n      </div>\n      <div class=\"pill-row\">\n        <button\n          class=\"pill-btn pill-btn--sm pill-btn--priority-high\"\n          :class=\"{ active: currentTask?.priority === 'high' }\"\n          @click=\"setPriority('high')\"\n        >\n          <span class=\"priority-dot high\" />\n          High\n        </button>\n        <button\n          class=\"pill-btn pill-btn--sm pill-btn--priority-medium\"\n          :class=\"{ active: currentTask?.priority === 'medium' }\"\n          @click=\"setPriority('medium')\"\n        >\n          <span class=\"priority-dot medium\" />\n          Med\n        </button>\n        <button\n          class=\"pill-btn pill-btn--sm pill-btn--priority-low\"\n          :class=\"{ active: currentTask?.priority === 'low' }\"\n          @click=\"setPriority('low')\"\n        >\n          <span class=\"priority-dot low\" />\n          Low\n        </button>\n      </div>\n    </div>\n\n    <!-- Status & Duration Row -->\n    <div class=\"inline-row\">\n      <!-- Status with Submenu -->\n      <div\n        class=\"inline-select\"\n        @mouseenter=\"openSubmenu('status', $event)\"\n        @mouseleave=\"closeSubmenu('status')\"\n      >\n        <CheckCircle :size=\"14\" class=\"inline-icon\" />\n        <span class=\"inline-value\">{{ currentStatusLabel || 'Status' }}</span>\n        <ChevronDown :size=\"12\" class=\"inline-arrow\" />\n      </div>\n\n      <!-- Duration with Submenu -->\n      <div\n        class=\"inline-select\"\n        @mouseenter=\"openSubmenu('duration', $event)\"\n        @mouseleave=\"closeSubmenu('duration')\"\n      >\n        <Clock :size=\"14\" class=\"inline-icon\" />\n        <span class=\"inline-value\">{{ currentDurationLabel || 'Time' }}</span>\n        <ChevronDown :size=\"12\" class=\"inline-arrow\" />\n      </div>\n    </div>\n\n    <!-- Decomposed Submenus -->\n    <!-- BUG-1095: Pass parentVisible to ensure submenus close when parent closes -->\n    <StatusSubmenu\n      :is-visible=\"showStatusSubmenu\"\n      :parent-visible=\"isVisible\"\n      :style=\"statusSubmenuStyle\"\n      :current-status=\"currentTask?.status\"\n      @mouseenter=\"keepSubmenuOpen\"\n      @mouseleave=\"closeSubmenu('status')\"\n      @select=\"(s: string) => { closeAllSubmenusNow(); setStatus(s as 'planned' | 'in_progress' | 'done') }\"\n    />\n\n    <DurationSubmenu\n      :is-visible=\"showDurationSubmenu\"\n      :parent-visible=\"isVisible\"\n      :style=\"durationSubmenuStyle\"\n      :current-duration=\"currentTask?.estimatedDuration\"\n      @mouseenter=\"keepSubmenuOpen\"\n      @mouseleave=\"closeSubmenu('duration')\"\n      @select=\"(d: number | null) => { closeAllSubmenusNow(); setDuration(d) }\"\n    />\n\n    <!-- Quick Actions Row -->\n    <div class=\"action-bar\">\n      <button\n        class=\"action-btn action-btn--done\"\n        :class=\"{ active: currentTask?.status === 'done' }\"\n        title=\"Mark Done (D)\"\n        @click=\"toggleDone\"\n      >\n        <CheckCircle :size=\"16\" />\n        <span class=\"action-label\">Done</span>\n      </button>\n      <button class=\"action-btn action-btn--start\" title=\"Start Now (S)\" @click=\"startTaskNow\">\n        <Play :size=\"16\" />\n        <span class=\"action-label\">Start</span>\n      </button>\n      <button class=\"action-btn action-btn--timer\" title=\"Start Timer (Space)\" @click=\"startTimer\">\n        <Timer :size=\"16\" />\n        <span class=\"action-label\">Timer</span>\n      </button>\n      <button class=\"action-btn action-btn--focus\" title=\"Focus Mode (F)\" @click=\"enterFocus\">\n        <Eye :size=\"16\" />\n        <span class=\"action-label\">Focus</span>\n      </button>\n    </div>\n\n    <!-- More Actions with Submenu -->\n    <div\n      class=\"menu-item has-submenu\"\n      @mouseenter=\"openSubmenu('more', $event)\"\n      @mouseleave=\"closeSubmenu('more')\"\n    >\n      <MoreHorizontal :size=\"16\" class=\"menu-icon\" />\n      <span class=\"menu-text\">More</span>\n      <ChevronRight :size=\"14\" class=\"submenu-arrow\" />\n    </div>\n\n    <MoreSubmenu\n      :is-visible=\"showMoreSubmenu\"\n      :parent-visible=\"isVisible\"\n      :style=\"moreSubmenuStyle\"\n      :is-batch-operation=\"isBatchOperation\"\n      :task-id=\"currentTask?.id\"\n      @mouseenter=\"keepSubmenuOpen\"\n      @mouseleave=\"closeSubmenu('more')\"\n      @done-for-now=\"() => { closeAllSubmenusNow(); handleDoneForNow() }\"\n      @duplicate=\"() => { closeAllSubmenusNow(); duplicateTask() }\"\n      @pin-quick-task=\"() => { closeAllSubmenusNow(); pinAsQuickTask() }\"\n      @move-to-section=\"taskId => { closeAllSubmenusNow(); $emit('moveToSection', taskId); $emit('close') }\"\n      @clear-selection=\"() => { closeAllSubmenusNow(); clearSelection() }\"\n    />\n\n    <div class=\"menu-divider\" />\n\n    <!-- Delete -->\n    <button class=\"menu-item danger\" @click=\"deleteTask\">\n      <Trash2 :size=\"16\" class=\"menu-icon\" />\n      <span class=\"menu-text\">{{ deleteText }}</span>\n    </button>\n\n    <!-- AI Assist Popover -->\n    <AITaskAssistPopover\n      :is-visible=\"showAIAssist\"\n      :task=\"currentTask\"\n      :x=\"aiAssistPosition.x\"\n      :y=\"aiAssistPosition.y\"\n      context=\"context-menu\"\n      @close=\"closeAIAssist\"\n      @accept-priority=\"handleAIAcceptPriority\"\n      @accept-breakdown=\"handleAIAcceptBreakdown\"\n      @accept-date=\"handleAIAcceptDate\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onUnmounted, watch, inject } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport {\n  Calendar,\n  CalendarPlus,\n  CheckCircle,\n  Timer,\n  Clock,\n  Eye,\n  Play,\n  Flag,\n  ChevronRight,\n  ChevronDown,\n  Pencil,\n  Trash2,\n  MoreHorizontal,\n  Sparkles\n} from 'lucide-vue-next'\nimport { NPopover, NDatePicker } from 'naive-ui'\nimport { FOCUS_MODE_KEY } from '@/composables/useFocusMode'\nimport type { FocusModeState } from '@/composables/useFocusMode'\nimport type { Task } from '@/stores/tasks'\n\n// New Architecture Imports\nimport { useTaskContextMenuActions } from '@/composables/tasks/useTaskContextMenuActions'\nimport { useQuickTasks } from '@/composables/useQuickTasks'\nimport { useToast } from '@/composables/useToast'\nimport { statusOptions } from './context-menu/constants'\nimport StatusSubmenu from './context-menu/StatusSubmenu.vue'\nimport DurationSubmenu from './context-menu/DurationSubmenu.vue'\nimport MoreSubmenu from './context-menu/MoreSubmenu.vue'\nimport AITaskAssistPopover from '@/components/ai/AITaskAssistPopover.vue'\n\ninterface Props {\n  isVisible: boolean\n  x: number\n  y: number\n  task: Task | null\n  compactMode?: boolean\n  selectedCount?: number\n  contextTask?: Task | null\n}\n\nconst props = defineProps<Props>()\n\nconst emit = defineEmits<{\n  close: []\n  edit: [taskId: string]\n  confirmDelete: [taskId: string, instanceId?: string, isCalendarEvent?: boolean]\n  clearSelection: []\n  setPriority: [priority: 'low' | 'medium' | 'high']\n  setStatus: [status: 'planned' | 'in_progress' | 'done']\n  setDueDate: [dateType: 'today' | 'tomorrow' | 'weekend' | 'nextweek']\n  enterFocusMode: []\n  deleteSelected: []\n  setDuration: [duration: number | null]\n  moveToSection: [taskId: string]\n}>()\n\n// Use the new composable for business logic\nconst {\n  currentTask,\n  isBatchOperation,\n  handleEdit,\n  setDueDate,\n  setPriority,\n  setStatus,\n  setDuration,\n  toggleDone,\n  startTaskNow,\n  startTimer,\n  duplicateTask,\n  deleteTask,\n  clearSelection\n} = useTaskContextMenuActions(props, emit)\n\nconst focusModeState = inject<FocusModeState | null>(FOCUS_MODE_KEY, null)\nconst enterFocusModeFn = focusModeState?.enterFocusMode || null\n\n// Direct store access for custom date handling\nconst taskStore = useTaskStore()\nconst canvasStore = useCanvasStore()\n\nconst menuRef = ref<HTMLElement | null>(null)\nconst showDatePicker = ref(false)\n\n// AI Assist popover state\nconst showAIAssist = ref(false)\nconst aiAssistPosition = ref({ x: 0, y: 0 })\n\n// Submenu state\nconst showStatusSubmenu = ref(false)\nconst showDurationSubmenu = ref(false)\nconst showMoreSubmenu = ref(false)\nconst submenuTimeout = ref<ReturnType<typeof setTimeout> | null>(null)\nconst statusSubmenuPosition = ref({ x: 0, y: 0 })\nconst durationSubmenuPosition = ref({ x: 0, y: 0 })\nconst moreSubmenuPosition = ref({ x: 0, y: 0 })\n\n// Computed properties for display\nconst showInboxHeader = computed(() => {\n  return (props.selectedCount && props.selectedCount > 0) || props.contextTask\n})\n\nconst displayHeaderText = computed(() => {\n  if (props.contextTask) {\n    return props.contextTask.title\n  } else if (props.selectedCount && props.selectedCount > 1) {\n    return `${props.selectedCount} selected`\n  }\n  return ''\n})\n\nconst currentStatusLabel = computed(() => {\n  const status = currentTask.value?.status\n  return statusOptions.find(s => s.value === status)?.label || ''\n})\n\nconst currentDurationLabel = computed(() => {\n  const duration = currentTask.value?.estimatedDuration\n  if (!duration) return ''\n  if (duration === 15) return '15m'\n  if (duration === 30) return '30m'\n  if (duration === 60) return '1h'\n  if (duration === 120) return '2h'\n  return `${duration}m`\n})\n\nconst deleteText = computed(() => {\n  if (isBatchOperation.value) {\n    return `Delete ${props.selectedCount}`\n  }\n  const task = currentTask.value\n  return (task && 'isCalendarEvent' in task && (task as any).isCalendarEvent) ? 'Remove' : 'Delete'\n})\n\n// Date picker value (timestamp in milliseconds for Naive UI)\nconst currentDueDateTimestamp = computed(() => {\n  const dueDate = currentTask.value?.dueDate\n  if (!dueDate) return null\n  const date = new Date(dueDate)\n  return isNaN(date.getTime()) ? null : date.getTime()\n})\n\n// Handle date selection from picker - directly update task store\nconst handleDatePickerSelect = async (timestamp: number | null) => {\n  if (!timestamp || !currentTask.value) return\n\n  // Use local date components to avoid timezone shift\n  const date = new Date(timestamp)\n  const year = date.getFullYear()\n  const month = String(date.getMonth() + 1).padStart(2, '0')\n  const day = String(date.getDate()).padStart(2, '0')\n  const formattedDate = `${year}-${month}-${day}`\n\n  // Close the popover first\n  showDatePicker.value = false\n\n  // Update the task directly via task store\n  try {\n    await taskStore.updateTaskWithUndo(currentTask.value.id, { dueDate: formattedDate })\n    canvasStore.requestSync('user:context-menu')\n  } catch (error) {\n    console.error('Error updating task due date:', error)\n  }\n\n  emit('close')\n}\n\n// Handle \"Done for now\" - reschedule task to tomorrow with tracking badge\nconst handleDoneForNow = async () => {\n  // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n  emit('close')\n\n  if (!currentTask.value) return\n\n  const { showToast } = useToast()\n\n  // Calculate tomorrow's date\n  const tomorrow = new Date()\n  tomorrow.setDate(tomorrow.getDate() + 1)\n  const year = tomorrow.getFullYear()\n  const month = String(tomorrow.getMonth() + 1).padStart(2, '0')\n  const day = String(tomorrow.getDate()).padStart(2, '0')\n  const tomorrowStr = `${year}-${month}-${day}`\n\n  try {\n    // Set both dueDate and doneForNowUntil to track the badge\n    await taskStore.updateTaskWithUndo(currentTask.value.id, {\n      dueDate: tomorrowStr,\n      doneForNowUntil: tomorrowStr\n    })\n    canvasStore.requestSync('user:context-menu')\n    showToast('Moved to tomorrow', 'success', { duration: 2000 })\n  } catch (error) {\n    console.error('Error updating task due date:', error)\n    showToast('Failed to reschedule task', 'error')\n  }\n}\n\n// FEATURE-1248: Pin task as quick task shortcut\nconst { pinFromTask } = useQuickTasks()\nconst pinAsQuickTask = async () => {\n    emit('close')\n    if (!currentTask.value) return\n    const { showToast } = useToast()\n    try {\n        await pinFromTask(currentTask.value)\n        showToast('Pinned as Quick Task', 'success', { duration: 2000 })\n    } catch (error) {\n        console.error('Error pinning quick task:', error)\n        showToast('Failed to pin task', 'error')\n    }\n}\n\n// AI Assist handlers\nconst openAIAssist = (event: MouseEvent) => {\n  const menuRect = menuRef.value?.getBoundingClientRect()\n  if (menuRect) {\n    aiAssistPosition.value = {\n      x: menuRect.right + 4,\n      y: menuRect.top\n    }\n  } else {\n    aiAssistPosition.value = { x: props.x + 240, y: props.y }\n  }\n  showAIAssist.value = true\n}\n\nconst closeAIAssist = () => {\n  showAIAssist.value = false\n}\n\nconst handleAIAcceptPriority = (priority: string, duration: number) => {\n  if (!currentTask.value) return\n  const validPriority = ['low', 'medium', 'high'].includes(priority) ? priority as 'low' | 'medium' | 'high' : undefined\n  if (validPriority) setPriority(validPriority)\n  if (duration) setDuration(duration)\n  emit('close')\n}\n\nconst handleAIAcceptBreakdown = async (tasks: Array<{ title: string; priority?: string }>) => {\n  for (const t of tasks) {\n    const validPriority = ['low', 'medium', 'high'].includes(t.priority || '') ? t.priority as 'low' | 'medium' | 'high' : 'medium'\n    await taskStore.createTask({\n      title: t.title,\n      priority: validPriority,\n      status: 'planned'\n    })\n  }\n  showAIAssist.value = false\n  emit('close')\n}\n\nconst handleAIAcceptDate = async (date: string) => {\n  if (!currentTask.value) return\n  try {\n    await taskStore.updateTaskWithUndo(currentTask.value.id, { dueDate: date })\n    canvasStore.requestSync('user:context-menu')\n  } catch (error) {\n    console.error('Error updating task due date from AI:', error)\n  }\n  showAIAssist.value = false\n  emit('close')\n}\n\n// Menu positioning\nconst menuPosition = computed(() => {\n  if (!menuRef.value) {\n    return { left: props.x + 'px', top: props.y + 'px' }\n  }\n\n  const menuHeight = menuRef.value.offsetHeight || 400\n  const menuWidth = menuRef.value.offsetWidth || 240\n  const viewportHeight = window.innerHeight\n  const viewportWidth = window.innerWidth\n  const padding = 8\n\n  let left = props.x\n  let top = props.y\n\n  if (top + menuHeight > viewportHeight - padding) {\n    top = props.y - menuHeight\n  }\n  if (left + menuWidth > viewportWidth - padding) {\n    left = viewportWidth - menuWidth - padding\n  }\n  if (left < padding) left = padding\n  if (top < padding) top = padding\n\n  return { left: left + 'px', top: top + 'px', position: 'absolute' as const }\n})\n\n// Submenu styles\nconst statusSubmenuStyle = computed(() => ({\n  left: statusSubmenuPosition.value.x + 'px',\n  top: statusSubmenuPosition.value.y + 'px'\n}))\n\nconst durationSubmenuStyle = computed(() => ({\n  left: durationSubmenuPosition.value.x + 'px',\n  top: durationSubmenuPosition.value.y + 'px'\n}))\n\nconst moreSubmenuStyle = computed(() => ({\n  left: moreSubmenuPosition.value.x + 'px',\n  top: moreSubmenuPosition.value.y + 'px'\n}))\n\n// Submenu handlers\nconst openSubmenu = (type: 'status' | 'duration' | 'more', event: MouseEvent) => {\n  if (submenuTimeout.value) {\n    clearTimeout(submenuTimeout.value)\n    submenuTimeout.value = null\n  }\n\n  // BUG-1095: Close ALL other submenus before opening a new one\n  showStatusSubmenu.value = false\n  showDurationSubmenu.value = false\n  showMoreSubmenu.value = false\n\n  const target = event.currentTarget as HTMLElement\n  const triggerRect = target.getBoundingClientRect()\n  const menuRect = menuRef.value?.getBoundingClientRect()\n  const submenuWidth = 150\n\n  // BUG-1095: Position to the right of the MENU, not the trigger\n  let x = menuRect ? menuRect.right + 4 : triggerRect.right + 4\n  // Y position stays relative to trigger for vertical alignment\n  let y = triggerRect.top\n\n  // Flip to left if not enough space on right\n  if (x + submenuWidth > window.innerWidth - 8) {\n    x = menuRect ? menuRect.left - submenuWidth - 4 : triggerRect.left - submenuWidth - 4\n  }\n\n  const submenuHeight = type === 'more' ? 100 : 180\n  if (y + submenuHeight > window.innerHeight - 8) {\n    y = window.innerHeight - submenuHeight - 8\n  }\n\n  if (type === 'status') {\n    statusSubmenuPosition.value = { x, y }\n    showStatusSubmenu.value = true\n  } else if (type === 'duration') {\n    durationSubmenuPosition.value = { x, y }\n    showDurationSubmenu.value = true\n  } else {\n    moreSubmenuPosition.value = { x, y }\n    showMoreSubmenu.value = true\n  }\n}\n\nconst keepSubmenuOpen = () => {\n  if (submenuTimeout.value) {\n    clearTimeout(submenuTimeout.value)\n    submenuTimeout.value = null\n  }\n}\n\nconst closeSubmenu = (type: 'status' | 'duration' | 'more') => {\n  submenuTimeout.value = setTimeout(() => {\n    if (type === 'status') showStatusSubmenu.value = false\n    else if (type === 'duration') showDurationSubmenu.value = false\n    else showMoreSubmenu.value = false\n  }, 150)\n}\n\n// BUG-1095: Immediately close ALL submenus - no timeout\nconst closeAllSubmenusNow = () => {\n  if (submenuTimeout.value) {\n    clearTimeout(submenuTimeout.value)\n    submenuTimeout.value = null\n  }\n  showStatusSubmenu.value = false\n  showDurationSubmenu.value = false\n  showMoreSubmenu.value = false\n}\n\nconst enterFocus = () => {\n  // BUG-1095: Close submenus first\n  closeAllSubmenusNow()\n  emit('close')\n\n  if (currentTask.value && !isBatchOperation.value && enterFocusModeFn) {\n    enterFocusModeFn(currentTask.value.id)\n  } else if (isBatchOperation.value) {\n    emit('enterFocusMode')\n  }\n}\n\n// Click outside handler\nconst handleClickOutside = (event: MouseEvent) => {\n  const target = event.target as HTMLElement\n  if (target.closest('.submenu')) return\n  if (menuRef.value && !menuRef.value.contains(target)) {\n    emit('close')\n  }\n}\n\nwatch(() => props.isVisible, (isVisible) => {\n  if (isVisible) {\n    setTimeout(() => document.addEventListener('click', handleClickOutside), 0)\n  } else {\n    document.removeEventListener('click', handleClickOutside)\n    showStatusSubmenu.value = false\n    showDurationSubmenu.value = false\n    showMoreSubmenu.value = false\n    showAIAssist.value = false\n  }\n})\n\nonUnmounted(() => {\n  document.removeEventListener('click', handleClickOutside)\n  if (submenuTimeout.value) clearTimeout(submenuTimeout.value)\n})\n</script>\n\n<style scoped>\n.context-menu {\n  position: absolute;\n  background: var(--overlay-component-bg);\n  backdrop-filter: var(--overlay-component-backdrop);\n  -webkit-backdrop-filter: var(--overlay-component-backdrop);\n  border: var(--overlay-component-border);\n  border-radius: var(--radius-lg);\n  box-shadow: var(--overlay-component-shadow);\n  padding: var(--space-2) 0;\n  min-width: 240px;\n  max-width: 280px;\n  z-index: var(--z-dropdown);\n  animation: menuSlideIn var(--duration-fast) var(--ease-out);\n}\n\n@keyframes menuSlideIn {\n  from { opacity: 0; transform: scale(0.96) translateY(-4px); }\n  to { opacity: 1; transform: scale(1) translateY(0); }\n}\n\n.context-menu-header {\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: 600;\n  color: var(--text-muted);\n  background: var(--glass-bg-light);\n  border-bottom: 1px solid var(--glass-border-light);\n  margin-bottom: var(--space-1);\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n/* Menu Items */\n.menu-item {\n  width: 100%;\n  background: transparent;\n  border: none;\n  color: var(--text-primary);\n  padding: var(--space-2) var(--space-3);\n  font-size: var(--text-sm);\n  text-align: left;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  transition: background var(--duration-fast);\n}\n\n.menu-item:hover { background: var(--glass-bg-heavy); }\n.menu-item.active { color: var(--brand-primary); }\n.menu-item.danger { color: var(--danger-text); }\n.menu-item.danger:hover { background: var(--danger-bg-subtle); }\n\n/* Highlighted menu item - stands out */\n.menu-item--highlight {\n  background: var(--amber-bg-light);\n  border-left: var(--space-0_75) solid var(--amber-text);\n  margin: var(--space-1) var(--space-2);\n  border-radius: var(--radius-md);\n  width: calc(100% - var(--space-4));\n}\n.menu-item--highlight:hover {\n  background: var(--amber-bg-medium);\n}\n.menu-item--highlight .menu-icon {\n  color: var(--amber-text);\n}\n\n.menu-hint {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  opacity: 0.7;\n}\n\n.menu-icon { flex-shrink: 0; opacity: 0.8; }\n.menu-text { flex: 1; }\n.menu-shortcut { color: var(--text-muted); font-size: var(--text-xs); opacity: 0.6; }\n\n.menu-divider {\n  height: 1px;\n  background: var(--glass-bg-heavy);\n  margin: var(--space-2) 0;\n}\n\n/* Sections */\n.menu-section { padding: var(--space-1_5) var(--space-3); }\n.menu-section--tight { padding: var(--space-1_5) var(--space-3) var(--space-2); }\n\n.section-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  margin-bottom: var(--space-2);\n}\n\n.section-header--inline {\n  margin-bottom: var(--space-1_5);\n}\n\n.section-icon { color: var(--text-muted); opacity: 0.6; }\n.section-title {\n  font-size: var(--text-xs);\n  font-weight: 600;\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n/* Pill Row */\n.pill-row {\n  display: flex;\n  gap: var(--space-1_5);\n  flex-wrap: nowrap;\n}\n\n.pill-btn {\n  padding: var(--space-1) var(--space-2_5);\n  border-radius: var(--radius-xl);\n  background: var(--glass-bg-heavy);\n  border: 1px solid var(--glass-border);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: 500;\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  white-space: nowrap;\n}\n\n.pill-btn--sm { padding: var(--space-1) var(--space-2); font-size: var(--text-xs); }\n\n.pill-btn:hover {\n  background: var(--glass-border);\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.pill-btn.active {\n  background: var(--brand-bg-subtle);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.pill-btn--icon {\n  padding: var(--space-0_5) var(--space-1);\n  min-width: 24px;\n  justify-content: center;\n}\n\n/* Priority Pills */\n.pill-btn--priority-high:hover,\n.pill-btn--priority-high.active {\n  background: var(--priority-high-bg);\n  border-color: var(--color-priority-high);\n  color: var(--color-priority-high);\n}\n\n.pill-btn--priority-medium:hover,\n.pill-btn--priority-medium.active {\n  background: var(--priority-medium-bg);\n  border-color: var(--color-priority-medium);\n  color: var(--color-priority-medium);\n}\n\n.pill-btn--priority-low:hover,\n.pill-btn--priority-low.active {\n  background: var(--priority-low-bg);\n  border-color: var(--color-priority-low);\n  color: var(--color-priority-low);\n}\n\n.priority-dot {\n  width: var(--space-1_75);\n  height: var(--space-1_75);\n  border-radius: var(--radius-full);\n}\n\n.priority-dot.high { background: var(--color-priority-high); }\n.priority-dot.medium { background: var(--color-priority-medium); }\n.priority-dot.low { background: var(--color-priority-low); }\n\n/* Date Picker Popover */\n.date-picker-popover {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.date-picker-footer {\n  display: flex;\n  gap: var(--space-1);\n  justify-content: flex-end;\n  padding-top: var(--space-2);\n  border-top: 1px solid var(--glass-border);\n}\n\n.footer-btn {\n  padding: 0 var(--space-2);\n  height: var(--space-7);\n  background: transparent;\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.footer-btn:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.footer-btn--now {\n  background: var(--brand-primary);\n  border-color: var(--brand-primary);\n  color: white;\n}\n\n.footer-btn--now:hover {\n  background: var(--brand-primary-hover, var(--brand-primary));\n}\n\n/* Inline Row for Status/Duration */\n.inline-row {\n  display: flex;\n  gap: var(--space-2);\n  padding: var(--space-1_5) var(--space-3) var(--space-2_5);\n}\n\n.inline-select {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-1_5) var(--space-2_5);\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-bg-heavy);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n}\n\n.inline-select:hover {\n  background: var(--glass-bg-heavy);\n  border-color: var(--glass-border-hover);\n}\n\n.inline-icon { color: var(--text-muted); flex-shrink: 0; }\n.inline-value { flex: 1; font-size: var(--text-xs); color: var(--text-secondary); }\n.inline-arrow { color: var(--text-muted); opacity: 0.5; }\n\n/* Action Bar */\n.action-bar {\n  display: flex;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  justify-content: space-between;\n}\n\n.action-btn {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-2_5) var(--space-1_5);\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-bg-heavy);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  transition: all var(--duration-fast) var(--spring-smooth);\n  color: var(--text-secondary);\n}\n\n.action-btn:hover {\n  background: var(--glass-bg-heavy);\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.action-btn--done { color: var(--color-work); }\n.action-btn--done:hover { background: var(--status-done-bg); border-color: var(--color-work); }\n.action-btn--done.active {\n  background: var(--status-done-bg);\n  border-color: var(--color-work);\n  color: var(--color-work);\n}\n\n.action-btn--start { color: var(--color-break); }\n.action-btn--start:hover { background: var(--status-in-progress-bg); border-color: var(--color-break); }\n\n.action-btn--timer { color: var(--brand-primary); }\n.action-btn--timer:hover { background: var(--brand-bg-subtle); border-color: var(--brand-primary); }\n\n.action-btn--focus { color: var(--color-focus); }\n.action-btn--focus:hover { background: var(--status-on-hold-bg); border-color: var(--color-focus); }\n\n.action-label { font-size: var(--text-xs); font-weight: 500; text-transform: uppercase; letter-spacing: 0.3px; }\n\n/* AI Assist Menu Item */\n.menu-item--ai {\n  color: var(--brand-primary);\n}\n\n.menu-item--ai:hover {\n  background: var(--brand-bg-subtle);\n}\n\n.menu-icon--ai {\n  color: var(--brand-primary);\n  opacity: 1;\n}\n\n/* Submenu */\n.has-submenu { position: relative; }\n.submenu-arrow { color: var(--text-muted); margin-left: auto; }\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/TaskEditModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/TaskList.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/TaskRow.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/TaskTable.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/context-menu/DurationSubmenu.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n<template>\n  <Teleport to=\"body\">\n    <div\n      v-if=\"isVisible && parentVisible\"\n      class=\"submenu\"\n      :style=\"style\"\n      @mouseenter=\"$emit('mouseenter')\"\n      @mouseleave=\"$emit('mouseleave')\"\n    >\n      <button\n        v-for=\"dur in durationOptions\"\n        :key=\"dur.value ?? 'none'\"\n        class=\"menu-item menu-item--sm\"\n        :class=\"{ active: currentDuration === dur.value }\"\n        @click.stop=\"handleSelect(dur.value)\"\n      >\n        <component\n          :is=\"dur.icon\"\n          :size=\"14\"\n          class=\"duration-icon\"\n          :class=\"[dur.class]\"\n        />\n        <span class=\"menu-text\">{{ dur.label }}</span>\n      </button>\n    </div>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport { durationOptions } from './constants'\nimport type { CSSProperties } from 'vue'\n\nconst props = defineProps<{\n  isVisible: boolean\n  parentVisible?: boolean // BUG-1095: Track parent menu visibility\n  style: CSSProperties\n  currentDuration?: number | null\n}>()\n\nconst emit = defineEmits<{\n  select: [duration: number | null]\n  mouseenter: []\n  mouseleave: []\n}>()\n\n// BUG-1095: Handle selection with immediate emit\nconst handleSelect = (duration: number | null) => {\n  emit('select', duration)\n}\n</script>\n\n<style scoped>\n/* Styles copied from TaskContextMenu.vue */\n.submenu {\n  position: fixed;\n  background: var(--overlay-component-bg);\n  backdrop-filter: var(--overlay-component-backdrop);\n  border: var(--overlay-component-border);\n  border-radius: var(--radius-lg);\n  box-shadow: var(--overlay-component-shadow);\n  padding: var(--space-1) 0;\n  min-width: 130px;\n  z-index: calc(var(--z-dropdown) + 1);\n  animation: menuSlideIn var(--duration-fast) var(--ease-out);\n}\n\n@keyframes menuSlideIn {\n  from { opacity: 0; transform: scale(0.96) translateY(-4px); }\n  to { opacity: 1; transform: scale(1) translateY(0); }\n}\n\n.menu-item {\n  width: 100%;\n  background: transparent;\n  border: none;\n  color: var(--text-primary);\n  padding: var(--space-1_5) var(--space-2_5);\n  font-size: var(--text-xs);\n  text-align: left;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  transition: background var(--duration-fast);\n}\n\n.menu-item:hover { background: var(--glass-bg-heavy); }\n.menu-item.active { color: var(--brand-primary); }\n\n.menu-text { flex: 1; }\n\n.duration-icon { flex-shrink: 0; }\n.duration-icon.quick { color: var(--green-text); }\n.duration-icon.short { color: var(--color-work); }\n.duration-icon.medium { color: var(--orange-text); }\n.duration-icon.long { color: var(--danger-text); }\n.duration-icon.none { color: var(--text-muted); }\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/context-menu/MoreSubmenu.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/context-menu/StatusSubmenu.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/context-menu/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/done-toggle/DoneToggleVisuals.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/drag-handle/DragHandleGhost.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/drag-handle/DragHandleHints.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/drag-handle/DragHandleVisuals.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/edit/RecurrenceSelector.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/edit/TaskEditChildTasks.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/edit/TaskEditHeader.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/edit/TaskEditMetadata.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/edit/TaskEditSubtasks.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/row/TaskRowActions.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/row/TaskRowDueDate.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/row/TaskRowPriority.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/row/TaskRowProject.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'props' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":92,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":92,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3038,3041],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3038,3041],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"task-row__project\" @click.stop>\n    <!-- Categorized: Show emoji -->\n    <span\n      v-if=\"visual.type === 'emoji'\"\n      class=\"project-emoji-badge project-visual--emoji\"\n      :title=\"`Project: ${projectDisplayName}`\"\n      @click=\"toggleDropdown\"\n    >\n      <ProjectEmojiIcon\n        :emoji=\"visual.content\"\n        size=\"xs\"\n      />\n    </span>\n    <!-- Categorized: Show color circle -->\n    <span\n      v-else-if=\"visual.type === 'css-circle'\"\n      class=\"project-emoji-badge project-visual--css-circle\"\n      :title=\"`Project: ${projectDisplayName}`\"\n      @click=\"toggleDropdown\"\n    >\n      <div\n        class=\"project-css-circle\"\n        :style=\"{ '--project-color': visual.color }\"\n      />\n    </span>\n    <!-- Uncategorized: Show subtle question mark -->\n    <span\n      v-else\n      class=\"project-placeholder\"\n      title=\"Click to assign a project\"\n      @click=\"toggleDropdown\"\n    >❓</span>\n\n    <!-- Project Selector Dropdown -->\n    <Transition name=\"dropdown-slide\">\n      <div v-if=\"isOpen\" class=\"project-dropdown\">\n        <div class=\"project-dropdown__list\">\n          <!-- Uncategorized option -->\n          <button\n            class=\"project-dropdown__item\"\n            :class=\"{ 'is-active': !currentProjectId }\"\n            @click=\"selectProject(null)\"\n          >\n            <span class=\"project-dropdown__icon\">❓</span>\n            <span class=\"project-dropdown__name\">Uncategorized</span>\n            <Check v-if=\"!currentProjectId\" :size=\"14\" class=\"project-dropdown__check\" />\n          </button>\n\n          <!-- Project items -->\n          <button\n            v-for=\"project in projects\"\n            :key=\"project.id\"\n            class=\"project-dropdown__item\"\n            :class=\"{ 'is-active': currentProjectId === project.id }\"\n            @click=\"selectProject(project.id)\"\n          >\n            <span class=\"project-dropdown__icon\">\n              <ProjectEmojiIcon\n                v-if=\"project.colorType === 'emoji' && project.emoji\"\n                :emoji=\"project.emoji\"\n                size=\"xs\"\n              />\n              <div\n                v-else-if=\"project.color\"\n                class=\"project-dropdown__color\"\n                :style=\"{ backgroundColor: Array.isArray(project.color) ? project.color[0] : project.color }\"\n              />\n            </span>\n            <span class=\"project-dropdown__name\">{{ project.name }}</span>\n            <Check v-if=\"currentProjectId === project.id\" :size=\"14\" class=\"project-dropdown__check\" />\n          </button>\n        </div>\n      </div>\n    </Transition>\n\n    <!-- Click outside overlay -->\n    <div\n      v-if=\"isOpen\"\n      class=\"project-dropdown__overlay\"\n      @click=\"closeDropdown\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onUnmounted } from 'vue'\nimport { Check } from 'lucide-vue-next'\nimport { useProjectStore } from '@/stores/projects'\nimport ProjectEmojiIcon from '@/components/base/ProjectEmojiIcon.vue'\n\nconst props = defineProps<{\n  visual: any\n  projectDisplayName: string\n  currentProjectId?: string | null\n}>()\n\nconst emit = defineEmits<{\n  'update:projectId': [projectId: string | null]\n}>()\n\nconst projectStore = useProjectStore()\nconst isOpen = ref(false)\n\nconst projects = computed(() => projectStore.projects)\n\nconst toggleDropdown = () => {\n  isOpen.value = !isOpen.value\n}\n\nconst closeDropdown = () => {\n  isOpen.value = false\n}\n\nconst selectProject = (projectId: string | null) => {\n  emit('update:projectId', projectId)\n  closeDropdown()\n}\n\n// Handle escape key to close dropdown\nconst handleEscapeKey = (event: KeyboardEvent) => {\n  if (event.key === 'Escape') {\n    closeDropdown()\n  }\n}\n\nonMounted(() => {\n  document.addEventListener('keydown', handleEscapeKey)\n})\n\nonUnmounted(() => {\n  document.removeEventListener('keydown', handleEscapeKey)\n})\n</script>\n\n<style scoped>\n.task-row__project {\n  grid-area: project;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n}\n\n.project-emoji-badge {\n  background: transparent;\n  border: none;\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--spring-smooth) ease;\n  padding: var(--space-0_5);\n  border-radius: var(--radius-full);\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-1);\n}\n\n.project-emoji-badge:hover {\n  background: var(--surface-hover);\n  transform: translateY(-1px) translateZ(0);\n}\n\n.project-css-circle {\n  width: var(--project-indicator-size-md, 24px);\n  height: var(--project-indicator-size-md, 24px);\n  border-radius: 50%;\n  background: var(--project-color);\n  box-shadow: var(--project-indicator-shadow-inset);\n  position: relative;\n  transition: all var(--spring-smooth) ease;\n}\n\n.project-emoji-badge:hover .project-css-circle {\n  transform: translateZ(0) scale(1.15);\n  box-shadow:\n    var(--project-indicator-shadow-inset),\n    0 0 16px var(--project-color),\n    0 0 32px var(--project-color);\n}\n\n/* Subtle placeholder for uncategorized tasks */\n.project-placeholder {\n  color: var(--text-muted);\n  font-size: var(--text-sm);\n  opacity: 0.5;\n  cursor: pointer;\n  transition: opacity var(--duration-fast) ease;\n}\n\n.project-placeholder:hover {\n  opacity: 0.8;\n}\n\n/* Project Selector Dropdown - Using design tokens for consistency */\n.project-dropdown {\n  position: absolute;\n  bottom: calc(100% + 4px); /* ADHD: Position ABOVE the trigger, not buried below */\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: var(--z-tooltip); /* High z-index to ensure visibility */\n\n  /* Glass morphism - using design tokens with solid fallback */\n  background-color: var(--overlay-component-bg);\n  background: var(--overlay-component-bg);\n  backdrop-filter: var(--overlay-component-backdrop);\n  -webkit-backdrop-filter: var(--overlay-component-backdrop);\n  border: var(--overlay-component-border);\n  box-shadow: var(--overlay-component-shadow-up);\n  border-radius: var(--radius-md);\n\n  min-width: 160px;\n  max-width: 220px;\n  max-height: 240px;\n  overflow: hidden;\n\n  /* Ensure backdrop-filter works and dropdown appears above other elements */\n  isolation: isolate;\n}\n\n.project-dropdown__list {\n  overflow-y: auto;\n  max-height: 200px;\n  padding: var(--space-1);\n}\n\n.project-dropdown__item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  width: 100%;\n  padding: var(--space-1_5) var(--space-2);\n  border: none !important;\n  background: none !important;\n  background-color: transparent !important;\n  color: var(--text-primary) !important;\n  font-size: var(--text-xs);\n  text-align: left;\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n  border-radius: var(--radius-md);\n  user-select: none;\n  white-space: nowrap;\n  min-height: 28px;\n}\n\n.project-dropdown__item:hover {\n  background: var(--glass-bg-heavy) !important;\n  background-color: var(--glass-bg-heavy) !important;\n}\n\n.project-dropdown__item.is-active {\n  /* Simple checkmark indicator, no background highlight */\n}\n\n.project-dropdown__icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: var(--space-5);\n  height: var(--space-5);\n  flex-shrink: 0;\n}\n\n.project-dropdown__color {\n  width: var(--space-3_5);\n  height: var(--space-3_5);\n  border-radius: var(--radius-full);\n}\n\n.project-dropdown__name {\n  flex: 1;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.project-dropdown__check {\n  flex-shrink: 0;\n  opacity: 0.7;\n}\n\n.project-dropdown__overlay {\n  position: fixed;\n  inset: 0;\n  z-index: var(--z-dropdown);\n}\n\n/* Dropdown transitions - slides down from above */\n.dropdown-slide-enter-active,\n.dropdown-slide-leave-active {\n  transition: all var(--duration-fast) ease;\n}\n\n.dropdown-slide-enter-from {\n  opacity: 0;\n  transform: translateX(-50%) translateY(4px); /* Slide down from above */\n}\n\n.dropdown-slide-leave-to {\n  opacity: 0;\n  transform: translateX(-50%) translateY(4px);\n}\n\n/* Custom scrollbar for dropdown list */\n.project-dropdown__list::-webkit-scrollbar {\n  width: var(--space-1);\n}\n\n.project-dropdown__list::-webkit-scrollbar-track {\n  background: transparent;\n}\n\n.project-dropdown__list::-webkit-scrollbar-thumb {\n  background: var(--glass-border);\n  border-radius: var(--radius-sm);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/tasks/row/TaskRowTitle.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/timer/QuickTaskDropdown.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ui/AuthStatusNotice.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ui/BraveBanner.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ui/LocalModeBanner.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/ui/WelcomeModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/weeklyplan/DayColumn.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/weeklyplan/WeeklyPlanGrid.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/components/weeklyplan/WeeklyTaskCard.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/__tests__/useDateTransition.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'expect' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":30,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"expect"},"fix":{"range":[22,30],"text":""},"desc":"Remove unused variable \"expect\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useDateTransition' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":27,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"useDateTransition"},"fix":{"range":[221,288],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { setActivePinia, createPinia } from 'pinia'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useDateTransition } from '@/composables/useDateTransition'\n\n// Mock the date transition composable to avoid real timers\nvi.mock('@/composables/useDateTransition', () => ({\n    useDateTransition: vi.fn(({ onDayChange }) => ({\n        startWatching: vi.fn(),\n        stopWatching: vi.fn(),\n        simulateTransition: () => onDayChange(new Date(), new Date())\n    }))\n}))\n\ndescribe('Date Transition Logic (TASK-082)', () => {\n    let canvasStore: any\n    let taskStore: any\n\n    beforeEach(() => {\n        setActivePinia(createPinia())\n        canvasStore = useCanvasStore()\n        taskStore = useTaskStore()\n    })\n\n    afterEach(() => {\n        vi.clearAllMocks()\n    })\n\n    it('moves tasks from \"Today\" to \"Overdue\" group on midnight transition', async () => {\n        // 1. Setup Groups\n        const todayGroup = {\n            id: 'group-today',\n            type: 'sectionNode',\n            name: 'Today', // Case insensitive check in implementation\n            position: { x: 0, y: 0, width: 300, height: 400 }\n        }\n\n        const overdueGroup = {\n            id: 'group-overdue',\n            type: 'sectionNode',\n            name: 'Overdue',\n            position: { x: 400, y: 0, width: 300, height: 400 }\n        }\n\n        // Add groups to store\n        // Note: Adjust based on actual store structure (groups vs sections)\n        canvasStore.sections = [todayGroup, overdueGroup]\n\n        // 2. Setup Task in \"Today\" group\n        const taskInToday = {\n            id: 'task-1',\n            title: 'Task in Today',\n            // Position visually inside Today group\n            canvasPosition: { x: 100, y: 100 },\n            isInInbox: false\n        }\n\n        const taskOutside = {\n            id: 'task-2',\n            title: 'Task Outside',\n            canvasPosition: { x: 800, y: 800 },\n            isInInbox: false\n        }\n\n        // Initialize tasks\n        taskStore.tasks = [taskInToday, taskOutside]\n\n        // 3. Trigger the logic\n        // We recreate the logic here since it lives in CanvasView.vue (which is hard to mount purely)\n        // or we verify the composable trigger. \n\n        // OPTION: We should move the logic from CanvasView to a composable/action to test it properly.\n        // For now, let's verify if we can extract the logic.\n    })\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/app/useAppInitialization.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2023,2026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2023,2026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2335,2338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2335,2338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11614,11617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11614,11617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12164,12167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12164,12167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12221,12224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12221,12224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12278,12281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12278,12281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":285,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13423,13426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13423,13426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":293,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13926,13929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13926,13929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13983,13986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13983,13986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":295,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14040,14043],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14040,14043],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":332,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":332,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15565,15568],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15565,15568],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":352,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16677,16680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16677,16680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":359,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17096,17099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17096,17099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":360,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17153,17156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17153,17156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":361,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":361,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17210,17213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17210,17213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20840,20843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20840,20843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":441,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21235,21238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21235,21238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":442,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21296,21299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21296,21299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":443,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":443,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21357,21360],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21357,21360],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":456,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":456,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21955,21958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21955,21958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":462,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":462,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22299,22302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22299,22302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":463,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":463,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22360,22363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22360,22363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":464,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":464,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22421,22424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22421,22424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":483,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":483,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23244,23247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23244,23247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":489,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":489,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23588,23591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23588,23591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":490,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":490,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23649,23652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23649,23652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":491,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":491,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23710,23713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23710,23713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, watch, onMounted, onUnmounted } from 'vue'\nimport { useTimerStore } from '@/stores/timer'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useProjectStore } from '@/stores/projects'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useUIStore } from '@/stores/ui'\nimport { useNotificationStore } from '@/stores/notifications'\nimport { useAuthStore } from '@/stores/auth'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useSupabaseDatabase, invalidateCache } from '@/composables/useSupabaseDatabase'\nimport { useSafariITPProtection } from '@/utils/safariITPProtection'\nimport { initGlobalKeyboardShortcuts } from '@/utils/globalKeyboardHandlerSimple'\nimport { clearGuestData, clearStaleGuestTasks } from '@/utils/guestModeStorage'\n// BUG-FIX: Import mappers to properly convert realtime data\nimport { fromSupabaseTask, fromSupabaseProject, fromSupabaseGroup, type SupabaseTask, type SupabaseProject, type SupabaseGroup } from '@/utils/supabaseMappers'\n// FEATURE-1118: Gamification hooks\nimport { useGamificationHooks } from '@/composables/useGamificationHooks'\n// FEATURE-1132: Challenge system\nimport { useChallengesStore } from '@/stores/challenges'\n// TASK-1177: Offline-first sync system\nimport { useSyncOrchestrator } from '@/composables/sync/useSyncOrchestrator'\nimport { useBeforeUnload } from '@/composables/useBeforeUnload'\n// TASK-1219: Time block progress notifications\nimport { useTimeBlockNotifications } from '@/composables/useTimeBlockNotifications'\n\nexport function useAppInitialization() {\n    const timerStore = useTimerStore()\n    const taskStore = useTaskStore()\n    const projectStore = useProjectStore()\n    const canvasStore = useCanvasStore()\n    const uiStore = useUIStore()\n    const notificationStore = useNotificationStore()\n    const authStore = useAuthStore()\n    const gamificationStore = useGamificationStore()\n    const challengesStore = useChallengesStore()\n    const itpProtection = useSafariITPProtection()\n    const activeChannel = ref<any>(null)\n    const realtimeInitialized = ref(false)\n    const onMountedCompleted = ref(false)  // BUG-1106: Prevent race condition between watcher and onMounted\n\n    onMounted(async () => {\n        // MARK: SESSION START for stability guards\n        if (typeof window !== 'undefined') {\n            (window as any).FlowStateSessionStart = Date.now()\n        }\n\n\n        // 0. Initialize auth and clear guest data if not authenticated\n        await authStore.initialize()\n\n        if (!authStore.isAuthenticated) {\n            // Guest mode: clear all persisted data for fresh experience\n            clearGuestData()\n        } else {\n            // BUG-339: Clear ALL stale guest localStorage (including legacy keys)\n            // This fixes race condition and historical key naming issues\n            clearStaleGuestTasks()\n        }\n\n        // 1. Initial Load from Supabase\n\n        // TASK-1083: Clear SWR cache on page load to ensure fresh positions from DB\n        // This prevents stale cached positions from overriding newer data on other devices\n        invalidateCache.all()\n        console.log('🗑️ [TASK-1083] SWR cache cleared on page load')\n\n        uiStore.loadState()\n\n        // TASK-1060: Add retry wrapper for initial load to handle transient auth failures\n        const loadWithRetry = async (maxRetries = 3, delayMs = 1000) => {\n            for (let attempt = 1; attempt <= maxRetries; attempt++) {\n                try {\n                    await Promise.all([\n                        taskStore.loadFromDatabase(),\n                        projectStore.loadProjectsFromDatabase(),\n                        canvasStore.loadFromDatabase()\n                    ])\n                    return // Success\n                } catch (error) {\n                    console.warn(`⚠️ [TASK-1060] Database load attempt ${attempt}/${maxRetries} failed:`, error)\n                    if (attempt === maxRetries) {\n                        throw error // Re-throw on final attempt\n                    }\n                    // Exponential backoff\n                    await new Promise(resolve => setTimeout(resolve, delayMs * attempt))\n                }\n            }\n        }\n\n        await loadWithRetry()\n\n        // TASK-1215: Load persisted filters (smart view, project, duration, etc.)\n        // This was previously missing — loadFromDatabase() only loads tasks,\n        // not the filter state. Without this, activeSmartView resets to null on restart.\n        await taskStore.loadPersistedFilters()\n\n        // BUG-1207: Tell auth store that app init has loaded stores\n        // This prevents the SIGNED_IN handler from doing a redundant double-load\n        authStore.markAppInitLoadComplete()\n\n        // FEATURE-1118: Initialize gamification system\n        try {\n            await gamificationStore.initialize()\n            // Record daily activity and update streak\n            const gamificationHooks = useGamificationHooks()\n            await gamificationHooks.onAppInitialized()\n            console.log('🎮 [GAMIFICATION] Initialized successfully')\n        } catch (error) {\n            console.warn('⚠️ Gamification system initialization failed:', error)\n        }\n\n        // FEATURE-1132: Initialize challenge system\n        try {\n            await challengesStore.initialize()\n            console.log('🎯 [CHALLENGES] Initialized successfully')\n        } catch (error) {\n            console.warn('⚠️ Challenge system initialization failed:', error)\n        }\n\n        // FEATURE-1317: Auto-refresh work profile insights (non-blocking)\n        if (authStore.isAuthenticated) {\n            try {\n                const { useWorkProfile } = await import('@/composables/useWorkProfile')\n                const { useSettingsStore: getSettings } = await import('@/stores/settings')\n                const settings = getSettings()\n                if (settings.aiLearningEnabled) {\n                    const wp = useWorkProfile()\n                    // Fire-and-forget: load profile then recalculate in background\n                    wp.loadProfile().then(() => {\n                        wp.computeCapacityMetrics().then(() => {\n                            console.log('📊 [FEATURE-1317] Work profile insights auto-refreshed')\n                        }).catch(e => console.debug('[FEATURE-1317] Auto-recalculate skipped:', e))\n                    }).catch(() => {})\n                }\n            } catch (error) {\n                console.debug('[FEATURE-1317] Work profile auto-refresh failed:', error)\n            }\n        }\n\n        // Initialize notification system\n        try {\n            await notificationStore.initializeNotifications()\n        } catch (error) {\n            console.warn('⚠️ Notification system initialization failed:', error)\n        }\n\n        // Request notification permission for timer\n        try {\n            await timerStore.requestNotificationPermission()\n        } catch (error) {\n            console.warn('⚠️ Timer notification permission request failed:', error)\n        }\n\n        // Safari ITP Protection\n        try {\n            itpProtection.initialize()\n            itpProtection.recordInteraction()\n        } catch (error) {\n            console.warn('⚠️ Safari ITP check failed:', error)\n        }\n\n        // TASK-1219 + BUG-1302: Time block progress notifications\n        // BUG-1303: Skip browser Notification.requestPermission() in Tauri — WebKitGTK\n        // can hang indefinitely on this call, blocking the entire init flow.\n        // Tauri uses its own notification plugin, not the Web Notification API.\n        try {\n            const isTauriRuntime = typeof window !== 'undefined' && '__TAURI__' in window\n            if (!isTauriRuntime && typeof Notification !== 'undefined' && Notification.permission === 'default') {\n                const perm = await Notification.requestPermission()\n                console.log('[TIME-BLOCK] Notification permission:', perm)\n            }\n            const timeBlockNotifications = useTimeBlockNotifications()\n            timeBlockNotifications.start()\n            console.log('[TIME-BLOCK] Initialized successfully')\n        } catch (error) {\n            console.warn('[TIME-BLOCK] Initialization failed:', error)\n        }\n\n        // Initialize global keyboard shortcuts\n        await initGlobalKeyboardShortcuts()\n\n        // BUG-1178: Handle timer action from URL query params (fallback when SW postMessage fails)\n        // This handles the case where user clicks notification action but window wasn't ready\n        // The SW opens a new window with action in URL: /?action=START_BREAK&taskId=xxx\n        if (typeof window !== 'undefined') {\n            const urlParams = new URLSearchParams(window.location.search)\n            const action = urlParams.get('action')\n            const taskIdFromUrl = urlParams.get('taskId')\n\n            if (action) {\n                console.log('🍅 [APP-INIT] Timer action from URL:', action, taskIdFromUrl)\n\n                // Small delay to ensure timer store is ready\n                setTimeout(() => {\n                    const settings = timerStore.settings\n\n                    switch (action) {\n                        case 'START_BREAK':\n                            timerStore.startTimer('break', settings.shortBreakDuration, true)\n                            break\n                        case 'START_WORK': {\n                            const taskId = taskIdFromUrl && taskIdFromUrl !== 'break' ? taskIdFromUrl : 'general'\n                            timerStore.startTimer(taskId, settings.workDuration, false)\n                            break\n                        }\n                        case 'POSTPONE_5MIN': {\n                            const postponeTaskId = taskIdFromUrl || 'general'\n                            const isBreak = postponeTaskId === 'break'\n                            timerStore.startTimer(postponeTaskId, 5 * 60, isBreak) // 5 minutes\n                            break\n                        }\n                    }\n\n                    // Clear the URL params after handling (to prevent re-triggering on refresh)\n                    window.history.replaceState({}, document.title, window.location.pathname)\n                }, 100)\n            }\n        }\n\n        // TASK-1177: Initialize offline-first sync system\n        // This starts the background queue processor and sets up online/offline listeners\n        try {\n            const syncOrchestrator = useSyncOrchestrator()\n            console.log('🔄 [SYNC] Offline-first sync system initialized')\n\n            // Process any pending operations from IndexedDB (queued while offline)\n            const stats = await syncOrchestrator.getQueueStats()\n            if (stats.pendingCount > 0) {\n                console.log(`📤 [SYNC] Found ${stats.pendingCount} pending operations - syncing...`)\n                // The orchestrator will auto-process these in the background\n            }\n        } catch (error) {\n            console.warn('⚠️ [SYNC] Sync system initialization failed (non-critical):', error)\n        }\n\n        // TASK-1177: Initialize beforeunload protection\n        // This warns users if they try to close the tab with unsaved changes\n        try {\n            useBeforeUnload()\n            console.log('🛡️ [SYNC] Page close protection enabled')\n        } catch (error) {\n            console.warn('⚠️ [SYNC] beforeunload protection failed (non-critical):', error)\n        }\n\n        // 3. Initialize Realtime Subscriptions\n        const { initRealtimeSubscription } = useSupabaseDatabase()\n\n        const onProjectChange = (payload: any) => {\n            // BUG-FIX: Fetch FRESH store instance inside callback to prevent stale closures\n            const canvas = useCanvasStore()\n            const projects = useProjectStore()\n            const tasks = useTaskStore()\n\n            // HARDENED LOCK: Check store, dragging, resizing, and settling flags\n            // BUG-1051: Fix sync race condition - also check for manual operations\n            const isLocked = canvas.isDragging || tasks.manualOperationInProgress || (typeof window !== 'undefined' && (\n                (window as any).__FlowStateIsDragging ||\n                (window as any).__FlowStateIsResizing ||\n                (window as any).__FlowStateIsSettling\n            ))\n\n            console.log('🔄 [HANDLER] onProjectChange called:', {\n                eventType: payload.eventType,\n                isLocked,\n                projectId: payload.new?.id?.substring(0, 8) || payload.old?.id?.substring(0, 8)\n            })\n\n            if (isLocked) {\n                console.log('🔒 [HANDLER] PROJECT change blocked - lock active')\n                return\n            }\n\n            const { eventType, new: newDoc, old: oldDoc } = payload\n            if (eventType === 'DELETE' || (newDoc && newDoc.is_deleted)) {\n                console.log('🗑️ [HANDLER] Removing project from sync')\n                projects.removeProjectFromSync(newDoc?.id || oldDoc?.id)\n            } else if (newDoc) {\n                // BUG-FIX: Map raw Supabase data to app format\n                const mappedProject = fromSupabaseProject(newDoc as SupabaseProject)\n                console.log('✅ [HANDLER] Updating project from sync:', mappedProject.name)\n                projects.updateProjectFromSync(mappedProject.id, mappedProject)\n            }\n        }\n\n        const onTaskChange = (payload: any) => {\n            // BUG-FIX: Fetch FRESH store instance inside callback to prevent stale closures\n            const canvas = useCanvasStore()\n            const tasks = useTaskStore()\n\n            // HARDENED LOCK: Check store, dragging, resizing, and settling flags\n            // BUG-1051: Fix sync race condition - also check for manual operations\n            const isLocked = canvas.isDragging || tasks.manualOperationInProgress || (typeof window !== 'undefined' && (\n                (window as any).__FlowStateIsDragging ||\n                (window as any).__FlowStateIsResizing ||\n                (window as any).__FlowStateIsSettling\n            ))\n\n            const { eventType, new: newDoc, old: oldDoc } = payload\n            const taskId = newDoc?.id || oldDoc?.id\n\n            console.log('🔄 [HANDLER] onTaskChange called:', {\n                eventType,\n                isLocked,\n                taskId: taskId?.substring(0, 8),\n                title: newDoc?.title?.substring(0, 20) || oldDoc?.title?.substring(0, 20)\n            })\n\n            if (isLocked) {\n                console.log('🔒 [HANDLER] TASK change blocked - lock active')\n                return\n            }\n\n            if (!taskId) {\n                console.log('⚠️ [HANDLER] TASK change skipped - no taskId')\n                return\n            }\n\n            // High Severity Issue #7: Skip if task is pending local write (drag in progress)\n            if (tasks.isPendingWrite(taskId)) {\n                console.log(`🔒 [HANDLER] TASK ${taskId.slice(0,8)} skipped - pending local write`)\n                return\n            }\n\n            // BUG-169 FIX: Safety guards to prevent spurious task deletions\n            // 1. Check for hard DELETE event (eventType === 'DELETE')\n            // 2. Check for soft delete ONLY if is_deleted is EXPLICITLY true (not just truthy)\n            const isHardDelete = eventType === 'DELETE'\n            const isSoftDelete = newDoc && newDoc.is_deleted === true\n\n            if (isHardDelete || isSoftDelete) {\n                // Extra safety: Check session start time\n                const sessionStart = (window as any).FlowStateSessionStart || 0\n                const timeSinceSessionStart = Date.now() - sessionStart\n\n                // Don't process deletions in the first 5 seconds of the session (anti-race guard)\n                if (timeSinceSessionStart < 5000) {\n                    console.warn(`⚠️ [HANDLER] BLOCKED deletion for task ${taskId.substring(0, 8)} - session just started`)\n                    return\n                }\n\n                console.log(`🗑️ [HANDLER] Removing task ${taskId.substring(0, 8)} from sync`)\n                tasks.updateTaskFromSync(taskId, null, true)\n            } else if (newDoc) {\n                // BUG-FIX: Map raw Supabase data to app format\n                // This ensures is_deleted -> _soft_deleted, position -> canvasPosition, etc.\n                const mappedTask = fromSupabaseTask(newDoc as SupabaseTask)\n                console.log(`✅ [HANDLER] Updating task ${taskId.substring(0, 8)} from sync:`, mappedTask.title?.substring(0, 20))\n                tasks.updateTaskFromSync(taskId, mappedTask, false)\n            }\n        }\n\n        const onGroupChange = (payload: any) => {\n            // BUG-FIX: Fetch FRESH store instance inside callback to prevent stale closures\n            const canvas = useCanvasStore()\n            const tasks = useTaskStore()\n\n            // HARDENED LOCK: Check store, dragging, resizing, and settling flags\n            const isLocked = canvas.isDragging || tasks.manualOperationInProgress || (typeof window !== 'undefined' && (\n                (window as any).__FlowStateIsDragging ||\n                (window as any).__FlowStateIsResizing ||\n                (window as any).__FlowStateIsSettling\n            ))\n\n            const { eventType, new: newDoc, old: oldDoc } = payload\n\n            console.log('🔄 [HANDLER] onGroupChange called:', {\n                eventType,\n                isLocked,\n                groupId: newDoc?.id?.substring(0, 8) || oldDoc?.id?.substring(0, 8),\n                name: newDoc?.name || oldDoc?.name\n            })\n\n            if (isLocked) {\n                console.log('🔒 [HANDLER] GROUP change blocked - lock active')\n                return\n            }\n\n            if (eventType === 'DELETE' || (newDoc && newDoc.is_deleted)) {\n                console.log('🗑️ [HANDLER] Removing group from sync')\n                canvas.removeGroupFromSync(newDoc?.id || oldDoc?.id)\n            } else if (newDoc) {\n                // BUG-1124 FIX: Map raw Supabase data to app format\n                // Groups need mapping: position_json -> position, and other field transformations\n                const mappedGroup = fromSupabaseGroup(newDoc as SupabaseGroup)\n                console.log('✅ [HANDLER] Updating group from sync:', mappedGroup.name, 'position:', mappedGroup.position)\n                canvas.updateGroupFromSync(mappedGroup.id, mappedGroup)\n            }\n        }\n\n        // TASK-1009: Consolidated Realtime subscription with ALL handlers\n        // Previously, timer store called initRealtimeSubscription separately, killing this channel\n        // Now we pass the timer handler here so there's only ONE subscription point\n        const timerHandler = timerStore.handleRemoteTimerUpdate\n\n        // BUG-1056: Recovery callback to reload data after WebSocket auth recovery\n        // This fixes intermittent \"0 tasks\" issue when initial load fails due to stale token\n        const onRecovery = async () => {\n            console.log('🔄 [APP-INIT] Reloading data after auth recovery...')\n            await Promise.all([\n                taskStore.loadFromDatabase(),\n                projectStore.loadProjectsFromDatabase(),\n                canvasStore.loadFromDatabase()\n            ])\n        }\n\n        const channel = initRealtimeSubscription(onProjectChange, onTaskChange, timerHandler, undefined, onGroupChange, onRecovery)\n        activeChannel.value = channel\n        realtimeInitialized.value = !!channel\n\n        if (channel) {\n            console.log('📡 [APP-INIT] Realtime subscription created with project, task, and timer handlers')\n        } else {\n            console.log('📡 [APP-INIT] No realtime subscription (user not authenticated yet)')\n        }\n\n        // BUG-1106: Mark onMounted as complete so watcher knows it can run\n        onMountedCompleted.value = true\n    })\n\n    // BUG-1106: Re-initialize realtime when user signs in after initial page load\n    // This handles the case where user opens the app as guest and later signs in via modal\n    watch(() => authStore.isAuthenticated, async (isAuthenticated, wasAuthenticated) => {\n        // Only trigger when:\n        // 1. Going from NOT authenticated to authenticated\n        // 2. Realtime wasn't already initialized\n        // 3. onMounted has completed (to prevent race condition with stored session)\n        if (isAuthenticated && !wasAuthenticated && !realtimeInitialized.value && onMountedCompleted.value) {\n            console.log('📡 [APP-INIT] User signed in after page load - initializing realtime subscription...')\n\n            const { initRealtimeSubscription } = useSupabaseDatabase()\n\n            // Simplified handlers for post-login initialization\n            // These use the same logic as the onMounted handlers\n            const onProjectChange = (payload: any) => {\n                const canvas = useCanvasStore()\n                const projects = useProjectStore()\n                const tasks = useTaskStore()\n\n                // BUG-1207: Add missing window flag checks (match primary handler)\n                const isLocked = canvas.isDragging || tasks.manualOperationInProgress || (typeof window !== 'undefined' && (\n                    (window as any).__FlowStateIsDragging ||\n                    (window as any).__FlowStateIsResizing ||\n                    (window as any).__FlowStateIsSettling\n                ))\n                if (isLocked) return\n\n                const { eventType, new: newDoc, old: oldDoc } = payload\n                if (eventType === 'DELETE' || (newDoc && newDoc.is_deleted)) {\n                    projects.removeProjectFromSync(newDoc?.id || oldDoc?.id)\n                } else if (newDoc) {\n                    const mappedProject = fromSupabaseProject(newDoc as SupabaseProject)\n                    projects.updateProjectFromSync(mappedProject.id, mappedProject)\n                }\n            }\n\n            const onTaskChange = (payload: any) => {\n                const canvas = useCanvasStore()\n                const tasks = useTaskStore()\n\n                // BUG-1207: Add missing window flag checks (match primary handler)\n                const isLocked = canvas.isDragging || tasks.manualOperationInProgress || (typeof window !== 'undefined' && (\n                    (window as any).__FlowStateIsDragging ||\n                    (window as any).__FlowStateIsResizing ||\n                    (window as any).__FlowStateIsSettling\n                ))\n                if (isLocked) return\n\n                const { eventType, new: newDoc, old: oldDoc } = payload\n                const taskId = newDoc?.id || oldDoc?.id\n                if (!taskId) return\n                if (tasks.isPendingWrite(taskId)) return\n\n                const isHardDelete = eventType === 'DELETE'\n                const isSoftDelete = newDoc && newDoc.is_deleted === true\n                if (isHardDelete || isSoftDelete) {\n                    tasks.updateTaskFromSync(taskId, null, true)\n                } else if (newDoc) {\n                    const mappedTask = fromSupabaseTask(newDoc as SupabaseTask)\n                    tasks.updateTaskFromSync(taskId, mappedTask, false)\n                }\n            }\n\n            const onGroupChange = (payload: any) => {\n                const canvas = useCanvasStore()\n                const tasks = useTaskStore()\n\n                // BUG-1207: Add missing window flag checks (match primary handler)\n                const isLocked = canvas.isDragging || tasks.manualOperationInProgress || (typeof window !== 'undefined' && (\n                    (window as any).__FlowStateIsDragging ||\n                    (window as any).__FlowStateIsResizing ||\n                    (window as any).__FlowStateIsSettling\n                ))\n                if (isLocked) return\n\n                const { eventType, new: newDoc, old: oldDoc } = payload\n                if (eventType === 'DELETE' || (newDoc && newDoc.is_deleted)) {\n                    canvas.removeGroupFromSync(newDoc?.id || oldDoc?.id)\n                } else if (newDoc) {\n                    // BUG-1207 FIX: Use fromSupabaseGroup mapper (was passing raw data)\n                    const mappedGroup = fromSupabaseGroup(newDoc as SupabaseGroup)\n                    canvas.updateGroupFromSync(mappedGroup.id, mappedGroup)\n                }\n            }\n\n            const onRecovery = async () => {\n                console.log('🔄 [APP-INIT] Reloading data after auth recovery...')\n                await Promise.all([\n                    taskStore.loadFromDatabase(),\n                    projectStore.loadProjectsFromDatabase(),\n                    canvasStore.loadFromDatabase()\n                ])\n            }\n\n            const timerHandler = timerStore.handleRemoteTimerUpdate\n            const channel = initRealtimeSubscription(onProjectChange, onTaskChange, timerHandler, undefined, onGroupChange, onRecovery)\n\n            if (channel) {\n                activeChannel.value = channel\n                realtimeInitialized.value = true\n                console.log('📡 [APP-INIT] Realtime subscription created after sign-in')\n            }\n        }\n    })\n\n    onUnmounted(() => {\n        if (activeChannel.value) {\n\n            activeChannel.value.unsubscribe()\n            activeChannel.value = null\n        }\n    })\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/app/useAppShortcuts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/app/useSidebarManagement.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":73,"column":32,"nodeType":"BlockStatement","messageId":"unexpected","endLine":75,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2482,2488],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":361,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":361,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12137,12140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12137,12140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, toRefs } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useUIStore } from '@/stores/ui'\nimport { useRouter } from 'vue-router'\nimport type { Project } from '@/types/tasks'\nimport { useSmartViews } from '@/composables/useSmartViews'\n\n/**\n * Sidebar Management State Management Composable\n *\n * Extracted from App.vue to centralize all sidebar-related state and functionality\n * including project navigation, smart views, quick task creation, and project management.\n *\n * This composable manages:\n * - Quick task creation and input state\n * - Project tree navigation and expansion\n * - Smart view selection and filtering\n * - Project hierarchy management\n * - Context menu handling for projects\n * - Drag and drop functionality for projects\n */\n\n// Shared state instances to ensure all components see the same sidebar state\nconst newTaskTitle = ref('')\nconst showCreateProject = ref(false)\n// const expandedProjects = ref<string[]>([]) // Moved to UI Store\nconst showProjectModal = ref(false)\nconst editingProject = ref<Project | null>(null)\n// const isDurationSectionExpanded = ref(true) // Moved to UI Store\n\nexport function useSidebarManagement() {\n  const taskStore = useTaskStore()\n  const uiStore = useUIStore()\n  const { isDurationSectionExpanded, expandedProjectIds: expandedProjects } = toRefs(uiStore)\n  const { isTodayTask, isWeekTask } = useSmartViews()\n\n  const router = useRouter()\n\n  // Platform detection\n  const isMac = typeof navigator !== 'undefined' && navigator.platform.toUpperCase().indexOf('MAC') >= 0\n\n  // Helper function to filter projects for sidebar display\n  const filterSidebarProjects = (projects: Project[]): Project[] => {\n    // ... (rest of function unchanged, just need to make sure we don't break indentation)\n\n\n    // FIX: More robust filtering logic\n    const filtered = projects.filter((p): p is Project => {\n      if (!p) return false // Remove null/undefined projects\n\n      if (!p.id) {\n        return false // Remove projects without ID\n      }\n\n      // Keep ALL real projects, filter out only synthetic ones\n      const isSynthetic = p.id.startsWith('synthetic')\n      if (isSynthetic) {\n        return false\n      }\n\n      // FIX: Additional validation for real projects\n      if (!p.name || p.name.trim() === '') {\n        return false\n      }\n\n\n      return true\n    })\n\n\n\n    // No projects is valid - user can have uncategorized tasks without any projects\n    if (filtered.length === 0) {\n\n    }\n\n    return filtered\n  }\n\n  // Computed Properties for Project Hierarchy\n  // Use centralized rootProjects from task store\n  const rootProjects = computed(() => {\n    const result = taskStore.rootProjects || []\n    return result\n  })\n\n  const getChildren = (parentId: string) => {\n    try {\n      const allProjects = Array.isArray(taskStore.projects) ? taskStore.projects : []\n      const childrenOnly = allProjects.filter(p => p && p.id && p.parentId === parentId)\n      return filterSidebarProjects(childrenOnly) // Exclude synthetic projects\n    } catch (error) {\n      console.error('❌ Error in getChildren computation:', error)\n      return []\n    }\n  }\n\n  const hasChildren = (projectId: string) => {\n    try {\n      const allProjects = Array.isArray(taskStore.projects) ? taskStore.projects : []\n      const childrenOnly = allProjects.filter(p => p && p.id && p.parentId === projectId)\n      return filterSidebarProjects(childrenOnly).length > 0 // Check if there are any child projects\n    } catch (error) {\n      console.error('❌ Error in hasChildren computation:', error)\n      return false\n    }\n  }\n\n  // Smart View Counts\n  // BUG-1210: Use centralized useSmartViews instead of duplicated logic.\n  // Previously had divergent logic (e.g., including all in_progress tasks\n  // regardless of date, excluding overdue) causing count/filter mismatches.\n  const todayTaskCount = computed(() => {\n    return taskStore.tasks.filter(task => {\n      if (task._soft_deleted) return false\n      return isTodayTask(task)\n    }).length\n  })\n\n  // BUG-1210: Use centralized useSmartViews instead of duplicated logic.\n  // Previously had divergent logic (e.g., including all in_progress tasks\n  // regardless of date, excluding overdue) causing count/filter mismatches.\n  const weekTaskCount = computed(() => {\n    return taskStore.tasks.filter(task => {\n      if (task._soft_deleted) return false\n      return isWeekTask(task)\n    }).length\n  })\n\n  // All Active task count - counts all non-done tasks\n  const allActiveCount = computed(() => {\n    // Use the centralized counter from task store for consistency\n    if (taskStore && typeof taskStore.nonDoneTaskCount === 'number') {\n      return taskStore.nonDoneTaskCount\n    }\n\n    // Fallback to manual filtering\n    return taskStore.tasks.filter(task => {\n      // BUG-FIX: Exclude soft-deleted tasks\n      if (task._soft_deleted) return false\n      // Count all tasks that are not marked as done\n      // This matches the \"all_active\" smart view logic\n      return task.status !== 'done'\n    }).length\n  })\n\n  // Uncategorized task count for Quick Sort badge\n  const uncategorizedCount = computed(() => {\n    // Use the exact same logic as the store's uncategorized filter for consistency\n    const filteredTasks = taskStore.tasks.filter(task => {\n      // BUG-FIX: Exclude soft-deleted tasks\n      if (task._soft_deleted) return false\n      // Apply same filtering logic as uncategorized smart view in taskStore.filteredTasks\n      // Check isUncategorized flag first\n      if (task.isUncategorized === true) {\n        return true\n      }\n\n      // Backward compatibility: treat tasks without proper project assignment as uncategorized\n      // REMOVED: projectId === '1' check - \"My Tasks\" concept removed\n      if (!task.projectId || task.projectId === '' || task.projectId === null) {\n        return true\n      }\n\n      return false\n    })\n\n    // Apply the same hideDoneTasks logic as the task store\n    const finalCount = taskStore.hideDoneTasks\n      ? filteredTasks.filter(task => task.status !== 'done').length\n      : filteredTasks.length\n\n    return finalCount\n  })\n\n  // Duration Counts - Proxy from store\n  const quickCount = computed(() => taskStore.smartViewTaskCounts.quick)\n  const shortCount = computed(() => taskStore.smartViewTaskCounts.short)\n  const mediumCount = computed(() => taskStore.smartViewTaskCounts.medium)\n  const longCount = computed(() => taskStore.smartViewTaskCounts.long)\n  const unestimatedCount = computed(() => taskStore.smartViewTaskCounts.unestimated)\n\n  // Task management methods\n  const createQuickTask = async () => {\n    if (newTaskTitle.value.trim()) {\n      // Use the unified undo system\n      const { useUnifiedUndoRedo } = await import('@/composables/useUnifiedUndoRedo')\n      const undoRedoActions = useUnifiedUndoRedo()\n      undoRedoActions.createTaskWithUndo({\n        title: newTaskTitle.value.trim(),\n        description: '',\n        status: 'planned',\n        projectId: undefined // ✅ FIXED: Use undefined instead of forbidden '1'\n      })\n      newTaskTitle.value = ''\n    }\n  }\n\n  // Project Navigation Methods\n  const toggleProjectExpansion = (projectId: string) => {\n    const index = expandedProjects.value.indexOf(projectId)\n    if (index > -1) {\n      expandedProjects.value.splice(index, 1)\n    } else {\n      expandedProjects.value.push(projectId)\n    }\n    uiStore.persistState() // Manual save trigger since we're modifying the array in place\n  }\n\n  const selectProject = (project: Project) => {\n    taskStore.setActiveProject(project.id)\n    taskStore.setSmartView(null)\n  }\n\n  // Keyboard navigation for project tree\n  const handleProjectTreeKeydown = (event: KeyboardEvent) => {\n    const { key } = event\n\n    switch (key) {\n      case 'ArrowDown':\n        event.preventDefault()\n        navigateToNextProject()\n        break\n      case 'ArrowUp':\n        event.preventDefault()\n        navigateToPreviousProject()\n        break\n      case 'ArrowRight':\n        event.preventDefault()\n        expandCurrentProject()\n        break\n      case 'ArrowLeft':\n        event.preventDefault()\n        collapseCurrentProjectOrNavigateToParent()\n        break\n      case 'Enter':\n      case ' ':\n        event.preventDefault()\n        activateCurrentProject()\n        break\n      case 'Home':\n        event.preventDefault()\n        navigateToFirstProject()\n        break\n      case 'End':\n        event.preventDefault()\n        navigateToLastProject()\n        break\n    }\n  }\n\n  // Navigation helpers\n  const navigateToNextProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    const allProjects = getFlattenedProjectList()\n    const currentIndex = allProjects.findIndex(p => p.id === currentProjectId)\n\n    if (currentIndex < allProjects.length - 1) {\n      taskStore.setActiveProject(allProjects[currentIndex + 1].id)\n    }\n  }\n\n  const navigateToPreviousProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    const allProjects = getFlattenedProjectList()\n    const currentIndex = allProjects.findIndex(p => p.id === currentProjectId)\n\n    if (currentIndex > 0) {\n      taskStore.setActiveProject(allProjects[currentIndex - 1].id)\n    }\n  }\n\n  const expandCurrentProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    if (currentProjectId && hasChildren(currentProjectId)) {\n      if (!expandedProjects.value.includes(currentProjectId)) {\n        expandedProjects.value.push(currentProjectId)\n        uiStore.persistState()\n      }\n    }\n  }\n\n  const collapseCurrentProjectOrNavigateToParent = () => {\n    const currentProjectId = taskStore.activeProjectId\n    if (!currentProjectId) return\n\n    // If project has children and is expanded, collapse it\n    if (hasChildren(currentProjectId) && expandedProjects.value.includes(currentProjectId)) {\n      const index = expandedProjects.value.indexOf(currentProjectId)\n      expandedProjects.value.splice(index, 1)\n      uiStore.persistState()\n    } else {\n      // Otherwise, navigate to parent if exists\n      const project = taskStore.getProjectById(currentProjectId)\n      if (project?.parentId) {\n        taskStore.setActiveProject(project.parentId)\n      }\n    }\n  }\n\n  const activateCurrentProject = () => {\n    const currentProjectId = taskStore.activeProjectId\n    if (currentProjectId) {\n      const project = taskStore.getProjectById(currentProjectId)\n      if (project) {\n        selectProject(project)\n      }\n    }\n  }\n\n  const navigateToFirstProject = () => {\n    const allProjects = getFlattenedProjectList()\n    if (allProjects.length > 0) {\n      taskStore.setActiveProject(allProjects[0].id)\n    }\n  }\n\n  const navigateToLastProject = () => {\n    const allProjects = getFlattenedProjectList()\n    if (allProjects.length > 0) {\n      taskStore.setActiveProject(allProjects[allProjects.length - 1].id)\n    }\n  }\n\n  // Helper functions for navigation\n  const getFlattenedProjectList = (): Project[] => {\n    const flatten = (projects: Project[], _level = 1): Project[] => {\n      const result: Project[] = []\n\n      for (const project of projects) {\n        if (!project.parentId) { // Only include root projects initially\n          result.push(project)\n\n          if (expandedProjects.value.includes(project.id)) {\n            const children = taskStore.projects.filter(p => p.parentId === project.id)\n            result.push(...flatten(children, _level + 1))\n          }\n        }\n      }\n\n      return result\n    }\n\n    return flatten(taskStore.projects)\n  }\n\n\n\n  const toggleDurationSection = () => {\n    isDurationSectionExpanded.value = !isDurationSectionExpanded.value\n    uiStore.persistState()\n  }\n\n  const selectSmartView = (view: 'today' | 'week' | 'uncategorized' | 'all_active' | 'quick' | 'short' | 'medium' | 'long' | 'unestimated' | 'unscheduled' | 'in_progress') => {\n    // Check if view is a duration filter\n    if (view === 'quick' || view === 'short' || view === 'medium' || view === 'long' || view === 'unestimated') {\n      taskStore.setActiveDurationFilter(view)\n      taskStore.setSmartView(null)\n    } else {\n      // It's a smart view\n      taskStore.setSmartView(view as any) // Cast still needed because view union is wide, but logic is safe\n      taskStore.setActiveDurationFilter(null)\n    }\n  }\n\n  // Start Quick Sort from uncategorized view\n  const handleStartQuickSort = () => {\n\n    router.push({ name: 'quick-sort' })\n  }\n\n  const getProjectTaskCount = (projectId: string) => {\n    // Include tasks from child projects recursively\n    const countTasksRecursive = (pid: string): number => {\n      const directTasks = taskStore.tasks.filter(task => task.projectId === pid).length\n      const children = getChildren(pid)\n      const childTasks = children.reduce((sum, child) => sum + countTasksRecursive(child.id), 0)\n      return directTasks + childTasks\n    }\n\n    return countTasksRecursive(projectId)\n  }\n\n  // Project management methods\n  const openCreateProject = () => {\n    editingProject.value = null\n    showProjectModal.value = true\n  }\n\n  const openEditProject = (project: Project) => {\n    editingProject.value = project\n    showProjectModal.value = true\n  }\n\n  // Handle project un-nesting (drag to \"All Projects\")\n  const handleProjectUnnest = (data: { projectId?: string; title?: string }) => {\n    if (data.projectId) {\n      // Remove parent relationship by setting parentId to null\n      taskStore.updateProject(data.projectId, { parentId: null })\n\n    }\n  }\n\n  return {\n    // State\n    newTaskTitle,\n    showCreateProject,\n    expandedProjects,\n    showProjectModal,\n    editingProject,\n    isMac,\n    isDurationSectionExpanded,\n\n    // Computed properties\n    rootProjects,\n    todayTaskCount,\n    weekTaskCount,\n    allActiveCount,\n    uncategorizedCount,\n    quickCount,\n    shortCount,\n    mediumCount,\n    longCount,\n    unestimatedCount,\n\n    // Task management methods\n    createQuickTask,\n\n    // Project navigation methods\n    toggleProjectExpansion,\n    toggleDurationSection,\n    selectProject,\n    handleProjectTreeKeydown,\n    selectSmartView,\n    handleStartQuickSort,\n    getProjectTaskCount,\n\n    // Project management methods\n    openCreateProject,\n    openEditProject,\n    handleProjectUnnest,\n\n    // Helper methods\n    getChildren,\n    hasChildren\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'errorMessage' is defined but never used. Allowed unused args must match /^_/u.","line":53,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { useTaskStore, Task } from '@/stores/tasks'\nimport type { useTimerStore } from '@/stores/timer'\nimport type { BoardViewType } from './useBoardModals'\n\ninterface BoardActionsDependencies {\n    taskStore: ReturnType<typeof useTaskStore>\n    timerStore: ReturnType<typeof useTimerStore>\n}\n\n/**\n * Convert date column keys to actual date strings\n */\nfunction getDateFromColumnKey(key: string): string | undefined {\n    const today = new Date()\n    today.setHours(0, 0, 0, 0)\n\n    switch (key) {\n        case 'today':\n            return today.toISOString().split('T')[0]\n        case 'tomorrow': {\n            const tomorrow = new Date(today)\n            tomorrow.setDate(tomorrow.getDate() + 1)\n            return tomorrow.toISOString().split('T')[0]\n        }\n        case 'overdue':\n            // For overdue column, set to today (the task is being created as \"due today\")\n            return today.toISOString().split('T')[0]\n        case 'thisWeek': {\n            // End of current week (Sunday)\n            const endOfWeek = new Date(today)\n            const daysUntilSunday = 7 - today.getDay()\n            endOfWeek.setDate(today.getDate() + daysUntilSunday)\n            return endOfWeek.toISOString().split('T')[0]\n        }\n        case 'later': {\n            // Two weeks from today\n            const later = new Date(today)\n            later.setDate(today.getDate() + 14)\n            return later.toISOString().split('T')[0]\n        }\n        case 'inbox':\n        case 'noDate':\n        default:\n            return undefined\n    }\n}\n\nexport function useBoardActions(deps: BoardActionsDependencies) {\n    const { taskStore, timerStore } = deps\n\n    const handleWithError = async <T>(\n        operation: () => Promise<T>,\n        errorMessage: string\n    ): Promise<T | null> => {\n        try {\n            return await operation()\n        } catch (_error) {\n            return null\n        }\n    }\n\n    const selectTask = (taskId: string) => {\n        taskStore.selectTask(taskId)\n    }\n\n    const startTimer = async (taskId: string) => {\n        // BUG-1051: AWAIT for timer sync\n        await timerStore.startTimer(taskId, timerStore.settings.workDuration, false)\n    }\n\n    const quickTaskCreate = async (title: string, description: string, status: string, projectId?: string) => {\n        return handleWithError(\n            () => taskStore.createTaskWithUndo({\n                title,\n                description,\n                status: status as 'planned' | 'in_progress' | 'done',\n                projectId: projectId\n            }),\n            '❌ Error creating task:'\n        )\n    }\n\n    /**\n     * Create a task with correct field based on view type\n     * - Status view: sets status field\n     * - Priority view: sets priority field\n     * - Date view: sets dueDate field\n     */\n    const createTaskForColumn = async (\n        title: string,\n        description: string,\n        columnKey: string,\n        viewType: BoardViewType,\n        projectId?: string\n    ) => {\n        const taskData: Partial<Task> = {\n            title,\n            description,\n            projectId,\n            status: 'planned' // default status\n        }\n\n        // Set correct field based on view type\n        if (viewType === 'status') {\n            taskData.status = columnKey as Task['status']\n        } else if (viewType === 'priority') {\n            taskData.priority = columnKey === 'no_priority' ? undefined : columnKey as Task['priority']\n        } else if (viewType === 'date') {\n            taskData.dueDate = getDateFromColumnKey(columnKey)\n        }\n\n        return handleWithError(\n            () => taskStore.createTaskWithUndo(taskData),\n            '❌ Error creating task:'\n        )\n    }\n\n    const deleteTask = async (taskId: string) => {\n        return handleWithError(\n            () => taskStore.deleteTaskWithUndo(taskId),\n            '❌ Error deleting task:'\n        )\n    }\n\n    const moveTask = async (taskId: string, newStatus: string) => {\n        return handleWithError(\n            () => taskStore.moveTaskWithUndo(taskId, newStatus as 'planned' | 'in_progress' | 'done'),\n            '❌ Error moving task:'\n        )\n    }\n\n    const addSubtask = async (taskId: string, title: string = 'New Subtask') => {\n        return handleWithError(\n            () => taskStore.createSubtaskWithUndo(taskId, { title }),\n            '❌ Error creating subtask:'\n        )\n    }\n\n    return {\n        selectTask,\n        startTimer,\n        quickTaskCreate,\n        createTaskForColumn,\n        deleteTask,\n        moveTask,\n        addSubtask\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardContextMenu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardModals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/board/useBoardState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":83,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":83,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6837,6840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6837,6840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7612,7615],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7612,7615],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed } from 'vue'\nimport type { Task, useTaskStore } from '@/stores/tasks'\nimport { parseDateKey, getTaskInstances, formatDateKey } from '@/stores/tasks'\nimport { UNCATEGORIZED_PROJECT_ID } from '@/stores/tasks/taskOperations'\n\ninterface BoardStateDependencies {\n    taskStore: ReturnType<typeof useTaskStore>\n}\n\nexport function useBoardState(deps: BoardStateDependencies) {\n    const { taskStore } = deps\n\n    // Helper to get a project and all its descendants recursively with cycle detection\n    const getProjectAndChildren = (projectId: string, visited = new Set<string>()): string[] => {\n        if (visited.has(projectId)) return []\n        visited.add(projectId)\n\n        const ids = [projectId]\n        const childProjects = taskStore.projects.filter(p => p.parentId === projectId)\n        childProjects.forEach(child => {\n            ids.push(...getProjectAndChildren(child.id, visited))\n        })\n        return ids\n    }\n\n    // Group tasks by project (using filtered tasks from store)\n    // TASK-243: Filter done tasks locally based on hideDoneTasks setting\n    const tasksByProject = computed(() => {\n        const grouped: Record<string, Task[]> = {}\n\n        taskStore.filteredTasks\n            .filter(task => !(taskStore.hideDoneTasks && task.status === 'done'))\n            .forEach(task => {\n                const projectId = task.projectId || UNCATEGORIZED_PROJECT_ID\n                if (!grouped[projectId]) {\n                    grouped[projectId] = []\n                }\n                grouped[projectId].push(task)\n            })\n\n        return grouped\n    })\n\n    // Get projects to display (TASK-243: Filter out empty projects)\n    const projectsWithTasks = computed(() => {\n        // If a specific project is selected, show that project AND its children\n        if (taskStore.activeProjectId) {\n            const projectIds = getProjectAndChildren(taskStore.activeProjectId)\n            return taskStore.projects.filter(project => projectIds.includes(project.id))\n        }\n\n        // Get real projects that have tasks (filter out empty ones)\n        const projects = taskStore.projects.filter(project => {\n            const tasksInProject = tasksByProject.value[project.id] || []\n            return tasksInProject.length > 0\n        })\n\n        // Add virtual \"Uncategorized\" project only if there are VISIBLE uncategorized tasks\n        // TASK-243: Use tasksByProject which already applies hideDoneTasks filter\n        const uncategorizedTasks = tasksByProject.value[UNCATEGORIZED_PROJECT_ID] || []\n        if (uncategorizedTasks.length > 0) {\n            projects.push({\n                id: UNCATEGORIZED_PROJECT_ID,\n                name: 'Uncategorized',\n                color: '#6B7280',\n                colorType: 'hex' as const,\n                viewType: 'status' as const,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            })\n        }\n\n        return projects\n    })\n\n    // Total displayed tasks\n    const totalDisplayedTasks = computed(() => {\n        try {\n            if (taskStore && typeof taskStore.nonDoneTaskCount === 'number') {\n                return taskStore.nonDoneTaskCount\n            }\n            return taskStore?.filteredTasks?.length || 0\n        } catch (error) {\n            return 0\n        }\n    })\n\n    return {\n        tasksByProject,\n        projectsWithTasks,\n        totalDisplayedTasks,\n        getProjectAndChildren\n    }\n}\n\n// --- Grouping Helpers ---\n\nexport const addDays = (date: Date, amount: number) => {\n    const next = new Date(date)\n    next.setDate(next.getDate() + amount)\n    next.setHours(0, 0, 0, 0)\n    return next\n}\n\nexport const isSameDay = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport const getUpcomingFriday = (base: Date) => {\n    const friday = new Date(base)\n    const diff = (5 - base.getDay() + 7) % 7\n    friday.setDate(base.getDate() + diff)\n    friday.setHours(0, 0, 0, 0)\n    return friday\n}\n\nexport const getNextMonday = (base: Date) => {\n    const monday = new Date(base)\n    const diff = (8 - base.getDay()) % 7 || 7\n    monday.setDate(base.getDate() + diff)\n    monday.setHours(0, 0, 0, 0)\n    return monday\n}\n\n/** Sort tasks by order (ascending), then by createdAt as tiebreaker */\nfunction sortByOrder(tasks: Task[]): Task[] {\n    return tasks.sort((a, b) => {\n        const orderA = a.order ?? Number.MAX_SAFE_INTEGER\n        const orderB = b.order ?? Number.MAX_SAFE_INTEGER\n        if (orderA !== orderB) return orderA - orderB\n        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n    })\n}\n\nexport function groupTasksByStatus(tasks: Task[]) {\n    const result: Record<string, Task[]> = {\n        planned: [],\n        in_progress: [],\n        backlog: [],\n        on_hold: [],\n        done: []\n    }\n    tasks.forEach(task => {\n        if (result[task.status]) {\n            result[task.status].push(task)\n        }\n    })\n    for (const key of Object.keys(result)) {\n        sortByOrder(result[key])\n    }\n    return result\n}\n\nexport function groupTasksByPriority(tasks: Task[]) {\n    const result: Record<string, Task[]> = {\n        high: [],\n        medium: [],\n        low: [],\n        no_priority: []\n    }\n    tasks.forEach(task => {\n        const p = task.priority || 'no_priority'\n        if (result[p]) {\n            result[p].push(task)\n        }\n    })\n    for (const key of Object.keys(result)) {\n        sortByOrder(result[key])\n    }\n    return result\n}\n\nexport function groupTasksByDate(tasks: Task[], hideDoneTasks: boolean = false) {\n    const result: Record<string, Task[]> = {\n        overdue: [],\n        inbox: [],\n        today: [],\n        tomorrow: [],\n        thisWeek: [],\n        later: [],\n        noDate: []\n    }\n\n    const today = new Date()\n    today.setHours(0, 0, 0, 0)\n    // BUG-1093: Use formatDateKey for local timezone (toISOString returns UTC)\n    const todayStr = formatDateKey(today)\n    const tomorrow = addDays(today, 1)\n    const weekendStart = getUpcomingFriday(today)\n    const weekendEnd = addDays(weekendStart, 2)\n    const nextWeekStart = getNextMonday(today)\n    const nextWeekEnd = addDays(nextWeekStart, 6)\n    const afterNextWeekStart = addDays(nextWeekEnd, 1)\n\n    tasks.forEach(task => {\n        const instances = getTaskInstances(task)\n        const taskCreatedDate = new Date(task.createdAt)\n        taskCreatedDate.setHours(0, 0, 0, 0)\n        const oneDayAgo = new Date(today)\n        oneDayAgo.setDate(oneDayAgo.getDate() - 1)\n\n        const isCreatedToday = taskCreatedDate.getTime() === today.getTime()\n        const isDueToday = task.dueDate === todayStr\n        const isInProgress = task.status === 'in_progress'\n        const isOverdueByDate = task.dueDate && task.dueDate < todayStr\n\n        const hasPastInstance = instances.length > 0 && instances.some((instance: any) => {\n            const instanceDate = parseDateKey(instance.scheduledDate)\n            return instanceDate && instanceDate < today\n        })\n        const isOldAndUnscheduled = taskCreatedDate < oneDayAgo && instances.length === 0 &&\n            !task.dueDate && task.status !== 'backlog'\n\n        // Overdue check\n        if (task.status !== 'done' && (isOverdueByDate || hasPastInstance || isOldAndUnscheduled)) {\n            result.overdue.push(task)\n            return\n        }\n\n        if (instances.length === 0) {\n            if (isCreatedToday || isDueToday || isInProgress) {\n                result.today.push(task)\n            } else {\n                result.noDate.push(task)\n            }\n            return\n        }\n\n        instances.forEach((instance: any) => {\n            if (instance.isLater) {\n                result.later.push(task)\n                return\n            }\n\n            const instanceDate = parseDateKey(instance.scheduledDate)\n            if (!instanceDate) return\n\n            if (instanceDate < today) {\n                result.overdue.push(task)\n            } else if (isSameDay(instanceDate, today)) {\n                result.today.push(task)\n            } else if (isSameDay(instanceDate, tomorrow) && !(instanceDate >= weekendStart && instanceDate <= weekendEnd)) {\n                result.tomorrow.push(task)\n            } else if ((instanceDate >= weekendStart && instanceDate <= weekendEnd) || (instanceDate >= nextWeekStart && instanceDate <= nextWeekEnd)) {\n                result.thisWeek.push(task)\n            } else if (instanceDate >= afterNextWeekStart) {\n                result.later.push(task)\n            }\n        })\n    })\n\n    if (!hideDoneTasks) {\n        tasks.forEach(task => {\n            if (task.status === 'done' && !result.noDate.includes(task)) {\n                result.noDate.push(task)\n            }\n        })\n    }\n\n    for (const key of Object.keys(result)) {\n        sortByOrder(result[key])\n    }\n\n    return result\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarDayView.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'taskError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":228,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":228,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'positionError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":237,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":237,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":241,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":241,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":374,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":374,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":473,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":473,"endColumn":19},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":473,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":474,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[15977,15982],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":614,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":614,"endColumn":23},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":619,"column":12,"nodeType":"BlockStatement","messageId":"unexpected","endLine":620,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[21024,21029],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, onUnmounted, type Ref } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport type { CalendarEvent, DragGhost } from '@/types/tasks'\nimport { calculateOverlappingPositions } from '@/utils/calendar/overlapCalculation'\n\nexport interface TimeSlot {\n  id: string\n  hour: number\n  minute: number\n  slotIndex: number\n  date: string\n}\n\n// Drag data from calendar drag operations\ninterface CalendarDragData {\n  taskId?: string\n  title?: string\n  source?: string\n  [key: string]: unknown\n}\n\n// Re-export for consumers\nexport type { DragGhost } from '@/types/tasks'\n\n/**\n * Day view specific logic for calendar\n * Handles event computation, drag-and-drop, resizing, and time slots\n */\n// Helper function to snap time to 15-minute intervals\nfunction snapTo15Minutes(hour: number, minute: number): { hour: number; minute: number } {\n  const totalMinutes = hour * 60 + minute\n\n  // Round to nearest 15-minute interval\n  const snappedMinutes = Math.round(totalMinutes / 15) * 15\n\n  // Convert back to hour and minute\n  const snappedHour = Math.floor(snappedMinutes / 60)\n  const snappedMinute = snappedMinutes % 60\n\n  return { hour: snappedHour, minute: snappedMinute }\n}\n\nexport function useCalendarDayView(currentDate: Ref<Date>, _statusFilter: Ref<string | null>, timerGrowthMap?: Ref<Map<string, number>>) {\n  const taskStore = useTaskStore()\n  const { getPriorityColor, getDateString } = useCalendarCore()\n\n  // --- MEMORY LEAK FIX: Listener Registry ---\n  let currentMouseMoveHandler: ((e: MouseEvent) => void) | null = null\n  let currentMouseUpHandler: (() => void) | null = null\n  let currentKeydownHandler: ((e: KeyboardEvent) => void) | null = null\n  let currentBlurHandler: (() => void) | null = null\n\n  const cleanupListeners = () => {\n    if (currentMouseMoveHandler) {\n      document.removeEventListener('mousemove', currentMouseMoveHandler)\n      currentMouseMoveHandler = null\n    }\n    if (currentMouseUpHandler) {\n      document.removeEventListener('mouseup', currentMouseUpHandler)\n      currentMouseUpHandler = null\n    }\n  }\n\n  const cleanupAllListeners = () => {\n    cleanupListeners()\n    if (currentKeydownHandler) {\n      document.removeEventListener('keydown', currentKeydownHandler)\n      currentKeydownHandler = null\n    }\n    if (currentBlurHandler) {\n      window.removeEventListener('blur', currentBlurHandler)\n      currentBlurHandler = null\n    }\n    // Clear any stuck selection\n    window.getSelection()?.removeAllRanges()\n    // Restore text selection\n    document.body.style.userSelect = ''\n    ;(document.body.style as CSSStyleDeclaration & { webkitUserSelect?: string }).webkitUserSelect = ''\n  }\n\n  onUnmounted(cleanupAllListeners)\n  // ------------------------------------------\n\n  const hours = Array.from({ length: 24 }, (_, i) => i)\n\n  // Drag ghost state\n  const dragGhost = ref<DragGhost>({\n    visible: false,\n    title: '',\n    duration: 30,\n    slotIndex: 0\n  })\n\n  // Drag mode state - enable dragging by default\n  const dragMode = ref<'none' | 'shift'>('shift')\n\n  // Drag state for visual feedback\n  const isDragging = ref(false)\n  const draggedEventId = ref<string | null>(null)\n  const activeDropSlot = ref<number | null>(null)\n\n  // Resize preview state - shows visual feedback during resize without updating store\n  const resizePreview = ref<{\n    taskId: string\n    direction: 'top' | 'bottom'\n    originalDuration: number\n    originalStartSlot: number\n    previewDuration: number\n    previewStartTime: string\n    isResizing: boolean\n  } | null>(null)\n\n  // Generate time slots for current day\n  const timeSlots = computed<TimeSlot[]>(() => {\n    const slots: TimeSlot[] = []\n    const dateStr = getDateString(currentDate.value)\n    let slotIndex = 0\n\n    hours.forEach(hour => {\n      [0, 30].forEach(minute => {\n        slots.push({\n          id: `${dateStr}-${hour}-${minute}`,\n          hour,\n          minute,\n          slotIndex,\n          date: dateStr\n        })\n        slotIndex++\n      })\n    })\n\n    return slots\n  })\n\n  // Generate calendar events with overlap positioning - simplified and error-resistant\n  const calendarEvents = computed<CalendarEvent[]>(() => {\n    try {\n      const dateStr = getDateString(currentDate.value)\n      const events: CalendarEvent[] = []\n\n      // Use calendarFilteredTasks to bypass smart view filters (done tasks stay visible)\n      // Only filters by project + hideCalendarDoneTasks toggle\n      const filteredTasks = taskStore.calendarFilteredTasks || []\n\n      filteredTasks.forEach(task => {\n        if (!task) return // Skip invalid tasks\n\n        try {\n          // GUARD: Limit instance processing to prevent OOM from corrupted data\n          // If a task has > 100 instances for a single day, something is wrong.\n          const MAX_INSTANCES_PER_TASK = 50\n\n          // Check if task has instances scheduled for today\n          let instanceCount = 0\n          const hasInstanceForToday = task.instances && task.instances.some(instance => {\n            if (instanceCount++ > MAX_INSTANCES_PER_TASK) return false\n            return instance && instance.scheduledDate === dateStr\n          })\n\n          // Check for legacy schedule\n          const hasLegacyScheduleToday = task.scheduledDate === dateStr && task.scheduledTime\n\n          // Create calendar events only for tasks with explicit scheduling\n          if (hasInstanceForToday || hasLegacyScheduleToday) {\n            let startTime: Date\n            let duration: number\n            let instanceId: string | undefined\n\n            if (hasInstanceForToday) {\n              // Use instance-specific schedule\n              const todayInstance = task.instances?.find(instance => instance && instance.scheduledDate === dateStr)\n              if (!todayInstance || !todayInstance.scheduledTime) return\n\n              const [hour, minute] = todayInstance.scheduledTime.split(':').map(Number)\n              if (isNaN(hour) || isNaN(minute)) return\n\n              startTime = new Date(`${dateStr}T${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`)\n              duration = todayInstance.duration || task.estimatedDuration || 30\n              instanceId = todayInstance.id\n            } else if (task.scheduledTime) {\n              // Legacy schedule - use scheduledTime\n              const [hour, minute] = task.scheduledTime.split(':').map(Number)\n              if (isNaN(hour) || isNaN(minute)) return\n\n              startTime = new Date(`${dateStr}T${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`)\n              duration = task.estimatedDuration || 30\n            } else {\n              return\n            }\n\n            // Validate startTime\n            if (isNaN(startTime.getTime())) return\n\n            // TASK-1285: Apply timer growth if active\n            const growthMinutes = (instanceId && timerGrowthMap?.value?.get(instanceId)) || 0\n            const visualDuration = duration + growthMinutes\n\n            const endTime = new Date(startTime.getTime() + visualDuration * 60000)\n            const startSlot = (startTime.getHours() * 2) + (startTime.getMinutes() >= 30 ? 1 : 0)\n            const slotSpan = Math.max(1, Math.ceil(visualDuration / 30))\n\n            // TASK-1285: Get instance status for completion tracking\n            const todayInstance = hasInstanceForToday\n              ? task.instances?.find(instance => instance && instance.scheduledDate === dateStr)\n              : undefined\n\n            const event = {\n              id: instanceId || task.id,\n              taskId: task.id,\n              instanceId: instanceId || '',\n              title: task.title || 'Untitled Task',\n              startTime,\n              endTime,\n              duration: visualDuration,\n              startSlot,\n              slotSpan,\n              color: getPriorityColor(task.priority),\n              column: 0,\n              totalColumns: 1,\n              isDueDate: false,\n              instanceStatus: todayInstance?.status,\n              taskStatus: task.status\n            }\n\n            events.push(event)\n          }\n        } catch (taskError) {\n          // Continue with other tasks\n        }\n      })\n\n      // Calculate overlapping positions with error handling\n      try {\n        const positionedEvents = calculateOverlappingPositions(events)\n        return positionedEvents as CalendarEvent[]\n      } catch (positionError) {\n        // Return events without positioning if calculation fails\n        return events as CalendarEvent[]\n      }\n    } catch (error) {\n      // Return empty array to prevent template rendering failure\n      return []\n    }\n  })\n\n  /**\n   * Get tasks that should be rendered inside a specific time slot\n   * For slot-based rendering (tasks as children of slots, not floating events)\n   * Multi-slot tasks appear in each slot they span\n   */\n  const getTasksForSlot = (slot: TimeSlot): CalendarEvent[] => {\n    const allEvents = calendarEvents.value\n    const slotEvents = allEvents.filter(event => {\n      // Check if this slot is within the event's time range\n      const eventEndSlot = event.startSlot + event.slotSpan\n      return slot.slotIndex >= event.startSlot && slot.slotIndex < eventEndSlot\n    })\n\n    return slotEvents\n  }\n\n  /**\n   * Check if a task is the \"primary\" slot (first slot of multi-slot task)\n   * Used to determine if we should render full task content vs continuation indicator\n   */\n  const isTaskPrimarySlot = (slot: TimeSlot, event: CalendarEvent): boolean => {\n    return slot.slotIndex === event.startSlot\n  }\n\n  // use overlapCalculation utility\n\n  // Event styling\n  const getEventStyle = (event: CalendarEvent) => {\n    const slotHeight = 30\n    const widthPercentage = 100 / event.totalColumns\n    const leftPercentage = widthPercentage * event.column\n\n    return {\n      top: `${event.startSlot * slotHeight}px`,\n      height: `${event.slotSpan * slotHeight}px`,\n      left: `${leftPercentage}%`,\n      width: `${widthPercentage}%`\n    }\n  }\n\n  /**\n   * Compute positioning style for slot tasks (handles overlapping tasks side-by-side)\n   * Short tasks (<= 30min) get compact class for single-line layout\n   */\n  const getSlotTaskStyle = (calEvent: CalendarEvent) => {\n    const baseHeight = (calEvent.slotSpan * 30) - 4\n    // Mark short tasks for compact CSS styling (single horizontal line)\n    const isCompact = calEvent.duration <= 30\n\n    // If no overlap (totalColumns is 1 or undefined), use normal flow with full width\n    if (!calEvent.totalColumns || calEvent.totalColumns <= 1) {\n      return {\n        height: `${baseHeight}px`,\n        minHeight: `${baseHeight}px`,\n        zIndex: 10,\n        '--is-compact': isCompact ? '1' : '0'\n      }\n    }\n\n    // Calculate width and position for overlapping events (like Google Calendar)\n    const gapPercent = 1 // 1% gap between columns\n    const totalGaps = calEvent.totalColumns - 1\n    const availableWidth = 100 - (totalGaps * gapPercent)\n    const widthPercentage = availableWidth / calEvent.totalColumns\n    const leftPercentage = (widthPercentage + gapPercent) * (calEvent.column || 0)\n\n    return {\n      position: 'absolute' as const,\n      top: '2px',\n      height: `${baseHeight}px`,\n      minHeight: `${baseHeight}px`,\n      width: `calc(${widthPercentage}% - 4px)`,\n      left: `calc(${leftPercentage}% + 2px)`,\n      zIndex: 10 + (calEvent.column || 0), // Later columns render on top\n      '--is-compact': isCompact ? '1' : '0'\n    }\n  }\n\n  const getGhostStyle = () => {\n    const slotHeight = 30\n    const slotSpan = Math.ceil(dragGhost.value.duration / 30)\n\n    return {\n      top: `${dragGhost.value.slotIndex * slotHeight}px`,\n      height: `${slotSpan * slotHeight}px`,\n      left: '0',\n      width: '100%'\n    }\n  }\n\n  // Drag-and-drop handlers for sidebar → calendar\n  const handleDragEnter = (event: DragEvent, slot: TimeSlot) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    let parsedData: CalendarDragData | null = null\n\n    // FALLBACK: Check for global dragging state when dataTransfer is empty\n    // This handles mouse-based dragging where dataTransfer might not be populated\n    if (!data) {\n\n\n      // Try to get dragged task from global state (CalendarInboxPanel sets this)\n      const draggingTaskId = (window as Window & typeof globalThis).__draggingTaskId ||\n        document.querySelector('[data-dragging-task-id]')?.getAttribute('data-dragging-task-id')\n\n      if (draggingTaskId) {\n        const task = taskStore.tasks.find(t => t.id === draggingTaskId)\n        if (task) {\n\n          parsedData = {\n            ...task,\n            taskId: task.id,\n            source: 'calendar-inbox'\n          }\n\n        }\n      }\n\n      if (!parsedData) {\n        return\n      }\n    } else {\n      // Parse dataTransfer data\n      try {\n        parsedData = JSON.parse(data) as CalendarDragData\n\n      } catch (error) {\n        return\n      }\n    }\n\n    if (!parsedData) {\n      return\n    }\n\n    // Use the parsedData we already created above\n    const { title, taskId } = parsedData\n    const task = taskStore.tasks.find(t => t.id === taskId)\n\n    if (!task) {\n      return\n    }\n\n    dragGhost.value = {\n      visible: true,\n      title: title || 'New Task',\n      duration: task?.estimatedDuration || 30,\n      slotIndex: slot.slotIndex\n    }\n  }\n\n  const handleDragOver = (event: DragEvent, slot: TimeSlot) => {\n    event.preventDefault()\n    // Check if dataTransfer exists before setting dropEffect\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = 'move'\n    }\n\n    // Track active drop slot for visual feedback\n    activeDropSlot.value = slot.slotIndex\n\n    if (dragGhost.value.visible) {\n      dragGhost.value.slotIndex = slot.slotIndex\n    }\n  }\n\n  const handleDragLeave = () => {\n    // Keep ghost visible, only hide on drop\n  }\n\n  const handleDrop = async (event: DragEvent, slot: TimeSlot) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (!data) {\n      // Try fallback for browser compatibility\n      const draggingTaskId = (window as Window & typeof globalThis).__draggingTaskId\n      if (!draggingTaskId) {\n        return\n      }\n    }\n\n    try {\n      const parsedData = data ? JSON.parse(data) : { taskId: (window as Window & typeof globalThis).__draggingTaskId, source: 'calendar-event' }\n      const taskId = parsedData.taskId || parsedData.taskIds?.[0]\n      const source = parsedData.source\n\n      if (!taskId) {\n        return\n      }\n\n      // Calculate snapped time with 15-minute precision\n      const snappedTime = snapTo15Minutes(slot.hour, slot.minute)\n      const timeStr = `${snappedTime.hour.toString().padStart(2, '0')}:${snappedTime.minute.toString().padStart(2, '0')}`\n\n      const task = taskStore.tasks.find(t => t.id === taskId)\n\n\n\n      if (source === 'calendar-event') {\n        const instanceToUpdate = task?.instances?.find(i => i.id)\n\n        await taskStore.updateTaskWithSchedule(taskId, {\n          scheduledDate: slot.date,\n          scheduledTime: timeStr,\n          instanceId: instanceToUpdate?.id\n        })\n      } else {\n        // Drag from inbox or other sources\n        // Create task instance and update task to remove from inbox\n        // BUG-1321: await for proper sync queue + echo protection\n        const instance = await taskStore.createTaskInstance(taskId, {\n          scheduledDate: slot.date,\n          scheduledTime: timeStr\n        })\n\n        // If instance was created successfully, log it\n        // Dec 16, 2025 fix: DO NOT modify isInInbox or canvasPosition here\n        // Calendar and Canvas are INDEPENDENT systems:\n        // - Creating an instance removes task from CALENDAR inbox (filtered by !hasInstances)\n        // - Canvas state (isInInbox, canvasPosition) should NOT be affected\n        if (instance) {\n          // Successfully created instance\n        }\n      }\n    } catch (error) {\n    }\n\n    dragGhost.value.visible = false\n\n    // Reset drag state\n    isDragging.value = false\n    draggedEventId.value = null\n    activeDropSlot.value = null\n\n  }\n\n  // Event drag-and-drop (repositioning within calendar)\n  const _startEventDrag = (event: MouseEvent, calendarEvent: CalendarEvent) => {\n    event.preventDefault()\n\n    const container = document.querySelector('.calendar-events-container') as HTMLElement\n    if (!container) return\n\n    const rect = container.getBoundingClientRect()\n    const SLOT_HEIGHT = 30\n    const eventElement = (event.target as HTMLElement).closest('.calendar-event') as HTMLElement\n    if (!eventElement) return\n\n    const eventRect = eventElement.getBoundingClientRect()\n    const clickOffsetY = event.clientY - eventRect.top\n\n    const isDuplicateMode = event.altKey\n\n    const initialSlot = calendarEvent.startSlot\n    let lastUpdatedSlot = initialSlot\n\n    const handleMouseMove = async (e: MouseEvent) => {\n      requestAnimationFrame(async () => {\n        const containerScrollTop = container.scrollTop || 0\n        const targetY = e.clientY - rect.top + containerScrollTop - clickOffsetY\n        const targetSlot = Math.max(0, Math.min(47, Math.floor(targetY / SLOT_HEIGHT)))\n\n        if (targetSlot !== lastUpdatedSlot) {\n          lastUpdatedSlot = targetSlot\n\n          const newHour = Math.floor((targetSlot * 30) / 60)\n          const newMinute = (targetSlot * 30) % 60\n          const newTime = `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')} `\n          const newDate = currentDate.value.toISOString().split('T')[0]\n\n          if (isDuplicateMode) {\n            // In duplicate mode, create a copy of the task with new schedule\n            const originalTask = taskStore.getTask(calendarEvent.taskId)\n            if (originalTask) {\n              taskStore.createTask({\n                title: originalTask.title,\n                description: originalTask.description,\n                scheduledDate: newDate,\n                scheduledTime: newTime,\n                estimatedDuration: calendarEvent.duration,\n                projectId: originalTask.projectId,\n                priority: originalTask.priority,\n                status: originalTask.status,\n                isInInbox: false\n              })\n            }\n          } else {\n            // Simple update: modify task's scheduledDate and scheduledTime directly\n            await taskStore.updateTask(calendarEvent.taskId, { // BUG-1051: AWAIT to ensure persistence\n              scheduledDate: newDate,\n              scheduledTime: newTime\n            })\n          }\n        }\n      })\n    }\n\n    const handleMouseUp = () => {\n      cleanupListeners()\n    }\n\n    // Use registry for cleanup\n    cleanupListeners()\n    currentMouseMoveHandler = handleMouseMove\n    currentMouseUpHandler = handleMouseUp\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n  }\n\n  const handleEventMouseDown = (event: MouseEvent, _calendarEvent: CalendarEvent) => {\n    // Only handle mouse down for resize handles, let HTML5 drag handle dragging\n    // Don't interfere with dragstart events\n    if (event.shiftKey) {\n      dragMode.value = 'shift'\n      return\n    }\n\n    // Let HTML5 drag events handle the dragging - don't block them\n    // Remove preventDefault and stopPropagation to allow drag events\n  }\n\n  const handleEventDragStart = (event: DragEvent, calendarEvent: CalendarEvent) => {\n\n    // Set drag state for visual feedback\n    isDragging.value = true\n    draggedEventId.value = calendarEvent.id\n\n    // Allow dragging calendar events without Shift key or restrictions\n    if (event.dataTransfer) {\n      const dragData = {\n        taskId: calendarEvent.taskId,\n        instanceId: calendarEvent.instanceId,\n        source: 'calendar-event'\n      }\n\n\n\n      event.dataTransfer.setData('application/json', JSON.stringify(dragData))\n      event.dataTransfer.effectAllowed = 'move'\n\n      // Create a custom drag image for better visual feedback\n      const dragElement = event.target as HTMLElement\n      if (dragElement) {\n        // Create a clone for the drag image\n        const dragImage = dragElement.cloneNode(true) as HTMLElement\n        dragImage.style.opacity = '0.8'\n        dragImage.style.transform = 'rotate(-2deg)'\n        dragImage.style.maxWidth = '200px'\n        dragImage.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)'\n\n        // Temporarily add to body to create image\n        document.body.appendChild(dragImage)\n\n        // Set the drag image\n        try {\n          event.dataTransfer.setDragImage(dragImage, 20, 20)\n\n\n          // Remove the temporary element after a short delay\n          setTimeout(() => {\n            if (document.body.contains(dragImage)) {\n              document.body.removeChild(dragImage)\n            }\n          }, 100)\n        } catch (error) {\n          // Fallback: use the original element\n          event.dataTransfer.setDragImage(dragElement, 20, 20)\n        }\n      }\n    } else {\n    }\n\n    // Don't prevent default - let HTML5 drag work naturally\n\n  }\n\n  const handleEventDragEnd = (_event: DragEvent, _calendarEvent: CalendarEvent) => {\n\n    // Clean up drag state to prevent stuck states\n    if (isDragging.value) {\n\n      isDragging.value = false\n      draggedEventId.value = null\n      activeDropSlot.value = null\n\n      // Clean up any visual dragging classes that might be stuck\n      setTimeout(() => {\n        const draggingElements = document.querySelectorAll('.calendar-event.dragging')\n        draggingElements.forEach(el => {\n          el.classList.remove('dragging')\n\n        })\n\n        const dragOverSlots = document.querySelectorAll('.time-slot.drag-over')\n        dragOverSlots.forEach(slot => {\n          slot.classList.remove('drag-over')\n\n        })\n      }, 50) // Small delay to ensure DOM updates are processed\n    }\n\n    // Add fallback cleanup timeout as safety net\n    setTimeout(() => {\n      if (isDragging.value || draggedEventId.value || activeDropSlot.value !== null) {\n        isDragging.value = false\n        draggedEventId.value = null\n        activeDropSlot.value = null\n      }\n    }, 2000) // 2 second fallback\n\n\n  }\n\n  // Event resizing - uses preview state during drag, commits on mouseup\n  const startResize = (event: MouseEvent, calendarEvent: CalendarEvent, direction: 'top' | 'bottom') => {\n    event.preventDefault()\n    event.stopPropagation() // Prevent drag events from interfering\n\n    const startY = event.clientY\n    const SLOT_HEIGHT = 30\n    const originalStartSlot = calendarEvent.startSlot\n    const originalDuration = calendarEvent.duration\n    const MIN_DURATION = 15 // 15-minute minimum\n\n    // Get current time information\n    const [currentHour, currentMinute] = calendarEvent.startTime.toTimeString().slice(0, 5).split(':').map(Number)\n    const currentStartTime = currentHour * 60 + currentMinute\n    const originalTimeStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')} `\n\n    // Initialize resize preview state\n    resizePreview.value = {\n      taskId: calendarEvent.taskId,\n      direction,\n      originalDuration,\n      originalStartSlot,\n      previewDuration: originalDuration,\n      previewStartTime: originalTimeStr,\n      isResizing: true\n    }\n\n    // Track final values to commit on mouseup\n    let finalDuration = originalDuration\n    let finalStartTime = originalTimeStr\n\n    const handleMouseMove = (e: MouseEvent) => {\n      requestAnimationFrame(() => {\n        if (!resizePreview.value) return\n\n        const deltaY = e.clientY - startY\n        const deltaSlots = Math.round(deltaY / SLOT_HEIGHT)\n\n        let newDuration = originalDuration\n        let newStartHour = currentHour\n        let newStartMinute = currentMinute\n\n        if (direction === 'bottom') {\n          // Resize from bottom - change duration only\n          const deltaMinutes = deltaSlots * 30\n          newDuration = Math.max(MIN_DURATION, originalDuration + deltaMinutes)\n\n          // Update preview state only (NOT the store)\n          resizePreview.value.previewDuration = newDuration\n          finalDuration = newDuration\n\n\n\n        } else {\n          // Resize from top - change start time and maintain end time\n          const deltaMinutes = deltaSlots * 30\n          const newStartTime = currentStartTime + deltaMinutes\n\n          if (newStartTime >= 0) {\n            // Snap new start time to 15-minute intervals\n            const snappedTime = snapTo15Minutes(\n              Math.floor(newStartTime / 60),\n              newStartTime % 60\n            )\n\n            newStartHour = snappedTime.hour\n            newStartMinute = snappedTime.minute\n\n            // Calculate new duration to maintain end time\n            const currentEndTime = currentStartTime + originalDuration\n            const actualNewStartTime = newStartHour * 60 + newStartMinute\n            newDuration = Math.max(MIN_DURATION, currentEndTime - actualNewStartTime)\n\n            const newTimeStr = `${newStartHour.toString().padStart(2, '0')}:${newStartMinute.toString().padStart(2, '0')} `\n\n            // Update preview state only (NOT the store)\n            resizePreview.value.previewDuration = newDuration\n            resizePreview.value.previewStartTime = newTimeStr\n            finalDuration = newDuration\n            finalStartTime = newTimeStr\n\n\n          }\n        }\n      })\n    }\n\n    const handleMouseUp = async () => {\n      // Clear visual state IMMEDIATELY to prevent stuck appearance\n      resizePreview.value = null\n      cleanupAllListeners()\n\n      // Commit final values to store (async, after cleanup)\n      if (direction === 'bottom') {\n        await taskStore.updateTask(calendarEvent.taskId, { // BUG-1051: AWAIT to ensure persistence\n          estimatedDuration: finalDuration\n        })\n\n        // Update instance if present\n        const task = taskStore.tasks.find(t => t.id === calendarEvent.taskId)\n        if (task?.instances && task.instances.length > 0) {\n          const todayInstance = task.instances.find(instance =>\n            instance && instance.scheduledDate === currentDate.value.toISOString().split('T')[0]\n          )\n          if (todayInstance && todayInstance.id) {\n            taskStore.updateTaskInstance(calendarEvent.taskId, todayInstance.id, {\n              duration: finalDuration\n            })\n          }\n        }\n      } else {\n        // Top resize - update both start time and duration\n        await taskStore.updateTask(calendarEvent.taskId, { // BUG-1051: AWAIT to ensure persistence\n          scheduledTime: finalStartTime,\n          estimatedDuration: finalDuration\n        })\n\n        // Update instance if present\n        const task = taskStore.tasks.find(t => t.id === calendarEvent.taskId)\n        if (task?.instances && task.instances.length > 0) {\n          const todayInstance = task.instances.find(instance =>\n            instance && instance.scheduledDate === currentDate.value.toISOString().split('T')[0]\n          )\n          if (todayInstance && todayInstance.id) {\n            taskStore.updateTaskInstance(calendarEvent.taskId, todayInstance.id, {\n              scheduledTime: finalStartTime,\n              duration: finalDuration\n            })\n          }\n        }\n      }\n    }\n\n    const handleKeydown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        // Cancel resize - don't commit changes\n        resizePreview.value = null\n        cleanupAllListeners()\n      }\n    }\n\n    const handleBlur = () => {\n      // Window lost focus - cleanup to prevent stuck state\n      // Don't commit changes on blur (user might have accidentally clicked away)\n      resizePreview.value = null\n      cleanupAllListeners()\n    }\n\n    // Clean up any existing listeners first\n    cleanupAllListeners()\n\n    // Prevent text selection during resize\n    document.body.style.userSelect = 'none'\n    ;(document.body.style as CSSStyleDeclaration & { webkitUserSelect?: string }).webkitUserSelect = 'none'\n\n    // Register all handlers\n    currentMouseMoveHandler = handleMouseMove\n    currentMouseUpHandler = handleMouseUp\n    currentKeydownHandler = handleKeydown\n    currentBlurHandler = handleBlur\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n    document.addEventListener('keydown', handleKeydown)\n    window.addEventListener('blur', handleBlur)\n  }\n\n  return {\n    hours,\n    timeSlots,\n    calendarEvents,\n    dragGhost,\n    dragMode,\n\n    // Slot-based rendering (tasks inside slots)\n    getTasksForSlot,\n    isTaskPrimarySlot,\n\n    // Drag state for visual feedback\n    isDragging,\n    draggedEventId,\n    activeDropSlot,\n\n    // Styling\n    getEventStyle,\n    getSlotTaskStyle,\n    getGhostStyle,\n\n    // Drag handlers\n    handleDragEnter,\n    handleDragOver,\n    handleDragLeave,\n    handleDrop,\n    handleEventDragStart,\n    handleEventDragEnd,\n    handleEventMouseDown,\n\n    // Resize handlers\n    startResize,\n    resizePreview\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarInteractionHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarModals.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":55,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":27},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":55,"column":29,"nodeType":"BlockStatement","messageId":"unexpected","endLine":56,"endColumn":14,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1464,1477],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { useTaskStore } from '@/stores/tasks'\n\n/**\n * Calendar modals composable\n * Manages TaskEditModal and ConfirmationModal (deletion) states\n */\nexport function useCalendarModals() {\n    const taskStore = useTaskStore()\n\n    // Task Edit Modal state\n    const isEditModalOpen = ref(false)\n    const selectedTask = ref<Task | null>(null)\n\n    // Delete confirmation modal state\n    const showConfirmModal = ref(false)\n    const taskToDelete = ref<string | null>(null)\n\n    /**\n     * Open edit modal for a specific task\n     */\n    const handleEditTask = (taskId: string) => {\n        const task = taskStore.rawTasks.find(t => t.id === taskId)\n        if (task) {\n            selectedTask.value = task\n            isEditModalOpen.value = true\n        }\n    }\n\n    /**\n     * Close the edit modal\n     */\n    const closeEditModal = () => {\n        isEditModalOpen.value = false\n        selectedTask.value = null\n    }\n\n    /**\n     * Open delete confirmation modal\n     */\n    const handleConfirmDelete = (taskId: string) => {\n        taskToDelete.value = taskId\n        showConfirmModal.value = true\n    }\n\n    /**\n     * Finalize task deletion\n     */\n    const confirmDeleteTask = async () => {\n        if (taskToDelete.value) {\n            try {\n                await taskStore.deleteTaskWithUndo(taskToDelete.value)\n                taskToDelete.value = null\n            } catch (error) {\n            }\n        }\n        showConfirmModal.value = false\n    }\n\n    /**\n     * Cancel task deletion\n     */\n    const cancelDeleteTask = () => {\n        taskToDelete.value = null\n        showConfirmModal.value = false\n    }\n\n    return {\n        isEditModalOpen,\n        selectedTask,\n        showConfirmModal,\n        taskToDelete,\n        handleEditTask,\n        closeEditModal,\n        handleConfirmDelete,\n        confirmDeleteTask,\n        cancelDeleteTask\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarMonthView.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1901,1904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1901,1904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1980,1983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1980,1983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4004,4007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4004,4007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, type Ref } from 'vue'\nimport { useTaskStore, getTaskInstances } from '@/stores/tasks'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport { useSettingsStore } from '@/stores/settings'\nimport type { CalendarEvent } from '@/types/tasks'\n\nexport interface MonthDay {\n  dateString: string\n  dayNumber: number\n  isCurrentMonth: boolean\n  isToday: boolean\n  events: CalendarEvent[]\n}\n\n/**\n * Month view specific logic for calendar\n * Handles month grid, day cells, and event aggregation\n */\nexport function useCalendarMonthView(currentDate: Ref<Date>, _statusFilter: Ref<string | null>) {\n  const taskStore = useTaskStore()\n  const settings = useSettingsStore()\n  const { getPriorityColor, getDateString } = useCalendarCore()\n\n  // Month days computation\n  const monthDays = computed<MonthDay[]>(() => {\n    const year = currentDate.value.getFullYear()\n    const month = currentDate.value.getMonth()\n\n    const firstDay = new Date(year, month, 1)\n    const startDate = new Date(firstDay)\n\n    // TASK-1321: Adjust to start on the configured week start day\n    const dayOfWeek = firstDay.getDay()\n    const weekStartsOn = settings.weekStartsOn ?? 0\n    const daysToSubtract = (dayOfWeek - weekStartsOn + 7) % 7\n    startDate.setDate(startDate.getDate() - daysToSubtract)\n\n    const days: MonthDay[] = []\n    const today = getDateString(new Date())\n\n    for (let i = 0; i < 42; i++) { // 6 weeks × 7 days\n      const date = new Date(startDate)\n      date.setDate(date.getDate() + i)\n\n      const dateString = getDateString(date)\n\n      // Get events for this day\n      const dayEvents: CalendarEvent[] = []\n      // Use calendarFilteredTasks to bypass smart view filters (consistent with week/day views)\n      taskStore.calendarFilteredTasks\n        .forEach(task => {\n          const instances = getTaskInstances(task)\n          instances\n            .filter((instance: any) => instance.scheduledDate === dateString)\n            .forEach((instance: any) => {\n              const [_hour, _minute] = (instance.scheduledTime || '12:00').split(':').map(Number)\n              const duration = instance.duration || task.estimatedDuration || 30\n\n              dayEvents.push({\n                id: instance.id,\n                taskId: task.id,\n                instanceId: instance.id,\n                title: task.title,\n                projectId: task.projectId,\n                startTime: new Date(`${instance.scheduledDate}T${instance.scheduledTime}`),\n                endTime: new Date(new Date(`${instance.scheduledDate}T${instance.scheduledTime}`).getTime() + duration * 60000),\n                duration,\n                startSlot: 0,\n                slotSpan: 0,\n                color: getPriorityColor(task.priority),\n                column: 0,\n                totalColumns: 1,\n                isDueDate: false\n              })\n            })\n        })\n\n      days.push({\n        dateString,\n        dayNumber: date.getDate(),\n        isCurrentMonth: date.getMonth() === month,\n        isToday: dateString === today,\n        events: dayEvents\n      })\n    }\n\n    return days\n  })\n\n  // Month drag handlers\n  const handleMonthDragStart = (event: DragEvent, calendarEvent: CalendarEvent) => {\n    event.dataTransfer?.setData('application/json', JSON.stringify({\n      taskId: calendarEvent.taskId,\n      instanceId: calendarEvent.instanceId\n    }))\n  }\n\n  const handleMonthDrop = async (event: DragEvent, targetDate: string) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (!data) return\n\n    const { taskId, instanceId } = JSON.parse(data)\n    const existingTask = taskStore.getTask(taskId)\n    if (!existingTask) return\n\n    // TASK-1322: Properly handle both instances[] and legacy fields\n    if (existingTask.instances && existingTask.instances.length > 0 && instanceId) {\n      // Update the specific instance's scheduledDate (move, not duplicate)\n      const updatedInstances = existingTask.instances.map((inst: any) =>\n        inst.id === instanceId\n          ? { ...inst, scheduledDate: targetDate }\n          : inst\n      )\n      await taskStore.updateTask(taskId, {\n        instances: updatedInstances,\n        isInInbox: false\n      })\n    } else {\n      // Legacy fields — update scheduledDate directly\n      const scheduledTime = existingTask.scheduledTime || '09:00'\n      await taskStore.updateTask(taskId, { // BUG-1051: AWAIT to ensure persistence\n        scheduledDate: targetDate,\n        scheduledTime: scheduledTime,\n        isInInbox: false\n      })\n    }\n  }\n\n  const handleMonthDragEnd = (_event: DragEvent) => {\n    // Cleanup any drag states\n    // Currently no specific cleanup needed for month view\n  }\n\n  const handleMonthDayClick = (dateString: string, viewMode: Ref<'day' | 'week' | 'month'>) => {\n    // Switch to Day view for the clicked date\n    const [year, month, day] = dateString.split('-').map(Number)\n    currentDate.value = new Date(year, month - 1, day)\n    viewMode.value = 'day'\n  }\n\n  return {\n    monthDays,\n\n    // Drag handlers\n    handleMonthDragStart,\n    handleMonthDrop,\n    handleMonthDragEnd,\n    handleMonthDayClick\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarScroll.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarTimerIntegration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useCalendarWeekView.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3870,3873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3870,3873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4145,4148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4145,4148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":152,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":152,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, ref, onUnmounted, type Ref } from 'vue'\nimport { useTaskStore, getTaskInstances } from '@/stores/tasks'\nimport { useCalendarCore } from '@/composables/useCalendarCore'\nimport type { WeekEvent } from '@/types/tasks'\nimport { calculateOverlappingPositions } from '@/utils/calendar/overlapCalculation'\n\nexport interface WeekDay {\n  dayName: string\n  date: number\n  dateString: string\n  fullDate: Date\n}\n\n// Re-export for consumers\nexport type { WeekEvent } from '@/types/tasks'\n\n/**\n * Week view specific logic for calendar\n * Handles 7-day grid, events positioning, drag-and-drop, and resizing\n */\nexport function useCalendarWeekView(currentDate: Ref<Date>, _statusFilter: Ref<string | null>, timerGrowthMap?: Ref<Map<string, number>>) {\n  const taskStore = useTaskStore()\n  const { getPriorityColor, getDateString, getWeekStart } = useCalendarCore()\n\n  // --- MEMORY LEAK FIX: Listener Registry ---\n  let currentMouseMoveHandler: ((e: MouseEvent) => void) | null = null\n  let currentMouseUpHandler: (() => void) | null = null\n  let currentKeydownHandler: ((e: KeyboardEvent) => void) | null = null\n  let currentBlurHandler: (() => void) | null = null\n\n  // Week resize state - exposed for visual feedback\n  const isWeekResizing = ref(false)\n  const weekResizeTaskId = ref<string | null>(null)\n\n  const cleanupListeners = () => {\n    if (currentMouseMoveHandler) {\n      document.removeEventListener('mousemove', currentMouseMoveHandler)\n      currentMouseMoveHandler = null\n    }\n    if (currentMouseUpHandler) {\n      document.removeEventListener('mouseup', currentMouseUpHandler)\n      currentMouseUpHandler = null\n    }\n  }\n\n  const cleanupAllListeners = () => {\n    cleanupListeners()\n    if (currentKeydownHandler) {\n      document.removeEventListener('keydown', currentKeydownHandler)\n      currentKeydownHandler = null\n    }\n    if (currentBlurHandler) {\n      window.removeEventListener('blur', currentBlurHandler)\n      currentBlurHandler = null\n    }\n    // Reset resize state\n    isWeekResizing.value = false\n    weekResizeTaskId.value = null\n    // Clear any stuck selection\n    window.getSelection()?.removeAllRanges()\n    // Restore text selection\n    document.body.style.userSelect = ''\n    ;(document.body.style as CSSStyleDeclaration & { webkitUserSelect?: string }).webkitUserSelect = ''\n  }\n\n  onUnmounted(cleanupAllListeners)\n  // ------------------------------------------\n\n  const workingHours = Array.from({ length: 17 }, (_, i) => i + 6) // 6 AM to 10 PM\n  const dragMode = ref<string | null>(null)\n\n  // Week days computation (TASK-1321: uses shared getWeekStart from useCalendarCore)\n  const weekDays = computed<WeekDay[]>(() => {\n    const weekStart = getWeekStart(currentDate.value)\n    const days: WeekDay[] = []\n\n    for (let i = 0; i < 7; i++) {\n      const date = new Date(weekStart)\n      date.setDate(weekStart.getDate() + i)\n\n      days.push({\n        dayName: date.toLocaleDateString('en-US', { weekday: 'short' }),\n        date: date.getDate(),\n        dateString: getDateString(date),\n        fullDate: date\n      })\n    }\n\n    return days\n  })\n\n  // Week events computation with day positioning\n  const weekEvents = computed<WeekEvent[]>(() => {\n    const eventsByDay: WeekEvent[][] = Array.from({ length: 7 }, () => [])\n\n    weekDays.value.forEach((day, dayIndex) => {\n      const dayEvents: WeekEvent[] = []\n\n      // Use calendarFilteredTasks to bypass smart view filters (done tasks stay visible)\n      // Only filters by project + hideCalendarDoneTasks toggle\n      taskStore.calendarFilteredTasks.forEach(task => {\n        if (!task) return\n\n        try {\n          const instances = getTaskInstances(task)\n\n          // GUARD: Limit processed instances per task to prevent OOM\n          const MAX_INSTANCES_PER_TASK = 50\n          let processedCount = 0\n\n          instances\n            .filter((instance: any) => {\n              if (processedCount >= MAX_INSTANCES_PER_TASK) return false\n              const matches = instance.scheduledDate === day.dateString\n              if (matches) processedCount++\n              return matches\n            })\n            .forEach((instance: any) => {\n              const [hour, minute] = (instance.scheduledTime || '12:00').split(':').map(Number)\n              const baseDuration = instance.duration || task.estimatedDuration || 30\n\n              // TASK-1285: Apply timer growth if active\n              const growthMinutes = (instance.id && timerGrowthMap?.value?.get(instance.id)) || 0\n              const duration = baseDuration + growthMinutes\n\n              // Only show if within working hours\n              if (hour >= 6 && hour < 23) {\n                const startTime = new Date(`${instance.scheduledDate}T${instance.scheduledTime}`)\n                const endTime = new Date(startTime.getTime() + duration * 60000)\n\n                dayEvents.push({\n                  id: instance.id,\n                  taskId: task.id,\n                  instanceId: instance.id,\n                  title: task.title,\n                  projectId: task.projectId,\n                  startTime,\n                  endTime,\n                  duration,\n                  startSlot: (hour - 6) * 2 + (minute === 30 ? 1 : 0),\n                  slotSpan: Math.ceil(duration / 30),\n                  color: getPriorityColor(task.priority),\n                  column: 0,\n                  totalColumns: 1,\n                  dayIndex,\n                  isDueDate: false,\n                  instanceStatus: instance.status,\n                  taskStatus: task.status\n                })\n              }\n            })\n        } catch (err) {\n          // Task processing error\n        }\n      })\n\n      // Calculate overlapping positions for this day\n      eventsByDay[dayIndex] = calculateOverlappingPositions(dayEvents) as WeekEvent[]\n    })\n\n    // Flatten all events into a single array\n    return eventsByDay.flat()\n  })\n\n  // use overlapCalculation utility\n\n  // Event styling for week grid\n  const getWeekEventStyle = (event: WeekEvent): Record<string, string | number> => {\n    const HALF_HOUR_HEIGHT = 30\n    const dayColumnWidth = 100 / 7\n\n    // Calculate column positioning within the day\n    const eventWidthWithinDay = dayColumnWidth / event.totalColumns\n    const eventLeftOffset = (dayColumnWidth * event.dayIndex) + (eventWidthWithinDay * event.column)\n\n    return {\n      position: 'absolute',\n      top: `${event.startSlot * HALF_HOUR_HEIGHT}px`,\n      height: `${event.slotSpan * HALF_HOUR_HEIGHT}px`,\n      left: `calc(${eventLeftOffset}% + 2px)`,\n      width: `calc(${eventWidthWithinDay}% - 4px)`\n    }\n  }\n\n  // Week drag-and-drop handlers\n  const _startWeekDrag = (event: MouseEvent, calendarEvent: WeekEvent) => {\n    event.preventDefault()\n    event.stopPropagation()\n\n    const weekDaysGrid = document.querySelector('.week-days-grid') as HTMLElement\n    if (!weekDaysGrid) return\n\n    const gridRect = weekDaysGrid.getBoundingClientRect()\n    const dayColumnWidth = gridRect.width / 7\n    const HALF_HOUR_HEIGHT = 30\n    const WORKING_HOURS_OFFSET = 6\n\n    const eventRect = (event.target as HTMLElement).closest('.week-event')?.getBoundingClientRect()\n    if (!eventRect) return\n\n    const clickOffsetY = event.clientY - eventRect.top\n\n    const isDuplicateMode = event.altKey\n    const _duplicateInstanceId: string | null = null\n\n    let lastUpdatedDayIndex = calendarEvent.dayIndex\n    let lastUpdatedSlot = calendarEvent.startSlot\n\n    const handleMouseMove = async (e: MouseEvent) => {\n      requestAnimationFrame(async () => {\n        const scrollTop = weekDaysGrid.scrollTop || 0\n\n        // Calculate day column\n        const relativeX = e.clientX - gridRect.left\n        const newDayIndex = Math.max(0, Math.min(6, Math.floor(relativeX / dayColumnWidth)))\n\n        // Calculate time slot\n        const mouseYInGrid = e.clientY - gridRect.top + scrollTop\n        const eventTopInGrid = mouseYInGrid - clickOffsetY\n        const slotFromTop = Math.max(0, Math.min(33, Math.round(eventTopInGrid / HALF_HOUR_HEIGHT)))\n\n        if (slotFromTop !== lastUpdatedSlot || newDayIndex !== lastUpdatedDayIndex) {\n          lastUpdatedSlot = slotFromTop\n          lastUpdatedDayIndex = newDayIndex\n\n          const newHour = Math.floor(slotFromTop / 2) + WORKING_HOURS_OFFSET\n          const newMinute = (slotFromTop % 2) * 30\n          const newDate = weekDays.value[newDayIndex].dateString\n          const newTime = `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`\n\n          if (isDuplicateMode) {\n            // In duplicate mode, create a copy of the task with new schedule\n            const originalTask = taskStore.getTask(calendarEvent.taskId)\n            if (originalTask) {\n              taskStore.createTask({\n                title: originalTask.title,\n                description: originalTask.description,\n                scheduledDate: newDate,\n                scheduledTime: newTime,\n                estimatedDuration: calendarEvent.duration,\n                projectId: originalTask.projectId,\n                priority: originalTask.priority,\n                status: originalTask.status,\n                isInInbox: false\n              })\n            }\n          } else {\n            // Simple update: modify task's scheduledDate and scheduledTime directly\n            await taskStore.updateTask(calendarEvent.taskId, { // BUG-1051: AWAIT to ensure persistence\n              scheduledDate: newDate,\n              scheduledTime: newTime\n            })\n          }\n        }\n      })\n    }\n\n    const handleMouseUp = () => {\n      cleanupListeners()\n    }\n\n    // Use registry for cleanup\n    cleanupListeners()\n    currentMouseMoveHandler = handleMouseMove\n    currentMouseUpHandler = handleMouseUp\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n  }\n\n  const handleWeekEventMouseDown = (event: MouseEvent, _calendarEvent: WeekEvent) => {\n    // Only handle mouse down for resize handles, let HTML5 drag handle dragging\n    // Don't interfere with dragstart events\n    if (event.shiftKey) {\n      dragMode.value = 'shift'\n      return\n    }\n    // Let HTML5 drag events handle the dragging - don't block them\n    // Remove preventDefault and stopPropagation to allow drag events\n  }\n\n  // Week resize handlers\n  const startWeekResize = (event: MouseEvent, calendarEvent: WeekEvent, direction: 'top' | 'bottom') => {\n    event.preventDefault()\n    event.stopPropagation() // Prevent drag events from interfering\n\n    // Set resize state for visual feedback\n    isWeekResizing.value = true\n    weekResizeTaskId.value = calendarEvent.taskId\n\n    const startY = event.clientY\n    const HALF_HOUR_HEIGHT = 30\n    const WORKING_HOURS_OFFSET = 6\n    const originalStartSlot = calendarEvent.startSlot\n    const originalDuration = calendarEvent.duration\n\n    // Prevent text selection during resize\n    document.body.style.userSelect = 'none'\n    ;(document.body.style as CSSStyleDeclaration & { webkitUserSelect?: string }).webkitUserSelect = 'none'\n\n    // Track final values to commit on mouseup (don't update store during drag)\n    let finalDuration = originalDuration\n    let finalStartSlot = originalStartSlot\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!isWeekResizing.value) return // Guard against stale handlers\n\n      const deltaY = e.clientY - startY\n      const deltaSlots = Math.round(deltaY / HALF_HOUR_HEIGHT)\n\n      if (direction === 'bottom') {\n        finalDuration = Math.max(30, originalDuration + (deltaSlots * 30))\n      } else {\n        const endSlot = originalStartSlot + Math.ceil(originalDuration / 30)\n        finalStartSlot = Math.max(0, Math.min(33, originalStartSlot + deltaSlots))\n        finalDuration = Math.max(30, (endSlot - finalStartSlot) * 30)\n      }\n    }\n\n    const handleMouseUp = async () => {\n      // Clear visual state IMMEDIATELY\n      cleanupAllListeners()\n\n      // Commit final values to store (async, after visual cleanup)\n      if (direction === 'bottom') {\n        await taskStore.updateTask(calendarEvent.taskId, {\n          estimatedDuration: finalDuration\n        })\n      } else {\n        const newHour = Math.floor(finalStartSlot / 2) + WORKING_HOURS_OFFSET\n        const newMinute = (finalStartSlot % 2) * 30\n\n        if (newHour >= WORKING_HOURS_OFFSET && newHour < 23) {\n          await taskStore.updateTask(calendarEvent.taskId, {\n            scheduledTime: `${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`,\n            estimatedDuration: finalDuration\n          })\n        }\n      }\n    }\n\n    const handleKeydown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        // Restore text selection\n        document.body.style.userSelect = ''\n        ;(document.body.style as CSSStyleDeclaration & { webkitUserSelect?: string }).webkitUserSelect = ''\n        cleanupAllListeners()\n      }\n    }\n\n    const handleBlur = () => {\n      // Window lost focus - cleanup to prevent stuck state\n      document.body.style.userSelect = ''\n      ;(document.body.style as CSSStyleDeclaration & { webkitUserSelect?: string }).webkitUserSelect = ''\n      cleanupAllListeners()\n    }\n\n    // Clean up any existing listeners first\n    cleanupAllListeners()\n\n    // Register all handlers\n    currentMouseMoveHandler = handleMouseMove\n    currentMouseUpHandler = handleMouseUp\n    currentKeydownHandler = handleKeydown\n    currentBlurHandler = handleBlur\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n    document.addEventListener('keydown', handleKeydown)\n    window.addEventListener('blur', handleBlur)\n  }\n\n  // Week drop handlers\n  const handleWeekDragOver = (event: DragEvent) => {\n    event.preventDefault()\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = 'move'\n    }\n  }\n\n  const handleWeekDrop = async (event: DragEvent, dateString: string, hour: number) => {\n    event.preventDefault()\n\n    const data = event.dataTransfer?.getData('application/json')\n    if (!data) return\n\n    const { taskId } = JSON.parse(data)\n    const timeStr = `${hour.toString().padStart(2, '0')}:00`\n\n    // Simple update: modify task's scheduledDate and scheduledTime directly\n    await taskStore.updateTask(taskId, { // BUG-1051: AWAIT to ensure persistence\n      scheduledDate: dateString,\n      scheduledTime: timeStr,\n      isInInbox: false // Task is now scheduled, no longer in inbox\n    })\n  }\n\n  // Current time detection for week view\n  const isCurrentWeekTimeCell = (dateString: string, hour: number) => {\n    const now = new Date()\n    const currentHour = now.getHours()\n    const todayString = getDateString(now)\n\n    return dateString === todayString && hour === currentHour\n  }\n\n  return {\n    workingHours,\n    weekDays,\n    weekEvents,\n\n    // Styling\n    getWeekEventStyle,\n\n    // Drag handlers\n    handleWeekEventMouseDown,\n    handleWeekDragOver,\n    handleWeekDrop,\n\n    // Resize handlers\n    startWeekResize,\n    isWeekResizing,\n    weekResizeTaskId,\n    cancelWeekResize: cleanupAllListeners, // Allow external cancellation\n\n    // Utilities\n    isCurrentWeekTimeCell\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/calendar/useExternalCalendar.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4250,4253],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4250,4253],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4553,4556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4553,4556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6303,6306],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6303,6306],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TASK-1317: External Calendar (iCal) Sync\n * Fetches iCal URLs, parses VEVENT data, and provides read-only events for calendar views.\n * Supports Google Calendar .ics URLs and any standard iCal feed.\n */\nimport { ref, computed, watch, onUnmounted } from 'vue'\nimport { useSettingsStore, type ExternalCalendarConfig } from '@/stores/settings'\n\nexport interface ExternalCalendarEvent {\n  id: string\n  title: string\n  startTime: Date\n  endTime: Date\n  isAllDay: boolean\n  location?: string\n  description?: string\n  calendarId: string\n  color: string\n}\n\n// ─── iCal Parser ───────────────────────────────────────────────────────────\n\nfunction getPropertyWithParams(text: string, name: string): { value: string | null; params: string } {\n  const unfolded = text.replace(/\\r?\\n[ \\t]/g, '')\n  const regex = new RegExp(`^${name}([;:].*)$`, 'm')\n  const match = unfolded.match(regex)\n  if (!match) return { value: null, params: '' }\n\n  const rest = match[1]\n  if (rest.startsWith(':')) {\n    return { value: rest.substring(1).trim(), params: '' }\n  }\n  // Has params — find the colon separating params from value\n  const colonIdx = rest.indexOf(':')\n  if (colonIdx === -1) return { value: rest, params: '' }\n\n  return {\n    value: rest.substring(colonIdx + 1).trim(),\n    params: rest.substring(0, colonIdx)\n  }\n}\n\nfunction parseICalDate(dateStr: string): Date {\n  // DATE format: 20260214\n  if (dateStr.length === 8) {\n    return new Date(\n      parseInt(dateStr.substring(0, 4)),\n      parseInt(dateStr.substring(4, 6)) - 1,\n      parseInt(dateStr.substring(6, 8))\n    )\n  }\n\n  // DATE-TIME format: 20260214T090000Z or 20260214T090000\n  const year = parseInt(dateStr.substring(0, 4))\n  const month = parseInt(dateStr.substring(4, 6)) - 1\n  const day = parseInt(dateStr.substring(6, 8))\n  const hour = parseInt(dateStr.substring(9, 11))\n  const minute = parseInt(dateStr.substring(11, 13))\n  const second = parseInt(dateStr.substring(13, 15)) || 0\n\n  if (dateStr.endsWith('Z')) {\n    return new Date(Date.UTC(year, month, day, hour, minute, second))\n  }\n\n  return new Date(year, month, day, hour, minute, second)\n}\n\nfunction unescapeIcal(str: string): string {\n  return str\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\,/g, ',')\n    .replace(/\\\\;/g, ';')\n    .replace(/\\\\\\\\/g, '\\\\')\n}\n\nfunction parseICalText(icsText: string, calendarId: string, color: string): ExternalCalendarEvent[] {\n  const events: ExternalCalendarEvent[] = []\n  const blocks = icsText.split('BEGIN:VEVENT')\n\n  for (let i = 1; i < blocks.length; i++) {\n    const endIdx = blocks[i].indexOf('END:VEVENT')\n    if (endIdx === -1) continue\n    const eventText = blocks[i].substring(0, endIdx)\n\n    const uid = getPropertyWithParams(eventText, 'UID')\n    const summary = getPropertyWithParams(eventText, 'SUMMARY')\n    const dtstart = getPropertyWithParams(eventText, 'DTSTART')\n    const dtend = getPropertyWithParams(eventText, 'DTEND')\n    const location = getPropertyWithParams(eventText, 'LOCATION')\n    const description = getPropertyWithParams(eventText, 'DESCRIPTION')\n\n    if (!summary.value || !dtstart.value) continue\n\n    // Skip recurring event templates (RRULE) — individual occurrences have RECURRENCE-ID\n    // For MVP, we only show non-recurring events and expanded occurrences\n    const hasRRule = eventText.includes('RRULE:')\n    const hasRecurrenceId = eventText.includes('RECURRENCE-ID')\n    if (hasRRule && !hasRecurrenceId) continue\n\n    const isAllDay = !dtstart.value.includes('T')\n    const startTime = parseICalDate(dtstart.value)\n    const endTime = dtend.value\n      ? parseICalDate(dtend.value)\n      : new Date(startTime.getTime() + (isAllDay ? 86400000 : 3600000))\n\n    events.push({\n      id: uid.value || `${calendarId}-${i}`,\n      title: unescapeIcal(summary.value),\n      startTime,\n      endTime,\n      isAllDay,\n      location: location.value ? unescapeIcal(location.value) : undefined,\n      description: description.value ? unescapeIcal(description.value) : undefined,\n      calendarId,\n      color\n    })\n  }\n\n  return events\n}\n\n// ─── Fetch Logic ───────────────────────────────────────────────────────────\n\nasync function fetchICalUrl(url: string): Promise<string> {\n  // Tauri desktop: use HTTP plugin (no CORS restrictions)\n  if ((window as any).__TAURI__) {\n    try {\n      const { fetch: tauriFetch } = await import('@tauri-apps/plugin-http')\n      const response = await tauriFetch(url, { method: 'GET' })\n      if (response.ok) {\n        return await response.text()\n      }\n      throw new Error(`HTTP ${response.status}`)\n    } catch (e: any) {\n      // If Tauri fetch fails, fall through to native fetch\n      console.warn('[ExternalCalendar] Tauri fetch failed:', e.message)\n    }\n  }\n\n  // Browser: try native fetch (works for CORS-enabled URLs)\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n  }\n  return await response.text()\n}\n\n// ─── Composable ────────────────────────────────────────────────────────────\n\nexport function useExternalCalendar() {\n  const settingsStore = useSettingsStore()\n\n  const allEvents = ref<ExternalCalendarEvent[]>([])\n  const isLoading = ref(false)\n  const syncErrors = ref<Map<string, string>>(new Map())\n\n  let syncInterval: ReturnType<typeof setInterval> | null = null\n\n  const calendars = computed(() => settingsStore.externalCalendars || [])\n  const enabledCalendars = computed(() => calendars.value.filter(c => c.enabled))\n  const hasEnabledCalendars = computed(() => enabledCalendars.value.length > 0)\n\n  const syncNow = async () => {\n    if (enabledCalendars.value.length === 0) return\n\n    isLoading.value = true\n    syncErrors.value.clear()\n    const newEvents: ExternalCalendarEvent[] = []\n\n    for (const cal of enabledCalendars.value) {\n      try {\n        const icsText = await fetchICalUrl(cal.url)\n        const events = parseICalText(icsText, cal.id, cal.color)\n        newEvents.push(...events)\n\n        // Update last synced\n        const cals = [...settingsStore.externalCalendars]\n        const idx = cals.findIndex(c => c.id === cal.id)\n        if (idx !== -1) {\n          cals[idx] = { ...cals[idx], lastSynced: new Date().toISOString(), error: undefined }\n          settingsStore.updateSetting('externalCalendars', cals)\n        }\n      } catch (e: any) {\n        console.error(`[ExternalCalendar] Sync failed for ${cal.name}:`, e)\n        syncErrors.value.set(cal.id, e.message)\n\n        const cals = [...settingsStore.externalCalendars]\n        const idx = cals.findIndex(c => c.id === cal.id)\n        if (idx !== -1) {\n          cals[idx] = { ...cals[idx], error: e.message }\n          settingsStore.updateSetting('externalCalendars', cals)\n        }\n      }\n    }\n\n    allEvents.value = newEvents\n    isLoading.value = false\n  }\n\n  const getEventsForDate = (dateString: string): ExternalCalendarEvent[] => {\n    return allEvents.value.filter(event => {\n      const d = event.startTime\n      const eventDate = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`\n      return eventDate === dateString\n    })\n  }\n\n  const addCalendar = (config: Omit<ExternalCalendarConfig, 'id'>) => {\n    const id = `ical-${Date.now()}`\n    const cals = [...(settingsStore.externalCalendars || []), { ...config, id }]\n    settingsStore.updateSetting('externalCalendars', cals)\n    syncNow()\n    return id\n  }\n\n  const removeCalendar = (calendarId: string) => {\n    const cals = (settingsStore.externalCalendars || []).filter(c => c.id !== calendarId)\n    settingsStore.updateSetting('externalCalendars', cals)\n    allEvents.value = allEvents.value.filter(e => e.calendarId !== calendarId)\n  }\n\n  const toggleCalendar = (calendarId: string) => {\n    const cals = [...(settingsStore.externalCalendars || [])]\n    const idx = cals.findIndex(c => c.id === calendarId)\n    if (idx !== -1) {\n      cals[idx] = { ...cals[idx], enabled: !cals[idx].enabled }\n      settingsStore.updateSetting('externalCalendars', cals)\n      syncNow()\n    }\n  }\n\n  // Auto-sync setup\n  const setupAutoSync = () => {\n    if (syncInterval) clearInterval(syncInterval)\n\n    const intervalMinutes = settingsStore.externalCalendarSyncInterval || 30\n    if (intervalMinutes > 0 && enabledCalendars.value.length > 0) {\n      syncInterval = setInterval(syncNow, intervalMinutes * 60 * 1000)\n    }\n  }\n\n  // Watch for calendar config changes\n  watch(enabledCalendars, (cals) => {\n    if (cals.length > 0) {\n      syncNow()\n      setupAutoSync()\n    } else {\n      allEvents.value = []\n      if (syncInterval) {\n        clearInterval(syncInterval)\n        syncInterval = null\n      }\n    }\n  }, { immediate: true })\n\n  onUnmounted(() => {\n    if (syncInterval) {\n      clearInterval(syncInterval)\n      syncInterval = null\n    }\n  })\n\n  return {\n    allEvents,\n    isLoading,\n    syncErrors,\n    calendars,\n    enabledCalendars,\n    hasEnabledCalendars,\n    syncNow,\n    getEventsForDate,\n    addCalendar,\n    removeCalendar,\n    toggleCalendar\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/__tests__/useCanvasOperationState.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/node/useTaskNodeActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/node/useTaskNodeState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/state-machine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'previousState' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":106,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":106,"endColumn":28},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":209,"column":16,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":209,"endColumn":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Node State Machine\n * \n * Replaces 7+ boolean flags with a single state machine\n * Prevents impossible states like isDragging + isSync + isConverting\n */\n\nimport { ref, computed, type Ref } from 'vue';\n\n/**\n * Valid states for a canvas node\n */\nexport enum NodeState {\n    IDLE = 'idle',\n    DRAGGING_LOCAL = 'dragging_local',\n    SYNCING = 'syncing',\n    CONFLICT = 'conflict',\n    RESIZING = 'resizing',\n    LOADING = 'loading',\n    ERROR = 'error'\n}\n\n/**\n * Define valid state transitions\n * Prevents impossible states like DRAGGING → ERROR → DRAGGING\n */\nconst STATE_TRANSITIONS: Record<NodeState, NodeState[]> = {\n    [NodeState.IDLE]: [\n        NodeState.DRAGGING_LOCAL,\n        NodeState.RESIZING,\n        NodeState.LOADING,\n        NodeState.SYNCING\n    ],\n    [NodeState.DRAGGING_LOCAL]: [\n        NodeState.SYNCING,\n        NodeState.IDLE\n    ],\n    [NodeState.SYNCING]: [\n        NodeState.IDLE,\n        NodeState.CONFLICT,\n        NodeState.ERROR,\n        NodeState.DRAGGING_LOCAL  // User drag takes priority over sync\n    ],\n    [NodeState.CONFLICT]: [\n        NodeState.DRAGGING_LOCAL,\n        NodeState.IDLE,\n        NodeState.SYNCING\n    ],\n    [NodeState.RESIZING]: [\n        NodeState.SYNCING,\n        NodeState.IDLE,\n        NodeState.ERROR\n    ],\n    [NodeState.LOADING]: [\n        NodeState.IDLE,\n        NodeState.ERROR\n    ],\n    [NodeState.ERROR]: [\n        NodeState.IDLE,\n        NodeState.SYNCING,\n        NodeState.DRAGGING_LOCAL\n    ]\n};\n\n/**\n * Composable for managing node state machine\n * Usage:\n *   const state = useNodeStateMachine();\n *   state.setState(NodeState.DRAGGING_LOCAL);\n *   if (state.canTransitionTo(NodeState.SYNCING)) { ... }\n */\nexport function useNodeStateMachine(initialState: NodeState = NodeState.IDLE) {\n    const currentState: Ref<NodeState> = ref(initialState);\n    const lastError: Ref<string | null> = ref(null);\n    const stateHistory: Ref<{ state: NodeState; timestamp: number }[]> = ref([]);\n\n    /**\n     * Check if transition is valid\n     */\n    function canTransitionTo(targetState: NodeState): boolean {\n        return STATE_TRANSITIONS[currentState.value].includes(targetState);\n    }\n\n    /**\n     * Attempt state transition\n     * Returns true if successful (or already in target state), false if invalid\n     *\n     * IDEMPOTENT: If already in targetState, returns true without logging warning.\n     * This prevents spurious \"Invalid state transition: X → X\" messages when\n     * Vue Flow fires duplicate drag events or multi-select triggers multiple handlers.\n     */\n    function setState(targetState: NodeState, reason?: string): boolean {\n        // IDEMPOTENT: Already in target state = success (no-op)\n        if (currentState.value === targetState) {\n            return true;\n        }\n\n        if (!canTransitionTo(targetState)) {\n            console.warn(\n                `Invalid state transition: ${currentState.value} → ${targetState}` +\n                (reason ? ` (${reason})` : '')\n            );\n            return false;\n        }\n\n        const previousState = currentState.value;\n        currentState.value = targetState;\n\n        // Track state history for debugging\n        stateHistory.value.push({\n            state: targetState,\n            timestamp: Date.now()\n        });\n\n        // Keep only last 50 state changes\n        if (stateHistory.value.length > 50) {\n            stateHistory.value = stateHistory.value.slice(-50);\n        }\n\n        // console.debug(\n        //   `State transition: ${previousState} → ${targetState}` +\n        //   (reason ? ` (${reason})` : '')\n        // );\n\n        return true;\n    }\n\n    /**\n     * Move to error state with message\n     */\n    function setError(message: string): boolean {\n        lastError.value = message;\n        return setState(NodeState.ERROR, message);\n    }\n\n    /**\n     * Get human-readable state label\n     */\n    function getStateLabel(state: NodeState = currentState.value): string {\n        const labels: Record<NodeState, string> = {\n            [NodeState.IDLE]: 'Idle',\n            [NodeState.DRAGGING_LOCAL]: 'Dragging',\n            [NodeState.SYNCING]: 'Syncing with server',\n            [NodeState.CONFLICT]: 'Conflict detected',\n            [NodeState.RESIZING]: 'Resizing',\n            [NodeState.LOADING]: 'Loading',\n            [NodeState.ERROR]: 'Error'\n        };\n        return labels[state] || 'Unknown';\n    }\n\n    /**\n     * Reset to idle (useful for cleanup)\n     */\n    function reset(): void {\n        currentState.value = NodeState.IDLE;\n        lastError.value = null;\n    }\n\n    /**\n     * Get debug info\n     */\n    function getDebugInfo(): object {\n        return {\n            currentState: currentState.value,\n            lastError: lastError.value,\n            recentStateChanges: stateHistory.value.slice(-10).map(entry => ({\n                state: entry.state,\n                secondsAgo: Math.round((Date.now() - entry.timestamp) / 1000)\n            })),\n            validNextStates: STATE_TRANSITIONS[currentState.value]\n        };\n    }\n\n    return {\n        // State\n        currentState: computed(() => currentState.value),\n        lastError: computed(() => lastError.value),\n        stateHistory: computed(() => stateHistory.value),\n\n        // Methods\n        setState,\n        setError,\n        canTransitionTo,\n        reset,\n\n        // UI Helpers\n        getStateLabel,\n\n        // Debug\n        getDebugInfo\n    };\n}\n\n/**\n * Global state machine for managing multiple nodes\n * Usage:\n *   const nodeStates = useNodeStateManager();\n *   nodeStates.setNodeState('node-123', NodeState.DRAGGING_LOCAL);\n */\nconst nodeStates = new Map<string, ReturnType<typeof useNodeStateMachine>>();\n\nexport function useNodeStateManager() {\n\n    function getOrCreateNodeState(nodeId: string): ReturnType<typeof useNodeStateMachine> {\n        if (!nodeStates.has(nodeId)) {\n            nodeStates.set(nodeId, useNodeStateMachine());\n        }\n        return nodeStates.get(nodeId)!;\n    }\n\n    function setNodeState(nodeId: string, state: NodeState, reason?: string): boolean {\n        return getOrCreateNodeState(nodeId).setState(state, reason);\n    }\n\n    function getNodeState(nodeId: string): NodeState {\n        return getOrCreateNodeState(nodeId).currentState.value;\n    }\n\n    function canNodeTransitionTo(nodeId: string, state: NodeState): boolean {\n        return getOrCreateNodeState(nodeId).canTransitionTo(state);\n    }\n\n    function resetNodeState(nodeId: string): void {\n        getOrCreateNodeState(nodeId).reset();\n    }\n\n    /**\n     * Get all nodes in specific state\n     */\n    function getNodesInState(state: NodeState): string[] {\n        const result: string[] = [];\n        nodeStates.forEach((machine, nodeId) => {\n            if (machine.currentState.value === state) {\n                result.push(nodeId);\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Cleanup state for node (e.g., after deletion)\n     */\n    function deleteNodeState(nodeId: string): void {\n        nodeStates.delete(nodeId);\n    }\n\n    return {\n        setNodeState,\n        getNodeState,\n        canNodeTransitionTo,\n        resetNodeState,\n        getNodesInState,\n        deleteNodeState\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1555,1558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1555,1558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1577,1580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1577,1580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'removeNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":46,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5648,5651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5648,5651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7557,7560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7557,7560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref, ref } from 'vue'\nimport { useVueFlow, type Node } from '@vue-flow/core'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useCanvasContextMenuStore } from '@/stores/canvas/contextMenus'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport { CANVAS } from '@/constants/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { CanvasGroup } from '@/types/canvas'\n\n// Imported Composables\nimport { useCanvasGroupActions } from './useCanvasGroupActions'\nimport { useCanvasTaskActions } from './useCanvasTaskActions'\n\ninterface ActionsDeps {\n    viewport: Ref<{ x: number; y: number; zoom: number }>\n    batchedSyncNodes: (priority?: 'high' | 'normal' | 'low') => void\n    syncNodes: () => void\n    closeCanvasContextMenu: () => void\n    closeEdgeContextMenu: () => void\n    closeNodeContextMenu: () => void\n    // TASK-149: Pass recentlyDeletedGroups to prevent zombie groups\n    recentlyDeletedGroups?: Ref<Set<string>>\n}\n\n// NOTE: State is now decomposed into sub-composables but we keep this interface \n// if we need to aggregate it for the view, but the ReturnType of this composable\n// will naturally expose everything.\n// \n// For backward compatibility with the View, we'll destructure and re-return everything.\n/*\ninterface ActionsState {\n    // ... moved to sub-composables\n}\n*/\n\n// Note: arguments changed slightly - state is now internal/distributed\nexport function useCanvasActions(\n    deps: ActionsDeps,\n    // state argument removed or ignored as we build it up\n    ignoredState: any,\n    undoHistory: any\n) {\n    const canvasStore = useCanvasStore()\n    const contextMenuStore = useCanvasContextMenuStore()\n    const taskStore = useTaskStore()\n    const { getSelectedNodes, screenToFlowCoordinate, removeNodes, fitView } = useVueFlow()\n\n    // --- Instantiate Sub-Composables ---\n\n    // Groups\n    const groupActions = useCanvasGroupActions({\n        viewport: deps.viewport,\n        syncNodes: deps.syncNodes,\n        batchSyncNodes: deps.batchedSyncNodes,\n        closeCanvasContextMenu: deps.closeCanvasContextMenu,\n        screenToFlowCoordinate: (pos) => screenToFlowCoordinate(pos),\n        recentlyDeletedGroups: deps.recentlyDeletedGroups,\n        state: ignoredState // Pass the potentially injected state (modals)\n    })\n\n    // Tasks\n    const taskActions = useCanvasTaskActions({\n        syncNodes: deps.syncNodes,\n        batchSyncNodes: deps.batchedSyncNodes,\n        closeCanvasContextMenu: deps.closeCanvasContextMenu,\n        screenToFlowCoordinate: (pos) => screenToFlowCoordinate(pos),\n        recentlyDeletedGroups: deps.recentlyDeletedGroups,\n        undoHistory,\n        fitView: (options) => fitView(options)\n    })\n\n    // --- Orchestrator Logic (things that don't fit cleanly or bridge both) ---\n\n    // Node Context Menu (Orchestrates between Groups and Tasks)\n    const selectedNode = ref<Node | null>(null)\n    const showNodeContextMenu = ref(false)\n    const nodeContextMenuX = ref(0)\n    const nodeContextMenuY = ref(0)\n\n    // BUG-208 FIX: Use Pinia store for context menu state\n    // Previously local refs were used but CanvasContextMenus.vue reads from the store\n    const handleNodeContextMenu = (event: { node: Node; event: MouseEvent | TouchEvent }) => {\n        if (import.meta.env.DEV) {\n            console.debug('[CANVAS:ACTIONS] handleNodeContextMenu called', {\n                nodeId: event.node.id,\n                eventType: event.event.type,\n                isGroupNode: CanvasIds.isGroupNode(event.node.id)\n            })\n        }\n        event.event.preventDefault()\n        event.event.stopPropagation()\n\n        if (!CanvasIds.isGroupNode(event.node.id)) return\n\n        const mouseEvent = event.event as MouseEvent\n        const { id: sectionId } = CanvasIds.parseNodeId(event.node.id)\n        const section = canvasStore.sections.find(s => s.id === sectionId)\n\n        if (section) {\n            // Show the canvas context menu with group actions (TASK-070)\n            contextMenuStore.openCanvasContextMenu(mouseEvent.clientX || 0, mouseEvent.clientY || 0, section)\n        } else {\n            // Ghost handling\n            const ghostSection: CanvasSection = {\n                id: sectionId,\n                name: (event.node.data?.name as string) || 'Unknown Group (Ghost)',\n                color: (event.node.data?.color as string) || '#6366f1',\n                position: { x: 0, y: 0, width: CANVAS.DEFAULT_GROUP_WIDTH, height: CANVAS.DEFAULT_GROUP_HEIGHT },\n                isCollapsed: false,\n                type: 'custom',\n                layout: 'freeform',\n                isVisible: true\n            }\n            contextMenuStore.openCanvasContextMenu(mouseEvent.clientX || 0, mouseEvent.clientY || 0, ghostSection)\n        }\n\n        deps.closeEdgeContextMenu()\n    }\n\n    const closeNodeContextMenu = () => {\n        showNodeContextMenu.value = false\n        selectedNode.value = null\n    }\n\n    const deleteNode = async () => {\n        if (!selectedNode.value) return\n\n        if (CanvasIds.isGroupNode(selectedNode.value.id)) {\n            const { id: sectionId } = CanvasIds.parseNodeId(selectedNode.value.id)\n            // Check existence\n            const section = canvasStore.sections.find(s => s.id === sectionId)\n\n            // Delegate to group actions\n            if (section) {\n                groupActions.deleteGroup(section)\n            } else {\n                // Ghost?\n                const ghost: CanvasSection = {\n                    id: sectionId,\n                    name: 'Ghost',\n                    color: '#000',\n                    position: { x: 0, y: 0, w: 0, h: 0 } as any,\n                    type: 'custom',\n                    layout: 'freeform',\n                    isVisible: true,\n                    isCollapsed: false\n                }\n                groupActions.deleteGroup(ghost)\n            }\n        }\n        closeNodeContextMenu()\n    }\n\n    /**\n     * TASK-1128: Create a new group from currently selected nodes\n     *\n     * 1. Gets all selected task nodes (ignores group nodes)\n     * 2. Calculates bounding box of selected nodes\n     * 3. Creates a new group that contains all selected tasks\n     * 4. Updates task parentIds to the new group\n     */\n    const createGroupFromSelection = async () => {\n        const selectedNodes = getSelectedNodes.value\n        if (import.meta.env.DEV) {\n            console.log('📦 [TASK-1128] createGroupFromSelection called', { selectedCount: selectedNodes.length })\n        }\n\n        // Filter to only task nodes (exclude group nodes)\n        const taskNodes = selectedNodes.filter(node => CanvasIds.isTaskNode(node.id))\n\n        if (taskNodes.length < 2) {\n            if (import.meta.env.DEV) {\n                console.warn('📦 [TASK-1128] Need at least 2 tasks selected to create a group')\n            }\n            return\n        }\n\n        // Calculate bounding box of selected task nodes using ABSOLUTE positions\n        // BUG-1203 FIX: node.position is relative when task has a parent group.\n        // Using computedPosition (absolute) prevents wrong bounding box calculation.\n        const PADDING = 40 // Padding around the group\n        const NODE_WIDTH = 280 // Approximate task card width\n        const NODE_HEIGHT = 80 // Approximate task card height\n\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n\n        for (const node of taskNodes) {\n            // BUG-1203: Use computedPosition (absolute) instead of position (may be relative)\n            const vfNode = node as any\n            const x = (vfNode.computedPosition?.x != null && isFinite(vfNode.computedPosition.x))\n                ? vfNode.computedPosition.x\n                : node.position.x\n            const y = (vfNode.computedPosition?.y != null && isFinite(vfNode.computedPosition.y))\n                ? vfNode.computedPosition.y\n                : node.position.y\n            minX = Math.min(minX, x)\n            minY = Math.min(minY, y)\n            maxX = Math.max(maxX, x + NODE_WIDTH)\n            maxY = Math.max(maxY, y + NODE_HEIGHT)\n        }\n\n        // Add padding to the bounding box\n        const groupPosition = {\n            x: minX - PADDING,\n            y: minY - PADDING,\n            width: (maxX - minX) + (PADDING * 2),\n            height: (maxY - minY) + (PADDING * 2)\n        }\n\n        if (import.meta.env.DEV) {\n            console.log('📦 [TASK-1128] Creating group at:', groupPosition, 'for', taskNodes.length, 'tasks')\n        }\n\n        // Create the group data\n        const groupData: Omit<CanvasGroup, 'id'> = {\n            name: 'New Group',\n            type: 'custom',\n            position: groupPosition,\n            color: '#6366f1', // Default indigo color\n            layout: 'freeform',\n            isVisible: true,\n            isCollapsed: false\n        }\n\n        try {\n            // Create the group via canvas store\n            const newGroup = await canvasStore.createGroup(groupData)\n\n            if (newGroup) {\n                if (import.meta.env.DEV) {\n                    console.log('📦 [TASK-1128] Group created:', newGroup.id, '- updating task parentIds')\n                }\n\n                // Update all selected tasks to have this group as their parent\n                for (const node of taskNodes) {\n                    const taskId = node.id\n                    const task = taskStore.tasks.find(t => t.id === taskId)\n\n                    if (task) {\n                        // Update task with new parentId\n                        await taskStore.updateTask(taskId, {\n                            parentId: newGroup.id\n                        }, 'USER')\n                    }\n                }\n\n                // Sync the canvas\n                deps.batchedSyncNodes('high')\n\n                if (import.meta.env.DEV) {\n                    console.log('📦 [TASK-1128] Successfully created group with', taskNodes.length, 'tasks')\n                }\n            }\n        } catch (error) {\n            console.error('📦 [TASK-1128] Failed to create group from selection:', error)\n        }\n\n        // Close context menu\n        deps.closeCanvasContextMenu()\n    }\n\n    // --- Re-Export Everything ---\n    return {\n        // Group Actions & State\n        createGroup: groupActions.createGroup,\n        closeGroupModal: groupActions.closeGroupModal,\n        handleGroupCreated: groupActions.handleGroupCreated,\n        handleGroupUpdated: groupActions.handleGroupUpdated,\n        editGroup: groupActions.editGroup,\n        closeGroupEditModal: groupActions.closeGroupEditModal,\n        handleGroupEditSave: groupActions.handleGroupEditSave,\n        deleteGroup: groupActions.deleteGroup,\n        confirmDeleteGroup: groupActions.confirmDeleteGroup,\n        cancelDeleteGroup: groupActions.cancelDeleteGroup,\n\n        isGroupModalOpen: groupActions.isGroupModalOpen,\n        selectedGroup: groupActions.selectedGroup,\n        groupModalPosition: groupActions.groupModalPosition,\n        isGroupEditModalOpen: groupActions.isGroupEditModalOpen,\n        selectedSectionForEdit: groupActions.selectedSectionForEdit,\n        isDeleteGroupModalOpen: groupActions.isDeleteGroupModalOpen,\n        groupPendingDelete: groupActions.groupPendingDelete,\n\n        // Task Actions & State\n        createTaskHere: taskActions.createTaskHere,\n        createTaskInGroup: taskActions.createTaskInGroup,\n        createConnectedTask: taskActions.createConnectedTask,\n        handleQuickTaskCreate: taskActions.handleQuickTaskCreate,\n        closeQuickTaskCreate: taskActions.closeQuickTaskCreate,\n        moveSelectedTasksToInbox: taskActions.moveSelectedTasksToInbox,\n        doneForNowSelectedTasks: taskActions.doneForNowSelectedTasks,\n        deleteSelectedTasks: taskActions.deleteSelectedTasks,\n        confirmBulkDelete: taskActions.confirmBulkDelete,\n        cancelBulkDelete: taskActions.cancelBulkDelete,\n        arrangeDoneTasksInGrid: taskActions.arrangeDoneTasksInGrid,\n        collectOverdueTasksNearGroup: taskActions.collectOverdueTasksNearGroup,\n\n        isQuickTaskCreateOpen: taskActions.isQuickTaskCreateOpen,\n        quickTaskPosition: taskActions.quickTaskPosition,\n        isBulkDeleteModalOpen: taskActions.isBulkDeleteModalOpen,\n        bulkDeleteItems: taskActions.bulkDeleteItems,\n        bulkDeleteIsPermanent: taskActions.bulkDeleteIsPermanent,\n\n        // Orchestrator State & Actions\n        handleNodeContextMenu,\n        closeNodeContextMenu,\n        deleteNode,\n        // TASK-1128: Create group from selected tasks\n        createGroupFromSelection,\n\n        selectedNode,\n        showNodeContextMenu,\n        nodeContextMenuX,\n        nodeContextMenuY\n        // BUG-208: Canvas context menu state removed - now managed by useCanvasContextMenuStore\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasAlignment.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2359,2362],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2359,2362],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2442,2445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2442,2445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":493,"column":53,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":493,"endColumn":94}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useCanvasAlignment - TASK-258, TASK-1081\n *\n * Multi-select alignment for canvas context menu.\n * Supports BOTH tasks AND groups (sections).\n * Provides Figma/Sketch-like alignment operations.\n *\n * CRITICAL INVARIANTS (TASK-255):\n * - Uses ABSOLUTE positions (computedPosition) for correct alignment of nested tasks\n * - Updates via taskStore.updateTask() with 'DRAG' source to respect geometry invariants\n * - Updates groups via canvasStore.updateGroup() preserving width/height\n * - Batches all updates into a single undo action via saveState()\n */\n\nimport { type Ref, nextTick } from 'vue'\nimport { type Node } from '@vue-flow/core'\nimport { useMessage } from 'naive-ui'\nimport { useTaskStore } from '../../stores/tasks'\nimport { useCanvasStore } from '../../stores/canvas'\nimport { getUndoSystem } from '../../composables/undoSingleton'\nimport { CanvasIds } from '../../utils/canvas/canvasIds'\n\ninterface NodeWithComputed extends Node {\n    computedPosition?: { x: number; y: number }\n    width?: number\n    height?: number\n}\n\n// TASK-258: Standard dimensions for fallback\nconst DEFAULT_WIDTH = 280  // Actual task cards are wider with content\nconst DEFAULT_HEIGHT = 100 // Actual task cards are taller with metadata\n\n// TASK-335/TASK-340: Spacing for layout operations\n// Use generous spacing to prevent overlap with varying task sizes\nconst DEFAULT_SPACING_X = 300  // Comfortable horizontal gap\nconst DEFAULT_SPACING_Y = 130  // Comfortable vertical gap\nconst MIN_SPACING_THRESHOLD = 10  // Below this, use default spacing\n\n/**\n * Get absolute position for a node.\n * Uses computedPosition if available (nested nodes), falls back to position (root nodes).\n */\nfunction getAbsolutePosition(node: NodeWithComputed): { x: number; y: number } {\n    // computedPosition is always absolute (world coordinates)\n    if (node.computedPosition &&\n        typeof node.computedPosition.x === 'number' &&\n        typeof node.computedPosition.y === 'number') {\n        return { x: node.computedPosition.x, y: node.computedPosition.y }\n    }\n    // For root nodes without parent, position IS absolute\n    return { x: node.position.x, y: node.position.y }\n}\n\n/**\n * Get full bounding box for a node in absolute coordinates.\n */\nfunction getNodeBounds(node: NodeWithComputed) {\n    const abs = getAbsolutePosition(node)\n    const width = node.width ?? (node as any).dimensions?.width ?? DEFAULT_WIDTH\n    const height = node.height ?? (node as any).dimensions?.height ?? DEFAULT_HEIGHT\n\n    return {\n        left: abs.x,\n        top: abs.y,\n        right: abs.x + width,\n        bottom: abs.y + height,\n        width,\n        height,\n        centerX: abs.x + width / 2,\n        centerY: abs.y + height / 2\n    }\n}\n\nexport function useCanvasAlignment(\n    nodes: Ref<Node[]>,\n    status: {\n        isVueFlowMounted: Ref<boolean>\n        isVueFlowReady: Ref<boolean>\n        isCanvasReady: Ref<boolean>\n    },\n    actions: {\n        closeCanvasContextMenu: () => void\n        requestSync?: () => void\n    }\n) {\n    const message = useMessage()\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n\n    /**\n     * TASK-1081: Update position for either a task or a group\n     * - Tasks: use canvasPosition { x, y } via taskStore.updateTask\n     * - Groups: use position { x, y, width, height } via canvasStore.updateGroup\n     */\n    const updateNodePosition = async (node: NodeWithComputed, newX: number, newY: number) => {\n        if (node.type === 'sectionNode') {\n            // Group node - update via canvasStore, preserve width/height\n            const groupId = CanvasIds.parseNodeId(node.id).id\n            const currentGroup = canvasStore.groups.find(g => g.id === groupId)\n            if (currentGroup) {\n                await canvasStore.updateGroup(groupId, {\n                    position: {\n                        x: newX,\n                        y: newY,\n                        width: currentGroup.position.width,\n                        height: currentGroup.position.height\n                    }\n                })\n            }\n        } else {\n            // Task node - update via taskStore with 'DRAG' source\n            await taskStore.updateTask(node.id, {\n                canvasPosition: { x: newX, y: newY },\n                positionFormat: 'absolute'\n            }, 'DRAG')\n        }\n    }\n\n    // Pre-alignment state validation function\n    const validateAlignmentState = (minNodes: number = 2): { canProceed: boolean; reason?: string } => {\n        // Check if Vue Flow component is mounted\n        if (!status.isVueFlowMounted.value) {\n            return {\n                canProceed: false,\n                reason: 'Vue Flow component not yet mounted - please wait'\n            }\n        }\n\n        // Check if Vue Flow instance is available (DOM check)\n        const vueFlowInstance = document.querySelector('.vue-flow')\n        if (!vueFlowInstance) {\n            return {\n                canProceed: false,\n                reason: 'Vue Flow component not yet mounted'\n            }\n        }\n\n        if (nodes.value.length === 0) {\n            return {\n                canProceed: false,\n                reason: 'No nodes available in canvas'\n            }\n        }\n\n        // Check selection synchronization\n        // TASK-1081: Include both tasks AND groups (sections) for alignment\n        // Tasks have type 'taskNode', groups have type 'sectionNode'\n        const storeSelectedIds = canvasStore.selectedNodeIds\n        const vueFlowSelected = nodes.value.filter(n =>\n            'selected' in n && n.selected && (n.type === 'taskNode' || n.type === 'sectionNode')\n        )\n\n        if (vueFlowSelected.length < minNodes) {\n            // BUG-1062: Also check if store has enough items but Vue Flow is desynced\n            // This can happen when syncStoreToCanvas() rebuilds nodes without preserving selection\n            if (storeSelectedIds.length >= minNodes) {\n                console.warn('[ALIGNMENT] Selection desync: store has items but Vue Flow lost selection', {\n                    storeSelectedIds,\n                    vueFlowSelectedIds: vueFlowSelected.map(n => n.id)\n                })\n                return {\n                    canProceed: false,\n                    reason: `Selection lost during sync - please re-select your items (store: ${storeSelectedIds.length}, Vue Flow: ${vueFlowSelected.length})`\n                }\n            }\n            return {\n                canProceed: false,\n                reason: `Need at least ${minNodes} selected items, have ${vueFlowSelected.length}`\n            }\n        }\n\n        const syncInfo = {\n            storeSelection: storeSelectedIds.length,\n            vueFlowSelection: vueFlowSelected.length,\n            matched: vueFlowSelected.filter(n => storeSelectedIds.includes(n.id)).length\n        }\n\n        // BUG-1062 FIX: Compare selections on both sides\n        if (syncInfo.matched !== syncInfo.storeSelection) {\n            console.warn('[ALIGNMENT] Selection state mismatch detected', {\n                storeSelectedIds,\n                vueFlowSelectedIds: vueFlowSelected.map(n => n.id),\n                syncInfo\n            })\n            return {\n                canProceed: false,\n                reason: 'Selection state not synchronized between store and Vue Flow'\n            }\n        }\n\n        return { canProceed: true }\n    }\n\n    /**\n     * Execute an alignment operation with batch undo support.\n     *\n     * GEOMETRY INVARIANT: Uses 'DRAG' source for all position updates.\n     * UNDO SUPPORT: Wraps all updates in saveState() for single undo action.\n     */\n    const executeAlignmentOperation = async (\n        operationName: string,\n        operation: (selectedNodes: NodeWithComputed[]) => void | Promise<void>,\n        minNodes: number = 2\n    ) => {\n        // Pre-alignment state validation\n        console.log('🔍 executeAlignmentOperation:', operationName, 'minNodes:', minNodes)\n        const validation = validateAlignmentState(minNodes)\n        console.log('🔍 validation result:', validation)\n        if (!validation.canProceed) {\n            message.warning(validation.reason || 'Validation failed')\n            return false\n        }\n\n        // TASK-1081: Include both tasks (taskNode) and groups (sectionNode)\n        const selectedNodes = nodes.value.filter(n =>\n            canvasStore.selectedNodeIds.includes(n.id) &&\n            (n.type === 'taskNode' || n.type === 'sectionNode')\n        ) as NodeWithComputed[]\n\n        if (selectedNodes.length < minNodes) {\n            const errorMsg = `Need at least ${minNodes} selected items for ${operationName.toLowerCase()}, have ${selectedNodes.length}`\n            message.error(errorMsg)\n            return false\n        }\n\n        try {\n            // Show temporary loading state\n            message.loading(`Performing ${operationName.toLowerCase()}...`, { duration: 300 })\n\n            // BUG-1068 FIX: Set manualOperationInProgress to prevent sync from interfering\n            // This flag tells the sync system to skip updates while we're batch-updating positions\n            taskStore.manualOperationInProgress = true\n\n            // BATCH UNDO: Save state BEFORE all operations\n            await getUndoSystem().saveState(`Before ${operationName}`)\n\n            // BUG-1068 FIX: Await the operation - it's async since BUG-1051\n            // Without await, updateTask() calls yield and sync overwrites positions\n            await operation(selectedNodes)\n\n            // BATCH UNDO: Save state AFTER all operations\n            await nextTick()\n            await getUndoSystem().saveState(`After ${operationName}`)\n\n            // BUG-1068 FIX: Release the lock before triggering sync\n            taskStore.manualOperationInProgress = false\n\n            // Show success feedback\n            message.success(`Successfully aligned ${selectedNodes.length} items ${operationName.toLowerCase().replace('align ', '')}`)\n\n            // TASK-258 FIX: Force visual sync since orchestrator doesn't watch property changes\n            if (actions.requestSync) {\n                actions.requestSync()\n            }\n\n            return true\n        } catch (error) {\n            // BUG-1068: Always release the lock on error\n            taskStore.manualOperationInProgress = false\n            message.error(`Alignment operation failed: ${error instanceof Error ? error.message : 'Unknown error'}`)\n            return false\n        }\n    }\n\n    // =========================================================================\n    // ALIGNMENT OPERATIONS - TASK-1081: Now supports both tasks AND groups\n    // All use ABSOLUTE positions via getAbsolutePosition()\n    // Tasks use 'DRAG' source, groups update via canvasStore\n    // =========================================================================\n\n    const alignLeft = () => {\n        executeAlignmentOperation('Align Left', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            const minX = Math.min(...boundsMapping.map(b => b.bounds.left))\n\n            for (const { node, bounds } of boundsMapping) {\n                await updateNodePosition(node, minX, bounds.top)\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const alignRight = () => {\n        executeAlignmentOperation('Align Right', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            const maxX = Math.max(...boundsMapping.map(b => b.bounds.right))\n\n            for (const { node, bounds } of boundsMapping) {\n                // To align right edge, substract width from maxRight\n                await updateNodePosition(node, maxX - bounds.width, bounds.top)\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const alignTop = () => {\n        executeAlignmentOperation('Align Top', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            const minY = Math.min(...boundsMapping.map(b => b.bounds.top))\n\n            for (const { node, bounds } of boundsMapping) {\n                await updateNodePosition(node, bounds.left, minY)\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const alignBottom = () => {\n        executeAlignmentOperation('Align Bottom', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            const maxY = Math.max(...boundsMapping.map(b => b.bounds.bottom))\n\n            for (const { node, bounds } of boundsMapping) {\n                // To align bottom edge, substract height from maxBottom\n                await updateNodePosition(node, bounds.left, maxY - bounds.height)\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const alignCenterHorizontal = () => {\n        executeAlignmentOperation('Center Horizontal', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            const avgCenterX = boundsMapping.reduce((sum, b) => sum + b.bounds.centerX, 0) / boundsMapping.length\n\n            for (const { node, bounds } of boundsMapping) {\n                // To center, subtract half width from avg center X\n                await updateNodePosition(node, avgCenterX - bounds.width / 2, bounds.top)\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const alignCenterVertical = () => {\n        executeAlignmentOperation('Center Vertical', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            const avgCenterY = boundsMapping.reduce((sum, b) => sum + b.bounds.centerY, 0) / boundsMapping.length\n\n            for (const { node, bounds } of boundsMapping) {\n                // To middle-align, subtract half height from avg center Y\n                await updateNodePosition(node, bounds.left, avgCenterY - bounds.height / 2)\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const distributeHorizontal = () => {\n        executeAlignmentOperation('Distribute Horizontal', async (selectedNodes) => {\n            if (selectedNodes.length < 3) return\n\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            // Sort by current absolute left edge\n            const sorted = [...boundsMapping].sort((a, b) => a.bounds.left - b.bounds.left)\n\n            // BUG-1068: Calculate edge-to-edge distribution for consistent visual gaps\n            // Total width of all items combined\n            const totalItemWidth = sorted.reduce((sum, { bounds }) => sum + bounds.width, 0)\n            // Available space between first left and last right\n            const firstLeft = sorted[0].bounds.left\n            const lastRight = sorted[sorted.length - 1].bounds.right\n            const totalSpace = lastRight - firstLeft\n            // Calculate gap: (total space - item widths) / number of gaps\n            const gapCount = sorted.length - 1\n            let gap = gapCount > 0 ? (totalSpace - totalItemWidth) / gapCount : 16\n            // TASK-335: If items are stacked (negative or tiny gap), use fixed spacing\n            if (gap < MIN_SPACING_THRESHOLD) gap = 16\n\n            let currentX = firstLeft\n            for (const { node, bounds } of sorted) {\n                await updateNodePosition(node, currentX, bounds.top)\n                currentX += bounds.width + gap\n            }\n\n            actions.closeCanvasContextMenu()\n        }, 3) // Min 3 nodes\n    }\n\n    const distributeVertical = () => {\n        executeAlignmentOperation('Distribute Vertical', async (selectedNodes) => {\n            if (selectedNodes.length < 3) return\n\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            // Sort by current absolute top edge\n            const sorted = [...boundsMapping].sort((a, b) => a.bounds.top - b.bounds.top)\n\n            // BUG-1068: Calculate edge-to-edge distribution for consistent visual gaps\n            // Total height of all items combined\n            const totalItemHeight = sorted.reduce((sum, { bounds }) => sum + bounds.height, 0)\n            // Available space between first top and last bottom\n            const firstTop = sorted[0].bounds.top\n            const lastBottom = sorted[sorted.length - 1].bounds.bottom\n            const totalSpace = lastBottom - firstTop\n            // Calculate gap: (total space - item heights) / number of gaps\n            const gapCount = sorted.length - 1\n            let gap = gapCount > 0 ? (totalSpace - totalItemHeight) / gapCount : 16\n            // TASK-335: If items are stacked (negative or tiny gap), use fixed spacing\n            if (gap < MIN_SPACING_THRESHOLD) gap = 16\n\n            let currentY = firstTop\n            for (const { node, bounds } of sorted) {\n                await updateNodePosition(node, bounds.left, currentY)\n                currentY += bounds.height + gap\n            }\n\n            actions.closeCanvasContextMenu()\n        }, 3)\n    }\n\n    const arrangeInRow = () => {\n        executeAlignmentOperation('Arrange in Row', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            // Sort by current absolute X\n            const sorted = [...boundsMapping].sort((a, b) => a.bounds.left - b.bounds.left)\n\n            // Calculate average Center Y position (absolute)\n            const avgCenterY = sorted.reduce((sum, b) => sum + b.bounds.centerY, 0) / sorted.length\n\n            // Find the leftmost X position (absolute)\n            const startX = sorted[0].bounds.left\n\n            // BUG-1068: Use edge-to-edge gap spacing for consistent visual gaps\n            const GAP = 16  // Consistent visual gap between item edges\n\n            let currentX = startX\n            for (const { node, bounds } of sorted) {\n                await updateNodePosition(node, currentX, avgCenterY - bounds.height / 2)\n                // Move X right by this item's width + gap for next item\n                currentX += bounds.width + GAP\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const arrangeInColumn = () => {\n        executeAlignmentOperation('Arrange in Column', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n            // Sort by current absolute Y\n            const sorted = [...boundsMapping].sort((a, b) => a.bounds.top - b.bounds.top)\n\n            // Calculate average Center X position (absolute)\n            const avgCenterX = sorted.reduce((sum, b) => sum + b.bounds.centerX, 0) / sorted.length\n\n            // Find the topmost Y position (absolute)\n            const startY = sorted[0].bounds.top\n\n            // BUG-1068: Use edge-to-edge gap spacing for consistent visual gaps\n            // Instead of fixed spacing from top, position each item based on previous item's bottom\n            const GAP = 16  // Consistent visual gap between item edges\n\n            let currentY = startY\n            for (const { node, bounds } of sorted) {\n                await updateNodePosition(node, avgCenterX - bounds.width / 2, currentY)\n                // Move Y down by this item's height + gap for next item\n                currentY += bounds.height + GAP\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    const arrangeInGrid = () => {\n        executeAlignmentOperation('Arrange in Grid', async (selectedNodes) => {\n            const boundsMapping = selectedNodes.map(n => ({ node: n, bounds: getNodeBounds(n) }))\n\n            // Calculate grid dimensions - prefer wider grids\n            const count = boundsMapping.length\n            const cols = Math.ceil(Math.sqrt(count))\n\n            // Calculate average position as grid center (absolute)\n            const avgCenterX = boundsMapping.reduce((sum, b) => sum + b.bounds.centerX, 0) / boundsMapping.length\n            const avgCenterY = boundsMapping.reduce((sum, b) => sum + b.bounds.centerY, 0) / boundsMapping.length\n\n            // Use generous spacing to prevent overlap\n            const SPACING_X = DEFAULT_SPACING_X\n            const SPACING_Y = DEFAULT_SPACING_Y\n\n            // Calculate grid starting position (centered around average position)\n            const rows = Math.ceil(count / cols)\n            const gridWidth = (cols - 1) * SPACING_X\n            const gridHeight = (rows - 1) * SPACING_Y\n            const startX = avgCenterX - (gridWidth / 2)\n            const startY = avgCenterY - (gridHeight / 2)\n\n            // Arrange nodes in grid\n            for (const { node, bounds } of boundsMapping) {\n                const index = boundsMapping.indexOf(boundsMapping.find(b => b.node === node)!)\n                const row = Math.floor(index / cols)\n                const col = index % cols\n\n                const newX = startX + (col * SPACING_X) - bounds.width / 2  // Centering node in cell\n                const newY = startY + (row * SPACING_Y) - bounds.height / 2\n                await updateNodePosition(node, newX, newY)\n            }\n\n            actions.closeCanvasContextMenu()\n        })\n    }\n\n    return {\n        alignLeft,\n        alignRight,\n        alignTop,\n        alignBottom,\n        alignCenterHorizontal,\n        alignCenterVertical,\n        distributeHorizontal,\n        distributeVertical,\n        arrangeInRow,\n        arrangeInColumn,\n        arrangeInGrid\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasConnections.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[488,491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[488,491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[513,516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[513,516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[532,535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[532,535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":114,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":117,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[542,545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[542,545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { type Ref } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { EdgeMouseEvent, Edge } from '@vue-flow/core'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport { getViewportCoordinates } from '@/utils/contextMenuCoordinates'\n\ninterface ConnectionDeps {\n    syncEdges: () => void\n    closeCanvasContextMenu: () => void\n    closeEdgeContextMenu: () => void\n    closeNodeContextMenu: () => void\n    withVueFlowErrorBoundary: (name: string, fn: (...args: any[]) => any, options?: any) => ((...args: any[]) => any)\n    // For drag-to-create feature\n    screenToFlowCoordinate?: (pos: { x: number; y: number }) => { x: number; y: number }\n    createConnectedTask?: (position: { x: number; y: number }, parentTaskId: string) => void\n}\n\ninterface ConnectionState {\n    isConnecting: Ref<boolean>\n    recentlyRemovedEdges: Ref<Set<string>>\n    showEdgeContextMenu: Ref<boolean>\n    edgeContextMenuX: Ref<number>\n    edgeContextMenuY: Ref<number>\n    selectedEdge: Ref<Edge | null>\n    // For drag-to-create feature\n    pendingConnectionSource?: Ref<string | null>\n    connectionWasSuccessful?: Ref<boolean>\n}\n\nexport function useCanvasConnections(\n    deps: ConnectionDeps,\n    state: ConnectionState\n) {\n    const taskStore = useTaskStore()\n\n    const handleConnectStart = (event: { nodeId?: string; handleId?: string | null; handleType?: string }) => {\n        state.isConnecting.value = true\n        document.body.classList.add('connecting-active')\n\n        // Track source node for drag-to-create feature\n        if (state.pendingConnectionSource) {\n            state.pendingConnectionSource.value = event.nodeId || null\n        }\n        if (state.connectionWasSuccessful) {\n            state.connectionWasSuccessful.value = false\n        }\n\n        deps.closeCanvasContextMenu()\n        deps.closeEdgeContextMenu()\n        deps.closeNodeContextMenu()\n    }\n\n    const handleConnectEnd = (event?: MouseEvent | TouchEvent | { nodeId?: string; handleId?: string; handleType?: string }) => {\n        const sourceTaskId = state.pendingConnectionSource?.value\n        const wasSuccessful = state.connectionWasSuccessful?.value\n\n        // Use setTimeout to ensure onConnect has time to fire first\n        setTimeout(() => {\n            // Drag-to-create: Only trigger if:\n            // 1. We have a source task ID\n            // 2. Connection was NOT successful (dropped on empty space)\n            // 3. We have mouse coordinates\n            // 4. The deps are provided\n            if (\n                sourceTaskId &&\n                !wasSuccessful &&\n                event &&\n                'clientX' in event &&\n                deps.screenToFlowCoordinate &&\n                deps.createConnectedTask\n            ) {\n                const flowCoords = deps.screenToFlowCoordinate({\n                    x: (event as MouseEvent).clientX,\n                    y: (event as MouseEvent).clientY\n                })\n                deps.createConnectedTask(flowCoords, sourceTaskId)\n            }\n\n            // Cleanup\n            state.isConnecting.value = false\n            if (state.pendingConnectionSource) {\n                state.pendingConnectionSource.value = null\n            }\n            if (state.connectionWasSuccessful) {\n                state.connectionWasSuccessful.value = false\n            }\n            document.body.classList.remove('connecting-active')\n        }, 50) // Small delay to let onConnect fire first\n    }\n\n    const handleConnect = deps.withVueFlowErrorBoundary('handleConnect', async (connection: { source: string; target: string; sourceHandle?: string; targetHandle?: string }) => {\n        // Mark connection as successful FIRST - this prevents drag-to-create from firing\n        if (state.connectionWasSuccessful) {\n            state.connectionWasSuccessful.value = true\n        }\n\n        const { source, target } = connection\n\n        deps.closeCanvasContextMenu()\n        deps.closeEdgeContextMenu()\n        deps.closeNodeContextMenu()\n\n        // Allow immediate re-creation of recently deleted edges\n        // If the user manually connects A->B, we must unblock it from the \"zombie edge\" protection list\n        const potentialEdgeId = CanvasIds.edgeId(source, target)\n        if (state.recentlyRemovedEdges.value.has(potentialEdgeId)) {\n            state.recentlyRemovedEdges.value.delete(potentialEdgeId)\n        }\n\n        if (CanvasIds.isGroupNode(source) || CanvasIds.isGroupNode(target)) return\n        if (source === target) return\n\n        const sourceTask = taskStore.tasks.find(t => t.id === source)\n        const targetTask = taskStore.tasks.find(t => t.id === target)\n\n        if (sourceTask && targetTask && sourceTask.canvasPosition && targetTask.canvasPosition) {\n            // SUBTASK MODEL: Connection makes target a direct child of source (nested hierarchy)\n            // Only set if target doesn't already have a parent\n            if (!targetTask.parentTaskId) {\n                await taskStore.updateTaskWithUndo(target, { parentTaskId: source })\n                deps.syncEdges()\n            }\n        }\n    })\n\n    const disconnectEdge = async () => {\n        if (!state.selectedEdge.value) return\n\n        const { target, id: edgeId } = state.selectedEdge.value\n        const targetTask = taskStore.tasks.find(t => t.id === target)\n\n        state.recentlyRemovedEdges.value.add(edgeId)\n\n        setTimeout(() => {\n            state.recentlyRemovedEdges.value.delete(edgeId)\n        }, 2000)\n\n        // SUBTASK MODEL: Clear parentTaskId to remove subtask relationship\n        if (targetTask && targetTask.parentTaskId) {\n            await taskStore.updateTaskWithUndo(targetTask.id, { parentTaskId: null })\n            deps.syncEdges()\n        }\n\n        deps.closeEdgeContextMenu()\n    }\n\n    const handleEdgeContextMenu = (event: EdgeMouseEvent) => {\n        const mouseEvent = event.event as MouseEvent\n        event.event.preventDefault()\n        event.event.stopPropagation()\n\n        // BUG-1096: Use normalized coordinates for Tauri compatibility\n        const { x, y } = getViewportCoordinates(mouseEvent)\n        state.edgeContextMenuX.value = x\n        state.edgeContextMenuY.value = y\n        state.selectedEdge.value = event.edge\n        state.showEdgeContextMenu.value = true\n\n        deps.closeCanvasContextMenu()\n        deps.closeNodeContextMenu()\n    }\n\n    const closeEdgeContextMenu = () => {\n        state.showEdgeContextMenu.value = false\n        state.selectedEdge.value = null\n    }\n\n    /**\n     * Handle double-click on edge to disconnect it immediately\n     */\n    const handleEdgeDoubleClick = async (event: EdgeMouseEvent) => {\n        event.event.preventDefault()\n        event.event.stopPropagation()\n\n        const edge = event.edge\n        if (!edge) return\n\n        const { target, id: edgeId } = edge\n        const targetTask = taskStore.tasks.find(t => t.id === target)\n\n        // Add to recently removed to prevent zombie edge reappearing\n        state.recentlyRemovedEdges.value.add(edgeId)\n        setTimeout(() => {\n            state.recentlyRemovedEdges.value.delete(edgeId)\n        }, 2000)\n\n        // SUBTASK MODEL: Clear parentTaskId to remove subtask relationship\n        if (targetTask && targetTask.parentTaskId) {\n            await taskStore.updateTaskWithUndo(targetTask.id, { parentTaskId: null })\n            deps.syncEdges()\n        }\n    }\n\n    return {\n        handleConnectStart,\n        handleConnectEnd,\n        handleConnect,\n        disconnectEdge,\n        handleEdgeContextMenu,\n        handleEdgeDoubleClick,\n        closeEdgeContextMenu\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasContextMenus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasCore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasEdgeSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasFilteredState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ref' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ref"},"fix":{"range":[17,22],"text":""},"desc":"Remove unused variable \"ref\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, ref, type Ref } from 'vue'\nimport type { Task } from '@/types/tasks'\n\nimport { assertNoDuplicateIds } from '@/utils/canvas/invariants'\n\ninterface TaskStoreSettings {\n    hideCanvasDoneTasks?: boolean\n    hideCanvasOverdueTasks?: boolean\n}\n\ninterface CanvasGroup {\n    id: string\n    position: { x: number; y: number; width: number; height: number }\n}\n\ninterface CanvasStore {\n    calculateContentBounds: (tasks: Task[]) => { x: number; y: number; width: number; height: number }\n    taskStore?: TaskStoreSettings\n    groups?: CanvasGroup[]\n}\n\nexport function useCanvasFilteredState(filteredTasks: Ref<Task[]>, canvasStore: CanvasStore) {\n\n\n    // --- Caching Variables ---\n    let lastCanvasTasks: Task[] = []\n    let lastCanvasTasksHash = ''\n\n    let lastHasNoTasks = false\n    let lastHasNoTasksLength = -1\n\n    let lastHasInboxTasks = false\n    let lastHasInboxTasksHash = ''\n\n    let lastDynamicNodeExtent: [[number, number], [number, number]] | null = null\n    let lastDynamicNodeExtentHash = ''\n\n    // --- Computed State ---\n\n    /**\n     * Optimized filtering for tasks that have valid canvas positions.\n     * Consolidates filteredTasksWithCanvasPosition and tasksWithCanvasPositions.\n     * Also handles view-specific filtering (Hide Done, Hide Overdue).\n     */\n    const tasksWithCanvasPosition = computed(() => {\n        let tasks = filteredTasks.value\n        if (!Array.isArray(tasks)) return []\n\n        // 1. Filter out Done tasks if enabled in store\n        if (canvasStore.taskStore?.hideCanvasDoneTasks) {\n            tasks = tasks.filter(t => t.status !== 'done')\n        }\n\n        // 2. Filter out Overdue tasks if enabled\n        if (canvasStore.taskStore?.hideCanvasOverdueTasks) {\n            const today = new Date()\n            today.setHours(0, 0, 0, 0)\n            tasks = tasks.filter(t => {\n                if (!t.dueDate) return true\n                const due = new Date(t.dueDate)\n                return due >= today\n            })\n        }\n\n        // Robust hashing for cache invalidation\n        // TASK-370: Added parentId to hash - without it, parentId changes weren't invalidating cache,\n        // causing Vue Flow to not receive updated parentNode, breaking group dragging\n        const currentHash = tasks.map(t => `${t.id}:${t.title}:${t.description || ''}:${t.canvasPosition?.x || ''}:${t.canvasPosition?.y || ''}:${t.parentId || ''}:${t.updatedAt ? new Date(t.updatedAt).getTime() : ''}`).join('|')\n\n        if (currentHash === lastCanvasTasksHash && lastCanvasTasks.length > 0) {\n            return lastCanvasTasks\n        }\n\n        const result = tasks.filter(task => {\n            const pos = task.canvasPosition\n            return pos && typeof pos.x === 'number' && typeof pos.y === 'number'\n        })\n\n        // ================================================================\n        // DUPLICATE DETECTION - Canvas Selector Layer (AUTHORITATIVE)\n        // ================================================================\n        // This detects if the store/filtering layer is returning duplicates\n        // A duplicate here means the bug is upstream (in task store or filtering)\n        // Uses assertNoDuplicateIds for consistent detection across layers\n        if (import.meta.env.DEV) {\n            const checkResult = assertNoDuplicateIds(result, 'tasksWithCanvasPosition')\n\n            if (checkResult.hasDuplicates) {\n                console.error('[TASK-ID-HISTOGRAM] DUPLICATES in tasksWithCanvasPosition', {\n                    duplicates: checkResult.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                    totalCount: checkResult.totalCount,\n                    uniqueIdCount: checkResult.uniqueIdCount\n                })\n            }\n        }\n\n        lastCanvasTasksHash = currentHash\n        lastCanvasTasks = result\n        return result\n    })\n\n    const hasNoTasks = computed(() => {\n        const currentLength = filteredTasks.value?.length || 0\n        if (currentLength === lastHasNoTasksLength) return lastHasNoTasks\n\n        lastHasNoTasksLength = currentLength\n        lastHasNoTasks = currentLength === 0\n        return lastHasNoTasks\n    })\n\n    const hasInboxTasks = computed(() => {\n        const tasks = filteredTasks.value\n        if (!Array.isArray(tasks)) return false\n\n        const currentHash = tasks.map(t => `${t.id}:${!!t.canvasPosition}:${t.status}`).join('|')\n        if (currentHash === lastHasInboxTasksHash) return lastHasInboxTasks\n\n        // Logic: Task is in \"inbox\" if it has no canvas position and is not done\n        const result = tasks.some(task => !task.canvasPosition && task.status !== 'done')\n\n        lastHasInboxTasksHash = currentHash\n        lastHasInboxTasks = result\n        return result\n    })\n\n    const dynamicNodeExtent = computed(() => {\n        const tasks = tasksWithCanvasPosition.value\n        const groups = canvasStore.groups || []\n\n        // BUG-1310 FIX: When no tasks have canvas positions, the old default [-2000, 5000]\n        // was too small — groups near x=4556 hit an invisible wall at x=5000.\n        // Now we also consider group positions to compute the extent.\n        if (!tasks.length && !groups.length) {\n            return [[-50000, -50000], [50000, 50000]] as [[number, number], [number, number]]\n        }\n\n        // Build a hash from both tasks AND groups for cache invalidation\n        const taskHash = tasks.map(t => `${t.id}:${t.canvasPosition?.x || 0}:${t.canvasPosition?.y || 0}`).join('|')\n        const groupHash = groups.map(g => `${g.id}:${g.position?.x || 0}:${g.position?.y || 0}`).join('|')\n        const currentHash = `${taskHash}##${groupHash}`\n        if (currentHash === lastDynamicNodeExtentHash && lastDynamicNodeExtent) {\n            return lastDynamicNodeExtent\n        }\n\n        try {\n            const padding = 1000\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n\n            // Include task bounds\n            if (tasks.length) {\n                const bounds = canvasStore.calculateContentBounds(tasks)\n                minX = Math.min(minX, bounds.x)\n                minY = Math.min(minY, bounds.y)\n                maxX = Math.max(maxX, bounds.x + bounds.width)\n                maxY = Math.max(maxY, bounds.y + bounds.height)\n            }\n\n            // BUG-1310: Also include group bounds (critical when taskNodes=0)\n            for (const group of groups) {\n                if (!group.position) continue\n                const gx = group.position.x\n                const gy = group.position.y\n                const gw = group.position.width || 0\n                const gh = group.position.height || 0\n                minX = Math.min(minX, gx)\n                minY = Math.min(minY, gy)\n                maxX = Math.max(maxX, gx + gw)\n                maxY = Math.max(maxY, gy + gh)\n            }\n\n            // Fallback if somehow no valid bounds found\n            if (!isFinite(minX)) {\n                return [[-50000, -50000], [50000, 50000]] as [[number, number], [number, number]]\n            }\n\n            const result = [\n                [minX - padding * 10, minY - padding * 10],\n                [maxX + padding * 10, maxY + padding * 10]\n            ] as [[number, number], [number, number]]\n\n            if (import.meta.env.DEV) {\n                console.log('[BUG-1310:EXTENT] dynamicNodeExtent recalculated', {\n                    contentBounds: { minX: Math.round(minX), minY: Math.round(minY), maxX: Math.round(maxX), maxY: Math.round(maxY) },\n                    extent: { minX: Math.round(result[0][0]), minY: Math.round(result[0][1]), maxX: Math.round(result[1][0]), maxY: Math.round(result[1][1]) },\n                    taskCount: tasks.length,\n                    groupCount: groups.length\n                })\n            }\n\n            lastDynamicNodeExtent = result\n            lastDynamicNodeExtentHash = currentHash\n            return result\n        } catch (error) {\n            console.warn('⚠️ [COMPUTED] Error calculating dynamic node extent:', error)\n            return [[-50000, -50000], [50000, 50000]] as [[number, number], [number, number]]\n        }\n    })\n\n    // --- Helper Logic ---\n\n    return {\n        tasksWithCanvasPosition,\n        hasNoTasks,\n        hasInboxTasks,\n        dynamicNodeExtent\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasGroupActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sectionNodeId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":166,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":166,"endColumn":32},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":200,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":200,"endColumn":52,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8493,8494],"text":"?."},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, type Ref, nextTick } from 'vue'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\n// TASK-158: Persistent deleted groups tracking\nimport { markGroupDeleted, confirmGroupDeleted } from '@/utils/deletedGroupsTracker'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\n\nexport interface GroupActionsDeps {\n    viewport?: Ref<{ x: number; y: number; zoom: number }>\n    syncNodes: () => void\n    batchSyncNodes?: (priority?: 'high' | 'normal' | 'low') => void // Optional for now\n    closeCanvasContextMenu: () => void\n    screenToFlowCoordinate: (position: { x: number; y: number }) => { x: number; y: number }\n    recentlyDeletedGroups?: Ref<Set<string>>\n    state?: {\n        isGroupModalOpen: Ref<boolean>\n        selectedGroup: Ref<CanvasSection | null>\n        groupModalPosition: Ref<{ x: number; y: number }>\n        isGroupEditModalOpen: Ref<boolean>\n        selectedSectionForEdit: Ref<CanvasSection | null>\n        isDeleteGroupModalOpen: Ref<boolean>\n        groupPendingDelete: Ref<CanvasSection | null>\n    }\n}\n\nexport function useCanvasGroupActions(deps: GroupActionsDeps) {\n    const canvasStore = useCanvasStore()\n\n    // --- State (Use injected state or fallback to local) ---\n    const isGroupModalOpen = deps.state?.isGroupModalOpen ?? ref(false)\n    const selectedGroup = deps.state?.selectedGroup ?? ref<CanvasSection | null>(null)\n    const groupModalPosition = deps.state?.groupModalPosition ?? ref({ x: 100, y: 100 })\n\n    const isGroupEditModalOpen = deps.state?.isGroupEditModalOpen ?? ref(false)\n    const selectedSectionForEdit = deps.state?.selectedSectionForEdit ?? ref<CanvasSection | null>(null)\n\n    const isDeleteGroupModalOpen = deps.state?.isDeleteGroupModalOpen ?? ref(false)\n    const groupPendingDelete = deps.state?.groupPendingDelete ?? ref<CanvasSection | null>(null)\n\n    // --- Helper for Ghost Removal ---\n    // Note: duplicated small helper to avoid complex sharing, or could be passed in.\n    // Given its simplicity, I'll keep it here, but ideally it should be a shared util.\n    // For this refactor, I'll access the store directly to avoid circular dependency with orchestrator.\n    const removeGhostNodeRef = (id: string) => {\n        // We can't easily access VueFlow's removeNodes here without passing it in.\n        // But the main orchestrator handles the view dependencies.\n        // For pure data operations, we can modify the store.\n        if (canvasStore.nodes) {\n            const nodeId = CanvasIds.groupNodeId(id)\n            canvasStore.nodes = canvasStore.nodes.filter(n => n.id !== nodeId)\n        }\n    }\n\n    // --- Actions ---\n\n    const createGroup = async (screenPos?: { x: number; y: number }) => {\n        if (import.meta.env.DEV) {\n            console.log('[BUG-1126] useCanvasGroupActions.createGroup called', {\n                screenPos,\n                hasState: !!deps.state,\n                hasGroupModalPosition: !!deps.state?.groupModalPosition\n            })\n        }\n\n        const vueFlowElement = document.querySelector('.vue-flow') as HTMLElement\n        const viewport = deps.viewport?.value || { x: 0, y: 0, zoom: 1 }\n\n        // If no position provided, use viewport center\n        let flowCoords: { x: number; y: number }\n        if (!screenPos) {\n            // Note: Simplistic viewport center calculation if screenPos is missing\n            flowCoords = {\n                x: -viewport.x / viewport.zoom + (window.innerWidth / 2) / viewport.zoom,\n                y: -viewport.y / viewport.zoom + (window.innerHeight / 2) / viewport.zoom\n            }\n            if (import.meta.env.DEV) {\n                console.log('[BUG-1126] No screenPos provided, using viewport center:', flowCoords)\n            }\n        } else {\n            // BUG-1126 FIX: Manual coordinate conversion to ensure accuracy\n            // screenToFlowCoordinate may have issues with container offset detection\n            if (vueFlowElement) {\n                const containerRect = vueFlowElement.getBoundingClientRect()\n                // Convert screen coords to container-relative, then to flow coords\n                const containerX = screenPos.x - containerRect.left\n                const containerY = screenPos.y - containerRect.top\n                flowCoords = {\n                    x: (containerX - viewport.x) / viewport.zoom,\n                    y: (containerY - viewport.y) / viewport.zoom\n                }\n                if (import.meta.env.DEV) {\n                    console.log('[BUG-1126] Manual conversion:', {\n                        screenPos,\n                        containerRect: { left: containerRect.left, top: containerRect.top },\n                        containerRelative: { x: containerX, y: containerY },\n                        viewport,\n                        flowCoords\n                    })\n                }\n            } else {\n                // Fallback to Vue Flow's built-in conversion\n                flowCoords = deps.screenToFlowCoordinate(screenPos)\n                if (import.meta.env.DEV) {\n                    console.log('[BUG-1126] Fallback to screenToFlowCoordinate:', { screenPos, flowCoords })\n                }\n            }\n        }\n\n        if (import.meta.env.DEV) {\n            console.log('[BUG-1126] Setting groupModalPosition to:', flowCoords)\n        }\n        groupModalPosition.value = flowCoords\n        selectedGroup.value = null // Ensure create mode\n\n        deps.closeCanvasContextMenu()\n        isGroupModalOpen.value = true\n\n        return undefined // Matches Promise<string | undefined> expectation of hotkeys\n    }\n\n    const closeGroupModal = () => {\n        isGroupModalOpen.value = false\n        selectedGroup.value = null\n        groupModalPosition.value = { x: 100, y: 100 }\n    }\n\n    const handleGroupCreated = (_group: CanvasSection) => {\n        deps.syncNodes()\n    }\n\n    const handleGroupUpdated = (_group: CanvasSection) => {\n        deps.syncNodes()\n    }\n\n    const editGroup = (section: CanvasSection) => {\n        selectedSectionForEdit.value = section\n        isGroupEditModalOpen.value = true\n        deps.closeCanvasContextMenu()\n    }\n\n    const closeGroupEditModal = () => {\n        isGroupEditModalOpen.value = false\n        selectedSectionForEdit.value = null\n    }\n\n    const handleGroupEditSave = (updatedSection: Partial<CanvasSection> & { id: string }) => {\n        if (!updatedSection) return\n        canvasStore.updateSectionWithUndo(updatedSection.id, updatedSection)\n        deps.syncNodes()\n        closeGroupEditModal()\n    }\n\n    const deleteGroup = (section: CanvasSection) => {\n        if (!section) return\n\n        // Show designed confirmation modal instead of native confirm()\n        groupPendingDelete.value = section\n        isDeleteGroupModalOpen.value = true\n        deps.closeCanvasContextMenu()\n    }\n\n    const confirmDeleteGroup = async () => {\n        const section = groupPendingDelete.value\n        if (!section) return\n\n        try {\n            const sectionNodeId = CanvasIds.groupNodeId(section.id)\n\n            // TASK-158 FIX: Use persistent deleted groups tracker\n            markGroupDeleted(section.id)\n            if (deps.recentlyDeletedGroups) {\n                deps.recentlyDeletedGroups.value.add(section.id)\n            }\n\n            // BUG-091 FIX: Check if section exists in store (might be a ghost)\n            const existsInStore = canvasStore.sections.some(s => s.id === section.id)\n\n            if (!existsInStore) {\n                removeGhostNodeRef(section.id)\n\n                // Confirm deletion since there's nothing in Supabase to delete\n                confirmGroupDeleted(section.id)\n                if (deps.recentlyDeletedGroups) {\n                    deps.recentlyDeletedGroups.value.delete(section.id)\n                }\n            } else {\n                try {\n                    await canvasStore.deleteSection(section.id)\n                    confirmGroupDeleted(section.id)\n                    if (deps.recentlyDeletedGroups) {\n                        deps.recentlyDeletedGroups.value.delete(section.id)\n                    }\n                } catch (e) {\n                    console.error('[ASYNC-ERROR] confirmDeleteGroup deleteSection failed', e)\n                    // Don't clear from tracker on failure - let TTL handle cleanup\n                }\n            }\n\n            // Force high priority sync which cleans up/re-verifies\n            if (deps.batchSyncNodes) {\n                nextTick(() => deps.batchSyncNodes!('high'))\n            } else {\n                nextTick(() => deps.syncNodes())\n            }\n\n            // Close the modal\n            cancelDeleteGroup()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] confirmDeleteGroup failed', error)\n        }\n    }\n\n    const cancelDeleteGroup = () => {\n        isDeleteGroupModalOpen.value = false\n        groupPendingDelete.value = null\n    }\n\n    return {\n        // State\n        isGroupModalOpen,\n        selectedGroup,\n        groupModalPosition,\n        isGroupEditModalOpen,\n        selectedSectionForEdit,\n        isDeleteGroupModalOpen,\n        groupPendingDelete,\n\n        // Actions\n        createGroup,\n        closeGroupModal,\n        handleGroupCreated,\n        handleGroupUpdated,\n        editGroup,\n        closeGroupEditModal,\n        handleGroupEditSave,\n        deleteGroup,\n        confirmDeleteGroup,\n        cancelDeleteGroup\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasGroupMembership.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasGroups.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":63,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":63,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'oldDirect' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":131,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":131,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'oldAggregated' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":132,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":132,"endColumn":32}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { nextTick } from 'vue'\nimport type { Task } from '@/types/tasks'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useCanvasCore } from './useCanvasCore'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport { CANVAS } from '@/constants/canvas'\n\n/**\n * useCanvasGroups\n *\n * Consolidates all group-related logic:\n * - Task counting (Single Source of Truth: parentId)\n * - Containment checks (using Vue Flow computed positions)\n * - Group Actions (Create, Delete, Update)\n * - Hierarchy management\n */\nexport function useCanvasGroups() {\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const { getNodes } = useCanvasCore()\n\n    // --- Helpers ---\n\n    const isPointInRect = (x: number, y: number, rect: { x: number, y: number, width: number, height: number }) => {\n        return x >= rect.x && x <= rect.x + rect.width &&\n            y >= rect.y && y <= rect.y + rect.height\n    }\n\n    // --- Containment Logic ---\n\n    // Find the deep-most section that contains the center of a task\n    const findSectionForTask = (taskCenter: { x: number, y: number }, excludeId?: string): CanvasSection | null => {\n        const sections = getNodes.value.filter(n => CanvasIds.isGroupNode(n.id) && !n.hidden)\n\n        const validContainers = sections.filter(node => {\n            const { id: sectionId } = CanvasIds.parseNodeId(node.id)\n            if (sectionId === excludeId) return false\n\n            // Use computed position (absolute) from Vue Flow\n            const absX = node.computedPosition?.x ?? node.position.x\n            const absY = node.computedPosition?.y ?? node.position.y\n            const width = node.data?.width ?? CANVAS.DEFAULT_GROUP_WIDTH\n            const height = node.data?.height ?? CANVAS.DEFAULT_GROUP_HEIGHT\n\n            return isPointInRect(taskCenter.x, taskCenter.y, {\n                x: absX,\n                y: absY,\n                width,\n                height\n            })\n        })\n\n        if (validContainers.length === 0) return null\n\n        // Sort by area (ascending: smallest first) - we want the most specific (deepest) group\n        return validContainers.sort((a, b) => {\n            const areaA = (a.data?.width ?? CANVAS.DEFAULT_GROUP_WIDTH) * (a.data?.height ?? CANVAS.DEFAULT_GROUP_HEIGHT)\n            const areaB = (b.data?.width ?? CANVAS.DEFAULT_GROUP_WIDTH) * (b.data?.height ?? CANVAS.DEFAULT_GROUP_HEIGHT)\n            return areaA - areaB\n        }).map(n => {\n            const { id } = CanvasIds.parseNodeId(n.id)\n            return canvasStore.groups.find(g => g.id === id)!\n        }).filter(Boolean)[0] || null\n    }\n\n    // Used during drag to find where a task is hovering\n    const getContainingGroupForTask = (x: number, y: number, w: number = CANVAS.DEFAULT_TASK_WIDTH, h: number = CANVAS.DEFAULT_TASK_HEIGHT) => {\n        const centerX = x + w / 2\n        const centerY = y + h / 2\n        return findSectionForTask({ x: centerX, y: centerY })\n    }\n\n    const findAllContainingSections = (_nodeRect: { x: number, y: number, width: number, height: number }) => {\n        // Implementation for group-in-group drag could go here if needed.\n        // For now, focusing on Task->Group drop.\n        return []\n    }\n\n    const getSectionAbsolutePosition = (sectionId: string) => {\n        const node = getNodes.value.find(n => n.id === CanvasIds.groupNodeId(sectionId))\n        return node?.computedPosition || { x: 0, y: 0 }\n    }\n\n    // --- Task Counting Logic ---\n\n    // Optimized Recursive Count (CYCLE-SAFE)\n    // Relies STRICTLY on parentId relationship, avoiding expensive spatial checks for counting.\n    // Uses visited set to prevent infinite recursion if cycles exist in data.\n    // FIX: Uses _rawGroups to include hidden groups in hierarchy traversal\n    const getTaskCountInGroupRecursive = (\n        groupId: string,\n        tasks: Task[],\n        visited: Set<string> = new Set()\n    ): number => {\n        // Cycle protection: don't revisit groups we've already counted\n        if (visited.has(groupId)) {\n            console.warn('[GROUPS] Detected cycle while counting tasks', { groupId })\n            return 0\n        }\n        visited.add(groupId)\n\n        // 1. Direct Children\n        let count = tasks.filter(t => t.parentId === groupId && !t._soft_deleted).length\n\n        // 2. Recursive Children (in subgroups)\n        // FIX: Use _rawGroups instead of canvasStore.groups to include hidden groups\n        // canvasStore.groups is filtered to visible only, which breaks hierarchy traversal\n        const allGroups = canvasStore._rawGroups\n        const childGroups = allGroups.filter(g => g.parentGroupId === groupId)\n        for (const child of childGroups) {\n            count += getTaskCountInGroupRecursive(child.id, tasks, visited)\n        }\n\n        return count\n    }\n\n    // Update a single section's task count node data\n    // FIX: Update BOTH directTaskCount and aggregatedTaskCount (not just taskCount)\n    // GroupNodeSimple.vue reads directTaskCount/aggregatedTaskCount from props.data\n    const updateSingleSectionCount = (sectionId: string, _tasks: Task[]) => {\n        const sectionNodeId = CanvasIds.groupNodeId(sectionId)\n\n        // Read from store's reactive computeds (source of truth)\n        const directCount = canvasStore.taskCountByGroupId.get(sectionId) ?? 0\n        const aggregatedCount = canvasStore.aggregatedTaskCountByGroupId.get(sectionId) ?? directCount\n\n        // Direct reactivity update on Vue Flow node data\n        const node = getNodes.value.find(n => n.id === sectionNodeId)\n        if (node && node.data) {\n            const oldDirect = node.data.directTaskCount\n            const oldAggregated = node.data.aggregatedTaskCount\n\n            // Update ALL count properties to ensure UI consistency\n            node.data.directTaskCount = directCount\n            node.data.aggregatedTaskCount = aggregatedCount\n            node.data.taskCount = aggregatedCount // Legacy compat\n\n        }\n    }\n\n    // Helper to get ancestor chain for bubbling updates\n    // FIX: Uses _rawGroups to include hidden groups in hierarchy traversal\n    const getAncestorGroupIds = (groupId: string, visited = new Set<string>()): string[] => {\n        if (visited.has(groupId)) return []\n        visited.add(groupId)\n\n        const allGroups = canvasStore._rawGroups\n        const group = allGroups.find(g => g.id === groupId)\n        if (!group || !group.parentGroupId) return []\n\n        const ancestors: string[] = [group.parentGroupId]\n        ancestors.push(...getAncestorGroupIds(group.parentGroupId, visited))\n        return ancestors\n    }\n\n    // Main entry point for updating counts\n    const updateSectionTaskCounts = async (oldSectionId?: string, newSectionId?: string) => {\n        // Ensure store is fresh\n        await nextTick()\n\n        const tasks = taskStore.tasks.filter(t => !t._soft_deleted)\n        const sectionsToUpdate = new Set<string>()\n\n        if (oldSectionId) {\n            sectionsToUpdate.add(oldSectionId)\n            getAncestorGroupIds(oldSectionId).forEach(id => sectionsToUpdate.add(id))\n        }\n\n        if (newSectionId) {\n            sectionsToUpdate.add(newSectionId)\n            getAncestorGroupIds(newSectionId).forEach(id => sectionsToUpdate.add(id))\n        }\n\n        sectionsToUpdate.forEach(sectionId => {\n            updateSingleSectionCount(sectionId, tasks)\n        })\n    }\n\n    return {\n        // Counting\n        getTaskCountInGroupRecursive,\n        updateSectionTaskCounts,\n        updateSingleSectionCount,\n        getAncestorGroupIds,\n\n        // Containment / Hierarchy\n        getContainingGroupForTask,\n        getSectionAbsolutePosition,\n        findAllContainingSections\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasHotkeys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasInteractions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reactive' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"reactive"},"fix":{"range":[12,22],"text":""},"desc":"Remove unused variable \"reactive\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onMounted' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":54,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"onMounted"},"fix":{"range":[42,53],"text":""},"desc":"Remove unused variable \"onMounted\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onUnmounted' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":67,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"onUnmounted"},"fix":{"range":[53,66],"text":""},"desc":"Remove unused variable \"onUnmounted\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getPlatformDiagnostics' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":32,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getPlatformDiagnostics"},"fix":{"range":[1446,1469],"text":""},"desc":"Remove unused variable \"getPlatformDiagnostics\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isLinuxTauri' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":46,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"isLinuxTauri"},"fix":{"range":[1437,1522],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5847,5850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5847,5850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":277,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11913,11916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11913,11916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":336,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":336,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13929,13932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13929,13932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":337,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13968,13971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13968,13971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":338,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13996,13999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13996,13999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14036,14039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14036,14039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":345,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":345,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getNodes' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":351,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":351,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'applyNodeChanges' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":354,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":354,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":355,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14720,14723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14720,14723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":621,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":621,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28673,28676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28673,28676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":622,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":622,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28748,28751],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28748,28751],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":654,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":654,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31103,31106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31103,31106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":707,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":707,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34516,34519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34516,34519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":805,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":805,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[40037,40040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[40037,40040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":847,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":847,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41705,41708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41705,41708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":901,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":901,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44303,44306],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44303,44306],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1010,"column":114,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1010,"endColumn":117,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[49860,49863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[49860,49863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, reactive, nextTick, type Ref, onMounted, onUnmounted } from 'vue'\nimport { type Node, type NodeDragEvent, useVueFlow } from '@vue-flow/core'\nimport { useCanvasStore, type CanvasSection } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { Task } from '@/types/tasks'\nimport type { CanvasGroup } from '@/types/canvas'\nimport { useCanvasGroups } from './useCanvasGroups'\nimport { useCanvasCore } from './useCanvasCore'\nimport { useCanvasOperationState } from './useCanvasOperationState'\nimport { useCanvasResizeState } from './useCanvasResizeState'\nimport { useCanvasResizeCalculation } from './useCanvasResizeCalculation'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport { getDeepestContainingGroup, DEFAULT_TASK_WIDTH, DEFAULT_TASK_HEIGHT, isNodeCompletelyInside } from '@/utils/canvas/spatialContainment'\nimport { useNodeSync } from './useNodeSync'\nimport { canvasSyncInProgress } from './useCanvasSync'\nimport { useNodeStateManager, NodeState } from './state-machine'\nimport { storeToRefs } from 'pinia'\nimport { getGroupAbsolutePosition, toAbsolutePosition } from '@/utils/canvas/coordinates'\nimport { useCanvasSectionProperties } from './useCanvasSectionProperties'\nimport { positionManager } from '@/services/canvas/PositionManager'\nimport { DRAG_SETTLE_TIMEOUT_MS, RESIZE_SETTLE_TIMEOUT_MS } from '@/config/timing'\nimport { lockManager } from '@/services/canvas/LockManager'\nimport { getPlatformDiagnostics, isLinuxTauri } from '@/utils/contextMenuCoordinates'\n\n// =============================================================================\n// DESCENDANT COLLECTION HELPERS (BUG #1 FIX)\n// =============================================================================\n// These helpers recursively collect ALL descendants (not just direct children)\n// so that when a parent group moves, all nested items are synced to DB.\n\n/**\n * Collect all descendant groups recursively (CYCLE-SAFE)\n * For hierarchy A → B → C, calling with A returns [B, C]\n *\n * Uses visited set to prevent infinite recursion if cycles exist in data.\n */\nfunction collectDescendantGroups(\n    rootId: string,\n    groups: CanvasGroup[],\n    visited: Set<string> = new Set()\n): CanvasGroup[] {\n    // Cycle protection: don't revisit nodes we've already processed\n    if (visited.has(rootId)) return []\n    visited.add(rootId)\n\n    const directChildren = groups.filter(g => g.parentGroupId === rootId)\n\n    return directChildren.flatMap(child => [\n        child,\n        ...collectDescendantGroups(child.id, groups, visited)\n    ])\n}\n\n/**\n * Collect all descendant tasks (tasks in the group AND all descendant groups)\n * For hierarchy A → B → C with tasks in each, returns all tasks\n */\nfunction collectDescendantTasks(rootId: string, tasks: Task[], groups: CanvasGroup[]): Task[] {\n    const descendants: Task[] = []\n\n    // Helper: check if task is spatially inside a group (BUG-1191)\n    const isTaskInsideGroup = (task: Task, groupId: string): boolean => {\n        if (!task.canvasPosition) return false\n        const group = groups.find(g => g.id === groupId)\n        if (!group) return false\n        const groupAbsPos = getGroupAbsolutePosition(groupId, groups)\n        const taskCenterX = task.canvasPosition.x + DEFAULT_TASK_WIDTH / 2\n        const taskCenterY = task.canvasPosition.y + DEFAULT_TASK_HEIGHT / 2\n        return (\n            taskCenterX >= groupAbsPos.x &&\n            taskCenterX <= groupAbsPos.x + group.position.width &&\n            taskCenterY >= groupAbsPos.y &&\n            taskCenterY <= groupAbsPos.y + group.position.height\n        )\n    }\n\n    // Direct tasks in this group (with spatial validation)\n    const directTasks = tasks.filter(t => t.parentId === rootId && isTaskInsideGroup(t, rootId))\n    descendants.push(...directTasks)\n\n    // Tasks in ALL descendant groups (recursive, with spatial validation)\n    const descendantGroups = collectDescendantGroups(rootId, groups)\n    for (const group of descendantGroups) {\n        const groupTasks = tasks.filter(t => t.parentId === group.id && isTaskInsideGroup(t, group.id))\n        descendants.push(...groupTasks)\n    }\n\n    return descendants\n}\n\n// =============================================================================\n// GROUP PARENT UPDATE HELPER\n// =============================================================================\n// This helper encapsulates ALL parent transition logic for groups:\n// - Center-based containment detection\n// - Cycle prevention\n// - Vue Flow node updates (parentNode, position)\n// - Store updates (parentGroupId)\n//\n// CRITICAL INVARIANT: Groups must NOT have extent: 'parent' set!\n// This allows them to escape their parent via drag.\n\ninterface GroupParentUpdateResult {\n    oldParentId: string | null\n    newParentId: string | null\n    transitionType: 'root-to-child' | 'child-to-root' | 'child-to-child' | 'no-change'\n    cyclePreventedAttemptedParent?: string\n}\n\n/**\n * Update a group's parent after drag, using center-based containment.\n *\n * BEHAVIOR:\n * 1. Computes targetParentId using center of group's bounding box\n * 2. If center is inside a group → becomes child of that group\n * 3. If center is outside all groups → becomes root (parentGroupId = null)\n * 4. Prevents cycles (can't make a descendant the parent)\n * 5. Updates Vue Flow node.parentNode (but NOT extent!)\n * 6. Returns detailed transition info for logging\n *\n * @param args.groupId - The group being moved\n * @param args.absoluteRect - The group's absolute bounding box {x, y, width, height}\n * @param args.node - The Vue Flow node to update\n * @param args.allGroups - All groups for containment lookup\n * @returns Result with old/new parent and transition type\n */\nfunction updateGroupParentAfterDrag(args: {\n    groupId: string\n    absoluteRect: { x: number; y: number; width: number; height: number }\n    node: any\n    allGroups: CanvasGroup[]\n}): GroupParentUpdateResult {\n    const { groupId, absoluteRect, node, allGroups } = args\n\n    // Find current group in store\n    const group = allGroups.find(g => g.id === groupId)\n    const oldParentId = group?.parentGroupId ?? null\n\n    // Build spatial representation for containment check\n    const spatialGroup = {\n        position: { x: absoluteRect.x, y: absoluteRect.y },\n        width: absoluteRect.width,\n        height: absoluteRect.height,\n    }\n\n    // Find containing group by CENTER (not overlap)\n    const targetParent = getDeepestContainingGroup(spatialGroup, allGroups, groupId)\n    let newParentId: string | null = targetParent?.id ?? null\n\n    if (import.meta.env.DEV) {\n        const centerX = absoluteRect.x + absoluteRect.width / 2\n        const centerY = absoluteRect.y + absoluteRect.height / 2\n\n        console.log(`[CANVAS:INTERACT] Checking containment for \"${group?.name || groupId}\"`, {\n            center: { x: Math.round(centerX), y: Math.round(centerY) },\n            oldParent: oldParentId ?? '(root)',\n            detectedParent: newParentId ?? '(root)',\n        })\n    }\n\n    // ================================================================\n    // CYCLE PREVENTION\n    // ================================================================\n    let cyclePreventedAttemptedParent: string | undefined\n\n    // 1) Don't allow self-parenting\n    if (newParentId === groupId) {\n        console.warn(`[GROUP-PARENT] Prevented self-parenting for ${groupId}`)\n        newParentId = null\n    }\n\n    // 2) Don't allow making a descendant the parent (creates A→B→A cycle)\n    if (newParentId) {\n        const descendants = collectDescendantGroups(groupId, allGroups)\n        const descendantIds = new Set(descendants.map(d => d.id))\n        if (descendantIds.has(newParentId)) {\n            console.warn(`[GROUP-PARENT] Prevented cycle: \"${group?.name}\" cannot have descendant \"${targetParent?.name}\" as parent`)\n            cyclePreventedAttemptedParent = newParentId\n            // BUG FIX: When cycle prevented, DON'T keep old parent!\n            // The user dragged outside, they want to escape. Set to root.\n            // Only exception: if they tried to drop INTO their own child.\n            // In that case, we keep position but become root.\n            newParentId = null\n        }\n    }\n\n    // ================================================================\n    // POSITION ADJUSTMENT (before parentNode change)\n    // ================================================================\n    // When parent changes, Vue Flow interprets node.position relative to new parent.\n    // Adjust position so visual location stays the same.\n    if (oldParentId !== newParentId) {\n        if (newParentId) {\n            // Going INTO a parent: convert absolute → relative\n            const newParentAbsolute = getGroupAbsolutePosition(newParentId, allGroups)\n            const newRelativePos = {\n                x: absoluteRect.x - newParentAbsolute.x,\n                y: absoluteRect.y - newParentAbsolute.y\n            }\n            if (isFinite(newRelativePos.x) && isFinite(newRelativePos.y)) {\n                node.position = newRelativePos\n            }\n        } else {\n            // Going to ROOT: use absolute position directly\n            node.position = { x: absoluteRect.x, y: absoluteRect.y }\n        }\n    }\n\n    // ================================================================\n    // VUE FLOW NODE UPDATE\n    // ================================================================\n    // CRITICAL: Do NOT set extent: 'parent'!\n    // This would lock the group inside and prevent future escape.\n    if (newParentId) {\n        node.parentNode = CanvasIds.groupNodeId(newParentId)\n        // NOTE: Intentionally NOT setting node.extent = 'parent'\n    } else {\n        node.parentNode = undefined\n        node.extent = undefined\n    }\n\n    // Determine transition type for logging\n    let transitionType: GroupParentUpdateResult['transitionType'] = 'no-change'\n    if (oldParentId !== newParentId) {\n        if (!oldParentId && newParentId) {\n            transitionType = 'root-to-child'\n        } else if (oldParentId && !newParentId) {\n            transitionType = 'child-to-root'\n        } else {\n            transitionType = 'child-to-child'\n        }\n\n        if (import.meta.env.DEV) {\n            const oldName = oldParentId ? allGroups.find(g => g.id === oldParentId)?.name : '(root)'\n            const newName = newParentId ? allGroups.find(g => g.id === newParentId)?.name : '(root)'\n            console.log(`[CANVAS:INTERACT] Transition: ${transitionType}`, {\n                group: group?.name || groupId,\n                from: oldName,\n                to: newName,\n            })\n        }\n    }\n\n    return {\n        oldParentId,\n        newParentId,\n        transitionType,\n        cyclePreventedAttemptedParent,\n    }\n}\n\n// =============================================================================\n// ABSOLUTE POSITION COMPUTATION HELPER\n// =============================================================================\n// This helper reliably computes the absolute world position of a Vue Flow node,\n// even when computedPosition is not available or stale.\n//\n// KEY INSIGHT: When expandParent is false, Vue Flow may not always populate\n// computedPosition correctly. We need to manually compute it when necessary.\n\n/**\n * Compute absolute world position for a Vue Flow node\n *\n * CONTAINMENT FIX: Instead of trusting computedPosition (which may be stale\n * or unavailable after setting expandParent: false), we manually compute\n * the absolute position using the store's absolute group positions.\n *\n * @param node - The Vue Flow node\n * @param allGroups - All groups from the canvas store (have absolute positions)\n * @returns Absolute world position {x, y}\n */\nfunction computeNodeAbsolutePosition(\n    node: Node,\n    allGroups: CanvasGroup[]\n): { x: number; y: number } {\n    // First try computedPosition - this is the most reliable if available\n    const vfNode = node as any\n    if (vfNode.computedPosition &&\n        typeof vfNode.computedPosition.x === 'number' &&\n        typeof vfNode.computedPosition.y === 'number' &&\n        isFinite(vfNode.computedPosition.x) &&\n        isFinite(vfNode.computedPosition.y)) {\n        return {\n            x: vfNode.computedPosition.x,\n            y: vfNode.computedPosition.y\n        }\n    }\n\n    // If no parentNode, position is already absolute\n    if (!node.parentNode) {\n        return { x: node.position.x, y: node.position.y }\n    }\n\n    // Has parentNode - position is RELATIVE to parent\n    // We need to compute absolute by adding parent's absolute position\n    const parentId = node.parentNode.startsWith('section-')\n        ? node.parentNode.replace('section-', '')\n        : node.parentNode\n\n    const parentAbsolute = getGroupAbsolutePosition(parentId, allGroups)\n    const absolute = toAbsolutePosition(node.position, parentAbsolute)\n\n    return { x: absolute.x, y: absolute.y }\n}\n\nexport interface SelectionBox {\n    x: number\n    y: number\n    width: number\n    height: number\n    startX: number\n    startY: number\n    isVisible: boolean\n}\n\n/**\n * useCanvasInteractions\n *\n * ============================================================================\n * DRAG/RESIZE HANDLERS - WRITE PATH\n * ============================================================================\n *\n * This composable handles user interactions that trigger the WRITE PATH:\n * - Drag end: saves new absolute positions to DB\n * - Resize end: saves new absolute positions and dimensions to DB\n *\n * FULLY ABSOLUTE ARCHITECTURE:\n * - Uses Vue Flow's computedPosition for absolute world coordinates\n * - Saves ABSOLUTE positions to DB for ALL nodes (tasks AND groups)\n * - When parent group moves, syncs both child tasks AND child groups\n *\n * KEY: Parent-drag triggers child sync because Vue Flow moves children\n * visually, but DB doesn't auto-update. We must explicitly sync.\n */\nexport function useCanvasInteractions(deps?: {\n    findNode: (id: string) => any\n    updateNode: (id: string, node: any) => void\n    nodes: Ref<any[]>\n    applyNodeChanges?: (changes: any[]) => void\n}) {\n    // Vue Flow context hooks with fallback\n    let vueFlow: ReturnType<typeof useVueFlow> | null = null\n    try {\n        if (!deps) vueFlow = useVueFlow()\n    } catch (e) {\n        if (import.meta.env.DEV) {\n            console.warn('⚠️ [CANVAS-INTERACTIONS] useVueFlow context fallback')\n        }\n    }\n\n    const { getNodes } = useCanvasCore()\n    const findNode = deps?.findNode || vueFlow?.findNode || (() => null)\n    const updateNode = deps?.updateNode || vueFlow?.updateNode || (() => { })\n    const applyNodeChanges = deps?.applyNodeChanges || vueFlow?.applyNodeChanges || (() => { })\n    const nodes = (deps?.nodes || vueFlow?.nodes || ref([])) as Ref<any[]>\n\n    const canvasStore = useCanvasStore()\n    const taskStore = useTaskStore()\n    const { nodeVersionMap } = storeToRefs(canvasStore)\n    const { updateSectionTaskCounts } = useCanvasGroups()\n    const { startDrag, endDrag, startResize, endResize } = useCanvasOperationState()\n    const { setNodeState } = useNodeStateManager()\n\n    // Smart Section Properties\n    const { getSectionProperties } = useCanvasSectionProperties({\n        taskStore,\n        getAllContainingSections: (_x, _y, _w, _h) => {\n            // This is used for nesting, but onNodeDragStop handles its own containment\n            return []\n        }\n    })\n\n    // Interaction sub-states\n    const { resizeState, isResizeSettling, resizeLineStyle, edgeHandleStyle } = useCanvasResizeState()\n    const { validateDimensions, calculateChildInverseDelta } = useCanvasResizeCalculation()\n\n    // --- DRAG HANDLERS ---\n\n    /**\n     * Handle drag start - SINGLE SOURCE OF TRUTH for initiating drag state\n     *\n     * GUARDS:\n     * 1. `startDrag()` checks if global operation state is idle (prevents duplicate drags)\n     * 2. `setNodeState()` is idempotent (no warning if node already in DRAGGING_LOCAL)\n     * 3. `canvasStore.isDragging` is only set TRUE once per drag session\n     *\n     * If Vue Flow fires duplicate events, the guards prevent duplicate state transitions.\n     */\n    const onNodeDragStart = (event: NodeDragEvent) => {\n        const { nodes: involvedNodes } = event\n\n\n        // Guard: Only proceed if we can start a new drag (operation state is idle)\n        // This is the AUTHORITATIVE guard that prevents duplicate drag starts\n        if (startDrag(involvedNodes.map(n => n.id))) {\n            // Set per-node state (idempotent - safe to call even if already DRAGGING_LOCAL)\n            involvedNodes.forEach(node => {\n                setNodeState(node.id, NodeState.DRAGGING_LOCAL)\n                // TASK-213: Acquire Lock\n                // FIX: Use raw ID (not Vue Flow node ID) to match PositionManager's key format\n                const { id: rawId } = CanvasIds.parseNodeId(node.id)\n                lockManager.acquire(rawId, 'user-drag')\n            })\n            // Set store-level drag flag ONCE per drag session\n            canvasStore.isDragging = true\n        }\n        // If startDrag() returned false, we are already dragging - ignore duplicate event\n    }\n\n    const onNodeDrag = (event: NodeDragEvent) => {\n        // Vue Flow updates node.position automatically (Visuals)\n\n        // TASK-213: Update PositionManager (Truth)\n        const allGroups = canvasStore._rawGroups || canvasStore.groups || []\n        event.nodes.forEach(node => {\n            const absPos = computeNodeAbsolutePosition(node, allGroups)\n            const parentId = node.parentNode\n                ? (node.parentNode.startsWith('section-') ? node.parentNode.replace('section-', '') : node.parentNode)\n                : null\n\n            // FIX: Use raw ID (not Vue Flow node ID) to match PositionManager's key format\n            const { id: rawId } = CanvasIds.parseNodeId(node.id)\n            positionManager.updatePosition(rawId, absPos, 'user-drag', parentId)\n        })\n    }\n\n    // useNodeSync expects Ref<Map> from storeToRefs for proper reactivity\n    const { syncNodePosition } = useNodeSync(nodeVersionMap)\n\n    /**\n     * Handle drag stop - save new absolute positions to DB\n     *\n     * =========================================================================\n     * GEOMETRY WRITE POLICY (TASK-240 Phase 2.5)\n     * =========================================================================\n     * This function (onNodeDragStop) is the ONLY place where user-initiated\n     * geometry changes are allowed:\n     *   - task.parentId\n     *   - task.canvasPosition\n     *   - group.parentGroupId\n     *   - group.position\n     *\n     * All other code paths (Smart Groups, sync, orchestrator, overdue collectors)\n     * must be READ-ONLY for geometry fields. They may change metadata (dueDate,\n     * priority, status, tags) but NEVER parent or position fields.\n     *\n     * This policy prevents sync loops and position drift.\n     * =========================================================================\n     *\n     * FULLY ABSOLUTE ARCHITECTURE:\n     * 1. Use computedPosition for absolute world coordinates\n     * 2. Detect new parent using spatial containment\n     * 3. Update store with absolute position\n     * 4. Sync to DB with optimistic locking\n     * 5. For groups: also sync child tasks AND child groups\n     */\n    const onNodeDragStop = async (event: NodeDragEvent) => {\n        // BUG-1061 FIX #5: Skip if triggered by setNodes() during canvas sync\n        // Vue Flow may fire nodeDragStop when setNodes() updates node positions programmatically.\n        // This creates a reactive loop: drag → Smart Group update → sync → setNodes → drag fires again.\n        if (canvasSyncInProgress.value) {\n            if (import.meta.env.DEV) {\n                console.log('[CANVAS:INTERACT] Drag stop blocked - triggered during canvas sync')\n            }\n            return\n        }\n\n        const { nodes: involvedNodes } = event\n        // BUG-1209: Do NOT set isDragging=false here — it opens a window where realtime\n        // handlers see \"not dragging\" while async save is still in progress.\n        // Moved to the finally block below, after all saves complete.\n\n        const callId = import.meta.env.DEV ? Math.random().toString(36).slice(2, 8) : ''\n        if (import.meta.env.DEV) {\n            console.log(`[CANVAS:INTERACT] Drag stop - callId=${callId}, involvedNodes=${involvedNodes.length}`,\n                involvedNodes.map(n => `${n.id.slice(0, 12)}(${n.type})`))\n        }\n\n        try {\n\n            for (const node of involvedNodes) {\n                if (CanvasIds.isGroupNode(node.id)) {\n                    // ============================================================\n                    // GROUP DRAG END\n                    // ============================================================\n                    const { id: groupId } = CanvasIds.parseNodeId(node.id)\n                    const allGroups = canvasStore._rawGroups || canvasStore.groups || []\n                    const group = allGroups.find(g => g.id === groupId)\n                    if (!group) continue\n\n                    // Compute absolute position for the group\n                    // BUG-1209/TASK-1289: Snap to 16px grid to prevent cumulative micro-drift\n                    const rawAbsolutePos = computeNodeAbsolutePosition(node, allGroups)\n                    const absolutePos = { x: Math.round(rawAbsolutePos.x / 16) * 16, y: Math.round(rawAbsolutePos.y / 16) * 16 }\n                    const groupWidth = group.position.width\n                    const groupHeight = group.position.height\n\n                    // Use the unified helper for parent update logic\n                    // This handles: containment detection, cycle prevention, position adjustment,\n                    // Vue Flow node updates (parentNode but NOT extent)\n                    const parentResult = updateGroupParentAfterDrag({\n                        groupId,\n                        absoluteRect: {\n                            x: absolutePos.x,\n                            y: absolutePos.y,\n                            width: groupWidth,\n                            height: groupHeight,\n                        },\n                        node,\n                        allGroups,\n                    })\n\n\n                    // Update store with ABSOLUTE position AND parentGroupId\n                    canvasStore.updateSection(groupId, {\n                        position: {\n                            x: absolutePos.x,\n                            y: absolutePos.y,\n                            width: groupWidth,\n                            height: groupHeight,\n                        },\n                        parentGroupId: parentResult.newParentId,\n                        positionFormat: 'absolute',\n                    })\n\n                    // TASK-213: Update PositionManager\n                    positionManager.updatePosition(groupId, absolutePos, 'user-drag', parentResult.newParentId)\n\n                    // Sync group to DB (persists parent_group_id)\n                    // Re-fetch allGroups after store update to ensure we have latest data\n                    const updatedAllGroups = canvasStore._rawGroups || canvasStore.groups || []\n                    setNodeState(groupId, NodeState.SYNCING)\n                    await syncNodePosition(groupId, node, updatedAllGroups, 'groups')\n                    setNodeState(groupId, NodeState.IDLE)\n\n                    // ================================================================\n                    // SYNC DESCENDANTS: Tasks and Groups\n                    // ================================================================\n                    // When parent moves, Vue Flow moves all children visually.\n                    // We must sync their NEW absolute positions to DB.\n\n                    const descendantTasks = collectDescendantTasks(groupId, taskStore.tasks, updatedAllGroups)\n                    const descendantGroups = collectDescendantGroups(groupId, updatedAllGroups)\n\n                    // BUG-1209: Wait for Vue Flow to re-render with parent's new position\n                    // so computedPosition is fresh for descendant position calculations.\n                    await nextTick()\n\n                    // Sync descendant GROUPS first (parents before their children)\n                    for (const descendantGroup of descendantGroups) {\n                        const childNodeId = CanvasIds.groupNodeId(descendantGroup.id)\n                        const childNode = findNode(childNodeId)\n                        if (!childNode) continue\n\n                        setNodeState(descendantGroup.id, NodeState.SYNCING)\n                        await syncNodePosition(descendantGroup.id, childNode, updatedAllGroups, 'groups')\n                        setNodeState(descendantGroup.id, NodeState.IDLE)\n                    }\n\n                    // Sync descendant TASKS\n                    for (const descendantTask of descendantTasks) {\n                        const childNode = findNode(descendantTask.id)\n                        if (!childNode) continue\n\n                        setNodeState(descendantTask.id, NodeState.SYNCING)\n                        await syncNodePosition(descendantTask.id, childNode, updatedAllGroups, 'tasks')\n                        setNodeState(descendantTask.id, NodeState.IDLE)\n                    }\n\n                } else {\n                    // ============================================================\n                    // TASK DRAG END\n                    // ============================================================\n                    const task = taskStore.getTask(node.id)\n                    if (!task) continue\n\n                    // BUG-1209: Re-snapshot groups per iteration to pick up any changes\n                    // from prior iterations (e.g., sibling that modified group positions)\n                    const taskAllGroups = canvasStore._rawGroups || canvasStore.groups || []\n\n                    // BUG-1191: Detect stale parentNode - task was dragged with wrong group\n                    // Compare Vue Flow's parentNode with store's parentId\n                    const vfParentGroupId = node.parentNode\n                        ? (node.parentNode.startsWith('section-') ? node.parentNode.replace('section-', '') : node.parentNode)\n                        : null\n                    const storeParentId = task.parentId ?? null\n\n                    if (vfParentGroupId !== storeParentId) {\n                        if (import.meta.env.DEV) {\n                            console.warn(`[BUG-1191] Stale parentNode for \"${task.title?.slice(0, 25)}\": VF=${vfParentGroupId?.slice(0, 8)}, Store=${storeParentId?.slice(0, 8) ?? 'null'}. Restoring position.`)\n                        }\n                        // Fix Vue Flow node to match store\n                        node.parentNode = storeParentId ? CanvasIds.groupNodeId(storeParentId) : undefined\n                        // Restore position from store (undo the wrong visual move)\n                        if (task.canvasPosition) {\n                            if (storeParentId) {\n                                const correctParentAbsolute = getGroupAbsolutePosition(storeParentId, taskAllGroups)\n                                node.position = {\n                                    x: task.canvasPosition.x - correctParentAbsolute.x,\n                                    y: task.canvasPosition.y - correctParentAbsolute.y\n                                }\n                            } else {\n                                node.position = { x: task.canvasPosition.x, y: task.canvasPosition.y }\n                            }\n                        }\n                        setNodeState(task.id, NodeState.IDLE)\n                        continue\n                    }\n\n                    // 1. Compute ABSOLUTE position for containment check\n                    // When node has parentNode, node.position is RELATIVE, not absolute\n                    // computedPosition is preferred; fallback calculates from parent's absolute\n                    const rawAbsolutePos = computeNodeAbsolutePosition(node, taskAllGroups)\n                    // BUG-1209/TASK-1289: Snap to 16px grid to prevent cumulative micro-drift\n                    // (CanvasView uses 16px grid — store should always save grid-aligned values)\n                    const absolutePos = { x: Math.round(rawAbsolutePos.x / 16) * 16, y: Math.round(rawAbsolutePos.y / 16) * 16 }\n\n                    // 2. Build spatial task with explicit dimensions for center-based containment\n                    const spatialTask = {\n                        position: absolutePos,\n                        width: (node as any).width ?? DEFAULT_TASK_WIDTH,\n                        height: (node as any).height ?? DEFAULT_TASK_HEIGHT\n                    }\n\n                    // BUG-1061 FIX: Skip if task just followed its parent group (didn't move independently)\n                    // When a group is dragged, Vue Flow reports child tasks as \"involved\".\n                    // We should NOT recalculate parentId/Smart Groups for tasks that stayed in their group.\n                    // Check: if task has a parent AND is still inside that parent, skip processing.\n                    const oldParentId = task.parentId\n                    if (oldParentId) {\n                        const currentParent = taskAllGroups.find(g => g.id === oldParentId)\n                        if (currentParent) {\n                            const parentAbsolutePos = getGroupAbsolutePosition(oldParentId, taskAllGroups)\n                            const parentBounds = {\n                                position: parentAbsolutePos,\n                                width: currentParent.position.width,\n                                height: currentParent.position.height\n                            }\n                            // If task center is still inside current parent, skip processing\n                            // BUG-1084 FIX: Reduced padding from 10 to 2 to prevent false \"outside\" detection\n                            const stillInside = isNodeCompletelyInside(spatialTask, parentBounds, 2)\n                            if (stillInside) {\n                                // Task just moved with its group - only sync position, skip parent/Smart Group recalc\n                                const posChanged = !task.canvasPosition ||\n                                    Math.abs(absolutePos.x - task.canvasPosition.x) > 1 ||\n                                    Math.abs(absolutePos.y - task.canvasPosition.y) > 1\n                                if (posChanged) {\n                                    // High Severity Issue #7: Mark task as pending write\n                                    taskStore.addPendingWrite(task.id)\n                                    try {\n                                        await taskStore.updateTask(task.id, {\n                                            canvasPosition: absolutePos,\n                                            positionFormat: 'absolute'\n                                        }, 'DRAG-FOLLOW-PARENT' as any)\n                                        positionManager.updatePosition(task.id, absolutePos, 'user-drag', oldParentId)\n                                    } finally {\n                                        // BUG-1209: Delay clearing pendingWrite to catch realtime echo\n                                        setTimeout(() => taskStore.removePendingWrite(task.id), DRAG_SETTLE_TIMEOUT_MS)\n                                    }\n                                }\n                                setNodeState(task.id, NodeState.IDLE)\n                                continue // Skip rest of TASK DRAG END (no parentId change, no Smart Group)\n                            }\n                        }\n                    }\n\n                    // 3. Detect new parent using spatial containment (center inside group bounds)\n                    // BUG-1061 FIX #4: Prefer current parent if it still contains the task\n                    // This prevents flip-flopping when task is in overlapping region of two groups\n                    let targetGroup = getDeepestContainingGroup(spatialTask, taskAllGroups)\n                    if (oldParentId && targetGroup?.id !== oldParentId) {\n                        // Check if current parent also contains the task\n                        const currentParent = taskAllGroups.find(g => g.id === oldParentId)\n                        if (currentParent) {\n                            const parentAbsPos = getGroupAbsolutePosition(oldParentId, taskAllGroups)\n                            const parentBounds = {\n                                position: parentAbsPos,\n                                width: currentParent.position.width,\n                                height: currentParent.position.height\n                            }\n                            // BUG-1084 FIX: Reduced padding from 10 to 2 (consistent with above)\n                            const stillInCurrentParent = isNodeCompletelyInside(spatialTask, parentBounds, 2)\n                            if (stillInCurrentParent) {\n                                // Task is inside BOTH current parent and detected group - prefer current\n                                targetGroup = currentParent\n                            }\n                        }\n                    }\n                    const newParentId = targetGroup?.id ?? null\n\n                    // Skip if position didn't change meaningfully\n                    // (prevents drift when task just followed parent group)\n                    // TASK-370: Increased threshold from 1 to 5 to prevent phantom movement of siblings\n                    if (oldParentId === newParentId && oldParentId !== null) {\n                        const oldPos = task.canvasPosition || { x: 0, y: 0 }\n                        const posDelta = Math.abs(absolutePos.x - oldPos.x) + Math.abs(absolutePos.y - oldPos.y)\n                        if (posDelta < 5) {\n                            continue\n                        }\n                    }\n\n                    // 4. Optimistic Store Update (Absolute position + parentId)\n                    // GEOMETRY WRITER: Primary drag handler (TASK-255)\n\n                    // TASK-1083: Combine position + smart-group updates into SINGLE save to prevent race condition\n                    // Previously: two separate updateTask calls could race with realtime events\n                    const dragUpdates: Record<string, any> = {\n                        parentId: newParentId ?? undefined,\n                        canvasPosition: absolutePos,\n                        positionFormat: 'absolute'\n                    }\n\n                    // 6. Collect Smart Section Properties (Today, Tomorrow, Priorities, etc.)\n                    // METADATA ONLY: Smart groups update dueDate/priority/status, never geometry (TASK-255)\n                    // TASK-1177: Pass allGroups to enable parent chain property inheritance\n                    if (targetGroup) {\n                        // TASK-1177: Pass allGroups to getSectionProperties for parent chain inheritance\n                        // This allows child groups to inherit properties (like dueDate) from parent groups\n                        const smartUpdates = getSectionProperties(\n                            targetGroup as CanvasSection,\n                            taskAllGroups as CanvasGroup[]\n                        )\n                        // Filter out updates where the task already has the same value\n                        // TASK-1177 FIX: Also skip empty/null dueDate values to prevent DB errors\n                        for (const [key, value] of Object.entries(smartUpdates)) {\n                            // Skip invalid dueDate values (empty string, null, undefined, \"null\" string)\n                            if (key === 'dueDate' && (!value || value === 'null')) {\n                                continue\n                            }\n                            const taskKey = key as keyof typeof task\n                            if (task[taskKey] !== value) {\n                                dragUpdates[key] = value\n                            }\n                        }\n                    }\n\n                    // BUG-1209 FIX: Update Vue Flow node and PositionManager BEFORE the store write.\n                    // Previously, the store write was first (line ~797), which triggered reactive\n                    // watchers → syncStoreToCanvas() → read inconsistent state (new store parentId,\n                    // old VF parentNode). By updating VF first, any sync triggered by the store\n                    // write sees consistent VF state.\n\n                    // 5. Update Vue Flow parentNode AND position to match new containment\n                    // BUG FIX: Set position BEFORE parentNode to avoid a micro-tick where\n                    // the old position is interpreted as relative to the new parent.\n                    if (newParentId) {\n                        // Convert absolute position to relative position for new parent\n                        const newParentAbsolute = getGroupAbsolutePosition(newParentId, taskAllGroups)\n                        node.position = {\n                            x: absolutePos.x - newParentAbsolute.x,\n                            y: absolutePos.y - newParentAbsolute.y\n                        }\n                        node.parentNode = CanvasIds.groupNodeId(newParentId)\n                    } else {\n                        // Root node: position is absolute (same as world position)\n                        node.position = { x: absolutePos.x, y: absolutePos.y }\n                        node.parentNode = undefined\n                    }\n\n                    // TASK-213: Update PositionManager (before store write for consistency)\n                    positionManager.updatePosition(task.id, absolutePos, 'user-drag', newParentId ?? null)\n\n                    // High Severity Issue #7: Mark task as pending write before save\n                    taskStore.addPendingWrite(task.id)\n\n                    try {\n                        // SINGLE atomic save with all updates\n                        await taskStore.updateTask(task.id, dragUpdates, 'DRAG') // BUG-1051: AWAIT to ensure persistence\n                    } finally {\n                        // BUG-1209: Delay clearing pendingWrite by 3s so the Supabase realtime echo\n                        // (arriving 100ms-2s later) is still blocked by isPendingWrite().\n                        // Previously cleared immediately, allowing echo to overwrite position.\n                        setTimeout(() => taskStore.removePendingWrite(task.id), DRAG_SETTLE_TIMEOUT_MS)\n                    }\n\n                    if (oldParentId !== newParentId) {\n                        // REACTIVITY FIX: Bump version FIRST to trigger count recomputation\n                        // Then updateSectionTaskCounts can read the fresh values from computeds\n                        canvasStore.bumpTaskParentVersion()\n                        updateSectionTaskCounts(oldParentId || undefined, newParentId || undefined)\n                    }\n\n                    setNodeState(task.id, NodeState.IDLE)\n                }\n            }\n\n        } finally {\n            // BUG-1209: Set isDragging=false AFTER all async saves complete,\n            // so realtime handlers don't overwrite positions mid-save.\n            canvasStore.isDragging = false\n            // TASK-213: Release Locks\n            // FIX: Use raw ID (not Vue Flow node ID) to match the ID used during acquire\n            involvedNodes.forEach(node => {\n                const { id: rawId } = CanvasIds.parseNodeId(node.id)\n                lockManager.release(rawId, 'user-drag')\n            })\n            endDrag(involvedNodes.map(n => n.id))\n        }\n    }\n\n    // --- RESIZE HANDLERS ---\n\n    // --- RESIZE HANDLERS ---\n\n    const onSectionResizeStart = ({ sectionId: rawSectionId }: { sectionId: string; event: any }) => {\n        const { id: sectionId } = CanvasIds.parseNodeId(rawSectionId)\n        const section = canvasStore.groups.find(s => s.id === sectionId)\n        if (!section) return\n\n        const vueFlowNode = findNode(CanvasIds.groupNodeId(sectionId))\n        const startX = vueFlowNode?.position.x ?? section.position.x\n        const startY = vueFlowNode?.position.y ?? section.position.y\n\n        setNodeState(sectionId, NodeState.RESIZING)\n        startResize(sectionId, 'se')\n\n        resizeState.value = {\n            ...resizeState.value,\n            isResizing: true,\n            sectionId,\n            startX,\n            startY,\n            startWidth: section.position.width,\n            startHeight: section.position.height,\n            currentX: startX,\n            currentY: startY,\n            currentWidth: section.position.width,\n            currentHeight: section.position.height,\n            childStartPositions: {}\n        }\n\n        const vueFlowParentId = CanvasIds.groupNodeId(sectionId)\n        nodes.value.forEach(node => {\n            if (node.parentNode === vueFlowParentId) {\n                // FIX: Use raw ID for consistent locking with PositionManager\n                const { id: childRawId } = CanvasIds.parseNodeId(node.id)\n                resizeState.value.childStartPositions[childRawId] = { ...node.position }\n                // TASK-213: Lock Children\n                lockManager.acquire(childRawId, 'user-resize')\n            }\n        })\n\n        // TASK-213: Lock Group\n        lockManager.acquire(sectionId, 'user-resize')\n    }\n\n    const onSectionResize = ({ sectionId: _rawSectionId, event }: { sectionId: string; event: any }) => {\n        const { id: sectionId } = CanvasIds.parseNodeId(_rawSectionId)\n        const typedEvent = event as { params?: { width?: number; height?: number; x?: number; y?: number } }\n        const width = typedEvent?.params?.width\n        const height = typedEvent?.params?.height\n\n        // STRICT GUARD: Ignore resize events if not in an active resize session\n        // This prevents spurious events from NodeResizer on mount or layout shift\n        if (!resizeState.value.isResizing) return\n\n        // TOLERANCE CHECK: Ignore sub-pixel jitter to prevent ResizeObserver loops\n        if (!width || !height) return\n\n        // Must change by at least 1px to matter\n        if (Math.abs(width - resizeState.value.currentWidth) < 1 &&\n            Math.abs(height - resizeState.value.currentHeight) < 1) {\n            return\n        }\n\n        resizeState.value.currentWidth = width\n        resizeState.value.currentHeight = height\n\n        const xParam = typedEvent?.params?.x\n        const yParam = typedEvent?.params?.y\n        if (typeof xParam === 'number') resizeState.value.currentX = xParam\n        if (typeof yParam === 'number') resizeState.value.currentY = yParam\n\n        const deltaX = resizeState.value.currentX - resizeState.value.startX\n        const deltaY = resizeState.value.currentY - resizeState.value.startY\n\n        if (deltaX !== 0 || deltaY !== 0) {\n            // TASK-213: Update Group in PositionManager\n            const groupNode = findNode(CanvasIds.groupNodeId(sectionId))\n            const parentId = groupNode?.parentNode ? groupNode.parentNode.replace('section-', '') : null\n\n            // TASK-213: Update Group in PositionManager via relative (local) coordinates\n            positionManager.updateFromRelative(\n                sectionId,\n                { x: resizeState.value.currentX, y: resizeState.value.currentY },\n                'user-resize',\n                parentId\n            )\n\n            Object.entries(resizeState.value.childStartPositions).forEach(([childId, startPos]) => {\n                const newRelPos = calculateChildInverseDelta(startPos, deltaX, deltaY)\n                updateNode(childId, { position: newRelPos })\n\n                // TASK-213: Update Child in PositionManager via relative (local) coordinates\n                // We pass 'sectionId' as the parentId so PM can calculate absolute\n                positionManager.updateFromRelative(childId, newRelPos, 'user-resize', sectionId)\n            })\n        }\n    }\n\n    const onSectionResizeEnd = async ({ sectionId: rawSectionId, event }: { sectionId: string; event: any }) => {\n        const { id: sectionId } = CanvasIds.parseNodeId(rawSectionId)\n        const vueFlowNode = findNode(CanvasIds.groupNodeId(sectionId))\n        if (!vueFlowNode) return\n\n        const typedEvent = event as { params?: { width?: number; height?: number } }\n        const width = typedEvent?.params?.width\n        const height = typedEvent?.params?.height\n        if (!width || !height) return\n\n        const section = canvasStore.groups.find(s => s.id === sectionId)\n        if (!section) return\n\n        isResizeSettling.value = true\n        resizeState.value.isResizing = false\n        endResize(sectionId)\n\n        const { width: validatedWidth, height: validatedHeight } = validateDimensions(width, height)\n        const newX = vueFlowNode.position.x\n        const newY = vueFlowNode.position.y\n        const deltaX = newX - resizeState.value.startX\n        const deltaY = newY - resizeState.value.startY\n\n        const absPos = { x: newX, y: newY }\n\n        // 1. Optimistic Store Update (Absolute)\n        canvasStore.updateGroup(sectionId, {\n            position: {\n                ...absPos,\n                width: validatedWidth,\n                height: validatedHeight\n            },\n            positionFormat: 'absolute'\n        })\n\n        // 2. Optimistic DB Sync\n        // We find the Vue Flow node to pass to key logic\n        if (vueFlowNode) {\n            // Ensure width/height are set for sync\n            vueFlowNode.data = { ...vueFlowNode.data, width: validatedWidth, height: validatedHeight }\n\n            setNodeState(sectionId, NodeState.SYNCING)\n            await syncNodePosition(sectionId, vueFlowNode, canvasStore.groups, 'groups')\n            setNodeState(sectionId, NodeState.IDLE)\n        }\n\n        // ================================================================\n        // BUG #4 FIX: Sync descendants when resize changes origin\n        // ================================================================\n        // If resize changed the group's origin (e.g., resizing from top-left),\n        // we must sync all descendant positions to DB. When resizing from\n        // bottom-right only, deltaX/deltaY will be 0 and no sync is needed.\n        if (deltaX !== 0 || deltaY !== 0) {\n            if (import.meta.env.DEV) {\n                console.log(`[CANVAS:INTERACT] Resize origin changed by (${deltaX}, ${deltaY}), syncing descendants...`)\n            }\n\n            // Sync ALL Descendant Tasks (reuse helpers from BUG #1 fix)\n            const descendantTasks = collectDescendantTasks(sectionId, taskStore.tasks, canvasStore.groups)\n            for (const descendantTask of descendantTasks) {\n                const childNode = findNode(descendantTask.id)\n                if (childNode) {\n                    setNodeState(descendantTask.id, NodeState.SYNCING)\n                    syncNodePosition(descendantTask.id, childNode, canvasStore.groups, 'tasks')\n                        .finally(() => setNodeState(descendantTask.id, NodeState.IDLE))\n                }\n            }\n\n            // Sync ALL Descendant Groups\n            const descendantGroups = collectDescendantGroups(sectionId, canvasStore.groups)\n            for (const descendantGroup of descendantGroups) {\n                const childNodeId = CanvasIds.groupNodeId(descendantGroup.id)\n                const childNode = findNode(childNodeId)\n                if (childNode) {\n                    setNodeState(descendantGroup.id, NodeState.SYNCING)\n                    syncNodePosition(descendantGroup.id, childNode, canvasStore.groups, 'groups')\n                        .finally(() => setNodeState(descendantGroup.id, NodeState.IDLE))\n                }\n            }\n        }\n        // NOTE: When deltaX === 0 && deltaY === 0 (bottom-right resize only),\n        // no child sync is needed because child absolute positions don't change.\n\n        // ================================================================\n        // BUG-1191 FIX: Reconcile parentId after resize\n        // ================================================================\n        // When a group is resized smaller, tasks that were inside may now\n        // be outside the new bounds. Clear their parentId to prevent them\n        // from being dragged with the group.\n        const allTasks = taskStore.tasks\n        const resizedGroup = canvasStore.groups.find(g => g.id === sectionId)\n        if (resizedGroup) {\n            const groupAbsPos = getGroupAbsolutePosition(sectionId, canvasStore.groups)\n            const tasksInGroup = allTasks.filter(t => t.parentId === sectionId)\n            for (const task of tasksInGroup) {\n                if (!task.canvasPosition) continue\n                const taskCenterX = task.canvasPosition.x + DEFAULT_TASK_WIDTH / 2\n                const taskCenterY = task.canvasPosition.y + DEFAULT_TASK_HEIGHT / 2\n                const isInside = (\n                    taskCenterX >= groupAbsPos.x &&\n                    taskCenterX <= groupAbsPos.x + validatedWidth &&\n                    taskCenterY >= groupAbsPos.y &&\n                    taskCenterY <= groupAbsPos.y + validatedHeight\n                )\n                if (!isInside) {\n                    if (import.meta.env.DEV) {\n                        console.log(`[BUG-1191] Task \"${task.title?.slice(0, 25)}\" outside resized group \"${resizedGroup.name}\". Clearing parentId.`)\n                    }\n                    // Clear parentId in store and DB\n                    taskStore.updateTask(task.id, { parentId: undefined, positionFormat: 'absolute' }, 'DRAG' as any)\n                    // Fix Vue Flow node\n                    const taskNode = findNode(task.id)\n                    if (taskNode) {\n                        taskNode.parentNode = undefined\n                        // Convert to absolute position (already stored as absolute)\n                        if (task.canvasPosition) {\n                            taskNode.position = { x: task.canvasPosition.x, y: task.canvasPosition.y }\n                        }\n                    }\n                }\n            }\n        }\n\n        // TASK-213: Release Locks\n        lockManager.release(sectionId, 'user-resize')\n        Object.keys(resizeState.value.childStartPositions).forEach(childId => {\n            lockManager.release(childId, 'user-resize')\n        })\n\n        setTimeout(() => isResizeSettling.value = false, RESIZE_SETTLE_TIMEOUT_MS)\n    }\n\n    return {\n        onNodeDragStart, onNodeDrag, onNodeDragStop,\n        onSectionResizeStart, onSectionResize, onSectionResizeEnd,\n        resizeState, isResizeSettling, resizeLineStyle, edgeHandleStyle\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasLifecycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasModals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasOperationState.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1551,1554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1551,1554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1715,1718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1715,1718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2314,2317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2314,2317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3169,3172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3169,3172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3531,3534],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3531,3534],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4508,4511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4508,4511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4645,4648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4645,4648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6751,6754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6751,6754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue'\nimport { DRAG_SETTLE_TIMEOUT_MS } from '@/config/timing'\n\nexport type CanvasOperationType =\n    | 'idle'\n    | 'dragging'\n    | 'drag-settling'\n    | 'resizing'\n    | 'resize-settling'\n    | 'syncing'\n    | 'editing'\n\nexport interface Position {\n    x: number\n    y: number\n}\n\nexport type CanvasOperationState =\n    | { type: 'idle' }\n    | { type: 'dragging'; nodeIds: string[] }\n    | { type: 'drag-settling'; nodeIds: string[]; settleTimeout: number }\n    | { type: 'resizing'; groupId: string; handle: string }\n    | { type: 'resize-settling'; groupId: string; settleTimeout: number }\n    | { type: 'syncing'; source: 'local' | 'remote' }\n    | { type: 'editing'; nodeId: string }\n\n// Singleton state to be shared across all canvas composables\nconst state = ref<CanvasOperationState>({ type: 'idle' })\n\n// Queue for updates that arrive during settling state\nconst pendingUpdates = ref<Array<() => void>>([])\n\n/**\n * State machine for canvas operations.\n * Replaces ad-hoc lock flags with formal transitions.\n */\nexport function useCanvasOperationState() {\n\n    // --- Transitions ---\n\n    const startDrag = (nodeIds: string[]) => {\n        if (state.value.type !== 'idle') return false\n        state.value = { type: 'dragging', nodeIds }\n        return true\n    }\n\n    const endDrag = (nodeIds: string[]) => {\n        if (state.value.type !== 'dragging') return\n\n        // Clear previous timeout if any\n        if ('settleTimeout' in state.value) {\n            window.clearTimeout(state.value.settleTimeout as any)\n        }\n\n        // BUG-1209: Set window flag so realtime handlers block during settling\n        if (typeof window !== 'undefined') {\n            (window as any).__FlowStateIsSettling = true\n        }\n\n        // TASK-1289: Use DRAG_SETTLE_TIMEOUT_MS (3000ms) instead of 800ms to match\n        // the pendingWrite guard. The previous 800ms left a 2.2s gap where realtime\n        // echo could trigger syncStoreToCanvas with stale positions.\n        const settleTimeout = window.setTimeout(() => {\n            if (state.value.type === 'drag-settling') {\n                state.value = { type: 'idle' }\n                // BUG-1209: Clear settling flag when returning to idle\n                if (typeof window !== 'undefined') {\n                    (window as any).__FlowStateIsSettling = false\n                }\n                // Process any queued updates after settling completes\n                const updates = [...pendingUpdates.value]\n                pendingUpdates.value = []\n                updates.forEach(update => update())\n            }\n        }, DRAG_SETTLE_TIMEOUT_MS)\n\n        state.value = { type: 'drag-settling', nodeIds, settleTimeout }\n    }\n\n    const startResize = (groupId: string, handle: string) => {\n        if (state.value.type !== 'idle') return false\n        state.value = { type: 'resizing', groupId, handle }\n        return true\n    }\n\n    const endResize = (groupId: string) => {\n        if (state.value.type !== 'resizing') return\n\n        // BUG-1209: Set window flag so realtime handlers block during settling\n        if (typeof window !== 'undefined') {\n            (window as any).__FlowStateIsSettling = true\n        }\n\n        const settleTimeout = window.setTimeout(() => {\n            if (state.value.type === 'resize-settling') {\n                state.value = { type: 'idle' }\n                // BUG-1209: Clear settling flag when returning to idle\n                if (typeof window !== 'undefined') {\n                    (window as any).__FlowStateIsSettling = false\n                }\n                // Process any queued updates after settling completes\n                const updates = [...pendingUpdates.value]\n                pendingUpdates.value = []\n                updates.forEach(update => update())\n            }\n        }, 800)\n\n        state.value = { type: 'resize-settling', groupId, settleTimeout }\n    }\n\n    const setSyncing = (source: 'local' | 'remote') => {\n        // Can only sync if idle or already syncing\n        if (state.value.type !== 'idle' && state.value.type !== 'syncing') return false\n        state.value = { type: 'syncing', source }\n        return true\n    }\n\n    const setEditing = (nodeId: string) => {\n        if (state.value.type !== 'idle') return false\n        state.value = { type: 'editing', nodeId }\n        return true\n    }\n\n    const resetToIdle = () => {\n        if ('settleTimeout' in state.value) {\n            window.clearTimeout(state.value.settleTimeout as any)\n        }\n        // BUG-1209: Clear settling flag on any reset\n        if (typeof window !== 'undefined') {\n            (window as any).__FlowStateIsSettling = false\n        }\n        state.value = { type: 'idle' }\n    }\n\n    // --- Guards/Selectors ---\n\n    const currentType = computed(() => state.value.type)\n\n    const isIdle = computed(() => state.value.type === 'idle')\n    const isDragging = computed(() => state.value.type === 'dragging')\n    const isResizing = computed(() => state.value.type === 'resizing')\n    const isSyncing = computed(() => state.value.type === 'syncing')\n\n    /**\n     * Whether remote updates should be blocked due to ongoing local interaction.\n     */\n    const isLocked = computed(() => {\n        return state.value.type !== 'idle' && state.value.type !== 'syncing'\n    })\n\n    /**\n     * Specific guard for sync updates.\n     */\n    const canAcceptRemoteUpdate = computed(() => {\n        return state.value.type === 'idle' || state.value.type === 'syncing'\n    })\n\n    const canStartOperation = computed(() => state.value.type === 'idle')\n\n    /**\n     * Is canvas in a settling state? (just finished interaction)\n     */\n    const isSettling = computed(() => {\n        return state.value.type === 'drag-settling' || state.value.type === 'resize-settling'\n    })\n\n    /**\n     * Should we block ALL updates? (interacting or settling)\n     */\n    const shouldBlockUpdates = computed(() => {\n        return isLocked.value || isSettling.value\n    })\n\n    /**\n     * Queue an update to be processed after settling completes\n     */\n    const queueUpdate = (updateFn: () => void) => {\n        pendingUpdates.value.push(updateFn)\n    }\n\n    /**\n     * BUG-1209: Unified guard that checks ALL position modification locks.\n     * Use this single function instead of checking individual flags separately.\n     * Returns true if positions should NOT be modified by remote/sync operations.\n     */\n    const isPositionModificationBlocked = computed(() => {\n        // State machine checks (dragging, settling, resizing, editing)\n        if (shouldBlockUpdates.value) return true\n        // Window-level flags (set by other subsystems)\n        if (typeof window !== 'undefined') {\n            const w = window as any\n            if (w.__FlowStateIsDragging || w.__FlowStateIsResizing || w.__FlowStateIsSettling) return true\n        }\n        return false\n    })\n\n    /**\n     * Get debug info for troubleshooting\n     */\n    const getDebugInfo = () => ({\n        type: state.value.type,\n        canAcceptRemoteUpdate: canAcceptRemoteUpdate.value,\n        isLocked: isLocked.value,\n        isSettling: isSettling.value,\n        pendingUpdatesCount: pendingUpdates.value.length,\n        fullState: state.value\n    })\n\n    return {\n        state,\n        currentType,\n        isIdle,\n        isDragging,\n        isResizing,\n        isSyncing,\n        isLocked,\n        canAcceptRemoteUpdate,\n        canStartOperation,\n        startDrag,\n        endDrag,\n        startResize,\n        endResize,\n        setSyncing,\n        setEditing,\n        resetToIdle,\n        isSettling,\n        shouldBlockUpdates,\n        isPositionModificationBlocked,\n        queueUpdate,\n        getDebugInfo\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5766,5769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5766,5769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":234,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8517,8520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8517,8520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":718,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":718,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28689,28692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28689,28692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":742,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":742,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29896,29899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29896,29899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, watch, nextTick, onMounted, onUnmounted } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasUiStore } from '@/stores/canvas/canvasUi'\nimport { useCanvasContextMenuStore } from '@/stores/canvas/contextMenus'\nimport { useUIStore } from '@/stores/ui'\nimport { useMagicKeys, useWindowSize } from '@vueuse/core'\n\nimport resourceManager from '../../utils/canvas/resourceManager'\nimport { getUndoSystem } from '@/composables/undoSingleton'\nimport { reconcileTaskParentsByContainment } from '@/utils/canvas/spatialContainment'\nimport { logHierarchySummary } from '@/utils/canvas/invariants'\nimport { useCanvasOperationState } from './useCanvasOperationState'\n\n// --- NEW COMPOSABLES (Phase 3) ---\nimport { useCanvasCore } from './useCanvasCore'\nimport { useCanvasSync } from './useCanvasSync'\nimport { useCanvasInteractions } from './useCanvasInteractions'\nimport { useCanvasSelection } from './useCanvasSelection'\n\n// ...\n// Persistence (Sync)\n// Moved inside useCanvasOrchestrator to ensure correct Vue context\n\nimport { useCanvasGroups } from './useCanvasGroups'\nimport { positionManager } from '@/services/canvas/PositionManager'\n\n\n// Legacy/Auxiliary Composables (Still used)\nimport { useCanvasEvents } from './useCanvasEvents'\nimport { useCanvasHotkeys } from './useCanvasHotkeys'\nimport { useCanvasActions } from './useCanvasActions'\nimport { useCanvasOverdueCollector } from './useCanvasOverdueCollector'\nimport { useCanvasModals } from './useCanvasModals'\nimport { useCanvasFilteredState } from './useCanvasFilteredState'\nimport { useCanvasLifecycle } from './useCanvasLifecycle'\nimport { useCanvasNavigation } from './useCanvasNavigation' // Keeping for specialized nav if needed\nimport { useCanvasZoom } from './useCanvasZoom' // Keeping for cleanup hooks\nimport { useCanvasAlignment } from './useCanvasAlignment'\nimport { useCanvasConnections } from './useCanvasConnections'\nimport { useCanvasEdgeSync } from './useCanvasEdgeSync'\n\n// Helper for error boundaries\nconst mockErrorBoundary = (_name: string, fn: (...args: unknown[]) => unknown) => {\n    if (typeof fn !== 'function') return (..._args: unknown[]) => {\n        return null\n    }\n    return (...args: unknown[]) => {\n        try {\n            return fn(...args)\n        } catch (e) {\n            console.error(`[CanvasError] Error in ${_name}:`, e)\n            return null\n        }\n    }\n}\n\n// =============================================================================\n// DRIFT FIX: Module-level flag to ensure reconciliation runs only ONCE per browser session\n// =============================================================================\n// This prevents parent drift when:\n// - Tab visibility changes (focus/unfocus)\n// - Auth token refreshes (TOKEN_REFRESHED event)\n// - CanvasView remounts for any reason\n// Reconciliation should only happen on FIRST load, not repeatedly.\nlet hasReconciledThisSession = false\n\nexport function useCanvasOrchestrator() {\n    const canvasStore = useCanvasStore()\n    const taskStore = useTaskStore()\n    const canvasUiStore = useCanvasUiStore()\n    const contextMenuStore = useCanvasContextMenuStore()\n    const uiStore = useUIStore()\n\n    // Store cleanup functions for onUnmounted - must be registered synchronously\n    const positionManagerUnsubscribe = ref<(() => void) | null>(null)\n\n    // --- 1. Core State & Vue Flow (Via useCanvasCore) ---\n    const {\n        nodes,\n        edges,\n        onPaneReady,\n        viewport,\n        updateNode,\n        findNode,\n        onMoveEnd,\n        applyNodeChanges,\n        applyEdgeChanges,\n        screenToFlowCoordinate\n    } = useCanvasCore()\n\n    const { hasInitialFit, operationLoading, operationError } = storeToRefs(canvasUiStore)\n    const { setOperationLoading, setOperationError, clearOperationError } = canvasUiStore\n    const { width: _width, height: _height } = useWindowSize()\n    const { shift, control, meta } = useMagicKeys()\n\n    // --- 2. Computed Data ---\n    const filteredTasks = computed(() => taskStore.filteredTasks)\n\n    // Pass taskStore reference so filtering can access hideCanvasDoneTasks etc.\n    const canvasStoreWithTaskStore = {\n        ...canvasStore,\n        taskStore: {\n            get hideCanvasDoneTasks() { return taskStore.hideCanvasDoneTasks },\n            get hideCanvasOverdueTasks() { return taskStore.hideCanvasOverdueTasks }\n        }\n    }\n\n    const {\n        tasksWithCanvasPosition,\n        dynamicNodeExtent,\n        hasNoTasks,\n        hasInboxTasks\n    } = useCanvasFilteredState(filteredTasks, canvasStoreWithTaskStore)\n\n    // --- 3. Feature Initialization ---\n\n    // Persistence (Sync)\n    // const persistence = useCanvasPersistence()\n\n    // Persistence (Sync)\n    const persistence = useCanvasSync()\n\n    // Unified Interactions (Drag & Resize)\n    const { canAcceptRemoteUpdate } = useCanvasOperationState()\n\n    const interactions = useCanvasInteractions({\n        nodes,\n        findNode,\n        updateNode,\n        applyNodeChanges\n    })\n\n    // Selection management\n    const selection = useCanvasSelection({\n        nodes,\n        applyNodeChanges\n    })\n\n    // Groups (Unified)\n    useCanvasGroups()\n\n    // Navigation & Zoom (Legacy cleanup support, transitioning to Core)\n    const { initialViewport, fitCanvas: legacyFitCanvas, zoomToSelection: legacyZoomToSelection, centerOnTodayGroup } = useCanvasNavigation(canvasStore)\n    const fitCanvas = legacyFitCanvas\n    const zoomToSelection = legacyZoomToSelection\n    const { cleanupZoom } = useCanvasZoom(resourceManager)\n\n    // Modals\n    const modals = useCanvasModals()\n\n    // Sync Helpers (Adapter for legacy calls)\n    const syncNodes = (tasks?: any[]) => {\n        // Prevent sync if explicitly unwanted (e.g. during specific interactions)\n        if (canvasUiStore.operationLoading.syncing) return\n\n        // TASK-241: State Machine Guard\n        // Block READ-PATH syncs if user is interacting (dragging/resizing)\n        if (!canAcceptRemoteUpdate.value) {\n            return\n        }\n\n        try {\n            const tasksToSync = tasks || tasksWithCanvasPosition.value\n            persistence.syncStoreToCanvas(tasksToSync)\n        } catch (e) {\n            console.error('💥 [ORCHESTRATOR] syncNodes failed:', e)\n        }\n    }\n\n    // OPTIMIZATION: True batching (only runs once per tick)\n    let isSyncScheduled = false\n    const batchedSyncNodes = (_priority?: string) => {\n        if (isSyncScheduled) return\n        isSyncScheduled = true\n        nextTick(() => {\n            syncNodes()\n            isSyncScheduled = false\n        })\n    }\n\n    // Edge sync: build edges from task.dependsOn arrays\n    const recentlyRemovedEdges = ref(new Set<string>())\n    const edgeSync = useCanvasEdgeSync({ recentlyRemovedEdges })\n    const syncEdges = () => {\n        if (!canAcceptRemoteUpdate.value) {\n            return\n        }\n        edgeSync.syncEdges(tasksWithCanvasPosition.value)\n    }\n\n    // Batched edge sync to coalesce multiple updates\n    let isEdgeSyncScheduled = false\n    const batchedSyncEdges = () => {\n        if (isEdgeSyncScheduled) return\n        isEdgeSyncScheduled = true\n        nextTick(() => {\n            syncEdges()\n            isEdgeSyncScheduled = false\n        })\n    }\n\n    // Events (Selection, Connection)\n    const isVueFlowReady = ref(false)\n    const isVueFlowMounted = ref(false)\n\n    const events = useCanvasEvents(syncNodes)\n\n    // Actions\n    const recentlyDeletedGroups = ref(new Set<string>())\n    const actions = useCanvasActions({\n        viewport,\n        batchedSyncNodes: batchedSyncNodes,\n        syncNodes: syncNodes,\n        closeCanvasContextMenu: events.closeCanvasContextMenu,\n        closeEdgeContextMenu: events.closeEdgeContextMenu,\n        closeNodeContextMenu: events.closeNodeContextMenu,\n        recentlyDeletedGroups\n    }, modals, getUndoSystem())\n\n    // Wrapper for createTaskHere to use stored context menu position\n    // This ensures tasks are created at the exact right-click location\n    const createTaskHere = () => {\n        const screenPos = {\n            x: events.canvasContextMenuX.value,\n            y: events.canvasContextMenuY.value\n        }\n        actions.createTaskHere(screenPos)\n    }\n\n    // Wrapper for createTaskInGroup to use stored context menu position\n    // TASK-288 FIX: This ensures tasks are created at the click location within the group\n    const createTaskInGroup = (groupOrId: string | any) => {\n        const screenPos = {\n            x: events.canvasContextMenuX.value,\n            y: events.canvasContextMenuY.value\n        }\n        actions.createTaskInGroup(groupOrId, screenPos)\n    }\n\n    // Wrapper for createGroup to use stored context menu position\n    // BUG-1126 FIX: This ensures groups are created at the right-click location, not viewport center\n    const createGroup = () => {\n        const screenPos = {\n            x: events.canvasContextMenuX.value,\n            y: events.canvasContextMenuY.value\n        }\n        if (import.meta.env.DEV) {\n            console.log('[BUG-1126] createGroup wrapper called', {\n                storedContextMenuX: events.canvasContextMenuX.value,\n                storedContextMenuY: events.canvasContextMenuY.value,\n                screenPos\n            })\n        }\n        actions.createGroup(screenPos)\n    }\n\n    // Hotkeys\n    const { handleKeyDown } = useCanvasHotkeys({\n        isBulkDeleteModalOpen: modals.isBulkDeleteModalOpen,\n        bulkDeleteItems: modals.bulkDeleteItems,\n        bulkDeleteIsPermanent: modals.bulkDeleteIsPermanent,\n        createGroup: actions.createGroup\n    })\n\n    // Lifecycle\n    const lifecycle = useCanvasLifecycle(\n        taskStore,\n        canvasStore,\n        uiStore,\n        fitCanvas,\n        cleanupZoom\n    )\n\n\n    const isCanvasReady = computed(() => {\n        return !operationLoading.value.loading && !operationLoading.value.syncing\n    })\n\n    // Alignment\n    const alignment = useCanvasAlignment(nodes, {\n        isVueFlowMounted,\n        isVueFlowReady,\n        isCanvasReady\n    }, {\n        closeCanvasContextMenu: events.closeCanvasContextMenu,\n        requestSync: batchedSyncNodes // Fix TASK-258\n    })\n\n    // Smart Groups\n    const smartGroups = useCanvasOverdueCollector()\n\n    // Events Wrapper\n    const handleCanvasContainerClick = (e: MouseEvent) => {\n        const target = e.target as HTMLElement\n\n        // BUG-FIX: Skip if shift/ctrl/meta is held (user is multi-selecting)\n        // This prevents clearing selection when Vue Flow's selection box is active\n        if (e.shiftKey || e.ctrlKey || e.metaKey) {\n            // Still close context menus\n            events.closeCanvasContextMenu()\n            events.closeEdgeContextMenu()\n            events.closeNodeContextMenu()\n            return\n        }\n\n        // Only clear selection when clicking on truly empty canvas (pane/viewport)\n        // Don't clear when clicking on nodes, edges, or other interactive elements\n        // BUG-FIX: Exclude \"selection\" class which is Vue Flow's selection box\n        const isVueFlowSelectionBox = target.classList.contains('selection')\n        const isEmptyCanvasClick = !isVueFlowSelectionBox && (\n            target.classList.contains('vue-flow__pane') ||\n            target.classList.contains('vue-flow__viewport') ||\n            target.classList.contains('vue-flow__container') ||\n            target.classList.contains('vue-flow__background')\n        )\n\n        if (isEmptyCanvasClick) {\n            selection.clearSelection()\n        }\n\n        // Always close context menus\n        events.closeCanvasContextMenu()\n        events.closeEdgeContextMenu()\n        events.closeNodeContextMenu()\n    }\n\n    const collectTasksForSection = (sectionId: string) => {\n        actions.collectOverdueTasksNearGroup(sectionId)\n    }\n\n    // TASK-1222: Collect overdue tasks and arrange near a group\n    const collectOverdueTasksNearGroup = (sectionId: string) => {\n        actions.collectOverdueTasksNearGroup(sectionId)\n    }\n\n    // Connections - use context menu store refs for edge menu to sync with EdgeContextMenu component\n    const { showEdgeContextMenu, edgeContextMenuX, edgeContextMenuY } = storeToRefs(contextMenuStore)\n    const selectedEdge = ref<import('@vue-flow/core').Edge | null>(null)\n    // State for drag-to-create feature\n    const pendingConnectionSource = ref<string | null>(null)\n    const connectionWasSuccessful = ref(false)\n\n    const connections = useCanvasConnections({\n        syncEdges: syncEdges,\n        closeCanvasContextMenu: events.closeCanvasContextMenu,\n        closeEdgeContextMenu: events.closeEdgeContextMenu,\n        closeNodeContextMenu: events.closeNodeContextMenu,\n        withVueFlowErrorBoundary: mockErrorBoundary,\n        // Drag-to-create dependencies\n        screenToFlowCoordinate,\n        createConnectedTask: actions.createConnectedTask\n    }, {\n        isConnecting: ref(false),\n        recentlyRemovedEdges, // Shared with useCanvasEdgeSync for zombie edge prevention\n        showEdgeContextMenu,\n        edgeContextMenuX,\n        edgeContextMenuY,\n        selectedEdge,\n        // Drag-to-create state\n        pendingConnectionSource,\n        connectionWasSuccessful\n    })\n\n    // --- 4. Initialization & Reactivity ---\n\n    // CRITICAL: Initialization guard to prevent watchers from calling syncNodes during startup\n    // Without this, watchers fire as data loads, causing multiple syncNodes() calls with different task counts\n    const isInitialized = ref(false)\n\n    // Initial sync\n    onMounted(async () => {\n        if (import.meta.env.DEV) {\n            console.log('🚀 [ORCHESTRATOR] onMounted starting...')\n        }\n\n        await canvasStore.loadSavedViewport()\n        await nextTick()\n\n        // Initialize Realtime\n        persistence.initRealtimeSubscription()\n\n        // BUG-1084 v5: Wait for stores to be ready before initial sync\n        // The root cause of empty canvas on initial load was calling syncNodes() before\n        // stores were populated. Now we use a watcher to wait for initialization.\n        // BUG-1107: Use let + nextTick to avoid \"can't access before initialization\" error\n        // when watcher runs immediately and tries to call stopInitWatcher()\n        let stopInitWatcher: (() => void) | null = null\n        stopInitWatcher = watch(\n            [\n                () => taskStore._hasInitializedOnce,\n                () => canvasStore._hasInitializedOnce\n            ],\n            async ([tasksReady, groupsReady]) => {\n                // Run initial sync once BOTH stores have finished loading\n                if (tasksReady && groupsReady && !isInitialized.value) {\n                    if (import.meta.env.DEV) {\n                        console.log('🚀 [ORCHESTRATOR] Stores initialized, running initial sync', {\n                            tasks: taskStore.tasks.length,\n                            groups: canvasStore.groups.length\n                        })\n                    }\n                    syncNodes()\n                    syncEdges()\n                    isInitialized.value = true\n                    if (import.meta.env.DEV) {\n                        console.log('✅ [ORCHESTRATOR] Initialization complete')\n                    }\n\n                    // CONTAINMENT RECONCILIATION: Fix legacy tasks with incorrect parentId\n                    // DRIFT FIX: Only run ONCE per browser session to prevent repeated parent changes\n                    // This guards against remounts from: tab focus, auth refresh, route changes\n                    // BUG-1084 FIX: Also guard against empty groups - reconciliation needs groups to determine containment\n                    // RACE FIX: Moved from onMounted into init watcher so reconciliation runs AFTER\n                    // both stores are fully loaded — prevents incorrect parentId from partial task data\n                    if (!hasReconciledThisSession && canvasStore.groups.length > 0) {\n                        hasReconciledThisSession = true\n                        if (import.meta.env.DEV) {\n                            console.log('🔧 [ORCHESTRATOR] Starting ONE-TIME reconciliation with', taskStore.tasks.length, 'tasks')\n                        }\n                        await reconcileTaskParentsByContainment(\n                            taskStore.tasks,\n                            canvasStore.groups,\n                            async (taskId, updates) => {\n                                // Update store (will auto-sync to Supabase via existing persistence)\n                                // GEOMETRY WRITER: One-time reconciliation only (TASK-255)\n                                if (import.meta.env.DEV) {\n                                    console.log(`🔧[RECONCILE-WRITE] Task ${taskId.slice(0, 8)}... parentId → ${updates.parentId ?? 'none'}`)\n                                }\n                                taskStore.updateTask(taskId, updates, 'RECONCILE')\n                            },\n                            { writeToDb: true, silent: false }\n                        )\n                    } else if (hasReconciledThisSession) {\n                        if (import.meta.env.DEV) {\n                            console.log('⏭️ [ORCHESTRATOR] Skipping reconciliation - already ran this session')\n                        }\n                    }\n\n                    // Calculate initial task counts AFTER reconciliation (fixes 0 counters on load)\n                    canvasStore.recalculateAllTaskCounts(taskStore.tasks)\n\n                    // Log hierarchy summary once on load (dev only)\n                    if (import.meta.env.DEV) {\n                        logHierarchySummary(canvasStore._rawGroups || [])\n                    }\n\n                    // Defer stop to next tick to ensure stopInitWatcher is assigned\n                    if (stopInitWatcher) stopInitWatcher()\n                }\n            },\n            { immediate: true }\n        )\n\n        // Fallback: If stores don't signal ready within 2s, sync anyway\n        // This handles edge cases like empty databases or network timeouts\n        setTimeout(() => {\n            if (!isInitialized.value) {\n                console.warn('⚠️ [ORCHESTRATOR] Fallback sync - stores took too long', {\n                    tasksReady: taskStore._hasInitializedOnce,\n                    groupsReady: canvasStore._hasInitializedOnce,\n                    tasks: taskStore.tasks.length,\n                    groups: canvasStore.groups.length\n                })\n                syncNodes()\n                syncEdges()\n                isInitialized.value = true\n                if (stopInitWatcher) stopInitWatcher()\n            }\n        }, 2000)\n\n        // TASK-299: Auto-center on Today group after nodes are rendered\n        // Use setTimeout to allow Vue Flow to calculate node dimensions\n        setTimeout(() => {\n            // Check if user has a custom saved viewport (not default 0,0,1)\n            const vp = canvasStore.viewport\n            const hasCustomViewport = vp && (vp.x !== 0 || vp.y !== 0 || vp.zoom !== 1)\n\n            // If no custom viewport (first visit), force fallback to busiest group\n            // If has custom viewport, only override if Today group exists\n            const forceFallback = !hasCustomViewport\n            const centered = centerOnTodayGroup(forceFallback)\n            if (import.meta.env.DEV) {\n                console.log('🎯 [ORCHESTRATOR] Auto-center result:', centered ? 'SUCCESS' : 'USING_SAVED_VIEWPORT', { hasCustomViewport })\n            }\n        }, 100)\n\n        // TASK-213: Position Manager Subscription\n        // Listen for updates from other sources (e.g. Alignment tools, Auto-layout)\n        // that are NOT 'user-drag' (handled by Vue Flow) or 'remote-sync' (handled by sync loop)\n        positionManagerUnsubscribe.value = positionManager.subscribe((event) => {\n            const { nodeId, payload } = event\n            if (payload.source !== 'user-drag' && payload.source !== 'remote-sync') {\n                if (import.meta.env.DEV) {\n                    console.log(`📡[ORCHESTRATOR] Applying external position update for ${nodeId} from ${payload.source}`)\n                }\n\n                const node = findNode(nodeId)\n                if (node) {\n                    // Convert Absolute (PM) -> Relative (Vue Flow)\n                    // If node has parent, we need parent's position to convert\n                    let relativePos = payload.position\n\n                    if (payload.parentId) {\n                        // Look up parent in PM (Truth) or Store\n                        const parentPm = positionManager.getPosition(payload.parentId)\n                        if (parentPm) {\n                            relativePos = {\n                                x: payload.position.x - parentPm.position.x,\n                                y: payload.position.y - parentPm.position.y\n                            }\n                        }\n                    }\n\n                    updateNode(nodeId, { position: relativePos })\n                }\n            }\n        })\n    })\n\n    // CRITICAL: Register onUnmounted synchronously (not inside async onMounted)\n    // This fixes Vue warning: \"onUnmounted is called when there is no active component instance\"\n    onUnmounted(() => {\n        if (positionManagerUnsubscribe.value) {\n            positionManagerUnsubscribe.value()\n            positionManagerUnsubscribe.value = null\n        }\n        // BUG-1216: Clean up viewport debounce timer\n        if (viewportSaveTimer) {\n            clearTimeout(viewportSaveTimer)\n            viewportSaveTimer = null\n        }\n    })\n\n    // Persist Viewport on Change\n    // BUG-1216: Debounce viewport persistence to prevent \"double take\" glitch during scroll-wheel zoom.\n    // Each scroll tick triggers a zoom animation → onMoveEnd fires → reactive store update → re-render.\n    // Without debounce, rapid scroll-wheel zoom causes cascading re-renders mid-animation.\n    let viewportSaveTimer: ReturnType<typeof setTimeout> | null = null\n    onMoveEnd((flow) => {\n        if (flow && flow.flowTransform) {\n            if (viewportSaveTimer) clearTimeout(viewportSaveTimer)\n            viewportSaveTimer = setTimeout(() => {\n                canvasStore.setViewport(flow.flowTransform.x, flow.flowTransform.y, flow.flowTransform.zoom)\n                viewportSaveTimer = null\n            }, 150)\n        }\n    })\n\n    // Watchers are now largely handled by persistence.initRealtimeSubscription which watches Stores\n    // But we still need to watch Filter changes here as they affect WHICH tasks we show\n    // CRITICAL: All watchers check isInitialized to prevent firing during startup\n    // OPTIMIZATION: Use batchedSyncNodes to coalesce multiple updates\n    watch(() => taskStore.activeStatusFilter, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n    })\n    watch(() => taskStore.hideCanvasDoneTasks, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n    })\n    watch(() => taskStore.hideCanvasOverdueTasks, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n    })\n    // BUG-1210 FIX: Watch smart view changes to re-sync canvas nodes\n    // Without this, switching to \"This Week\" doesn't refresh canvas when task count stays the same\n    watch(() => taskStore.activeSmartView, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n        batchedSyncEdges()\n    })\n\n    // REACTIVITY FIX: Watch for manual sync requests from context menus\n    watch(() => canvasStore.syncTrigger, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n        batchedSyncEdges()\n    })\n\n    watch(() => canvasUiStore.syncTrigger, () => {\n        if (!isInitialized.value) return\n        batchedSyncNodes()\n    })\n\n    // Global guard to prevent recursive watcher triggers\n    let isSyncingFromWatcher = false\n\n    // CRITICAL FIX: Watch for task data changes (e.g. after async load)\n    // BUG-1210: Watch task IDs, not just length — smart view switches swap which tasks\n    // are visible without necessarily changing the count\n    watch(() => tasksWithCanvasPosition.value.map(t => t.id).join(','), () => {\n        // Skip during initialization - onMounted handles initial sync\n        if (!isInitialized.value) return\n        if (isSyncingFromWatcher) return\n        isSyncingFromWatcher = true\n        try {\n            if (persistence.isSyncing.value) return\n            canvasStore.recalculateAllTaskCounts(taskStore.tasks)\n            batchedSyncNodes()\n            batchedSyncEdges() // Also sync edges when tasks change\n        } finally {\n            isSyncingFromWatcher = false\n        }\n    })\n\n    // CRITICAL FIX: Watch for group changes (e.g. creation/deletion/remote sync)\n    watch(() => canvasStore.groups.length, () => {\n        // Skip during initialization - onMounted handles initial sync\n        if (!isInitialized.value) return\n        if (isSyncingFromWatcher) return\n        isSyncingFromWatcher = true\n        try {\n            if (persistence.isSyncing.value) return\n            canvasStore.recalculateAllTaskCounts(taskStore.tasks)\n            batchedSyncNodes()\n        } finally {\n            isSyncingFromWatcher = false\n        }\n    })\n\n    // DRIFT FIX: REMOVED watcher on taskCountByGroupId\n    // This watcher was causing sync loops and is now redundant because:\n    // 1. updateSingleSectionCount() directly updates Vue Flow node.data with fresh counts\n    // 2. The drag handler calls bumpTaskParentVersion() + updateSectionTaskCounts()\n    // 3. No need to rebuild all nodes just because counts changed\n    // Keeping this comment to document why it was removed.\n    // watch(() => canvasStore.taskCountByGroupId, () => { ... }, { deep: true })\n\n    // Retry Logic\n    const retryFailedOperation = async () => {\n        if (!operationError.value?.retryable) return\n        const { type } = operationError.value\n        clearOperationError()\n\n        if (type === 'System Restart') {\n            // persistence.performSystemRestart() // Todo: implement if needed\n            window.location.reload()\n        } else {\n            setOperationLoading('syncing', true)\n            try {\n                await nextTick()\n                syncNodes()\n                setOperationLoading('syncing', false)\n            } catch (_error) {\n                setOperationError('Sync Operation', 'Retry failed', true)\n                setOperationLoading('syncing', false)\n            }\n        }\n    }\n\n    // --- Expose Public Interface ---\n    return {\n        // State\n        nodes,\n        edges,\n        isCanvasReady,\n        operationLoading,\n        operationError,\n\n        // UI\n        viewport,\n        initialViewport,\n        hasInitialFit,\n        shift,\n        control,\n        meta,\n        vueFlowRef: ref(null), // TODO: Do we need this ref if we use Core? CanvasView binds it.\n\n        // Computed\n        filteredTasks,\n        tasksWithCanvasPosition,\n        dynamicNodeExtent,\n        hasNoTasks,\n        hasInboxTasks,\n\n        // Actions & Handlers\n        ...actions,\n        createTaskHere, // Override to use stored context menu position\n        createTaskInGroup, // Override to use stored context menu position (TASK-288 fix)\n        createGroup, // Override to use stored context menu position (BUG-1126 fix)\n        ...modals,\n        closeSectionSettingsModal: actions.closeGroupEditModal,\n        handleSectionSettingsSave: actions.handleGroupEditSave,\n\n        ...events,\n\n        // Selection Handlers\n        handleMouseDown: selection.startSelection,\n        handleMouseMove: selection.updateSelection,\n        handleMouseUp: selection.endSelection,\n        handleCanvasContainerClick,\n\n        // New feature re-exports\n        ...selection,\n        ...interactions,\n        ...alignment,\n        ...smartGroups,\n        collectTasksForSection,\n        collectOverdueTasksNearGroup,\n        ...connections,\n\n        // Interaction Handlers\n        handleNodeDragStart: interactions.onNodeDragStart,\n        handleNodeDrag: interactions.onNodeDrag,\n        handleNodeDragStop: interactions.onNodeDragStop,\n\n        handleSectionResizeStart: interactions.onSectionResizeStart,\n        handleSectionResize: interactions.onSectionResize,\n        handleSectionResizeEnd: interactions.onSectionResizeEnd,\n\n        resizeState: interactions.resizeState,\n        isResizeSettling: interactions.isResizeSettling,\n        resizeLineStyle: interactions.resizeLineStyle,\n        edgeHandleStyle: interactions.edgeHandleStyle,\n\n        onPaneReady: (instance: any) => {\n            onPaneReady(instance) // Core handler\n            isVueFlowReady.value = true\n            isVueFlowMounted.value = true\n            setOperationLoading('loading', false)\n            setOperationLoading('syncing', false)\n\n            // BUG-1310: Log nodeExtent at VueFlow init for invisible barrier diagnosis\n            if (import.meta.env.DEV) {\n                const extent = dynamicNodeExtent.value\n                console.log('[BUG-1310:INIT] VueFlow pane ready — dynamicNodeExtent:', {\n                    extent: extent ? { minX: Math.round(extent[0][0]), minY: Math.round(extent[0][1]), maxX: Math.round(extent[1][0]), maxY: Math.round(extent[1][1]) } : 'null',\n                    nodeCount: nodes.value?.length ?? 0,\n                    tasksWithPos: tasksWithCanvasPosition.value?.length ?? 0\n                })\n            }\n        },\n        fitCanvas,\n        zoomToSelection,\n        retryFailedOperation,\n\n        // Vue Flow Handlers\n        // TASK-262: Filter selection changes to prevent unwanted deselection on node click\n        // Vue Flow default: clicking a node deselects all others. We only want pane click to deselect.\n        handleNodesChange: (changes: any[]) => {\n            // TASK-262 FIX: Allow all changes to pass through including deselection\n            // Previously, deselection was blocked which prevented clicking on empty canvas\n            // from clearing selection. Vue Flow's default behavior is correct - let it work.\n\n            applyNodeChanges(changes)\n        },\n        handleEdgesChange: applyEdgeChanges,\n        handleConnect: (params: import('@vue-flow/core').Connection) => {\n            connections.handleConnect(params)\n        },\n        handleConnectStart: connections.handleConnectStart,\n        handleConnectEnd: connections.handleConnectEnd,\n\n        // Debug\n        syncNodes,\n        syncEdges,\n        performSystemRestart: () => window.location.reload(), // Simple fallback\n        storeHealth: lifecycle.storeHealth,\n\n        // Hotkeys\n        handleKeyDown,\n\n        // TASK-241: State Machine Debug\n        operationState: useCanvasOperationState().state,\n        getOperationDebug: useCanvasOperationState().getDebugInfo\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasOverdueCollector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasResizeCalculation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasResizeState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasSectionProperties.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasSelection.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useVueFlow' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":31,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"useVueFlow"},"fix":{"range":[88,100],"text":""},"desc":"Remove unused variable \"useVueFlow\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useTaskStore' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"useTaskStore"},"fix":{"range":[174,219],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[708,711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[708,711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2608,2611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2608,2611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2670,2673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2670,2673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3791,3794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3791,3794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, reactive, type Ref, onMounted, onUnmounted } from 'vue'\nimport { type Node, useVueFlow } from '@vue-flow/core'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport type { Task } from '@/types/tasks'\nimport { useCanvasCore } from './useCanvasCore'\n\nexport interface SelectionBox {\n    x: number\n    y: number\n    width: number\n    height: number\n    startX: number\n    startY: number\n    isVisible: boolean\n    // Container offset for proper positioning (BUG-1067: Tauri coordinate fix)\n    containerOffsetX: number\n    containerOffsetY: number\n}\n\nexport function useCanvasSelection(deps: {\n    nodes: Ref<Node[]>\n    applyNodeChanges: (changes: any[]) => void\n}) {\n    const { nodes, applyNodeChanges } = deps\n    const canvasStore = useCanvasStore()\n    const { getNodes } = useCanvasCore()\n\n    // Selection state\n    const selectionBox = reactive<SelectionBox>({\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        startX: 0,\n        startY: 0,\n        isVisible: false,\n        // BUG-1067: Container offset for Tauri coordinate fix\n        containerOffsetX: 0,\n        containerOffsetY: 0\n    })\n\n    const selectedTask = ref<Task | null>(null)\n\n    // --- NODE CLICK HANDLER (Migrated from CanvasView.vue) ---\n    const handleNodeClick = (event: { event: MouseEvent | TouchEvent; node: Node }) => {\n        const { node } = event\n        const nodeId = node.id\n        const currentSelection = [...canvasStore.selectedNodeIds]\n\n        // Type guard for mouse event\n        const mouseEvent = event.event as MouseEvent\n\n        let newSelection: string[]\n\n        // If Ctrl/Cmd OR Shift is held, toggle selection\n        if (mouseEvent.ctrlKey || mouseEvent.metaKey || mouseEvent.shiftKey) {\n            if (currentSelection.includes(nodeId)) {\n                newSelection = currentSelection.filter(id => id !== nodeId)\n            } else {\n                newSelection = [...currentSelection, nodeId]\n            }\n        } else {\n            // Standard behavior: Single click replaces selection\n            newSelection = [nodeId]\n        }\n\n        // Update store\n        canvasStore.selectedNodeIds = newSelection\n\n        // Update Vue Flow's visual selection state\n        const selectionChanges = nodes.value.map(n => ({\n            id: n.id,\n            type: 'select' as const,\n            selected: newSelection.includes(n.id)\n        }))\n        applyNodeChanges(selectionChanges)\n    }\n\n    // --- SELECTION CHANGE HANDLER (Migrated from CanvasView.vue) ---\n    const handleSelectionChange = (params: any) => {\n        const newSelection = params?.nodes?.map((n: any) => n.id) ?? []\n        canvasStore.selectedNodeIds = newSelection\n    }\n\n    // --- TASK SELECT HANDLER (From TaskNode.vue) ---\n    const handleTaskSelect = (task: Task, multiSelect: boolean) => {\n        if (!task.id) return\n\n        let newSelection: string[]\n        const currentSelection = [...canvasStore.selectedNodeIds]\n\n        if (multiSelect) {\n            if (currentSelection.includes(task.id)) {\n                newSelection = currentSelection.filter(id => id !== task.id)\n            } else {\n                newSelection = [...currentSelection, task.id]\n            }\n        } else {\n            newSelection = [task.id]\n        }\n\n        canvasStore.setSelectedNodes(newSelection)\n\n        const selectionChanges = nodes.value.map(node => ({\n            id: node.id,\n            type: 'select' as const,\n            selected: newSelection.includes(node.id)\n        }))\n\n        applyNodeChanges(selectionChanges)\n    }\n\n    // --- CLEAR SELECTION ---\n    const clearSelection = () => {\n        canvasStore.setSelectedNodes([])\n        selectedTask.value = null\n\n        nodes.value.forEach((node: any) => {\n            if (node.selected) {\n                node.selected = false\n            }\n        })\n    }\n\n    // --- RECTANGLE SELECTION HANDLERS ---\n    const updateSelection = (event: MouseEvent) => {\n        if (!selectionBox.isVisible) return\n        const currentX = event.clientX\n        const currentY = event.clientY\n\n        // BUG-1067: Calculate position relative to container for rendering\n        // But keep viewport coordinates for width/height calculation\n        selectionBox.width = Math.abs(currentX - selectionBox.startX)\n        selectionBox.height = Math.abs(currentY - selectionBox.startY)\n        // Position relative to container\n        selectionBox.x = Math.min(currentX, selectionBox.startX) - selectionBox.containerOffsetX\n        selectionBox.y = Math.min(currentY, selectionBox.startY) - selectionBox.containerOffsetY\n    }\n\n    const startSelection = (event: MouseEvent) => {\n        if (!event.shiftKey) return\n        const { clientX, clientY } = event\n\n        // BUG-1067: Get canvas container offset for Tauri coordinate fix\n        // Use position: absolute relative to container instead of fixed to viewport\n        const canvasContainer = document.querySelector('.canvas-container')\n        if (canvasContainer) {\n            const rect = canvasContainer.getBoundingClientRect()\n            selectionBox.containerOffsetX = rect.left\n            selectionBox.containerOffsetY = rect.top\n        } else {\n            selectionBox.containerOffsetX = 0\n            selectionBox.containerOffsetY = 0\n        }\n\n        // Store viewport coordinates for intersection calculations\n        selectionBox.startX = clientX\n        selectionBox.startY = clientY\n        // Calculate position relative to container for rendering\n        selectionBox.x = clientX - selectionBox.containerOffsetX\n        selectionBox.y = clientY - selectionBox.containerOffsetY\n        selectionBox.width = 0\n        selectionBox.height = 0\n        selectionBox.isVisible = true\n        window.addEventListener('mousemove', updateSelection)\n        window.addEventListener('mouseup', endSelection)\n        event.preventDefault()\n        event.stopPropagation()\n    }\n\n    const endSelection = (_event: MouseEvent) => {\n        window.removeEventListener('mousemove', updateSelection)\n        window.removeEventListener('mouseup', endSelection)\n        if (!selectionBox.isVisible) return\n\n        const viewport = getViewportFromDOM()\n        const flowContainer = document.querySelector('.vue-flow__container') || document.querySelector('.canvas-container')\n        if (!flowContainer) return\n        const rect = flowContainer.getBoundingClientRect()\n\n        const involvedNodes = getNodes.value\n        const selectedIds: string[] = []\n        // BUG-1067: Convert container-relative coordinates back to viewport coordinates\n        // for intersection testing with node screen positions\n        const boxLeft = selectionBox.x + selectionBox.containerOffsetX\n        const boxTop = selectionBox.y + selectionBox.containerOffsetY\n        const boxRight = boxLeft + selectionBox.width\n        const boxBottom = boxTop + selectionBox.height\n\n        involvedNodes.forEach(node => {\n            const { x: graphX, y: graphY } = getAbsolutePositionRecursive(node, involvedNodes)\n            const graphW = Number(node.dimensions?.width ?? node.width ?? 200)\n            const graphH = Number(node.dimensions?.height ?? node.height ?? 100)\n            const screenX = (graphX * viewport.zoom) + viewport.x + rect.left\n            const screenY = (graphY * viewport.zoom) + viewport.y + rect.top\n            const screenW = graphW * viewport.zoom\n            const screenH = graphH * viewport.zoom\n\n            if (node.type === 'sectionNode') {\n                const isFullyContained = (\n                    screenX >= boxLeft && (screenX + screenW) <= boxRight &&\n                    screenY >= boxTop && (screenY + screenH) <= boxBottom\n                )\n                if (isFullyContained) selectedIds.push(node.id)\n                return\n            }\n\n            const intersects = (\n                screenX < boxRight && (screenX + screenW) > boxLeft &&\n                screenY < boxBottom && (screenY + screenH) > boxTop\n            )\n            if (intersects) selectedIds.push(node.id)\n        })\n\n        if (selectedIds.length > 0) {\n            canvasStore.setSelectedNodes(selectedIds)\n            const selectionChanges = nodes.value.map(node => ({\n                id: node.id,\n                type: 'select' as const,\n                selected: selectedIds.includes(node.id)\n            }))\n            applyNodeChanges(selectionChanges)\n        }\n        selectionBox.isVisible = false\n    }\n\n    // --- RECURSIVE HELPERS FOR ABSOLUTE POSITIONS ---\n    const getAbsolutePositionRecursive = (node: Node, allNodes: Node[]): { x: number, y: number } => {\n        let x = node.position.x\n        let y = node.position.y\n        let parentId = node.parentNode\n        while (parentId) {\n            const parent = allNodes.find(n => n.id === parentId)\n            if (parent) {\n                x += parent.position.x\n                y += parent.position.y\n                parentId = parent.parentNode\n            } else break\n        }\n        return { x, y }\n    }\n\n    const getViewportFromDOM = (): { x: number, y: number, zoom: number } => {\n        const transformPane = document.querySelector('.vue-flow__transformationpane') as HTMLElement\n        if (!transformPane) return { x: 0, y: 0, zoom: 1 }\n        const transform = transformPane.style.transform\n        const match = transform.match(/translate\\(([-\\d.]+)px,\\s*([-\\d.]+)px\\)\\s*scale\\(([-\\d.]+)\\)/)\n        return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]), zoom: parseFloat(match[3]) } : { x: 0, y: 0, zoom: 1 }\n    }\n\n    // --- BUG-1295: POINTER-EVENTS BYPASS FOR MODIFIER+CLICK ---\n    // Vue Flow renders a `.vue-flow__nodesselection-rect` overlay with\n    // `pointer-events: all` that covers all selected nodes when 2+ are selected.\n    // This blocks ALL clicks from reaching individual nodes underneath.\n    //\n    // When Ctrl/Meta/Shift is held, we disable pointer-events on this overlay\n    // so clicks pass through to task nodes. The node-level handlers in\n    // useTaskNodeActions.ts (handlePointerDown, handleMouseDown, handleClick)\n    // then handle selection toggle with stopPropagation to prevent Vue Flow\n    // from also processing the event.\n    const setSelectionRectPointerEvents = (value: string) => {\n        const rects = document.querySelectorAll('.vue-flow__nodesselection-rect') as NodeListOf<HTMLElement>\n        rects.forEach(rect => { rect.style.pointerEvents = value })\n    }\n\n    const handleModifierKeyDown = (e: KeyboardEvent) => {\n        if (e.key === 'Control' || e.key === 'Meta' || e.key === 'Shift') {\n            setSelectionRectPointerEvents('none')\n        }\n    }\n\n    const handleModifierKeyUp = (e: KeyboardEvent) => {\n        if (e.key === 'Control' || e.key === 'Meta' || e.key === 'Shift') {\n            setSelectionRectPointerEvents('')\n        }\n    }\n\n    // Safety: restore pointer-events when window loses focus (e.g., Alt+Tab while holding Ctrl)\n    const handleWindowBlur = () => {\n        setSelectionRectPointerEvents('')\n    }\n\n    onMounted(() => {\n        window.addEventListener('keydown', handleModifierKeyDown)\n        window.addEventListener('keyup', handleModifierKeyUp)\n        window.addEventListener('blur', handleWindowBlur)\n    })\n\n    onUnmounted(() => {\n        window.removeEventListener('keydown', handleModifierKeyDown)\n        window.removeEventListener('keyup', handleModifierKeyUp)\n        window.removeEventListener('blur', handleWindowBlur)\n    })\n\n    return {\n        selectionBox,\n        selectedTask,\n        handleNodeClick,\n        handleSelectionChange,\n        handleTaskSelect,\n        clearSelection,\n        startSelection,\n        updateSelection,\n        endSelection\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4628,4631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4628,4631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11085,11088],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11085,11088],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":337,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16070,16073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16070,16073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":519,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":519,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26309,26312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26309,26312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":519,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":519,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26319,26322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26319,26322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":522,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":522,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26483,26486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26483,26486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":567,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":567,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28696,28699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28696,28699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":570,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":570,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28848,28851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28848,28851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":598,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":598,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30640,30643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30640,30643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":599,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":599,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30733,30736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30733,30736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":615,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":615,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31517,31520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31517,31520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":616,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":616,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31615,31618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31615,31618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":668,"column":97,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":668,"endColumn":100,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34639,34642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34639,34642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, nextTick } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useVueFlow } from '@vue-flow/core'\nimport {\n    sanitizePosition,\n    getGroupAbsolutePosition\n} from '@/utils/canvas/coordinates'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport { positionManager } from '@/services/canvas/PositionManager'\nimport { validateAllInvariants, assertNoDuplicateIds } from '@/utils/canvas/invariants'\nimport { CANVAS } from '@/constants/canvas'\nimport { isNodeCompletelyInside, DEFAULT_TASK_WIDTH, DEFAULT_TASK_HEIGHT } from '@/utils/canvas/spatialContainment'\n\n// =============================================================================\n// MODULE-LEVEL HELPERS (defined before composable to ensure availability)\n// =============================================================================\n\n/**\n * Interface for groups that can be sorted by hierarchy\n */\ninterface HierarchicalGroup {\n    id: string\n    parentGroupId?: string | null\n}\n\n/**\n * Sort groups by hierarchy depth (parents before children)\n * Ensures Vue Flow can resolve parentNode references correctly.\n *\n * Uses topological sort: root groups (no parent) first, then their children, etc.\n * This guarantees that when a child group is added, its parent already exists.\n *\n * @param groups - Array of groups with id and optional parentGroupId\n * @returns Sorted array with root groups first, then depth 1, depth 2, etc.\n */\nfunction sortGroupsByHierarchy<T extends HierarchicalGroup>(groups: T[]): Array<T & { _depth: number }> {\n    // Helper to get depth (0 = root, 1 = direct child of root, etc.)\n    const getDepth = (groupId: string, visited: Set<string> = new Set()): number => {\n        const group = groups.find(g => g.id === groupId)\n        if (!group) return 0\n        if (!group.parentGroupId || group.parentGroupId === 'NONE') return 0\n        if (visited.has(groupId)) return 0 // Cycle protection\n\n        visited.add(groupId)\n        return 1 + getDepth(group.parentGroupId, visited)\n    }\n\n    // Calculate depth for each group\n    const groupsWithDepth = groups.map(g => ({\n        ...g,\n        _depth: getDepth(g.id)\n    }))\n\n    // Sort by depth: root groups (depth 0) first, then children (depth 1), etc.\n    groupsWithDepth.sort((a, b) => a._depth - b._depth)\n\n    return groupsWithDepth\n}\n\n// =============================================================================\n// COMPOSABLE\n// =============================================================================\n\n// BUG-1061 FIX #5: Module-level sync flag (singleton)\n// This MUST be at module level so all useCanvasSync() callers share the same state.\n// When setNodes() is called during sync, Vue Flow may fire onNodeDragStop spuriously.\n// useCanvasInteractions checks this flag to skip processing during sync operations.\nconst canvasSyncInProgress = ref(false)\n\n// BUG-1203: Guard flag to prevent re-sync loop when writing back stale parentId corrections.\n// When true, the store update from reconciliation should not trigger another sync cycle.\nconst isWritingBackStaleParents = ref(false)\n\n// Export for useCanvasInteractions to check\nexport { canvasSyncInProgress, isWritingBackStaleParents }\n\n/**\n * Canvas Sync Composable\n *\n * ============================================================================\n * READ PATH: DB/Store → Vue Flow\n * ============================================================================\n *\n * This composable handles the READ PATH of the Fully Absolute Architecture:\n * - Reads absolute positions from store (which mirrors DB)\n * - Converts to relative positions for nested nodes (Vue Flow requirement)\n * - Creates Vue Flow nodes with correct position and parentNode\n *\n * KEY PRINCIPLE:\n * - DB/Store stores ABSOLUTE world coordinates for ALL nodes\n * - Vue Flow displays nested nodes with RELATIVE positions\n * - Conversion happens HERE using groupPositionToVueFlow/taskPositionToVueFlow\n */\nexport function useCanvasSync() {\n    const canvasStore = useCanvasStore()\n    const { nodeVersionMap, aggregatedTaskCountByGroupId, taskCountByGroupId } = storeToRefs(canvasStore)\n    const taskStore = useTaskStore()\n    const { getNodes, setNodes } = useVueFlow()\n\n    // Alias to module-level ref for backward compatibility\n    const isSyncing = canvasSyncInProgress\n\n    /**\n     * Helper to detect if assigning a parent would create a cycle\n     * Traces up the parent chain to ensure we don't point back to ourselves\n     */\n    const hasParentCycle = (nodeId: string, potentialParentId: string | null, groups: any[]): boolean => {\n        if (!potentialParentId) return false\n        if (nodeId === potentialParentId) return true // Self-reference\n\n        let currentId = potentialParentId\n        const visited = new Set<string>()\n\n        // Safety Break: max depth\n        let depth = 0\n        const MAX_DEPTH = 50\n\n        while (currentId && currentId !== 'NONE' && depth < MAX_DEPTH) {\n            if (currentId === nodeId) return true // Cycle detected!\n            if (visited.has(currentId)) return true // Circular chain found upstream\n\n            visited.add(currentId)\n\n            const parentGroup = groups.find(g => g.id === currentId)\n            if (!parentGroup) break // End of known chain\n\n            currentId = parentGroup.parentGroupId\n            depth++\n        }\n\n        return false\n    }\n\n    /**\n     * Sync store data to canvas nodes (READ PATH)\n     *\n     * =========================================================================\n     * GEOMETRY WRITE POLICY (TASK-240 Phase 2.5)\n     * =========================================================================\n     * Sync is a READ-ONLY projection from store → Vue Flow display.\n     *\n     * This function MUST NEVER write to:\n     *   - taskStore (task positions, parentId, any task data)\n     *   - canvasStore.groups (group positions, parentGroupId, any group data)\n     *\n     * ALLOWED writes:\n     *   - nodeVersionMap (optimistic locking metadata, not user data)\n     *   - Vue Flow nodes via setNodes() (display layer, not persistence)\n     *\n     * RATIONALE:\n     * Writing to stores from sync would create feedback loops:\n     *   Store changes → sync runs → sync writes to store → sync runs → ...\n     * This causes position drift and groups \"merging back together\".\n     *\n     * Only useCanvasInteractions.onNodeDragStop() may write geometry.\n     * =========================================================================\n     *\n     * READ PATH FLOW:\n     * 1. Read groups/tasks from store (absolute positions)\n     * 2. For each item, compute Vue Flow position:\n     *    - Root items: use absolute directly\n     *    - Nested items: convert absolute → relative using parent's absolute\n     * 3. Create Vue Flow nodes with correct position and parentNode\n     *\n     * BUG #3 FIX: Always use fresh store positions instead of preserving\n     * stale Vue Flow positions. This ensures cross-tab sync works correctly.\n     */\n    const syncStoreToCanvas = (tasks?: Task[]) => {\n        if (isSyncing.value) return\n        // BUG-1203: Skip re-sync triggered by stale parentId write-back.\n        // The write-back updates the task store, which fires watchers that call syncStoreToCanvas.\n        // Without this guard, we'd get an infinite loop: sync → detect stale → write-back → sync → ...\n        if (isWritingBackStaleParents.value) return\n        isSyncing.value = true\n\n        // BUG-1203: Collect stale parentId detections for deferred cleanup.\n        // Declared outside try so it's accessible in the post-sync cleanup below.\n        const staleParentCleanups: Array<{taskId: string, oldParentId: string}> = []\n\n        try {\n            // BUG-1176 FIX: Filter out done tasks when hideCanvasDoneTasks is enabled\n            // This prevents done tasks from appearing on canvas even if they have canvasPosition\n            const shouldHideDone = taskStore.hideCanvasDoneTasks\n            const tasksToSync = (tasks || taskStore.tasks)\n                .filter(t => t.canvasPosition)\n                .filter(t => !shouldHideDone || t.status !== 'done')\n            const groups = canvasStore.groups || []\n            const currentNodes = getNodes.value\n\n            // BUG-1084 FIX v2: Instead of skipping entire sync, we'll skip individual tasks\n            // whose parent groups haven't loaded yet. This allows root tasks to display\n            // immediately while deferring nested tasks until groups load.\n            // The actual skip logic is in the PROCESS TASKS section below.\n\n            // BUG #3 FIX: Removed existingPositions preservation\n            // Previously we preserved existing Vue Flow positions to \"avoid visual jumps\",\n            // but this caused stale positions to win over fresh store data on cross-tab sync.\n            // Now we ALWAYS use the fresh position from the store (source of truth).\n\n            // TASK-213: POSITION MANAGER INTEGRATION\n            // 1. Feed Store data into PositionManager via batchUpdate('remote-sync').\n            //    This ensures that if legal (no lock), PositionManager is updated.\n            //    If locked (user dragging), the update is ignored, preserving the drag.\n            const updates = []\n\n            // Collect Group Updates\n            for (const g of groups) {\n                if (g.position) {\n                    updates.push({\n                        id: g.id,\n                        x: g.position.x,\n                        y: g.position.y,\n                        parentId: (!g.parentGroupId || g.parentGroupId === 'NONE') ? null : g.parentGroupId\n                    })\n                }\n            }\n\n            // Collect Task Updates\n            for (const t of tasksToSync) {\n                if (t.canvasPosition) {\n                    updates.push({\n                        id: t.id,\n                        x: t.canvasPosition.x,\n                        y: t.canvasPosition.y,\n                        parentId: (!t.parentId || t.parentId === 'NONE') ? null : t.parentId\n                    })\n                }\n            }\n\n            if (import.meta.env.DEV) {\n                const taskUpdates = updates.filter(u => !groups.some(g => g.id === u.id))\n                if (taskUpdates.length > 0) {\n                    console.log('[CANVAS:SYNC] Feeding to PositionManager:', taskUpdates.slice(0, 3).map(u => ({\n                        id: u.id.slice(0, 8),\n                        x: Math.round(u.x),\n                        y: Math.round(u.y)\n                    })))\n                }\n            }\n\n            // Commit updates (locks will prevent overwrites of dragged items)\n            const batchResult = positionManager.batchUpdate(updates, 'remote-sync')\n            const rejectedIds = batchResult?.rejectedIds ?? []\n            if (rejectedIds.length > 0 && import.meta.env.DEV) {\n                console.log(`[CANVAS:SYNC] Deferred ${rejectedIds.length} locked nodes (will retry next sync)`)\n            }\n\n            const newNodes: any[] = []\n\n            // ================================================================\n            // PROCESS GROUPS\n            // ================================================================\n            // CRITICAL: Sort groups so that parent groups are processed before children.\n            // Vue Flow needs parent nodes to exist before children reference them via parentNode.\n            // This ensures correct parent-child relationships on initial render after reload.\n\n            // === ASSERT: No duplicate group IDs before node creation (AUTHORITATIVE) ===\n            // Uses assertNoDuplicateIds for consistent detection across layers\n            if (import.meta.env.DEV) {\n                const groupCheck = assertNoDuplicateIds(groups, 'groups input to syncStoreToCanvas')\n                if (groupCheck.hasDuplicates) {\n                    console.error('[ASSERT-FAILED] Duplicate groupIds in groups before node creation', {\n                        duplicates: groupCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                        totalCount: groupCheck.totalCount,\n                        uniqueIdCount: groupCheck.uniqueIdCount\n                    })\n                }\n            }\n\n            const sortedGroups = sortGroupsByHierarchy(groups)\n\n            // Create a Set of visible group IDs for fast lookup\n            const visibleGroupIds = new Set(groups.map(g => g.id))\n\n            for (const group of sortedGroups) {\n                const nodeId = CanvasIds.groupNodeId(group.id)\n\n                // TASK-213: Read from PositionManager (Authoritative Source)\n                const pmNode = positionManager.getPosition(group.id)\n\n                // BUG-1084 FIX v3: Actually implement the fallback to store when PM is empty\n                // This can happen on initial load before PM is populated, or if batchUpdate was rejected\n                let absolutePos: { x: number; y: number }\n                if (pmNode) {\n                    absolutePos = pmNode.position\n                } else if (group.position && typeof group.position.x === 'number' && typeof group.position.y === 'number') {\n                    absolutePos = { x: group.position.x, y: group.position.y }\n                    if (import.meta.env.DEV) {\n                        console.log(`[CANVAS:SYNC] Group ${group.id.slice(0, 8)} not in PM, using store position`)\n                    }\n                } else {\n                    console.warn(`[CANVAS:SYNC] Group ${group.id.slice(0, 8)} has no valid position, skipping`)\n                    continue\n                }\n                // BUG-1061 FIX: Read parentId from STORE (group), not PM\n                // Same fix as for tasks - PM updates can be rejected if locked\n                let parentId = (group.parentGroupId && group.parentGroupId !== 'NONE') ? group.parentGroupId : null\n\n                // Calculate Relative Position for Vue Flow\n                let vueFlowPos = absolutePos\n                // Only convert to relative if we have a valid, visible parent\n                if (parentId && visibleGroupIds.has(parentId)) {\n                    const relative = positionManager.getRelativePosition(group.id)\n                    if (relative) vueFlowPos = relative\n                }\n\n                const displayPos = sanitizePosition(vueFlowPos, { x: 100, y: 100 })\n\n                // SAFETY: Cycle Detection\n                if (parentId && hasParentCycle(group.id, parentId, groups)) {\n                    console.error(`🔄 [CYCLE DETECTED] Creating group ${group.id} would create cycle with parent ${parentId}. Breaking link.`)\n                    parentId = null\n                }\n\n                // FIX: Only set parentNode if parent is VISIBLE (will be rendered in Vue Flow)\n                // If parent exists but is hidden, treat as root node to avoid \"Only child nodes can use a parent extent\" warning\n                if (parentId && !visibleGroupIds.has(parentId)) {\n                    if (import.meta.env.DEV) {\n                        console.warn(`[CANVAS:SYNC] Parent group ${parentId} is hidden, treating ${group.id} as root node`)\n                    }\n                    parentId = null\n                }\n\n                // Get BOTH direct and aggregated task counts\n                // Direct = tasks where task.parentId === group.id (only this group)\n                // Aggregated = direct + all tasks in descendant groups\n                const directTaskCount = taskCountByGroupId.value.get(group.id) ?? 0\n                const aggregatedTaskCount = aggregatedTaskCountByGroupId.value.get(group.id) ?? directTaskCount\n\n                // Compute parentNode for hierarchy\n                const parentNodeId = parentId ? CanvasIds.groupNodeId(parentId) : undefined\n\n                // BUG-226 FIX: Apply depth-based zIndex bonus\n                // ensures child groups (higher depth) are always on top of parent groups\n                const depth = (group as any)._depth || 0\n                const zIndex = 11 + (depth * 10) // Base group Z is 10 (CANVAS.Z_INDEX_GROUP)\n\n                newNodes.push({\n                    id: nodeId,\n                    type: 'sectionNode',\n                    position: displayPos,\n                    parentNode: parentNodeId,\n                    zIndex, // Explicit zIndex bonus\n                    // FIX: Removed extent: 'parent' so groups can be dragged OUT of their parent.\n                    // With extent: 'parent', Vue Flow constrains movement to parent bounds,\n                    // preventing groups from being detached via drag. Without it, groups can be\n                    // freely dragged, and onNodeDragStop handles re-parenting via spatial containment.\n                    // (Same approach as tasks - see line ~284)\n                    expandParent: false,\n                    data: {\n                        id: group.id,\n                        label: group.name || 'Group',\n                        name: group.name || 'Group',\n                        color: group.color || '#3b82f6',\n                        width: group.position?.width || CANVAS.DEFAULT_GROUP_WIDTH,\n                        height: group.position?.height || CANVAS.DEFAULT_GROUP_HEIGHT,\n                        collapsed: group.isCollapsed || false,\n                        // Pass BOTH counts - component decides which to show\n                        directTaskCount,\n                        aggregatedTaskCount,\n                        // Pass STORE's parentGroupId (not Vue Flow's parentId) so component\n                        // correctly determines if it's a root or child group for count logic\n                        parentGroupId: group.parentGroupId,\n                        // Legacy: keep taskCount for backwards compat (use aggregated)\n                        taskCount: aggregatedTaskCount\n                    },\n                    style: {\n                        width: `${group.position?.width || CANVAS.DEFAULT_GROUP_WIDTH}px`,\n                        height: `${group.position?.height || CANVAS.DEFAULT_GROUP_HEIGHT}px`\n                    }\n                })\n            }\n\n            // ================================================================\n            // PROCESS TASKS\n            // ================================================================\n            // Initialize task position versions in nodeVersionMap for optimistic locking\n            // This ensures syncNodePosition has version info when saving positions\n\n            // Defensive: ensure nodeVersionMap.value is a valid Map\n            if (!nodeVersionMap.value || !(nodeVersionMap.value instanceof Map)) {\n                nodeVersionMap.value = new Map()\n            }\n            const versionMap = nodeVersionMap.value\n\n            for (const task of tasksToSync) {\n                if (!task.canvasPosition) continue\n\n                // Initialize version if not already tracked\n                if (!versionMap.has(task.id)) {\n                    versionMap.set(task.id, task.positionVersion ?? 0)\n                }\n\n                const nodeId = task.id\n\n                // TASK-213: Read from PositionManager (Authoritative Source)\n                const pmNode = positionManager.getPosition(task.id)\n\n                // BUG-1084 FIX v3: Actually implement fallback to store when PM is empty\n                let absolutePos: { x: number; y: number }\n                if (pmNode) {\n                    absolutePos = pmNode.position\n                } else if (task.canvasPosition) {\n                    absolutePos = { x: task.canvasPosition.x, y: task.canvasPosition.y }\n                    if (import.meta.env.DEV) {\n                        console.log(`[CANVAS:SYNC] Task ${task.id.slice(0, 8)} not in PM, using store position`)\n                    }\n                } else {\n                    continue // Already checked canvasPosition at loop start, but safety first\n                }\n\n                // BUG-1061 FIX: Read parentId from STORE, not PM\n                // PM updates can be rejected if node is locked (user dragging).\n                // This causes PM to have stale parentId while store has correct one.\n                // Store is always updated by realtime sync, so it's the source of truth for parentId.\n                // PM is only authoritative for x/y position during drag operations.\n                let parentId = (task.parentId && task.parentId !== 'NONE') ? task.parentId : null\n\n                // BUG-1191 FIX: Validate parentId spatially before using it\n                // Tasks with stale parentId (pointing to group they're outside of) would be dragged with wrong group\n                if (parentId) {\n                    const parentGroup = groups.find(g => g.id === parentId)\n                    if (parentGroup) {\n                        const parentAbsolutePos = getGroupAbsolutePosition(parentId, groups)\n                        const parentBounds = {\n                            position: parentAbsolutePos,\n                            width: parentGroup.position.width,\n                            height: parentGroup.position.height\n                        }\n                        const taskSpatial = {\n                            position: absolutePos,\n                            width: DEFAULT_TASK_WIDTH,\n                            height: DEFAULT_TASK_HEIGHT\n                        }\n                        // Use 0 padding to be permissive (only check center containment)\n                        if (!isNodeCompletelyInside(taskSpatial, parentBounds, 0)) {\n                            if (import.meta.env.DEV) {\n                                if (import.meta.env.DEV) {\n                                console.warn(`[BUG-1203] Task \"${task.title?.slice(0, 25)}\" has stale parentId ${parentId.slice(0, 8)} - not spatially inside. Clearing.`)\n                            }\n                            }\n                            // BUG-1203: Queue deferred store cleanup to eliminate split-brain\n                            staleParentCleanups.push({ taskId: task.id, oldParentId: parentId })\n                            parentId = null\n                        }\n                    } else {\n                        // Parent group doesn't exist - clear parentId\n                        if (import.meta.env.DEV) {\n                            if (import.meta.env.DEV) {\n                            console.warn(`[BUG-1203] Task \"${task.title?.slice(0, 25)}\" parentId ${parentId.slice(0, 8)} not found. Clearing.`)\n                        }\n                        }\n                        // BUG-1203: Queue deferred store cleanup\n                        staleParentCleanups.push({ taskId: task.id, oldParentId: parentId })\n                        parentId = null\n                    }\n                }\n\n                // Calculate Relative Position for Vue Flow\n                let vueFlowPos = absolutePos\n                // TASK-1289: Only convert to relative if parent is both visible AND in PositionManager\n                // (prevents double-offset when PM hasn't ingested parent group yet)\n                if (parentId && visibleGroupIds.has(parentId)) {\n                    const parentInPM = positionManager.getPosition(parentId)\n                    if (parentInPM) {\n                        const relative = positionManager.getRelativePosition(task.id)\n                        if (relative) vueFlowPos = relative\n                    }\n                }\n\n                const displayPos = sanitizePosition(vueFlowPos, { x: 200, y: 200 })\n\n                // SAFETY: Cycle Detection\n                if (parentId && hasParentCycle(task.id, parentId, groups)) {\n                    console.error(`🔄 [CYCLE DETECTED] Creating task ${task.id} would create cycle with parent ${parentId}. Breaking link.`)\n                    parentId = null\n                }\n\n                // BUG-1084 FIX v2: SKIP tasks whose parent group isn't loaded yet\n                // Instead of treating as root (which causes JUMP when parent loads),\n                // we defer rendering until parent group is available. The watcher on\n                // groups.length will trigger another sync when groups load.\n                if (parentId && !visibleGroupIds.has(parentId)) {\n                    if (import.meta.env.DEV) {\n                        console.log(`[CANVAS:SYNC] Task ${task.id.slice(0, 8)}... (${task.title?.slice(0, 20)}) deferred - parent ${parentId?.slice(0, 8)} not loaded yet`, {\n                            visibleGroupCount: visibleGroupIds.size\n                        })\n                    }\n                    continue // Skip this task, will be synced when parent loads\n                }\n\n                newNodes.push({\n                    id: nodeId,\n                    type: 'taskNode',\n                    position: displayPos,\n                    parentNode: parentId ? CanvasIds.groupNodeId(parentId) : undefined,\n                    // FIX: Removed extent: 'parent' so tasks can be dragged OUT of groups.\n                    // With extent: 'parent', Vue Flow constrains movement to parent bounds,\n                    // preventing tasks from being dragged outside. Without it, tasks can be\n                    // freely dragged, and onNodeDragStop handles re-parenting via spatial containment.\n                    expandParent: false,\n                    data: {\n                        // BUG-FIX: Shallow clone task to break reference equality.\n                        // Without this, idempotence check compares same object (old === new),\n                        // causing sync to skip setNodes() even when task properties changed.\n                        task: { ...task },\n                        label: task.title\n                    }\n                })\n            }\n\n            // ================================================================\n            // IDEMPOTENCE CHECK\n            // ================================================================\n            // Prevent recursive updates if generated nodes match existing nodes\n            // We compare essential properties: id, position, parentNode, data (height/width)\n            const isDifferent = (a: any[], b: any[]) => {\n                if (a.length !== b.length) return true\n                // Create a map for faster lookup\n                const bMap = new Map(b.map((n: any) => [n.id, n]))\n\n                for (const nodeA of a) {\n                    const nodeB = bMap.get(nodeA.id)\n                    if (!nodeB) return true\n\n                    // Check Position - small threshold to detect intentional position changes\n                    if (Math.abs(nodeA.position.x - nodeB.position.x) > 0.1 ||\n                        Math.abs(nodeA.position.y - nodeB.position.y) > 0.1) return true\n\n                    // Check Parent\n                    if (nodeA.parentNode !== nodeB.parentNode) return true\n\n                    // Check Dimensions (for groups)\n                    if (nodeA.data?.width !== nodeB.data?.width ||\n                        nodeA.data?.height !== nodeB.data?.height) return true\n\n                    // TASK-DATA REACTION: Check critical task properties\n                    // If these change, we MUST update the node even if position is same\n                    if (nodeA.type === 'taskNode' && nodeB.type === 'taskNode') {\n                        const taskA = nodeA.data?.task\n                        const taskB = nodeB.data?.task\n\n                        if (taskA && taskB) {\n                            if (taskA.status !== taskB.status) return true\n                            if (taskA.priority !== taskB.priority) return true\n                            if (taskA.dueDate !== taskB.dueDate) return true\n                            if (taskA.title !== taskB.title) return true\n                        }\n                    }\n\n                    // GROUP-DATA REACTION: Check group labels/colors\n                    if (nodeA.type === 'sectionNode' && nodeB.type === 'sectionNode') {\n                        if (nodeA.data?.label !== nodeB.data?.label ||\n                            nodeA.data?.color !== nodeB.data?.color ||\n                            nodeA.data?.collapsed !== nodeB.data?.collapsed) return true\n                    }\n                }\n\n                return false\n            }\n\n            if (isDifferent(newNodes, currentNodes)) {\n                if (import.meta.env.DEV) {\n                    const taskNodesOld = currentNodes.filter(n => n.type === 'taskNode')\n                    const taskNodesNew = newNodes.filter((n: any) => n.type === 'taskNode')\n\n                    for (const newNode of taskNodesNew) {\n                        const oldNode = taskNodesOld.find((o: any) => o.id === newNode.id)\n                        if (oldNode && oldNode.parentNode !== newNode.parentNode) {\n                            console.warn(`[CANVAS:SYNC] Task ${newNode.id.slice(0, 8)}... parentNode: \"${oldNode.parentNode ?? 'root'}\" → \"${newNode.parentNode ?? 'root'}\"`, {\n                                taskTitle: newNode.data?.label?.slice(0, 20),\n                                oldPosition: oldNode.position,\n                                newPosition: newNode.position\n                            })\n                        }\n                    }\n                }\n\n                // ================================================================\n                // DUPLICATE DETECTION - Node Builder Layer (AUTHORITATIVE)\n                // ================================================================\n                // Uses assertNoDuplicateIds for consistent detection across layers\n                // This is the final checkpoint before nodes are rendered\n                if (import.meta.env.DEV) {\n                    // 1. Check tasksToSync for duplicates (upstream issue)\n                    const taskSyncCheck = assertNoDuplicateIds(tasksToSync, 'tasksToSync')\n                    if (taskSyncCheck.hasDuplicates) {\n                        console.error('[ASSERT-FAILED] Duplicate taskIds in tasksToSync before node creation', {\n                            duplicates: taskSyncCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                            totalCount: taskSyncCheck.totalCount,\n                            uniqueIdCount: taskSyncCheck.uniqueIdCount\n                        })\n                    }\n\n                    // 2. Check task nodes for duplicates\n                    const taskNodes = newNodes.filter((n: any) => n.type === 'taskNode')\n                    const taskNodeObjects = taskNodes.map((n: any) => ({\n                        id: n.data?.task?.id || n.id\n                    }))\n                    const taskNodeCheck = assertNoDuplicateIds(taskNodeObjects, 'taskNodes')\n\n                    if (taskNodeCheck.hasDuplicates) {\n                        console.error('[DUPLICATE-NODES]', {\n                            duplicates: taskNodeCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                            totalTaskNodes: taskNodeCheck.totalCount,\n                            uniqueTaskIds: taskNodeCheck.uniqueIdCount,\n                            source: 'syncStoreToCanvas'\n                        })\n                    }\n\n\n                    // 3. Check group nodes for duplicates\n                    const groupNodes = newNodes.filter((n: any) => n.type === 'sectionNode')\n                    const groupNodeObjects = groupNodes.map((n: any) => ({\n                        id: n.data?.id || n.id\n                    }))\n                    const groupNodeCheck = assertNoDuplicateIds(groupNodeObjects, 'groupNodes')\n\n                    if (groupNodeCheck.hasDuplicates) {\n                        console.error('[DUPLICATE-GROUP-NODES]', {\n                            duplicates: groupNodeCheck.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n                            totalGroupNodes: groupNodeCheck.totalCount,\n                            uniqueGroupIds: groupNodeCheck.uniqueIdCount,\n                            source: 'syncStoreToCanvas'\n                        })\n                    }\n\n\n                    // ================================================================\n                    // GEOMETRY DRIFT DETECTION - Compare store positions vs node positions\n                    // ================================================================\n                    // This catches drift at the moment nodes are about to be rendered.\n                    // For root nodes (no parent), store position should equal node position.\n                    // Any mismatch indicates position drift from an unexpected source.\n                    const DRIFT_EPSILON = 0.5\n\n                    // Check task nodes for drift\n                    for (const taskNode of taskNodes) {\n                        const task = taskNode.data?.task\n                        if (!task?.canvasPosition) continue\n\n                        const storeAbsolute = task.canvasPosition\n                        const nodePosition = taskNode.position\n                        const hasParent = task.parentId && task.parentId !== 'NONE'\n\n                        // For root tasks, store position should match node position directly\n                        if (!hasParent) {\n                            const dx = Math.abs((storeAbsolute.x ?? 0) - (nodePosition?.x ?? 0))\n                            const dy = Math.abs((storeAbsolute.y ?? 0) - (nodePosition?.y ?? 0))\n                            if (dx > DRIFT_EPSILON || dy > DRIFT_EPSILON) {\n                                console.warn('[CANVAS:SYNC] Geometry drift detected', {\n                                    type: 'task',\n                                    id: task.id?.slice(0, 8),\n                                    title: task.title?.slice(0, 20),\n                                    parentId: task.parentId,\n                                    storePosition: { x: storeAbsolute.x, y: storeAbsolute.y },\n                                    nodePosition: { x: nodePosition?.x, y: nodePosition?.y },\n                                    delta: { x: dx.toFixed(1), y: dy.toFixed(1) }\n                                })\n                            }\n                        }\n                    }\n\n                    // Check group nodes for drift\n                    for (const groupNode of groupNodes) {\n                        const group = groupNode.data?.group || canvasStore._rawGroups?.find((g: any) => g.id === groupNode.data?.id)\n                        if (!group?.position) continue\n\n                        const storeAbsolute = group.position\n                        const nodePosition = groupNode.position\n                        const hasParent = group.parentGroupId && group.parentGroupId !== 'NONE'\n\n                        // For root groups, store position should match node position directly\n                        if (!hasParent) {\n                            const dx = Math.abs((storeAbsolute.x ?? 0) - (nodePosition?.x ?? 0))\n                            const dy = Math.abs((storeAbsolute.y ?? 0) - (nodePosition?.y ?? 0))\n                            if (dx > DRIFT_EPSILON || dy > DRIFT_EPSILON) {\n                                console.warn('[CANVAS:SYNC] Geometry drift detected', {\n                                    type: 'group',\n                                    id: group.id?.slice(0, 8),\n                                    name: group.name?.slice(0, 20),\n                                    parentGroupId: group.parentGroupId,\n                                    storePosition: { x: storeAbsolute.x, y: storeAbsolute.y },\n                                    nodePosition: { x: nodePosition?.x, y: nodePosition?.y },\n                                    delta: { x: dx.toFixed(1), y: dy.toFixed(1) }\n                                })\n                            }\n                        }\n                    }\n                }\n\n\n                // BUG-1062 FIX: Preserve selection state from canvasStore.selectedNodeIds\n                // When setNodes() replaces all nodes, the `selected` property is lost.\n                // We must restore it from the store before calling setNodes().\n                const selectedIds = canvasStore.selectedNodeIds\n                if (selectedIds.length > 0) {\n                    for (const node of newNodes) {\n                        node.selected = selectedIds.includes(node.id)\n                    }\n                }\n\n                setNodes(newNodes)\n\n                // ================================================================\n                // INVARIANT VALIDATION (Dev Only)\n                // ================================================================\n                // Run invariant checks after sync to catch any violations early\n                // This helps identify bugs before they cause visual issues\n                if (import.meta.env.DEV) {\n                    // Use nextTick to ensure Vue Flow has processed the nodes\n                    nextTick(() => {\n                        const vueFlowNodes = getNodes.value\n                        const storeGroups = canvasStore._rawGroups || []\n                        const storeTasks = taskStore.tasks || []\n\n                        validateAllInvariants(\n                            vueFlowNodes,\n                            storeGroups,\n                            storeTasks,\n                            'syncStoreToCanvas'\n                        )\n\n                        // ================================================================\n                        // CHILD→ROOT INVARIANT CHECK\n                        // ================================================================\n                        // Verify: If a group has no parentGroupId in store,\n                        // its Vue Flow node must NOT have parentNode set.\n                        // This catches bugs where detach logic fails to clear parentNode.\n                        const nodeMap = new Map(vueFlowNodes.map(n => [n.id, n]))\n                        for (const group of storeGroups) {\n                            const nodeId = CanvasIds.groupNodeId(group.id)\n                            const node = nodeMap.get(nodeId)\n                            const hasStoreParent = group.parentGroupId && group.parentGroupId !== 'NONE'\n\n                            if (!hasStoreParent && node?.parentNode) {\n                                console.error('[INVARIANT A-child-root] Group has no parentGroupId but node.parentNode is set', {\n                                    groupId: group.id,\n                                    groupName: group.name,\n                                    storeParentGroupId: group.parentGroupId,\n                                    nodeParentNode: node.parentNode,\n                                })\n                            }\n                        }\n                    })\n                }\n            }\n        } finally {\n            isSyncing.value = false\n        }\n\n        // BUG-1203: Deferred write-back for stale parentId corrections.\n        // This is an explicit exception to the read-only invariant (TASK-255) for\n        // corruption repair only. Without write-back, stale parentIds persist forever\n        // if the task is never manually dragged.\n        //\n        // Guard: isWritingBackStaleParents prevents re-sync loop. The orchestrator\n        // watches the task store, so updating parentId would trigger another sync.\n        // The guard causes syncStoreToCanvas to early-return during write-back.\n        if (staleParentCleanups.length > 0 && !isWritingBackStaleParents.value) {\n            if (import.meta.env.DEV) {\n                for (const { taskId, oldParentId } of staleParentCleanups) {\n                    console.warn(`[BUG-1203] Stale parentId detected: task ${taskId.slice(0, 8)}... had parentId ${oldParentId.slice(0, 8)} but is outside group bounds. Writing back correction.`)\n                }\n            }\n\n            // Defer until after current sync completes and Vue has flushed\n            nextTick(() => {\n                isWritingBackStaleParents.value = true\n                const writePromises = staleParentCleanups.map(({ taskId }) =>\n                    taskStore.updateTask(taskId, { parentId: undefined }, 'RECONCILE')\n                )\n                Promise.all(writePromises)\n                    .catch(err => {\n                        console.error('[BUG-1203] Failed to write back stale parentId corrections:', err)\n                    })\n                    .finally(() => {\n                        isWritingBackStaleParents.value = false\n                    })\n            })\n        }\n    }\n\n    /**\n     * Initialize realtime subscription for store changes\n     * Note: Watchers are handled by useCanvasOrchestrator to avoid duplicate triggers\n     */\n    const initRealtimeSubscription = () => {\n        // No-op: Orchestrator handles watching to avoid infinite loops\n        // The orchestrator calls syncStoreToCanvas directly when stores change\n    }\n\n    return {\n        syncStoreToCanvas,\n        initRealtimeSubscription,\n        isSyncing\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasTaskActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[885,888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[885,888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3031,3034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3031,3034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'gridWidth' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":378,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":378,"endColumn":24},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":612,"column":46,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":612,"endColumn":63,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[25718,25719],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref, nextTick } from 'vue'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useCanvasModalsStore } from '@/stores/canvas/modals'\nimport { markGroupDeleted, confirmGroupDeleted } from '@/utils/deletedGroupsTracker'\nimport { storeToRefs } from 'pinia'\nimport { CanvasIds } from '@/utils/canvas/canvasIds'\nimport { CANVAS } from '@/constants/canvas'\nimport { useToast } from '@/composables/useToast'\nimport { positionManager } from '@/services/canvas/PositionManager'\n\n\n\nexport interface TaskActionsDeps {\n    syncNodes: (tasks?: Task[]) => void\n    batchSyncNodes?: (priority?: 'high' | 'normal' | 'low') => void\n    closeCanvasContextMenu: () => void\n    screenToFlowCoordinate: (position: { x: number; y: number }) => { x: number; y: number }\n    recentlyDeletedGroups?: Ref<Set<string>>\n    undoHistory: any\n    fitView?: (options?: { padding?: number; duration?: number; nodes?: string[] }) => void\n}\n\nexport function useCanvasTaskActions(deps: TaskActionsDeps) {\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const modalsStore = useCanvasModalsStore()\n    const { undoHistory } = deps\n\n    const {\n        isBulkDeleteModalOpen,\n        bulkDeleteItems,\n        bulkDeleteIsPermanent,\n        isQuickTaskCreateOpen,\n        quickTaskPosition\n    } = storeToRefs(modalsStore)\n\n    const removeGhostNodeRef = (id: string) => {\n        if (canvasStore.nodes) {\n            const nodeId = CanvasIds.groupNodeId(id)\n            canvasStore.nodes = canvasStore.nodes.filter(n => n.id !== nodeId)\n        }\n    }\n\n    const createTaskHere = (screenPos?: { x: number; y: number }) => {\n        try {\n            const vueFlowElement = document.querySelector('.vue-flow')\n            if (!vueFlowElement) {\n                quickTaskPosition.value = { x: 0, y: 0 }\n                deps.closeCanvasContextMenu()\n                isQuickTaskCreateOpen.value = true\n                return\n            }\n\n            let finalPos = screenPos\n            if (!finalPos) {\n                const rect = vueFlowElement.getBoundingClientRect()\n                finalPos = {\n                    x: rect.left + rect.width / 2,\n                    y: rect.top + rect.height / 2\n                }\n            }\n\n            const flowCoords = deps.screenToFlowCoordinate(finalPos)\n            if (!Number.isFinite(flowCoords.x) || !Number.isFinite(flowCoords.y)) {\n                quickTaskPosition.value = { x: 200, y: 200 }\n                deps.closeCanvasContextMenu()\n                isQuickTaskCreateOpen.value = true\n                return\n            }\n\n            quickTaskPosition.value = flowCoords\n            deps.closeCanvasContextMenu()\n            isQuickTaskCreateOpen.value = true\n\n        } catch (_error) {\n            quickTaskPosition.value = { x: 0, y: 0 }\n            deps.closeCanvasContextMenu()\n            isQuickTaskCreateOpen.value = true\n        }\n    }\n\n    const createTaskInGroup = (groupOrId: string | any, screenPos?: { x: number; y: number }) => {\n        const groupId = typeof groupOrId === 'string' ? groupOrId : groupOrId.id\n        const group = canvasStore._rawGroups.find(g => g.id === groupId)\n\n        if (!group) return\n\n        // Group's canvas position (for clamping only)\n        const groupX = group.position?.x || 0\n        const groupY = group.position?.y || 0\n        const groupWidth = group.position?.width || CANVAS.DEFAULT_GROUP_WIDTH\n        const groupHeight = group.position?.height || CANVAS.DEFAULT_GROUP_HEIGHT\n\n        let absolutePos: { x: number; y: number }\n\n        if (screenPos) {\n            // Convert screen position to flow coordinates\n            // CRITICAL: canvasPosition stores ABSOLUTE coordinates, not relative!\n            // The node builder handles conversion to relative for Vue Flow\n            const flowCoords = deps.screenToFlowCoordinate(screenPos)\n\n            // Store ABSOLUTE position (centered on click point)\n            // Node builder will convert to relative when building Vue Flow nodes\n            absolutePos = {\n                x: flowCoords.x - (CANVAS.DEFAULT_TASK_WIDTH / 2),\n                y: flowCoords.y - (CANVAS.DEFAULT_TASK_HEIGHT / 2)\n            }\n\n            // Clamp to group bounds (absolute coordinates)\n            const padding = 10\n            const minX = groupX + padding\n            const maxX = groupX + groupWidth - CANVAS.DEFAULT_TASK_WIDTH - padding\n            const minY = groupY + padding + 40 // +40 for header\n            const maxY = groupY + groupHeight - CANVAS.DEFAULT_TASK_HEIGHT - padding\n\n            absolutePos.x = Math.max(minX, Math.min(absolutePos.x, maxX))\n            absolutePos.y = Math.max(minY, Math.min(absolutePos.y, maxY))\n        } else {\n            // Fallback: center of group (absolute coordinates)\n            absolutePos = {\n                x: groupX + (groupWidth / 2) - (CANVAS.DEFAULT_TASK_WIDTH / 2),\n                y: groupY + (groupHeight / 2) - (CANVAS.DEFAULT_TASK_HEIGHT / 2)\n            }\n        }\n\n        const finalPosition = {\n            ...absolutePos,\n            parentId: group.id\n        }\n\n        quickTaskPosition.value = finalPosition\n        deps.closeCanvasContextMenu()\n        isQuickTaskCreateOpen.value = true\n    }\n\n    /**\n     * GEOMETRY WRITER: Creates task with initial canvas position (TASK-255)\n     * This is an ALLOWED geometry write as it's an explicit user action (creating a task).\n     */\n    interface QuickTaskData {\n        title: string\n        description: string\n        status?: string\n        priority?: 'low' | 'medium' | 'high'\n        dueDate?: string\n        projectId?: string\n    }\n\n    const handleQuickTaskCreate = async (data: QuickTaskData) => {\n        try {\n            if (!data.title?.trim()) return\n\n            const isDefaultPosition = quickTaskPosition.value.x === 0 && quickTaskPosition.value.y === 0\n            const shouldCreateInInbox = isDefaultPosition\n\n            const { x, y, parentId, parentTaskId } = quickTaskPosition.value\n\n            await taskStore.createTaskWithUndo({\n                title: data.title,\n                description: data.description,\n                canvasPosition: shouldCreateInInbox ? undefined : { x, y },\n                parentId: shouldCreateInInbox ? undefined : parentId,\n                parentTaskId: shouldCreateInInbox ? undefined : parentTaskId,\n                status: (data.status as 'planned' | 'in_progress' | 'done') || 'planned',\n                priority: data.priority || 'medium',\n                dueDate: data.dueDate,\n                projectId: data.projectId,\n                isInInbox: shouldCreateInInbox\n            })\n\n            if (deps.batchSyncNodes) {\n                deps.batchSyncNodes('high')\n            } else {\n                deps.syncNodes()\n            }\n\n        } catch (error) {\n            console.error('Failed to create task', error)\n        } finally {\n            // Always close modal, even on error\n            isQuickTaskCreateOpen.value = false\n            quickTaskPosition.value = { x: 0, y: 0 }\n        }\n    }\n\n    const closeQuickTaskCreate = () => {\n        isQuickTaskCreateOpen.value = false\n        quickTaskPosition.value = { x: 0, y: 0 }\n    }\n\n    /**\n     * Creates a new task at the specified position, pre-connected to a parent task.\n     * Called when user drops a connection cable on empty canvas space.\n     */\n    const createConnectedTask = (position: { x: number; y: number }, parentTaskId: string) => {\n        // Center task on drop position\n        const centeredX = position.x - (CANVAS.DEFAULT_TASK_WIDTH / 2)\n        const centeredY = position.y - (CANVAS.DEFAULT_TASK_HEIGHT / 2)\n\n        // Store position with parent task connection info\n        quickTaskPosition.value = {\n            x: centeredX,\n            y: centeredY,\n            parentTaskId  // This will create the connection when task is created\n        }\n\n        deps.closeCanvasContextMenu()\n        isQuickTaskCreateOpen.value = true\n    }\n\n    /**\n     * GEOMETRY WRITER: Removes tasks from canvas by clearing canvasPosition (TASK-255)\n     * This is an ALLOWED geometry write as it's an explicit user action (move to inbox).\n     */\n    const moveSelectedTasksToInbox = async () => {\n        const selectedNodeIds = canvasStore.selectedNodeIds.filter(id => !CanvasIds.isGroupNode(id))\n        if (selectedNodeIds.length === 0) return\n\n        try {\n            for (const nodeId of selectedNodeIds) {\n                await undoHistory.updateTaskWithUndo(nodeId, {\n                    isInInbox: true,\n                    canvasPosition: undefined\n                })\n            }\n            canvasStore.setSelectedNodes([])\n            if (deps.batchSyncNodes) deps.batchSyncNodes('high')\n            deps.closeCanvasContextMenu()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] moveSelectedTasksToInbox failed', error)\n        }\n    }\n\n    /**\n     * \"Done for now\" - Moves selected tasks' due date to tomorrow with tracking badge.\n     * User can work incrementally and automatically reschedule unfinished tasks.\n     * Badge shows until user changes the due date to something else.\n     */\n    const doneForNowSelectedTasks = async () => {\n        const { showToast } = useToast()\n        const selectedNodeIds = canvasStore.selectedNodeIds.filter(id => !CanvasIds.isGroupNode(id))\n        if (selectedNodeIds.length === 0) return\n\n        // Calculate tomorrow's date in YYYY-MM-DD format\n        const tomorrow = new Date()\n        tomorrow.setDate(tomorrow.getDate() + 1)\n        const tomorrowStr = tomorrow.toISOString().split('T')[0]\n\n        try {\n            for (const nodeId of selectedNodeIds) {\n                // Set both dueDate and doneForNowUntil to track the badge\n                await undoHistory.updateTaskWithUndo(nodeId, {\n                    dueDate: tomorrowStr,\n                    doneForNowUntil: tomorrowStr\n                })\n            }\n\n            // Show toast notification\n            const msg = selectedNodeIds.length === 1\n                ? 'Moved to tomorrow'\n                : `${selectedNodeIds.length} tasks moved to tomorrow`\n            showToast(msg, 'success', { duration: 2000 })\n\n            deps.closeCanvasContextMenu()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] doneForNowSelectedTasks failed', error)\n            showToast('Failed to reschedule tasks', 'error')\n        }\n    }\n\n    const deleteSelectedTasks = async () => {\n        const selectedNodeIds = canvasStore.selectedNodeIds.filter(id => !CanvasIds.isGroupNode(id))\n        if (selectedNodeIds.length === 0) return\n\n        if (!confirm('Delete selected tasks permanently?')) return\n\n        try {\n            for (const nodeId of selectedNodeIds) {\n                await undoHistory.deleteTaskWithUndo(nodeId)\n            }\n\n            canvasStore.setSelectedNodes([])\n            if (deps.batchSyncNodes) deps.batchSyncNodes('high')\n            deps.closeCanvasContextMenu()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] deleteSelectedTasks failed', error)\n        }\n    }\n\n    const confirmBulkDelete = async () => {\n        const items = bulkDeleteItems.value\n        const isPermanent = bulkDeleteIsPermanent.value\n\n        try {\n            for (const item of items) {\n                if (item.type === 'section') {\n                    markGroupDeleted(item.id)\n                    if (deps.recentlyDeletedGroups) deps.recentlyDeletedGroups.value.add(item.id)\n\n                    if (!canvasStore.sections.some(s => s.id === item.id)) {\n                        removeGhostNodeRef(item.id)\n                        confirmGroupDeleted(item.id)\n                        deps.recentlyDeletedGroups?.value.delete(item.id)\n                    } else {\n                        await canvasStore.deleteSection(item.id)\n                        confirmGroupDeleted(item.id)\n                        deps.recentlyDeletedGroups?.value.delete(item.id)\n                    }\n                } else if (isPermanent) {\n                    await undoHistory.permanentlyDeleteTaskWithUndo(item.id)\n                } else {\n                    await undoHistory.updateTaskWithUndo(item.id, {\n                        canvasPosition: undefined,\n                        isInInbox: true,\n                        instances: [],\n                        scheduledDate: undefined,\n                        scheduledTime: undefined\n                    })\n                }\n            }\n\n            canvasStore.setSelectedNodes([])\n            bulkDeleteItems.value = []\n            isBulkDeleteModalOpen.value = false\n            await nextTick()\n            deps.syncNodes()\n        } catch (error) {\n            console.error('[ASYNC-ERROR] confirmBulkDelete failed', error)\n        }\n    }\n\n    const cancelBulkDelete = () => {\n        bulkDeleteItems.value = []\n        isBulkDeleteModalOpen.value = false\n    }\n\n    /**\n     * GEOMETRY WRITER: Arranges all done tasks in a grid LEFT of all existing content (TASK-255)\n     * This is an ALLOWED geometry write as it's an explicit user action.\n     *\n     * Dynamically calculates position based on existing content to avoid overlap.\n     * Creates a \"Done Tasks\" group around the arranged tasks for easy navigation.\n     */\n    const arrangeDoneTasksInGrid = async () => {\n        console.log('[ARRANGE-DONE] Starting arrangement...')\n\n        // Step 0: Ensure done tasks are visible FIRST (before filtering)\n        // This must happen before we collect doneTasks, otherwise they might be filtered out\n        if (taskStore.hideCanvasDoneTasks) {\n            taskStore.toggleCanvasDoneTasks()\n            console.log(`[ARRANGE-DONE] Enabled showing done tasks on canvas`)\n            // Wait for reactivity to propagate\n            await new Promise(resolve => setTimeout(resolve, 50))\n        }\n\n        // Find all done tasks that have a canvas position\n        const doneTasks = taskStore.tasks.filter(\n            (t) => t.status === 'done' && t.canvasPosition\n        )\n\n        console.log(`[ARRANGE-DONE] Found ${doneTasks.length} done tasks with canvas positions`)\n\n        if (doneTasks.length === 0) {\n            console.log('[ARRANGE-DONE] No done tasks with canvas positions to arrange')\n            return\n        }\n\n        console.log(`[ARRANGE-DONE] Arranging ${doneTasks.length} done tasks in grid`)\n\n        // Grid configuration - BUG-1020: Fixed card dimensions to match actual TaskNode.vue\n        // TaskNode.vue: width=280px (min 200, max 320), min-height=80px but content makes it ~140-160px\n        const cardWidth = 300  // TaskNode is 280px wide, add buffer\n        const cardHeight = 180 // TaskNode with content (title, date, badges) is ~140-160px, add buffer\n        const gapX = 80        // Horizontal gap between columns\n        const gapY = 50        // Vertical gap between rows\n        const columns = 4      // Reduced columns since cards are wider\n        const gridWidth = columns * (cardWidth + gapX)\n        const groupPadding = 40 // Padding inside the group\n        const groupHeaderHeight = 70 // Space for the group header\n\n        // Find the leftmost X position of all NON-DONE tasks and groups (excluding Done Tasks group)\n        const nonDoneTasks = taskStore.tasks.filter(\n            (t) => t.status !== 'done' && t.canvasPosition\n        )\n        const groups = canvasStore._rawGroups || []\n\n        let minX = 0 // Default if no content exists\n\n        // Check non-done tasks\n        for (const task of nonDoneTasks) {\n            if (task.canvasPosition && task.canvasPosition.x < minX) {\n                minX = task.canvasPosition.x\n            }\n        }\n\n        // Check groups (excluding existing Done Tasks group)\n        for (const group of groups) {\n            if (group.name !== '✅ Done Tasks' && group.position && group.position.x < minX) {\n                minX = group.position.x\n            }\n        }\n\n        // Calculate grid dimensions\n        const rows = Math.ceil(doneTasks.length / columns)\n        const actualColumns = Math.min(doneTasks.length, columns)\n        const gridActualWidth = actualColumns * (cardWidth + gapX) - gapX\n        const gridActualHeight = rows * (cardHeight + gapY) - gapY\n\n        // Group dimensions (with padding)\n        const groupWidth = gridActualWidth + (groupPadding * 2)\n        const groupHeight = gridActualHeight + groupHeaderHeight + (groupPadding * 2)\n\n        // Place grid FAR LEFT - minimum of calculated position or -5000\n        const calculatedX = minX - groupWidth - 500\n        const groupX = Math.min(calculatedX, -5000) // Ensure at least -5000\n        const groupY = 100 // Near top\n\n        // Task grid starts inside the group with padding and header offset\n        const startX = groupX + groupPadding\n        const startY = groupY + groupHeaderHeight + groupPadding\n\n        console.log(`[ARRANGE-DONE] Placing group at x=${groupX}, tasks start at x=${startX}`)\n\n        try {\n            // Step 1: Delete existing \"Done Tasks\" group if it exists (search by name pattern)\n            const existingDoneGroup = groups.find(g =>\n                g.name === '✅ Done Tasks' ||\n                g.name.toLowerCase().includes('done tasks') ||\n                g.name === 'Done'  // May be truncated in display\n            )\n            if (existingDoneGroup) {\n                console.log(`[ARRANGE-DONE] Removing existing Done Tasks group: ${existingDoneGroup.id}`)\n                try {\n                    await canvasStore.deleteSection(existingDoneGroup.id)\n                    // Wait for deletion to propagate\n                    await new Promise(resolve => setTimeout(resolve, 100))\n                } catch (deleteError) {\n                    console.warn(`[ARRANGE-DONE] Failed to delete existing group, continuing:`, deleteError)\n                }\n            }\n\n            // Step 2: Create the \"Done Tasks\" group\n            const newGroup = await canvasStore.createSection({\n                name: '✅ Done Tasks',\n                type: 'custom',\n                color: '#10b981', // Green\n                position: {\n                    x: groupX,\n                    y: groupY,\n                    width: groupWidth,\n                    height: groupHeight\n                },\n                layout: 'freeform',\n                isVisible: true,\n                isCollapsed: false\n            })\n\n            if (!newGroup || !newGroup.id) {\n                console.error('[ARRANGE-DONE] Failed to create Done Tasks group')\n                return\n            }\n\n            console.log(`[ARRANGE-DONE] Created Done Tasks group: ${newGroup.id}`)\n\n            // Step 2.5: Sync to ensure group node exists in Vue Flow before assigning tasks\n            deps.syncNodes()\n            await new Promise(resolve => setTimeout(resolve, 150))\n\n            // Step 3: Arrange tasks in grid and assign to group\n            console.log(`[ARRANGE-DONE] Updating ${doneTasks.length} tasks with parentId: ${newGroup.id}`)\n            let updatedCount = 0\n\n            for (let i = 0; i < doneTasks.length; i++) {\n                const task = doneTasks[i]\n                const col = i % columns\n                const row = Math.floor(i / columns)\n\n                const newX = startX + col * (cardWidth + gapX)\n                const newY = startY + row * (cardHeight + gapY)\n\n                try {\n                    await undoHistory.updateTaskWithUndo(task.id, {\n                        parentId: newGroup.id,\n                        canvasPosition: { x: newX, y: newY }\n                    })\n                    updatedCount++\n                } catch (taskError) {\n                    console.error(`[ARRANGE-DONE] Failed to update task ${task.id}:`, taskError)\n                }\n            }\n\n            console.log(`[ARRANGE-DONE] Updated ${updatedCount}/${doneTasks.length} tasks`)\n\n            // Step 4: Final sync to establish parent-child relationship in Vue Flow\n            deps.syncNodes()\n            await new Promise(resolve => setTimeout(resolve, 150))\n\n            // Step 5: Force a second sync for Vue Flow parent-child hierarchy\n            deps.syncNodes()\n\n            console.log(`[ARRANGE-DONE] Successfully arranged ${updatedCount} tasks in Done Tasks group`)\n        } catch (error) {\n            console.error('[ASYNC-ERROR] arrangeDoneTasksInGrid failed', error)\n        }\n    }\n\n    /**\n     * GEOMETRY WRITER: Collects overdue tasks and arranges them in a grid to the LEFT of a target group (TASK-1222)\n     * This is an ALLOWED geometry write as it's an explicit user action (context menu click or AI command).\n     *\n     * - Finds all overdue tasks NOT inside the target group\n     * - Places them in a neat grid to the left of the group\n     * - Detects existing content in the target area to avoid overlaps\n     * - Clears parentId so tasks become free-floating on canvas\n     */\n    const collectOverdueTasksNearGroup = async (targetGroupId: string) => {\n        const toast = useToast()\n        console.log(`[COLLECT-OVERDUE] Starting collection for group: ${targetGroupId}`)\n\n        // Step 1: Find the target group\n        const groups = canvasStore._rawGroups || []\n        console.log(`[COLLECT-OVERDUE] Available groups: ${groups.length}`, groups.map(g => ({ id: g.id, name: g.name, hasPosition: !!g.position })))\n        const targetGroup = groups.find(g => g.id === targetGroupId)\n\n        if (!targetGroup) {\n            console.error('[COLLECT-OVERDUE] Target group not found')\n            toast.showToast('Target group not found', 'error')\n            return { success: false, count: 0 }\n        }\n\n        if (!targetGroup.position) {\n            console.error('[COLLECT-OVERDUE] Target group has no position:', targetGroup)\n            toast.showToast('Target group has no position data', 'error')\n            return { success: false, count: 0 }\n        }\n\n        // Step 2: Find overdue tasks not in this group\n        // Normalize dates: extract YYYY-MM-DD from \"2026-02-07\" or \"2026-02-07T22:00:00+00:00\"\n        const now = new Date()\n        const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`\n        const normDate = (d: string) => d.includes('T') ? d.split('T')[0] : d\n\n        // Use _rawTasks (unfiltered) — taskStore.tasks applies smart view/status filters\n        const allTasks = taskStore._rawTasks\n\n        // Collect ALL overdue tasks regardless of which group they're in.\n        // Tasks already inside the target group will be pulled OUT and arranged in the grid.\n        const overdueTasks = allTasks.filter(t => {\n            if (!t.dueDate || t.status === 'done') return false\n            const dueDateKey = normDate(t.dueDate)\n            if (dueDateKey >= today) return false\n            return true\n        })\n\n        // Include inbox tasks too — they'll get canvas positions assigned\n        const tasksToCollect = overdueTasks\n\n        console.log(`[COLLECT-OVERDUE] Found ${tasksToCollect.length} overdue tasks to arrange near group \"${targetGroup.name}\"`, { today, totalRaw: allTasks.length })\n\n        if (tasksToCollect.length === 0) {\n            toast.showToast('No overdue tasks found', 'info')\n            return { success: true, count: 0 }\n        }\n\n        // Step 3: Grid configuration (matches arrangeDoneTasksInGrid proven values)\n        const cardWidth = 300\n        const cardHeight = 180\n        const gapX = 80\n        const gapY = 50\n        const columns = Math.min(4, tasksToCollect.length)\n        const gap = 200 // Gap between target group and the grid\n\n        // Step 4: Calculate grid dimensions\n        const rows = Math.ceil(tasksToCollect.length / columns)\n        const gridActualWidth = columns * (cardWidth + gapX) - gapX\n        const gridActualHeight = rows * (cardHeight + gapY) - gapY\n\n        // Step 5: Calculate initial placement to the LEFT of the target group\n        const groupLeftEdge = targetGroup.position.x\n        const groupTopEdge = targetGroup.position.y\n        let startX = groupLeftEdge - gap - gridActualWidth\n        const startY = groupTopEdge // Align top with target group\n\n        // Step 6: Detect overlaps with existing content in the target area\n        const scanBuffer = 50\n        const scanLeft = startX - scanBuffer\n        const scanRight = startX + gridActualWidth + scanBuffer\n        const scanTop = startY - scanBuffer\n        const scanBottom = startY + gridActualHeight + scanBuffer\n\n        // Check all canvas tasks for overlaps (use raw to include filtered-out tasks)\n        const conflictingTasks = allTasks.filter(t => {\n            if (!t.canvasPosition) return false\n            if (tasksToCollect.some(ot => ot.id === t.id)) return false // Skip tasks we're moving\n            return t.canvasPosition.x >= scanLeft && t.canvasPosition.x <= scanRight &&\n                   t.canvasPosition.y >= scanTop && t.canvasPosition.y <= scanBottom\n        })\n\n        // Check all groups for overlaps (except target group)\n        const conflictingGroups = groups.filter(g => {\n            if (g.id === targetGroupId || !g.position) return false\n            return (g.position.x + (g.position.width || 300)) >= scanLeft &&\n                   g.position.x <= scanRight &&\n                   (g.position.y + (g.position.height || 200)) >= scanTop &&\n                   g.position.y <= scanBottom\n        })\n\n        // If conflicts, shift further left\n        if (conflictingTasks.length > 0 || conflictingGroups.length > 0) {\n            const allConflictXs = [\n                ...conflictingTasks.map(t => t.canvasPosition!.x),\n                ...conflictingGroups.map(g => g.position.x)\n            ]\n            const minConflictX = Math.min(...allConflictXs)\n            startX = minConflictX - gridActualWidth - gap\n            console.log(`[COLLECT-OVERDUE] Shifted left to avoid ${conflictingTasks.length + conflictingGroups.length} overlapping items, new startX: ${startX}`)\n        }\n\n        console.log(`[COLLECT-OVERDUE] Placing ${tasksToCollect.length} tasks in grid at x=${startX}, y=${startY}`)\n\n        try {\n            // Step 7: Position each task in the grid\n            let updatedCount = 0\n            const pmUpdates: Array<{ id: string; x: number; y: number; parentId: string | null }> = []\n\n            for (let i = 0; i < tasksToCollect.length; i++) {\n                const task = tasksToCollect[i]\n                const col = i % columns\n                const row = Math.floor(i / columns)\n\n                const newX = startX + col * (cardWidth + gapX)\n                const newY = startY + row * (cardHeight + gapY)\n\n                try {\n                    await undoHistory.updateTaskWithUndo(task.id, {\n                        parentId: null, // Explicitly clear parent — undefined skips DB update, null clears it\n                        canvasPosition: { x: newX, y: newY }\n                    })\n                    // Track for PositionManager force-update\n                    pmUpdates.push({ id: task.id, x: newX, y: newY, parentId: null })\n                    updatedCount++\n                } catch (taskError) {\n                    console.error(`[COLLECT-OVERDUE] Failed to update task ${task.id}:`, taskError)\n                }\n            }\n\n            console.log(`[COLLECT-OVERDUE] Updated ${updatedCount}/${tasksToCollect.length} tasks`)\n\n            // Step 8: Wait for watcher-triggered syncs from the sequential loop to settle.\n            // Each updateTaskWithUndo yields the event loop ~4 times, triggering canvas watchers\n            // that fire intermediate syncs with partially-updated data. Let them drain first.\n            await new Promise(resolve => setTimeout(resolve, 300))\n\n            // Step 9: Force-update PositionManager with the DEFINITIVE positions.\n            // This overwrites any stale PM entries left by intermediate watcher syncs.\n            const pmResult = positionManager.batchUpdate(pmUpdates, 'remote-sync')\n            console.log(`[COLLECT-OVERDUE] PositionManager updated: ${pmResult.successCount} succeeded, ${pmResult.rejectedIds.length} rejected`)\n\n            // Step 10: Final authoritative sync — this reads our fresh PM values\n            deps.syncNodes()\n            await new Promise(resolve => setTimeout(resolve, 200))\n            // Second sync for parent-child hierarchy changes (parentId: null detach)\n            deps.syncNodes()\n\n            // Step 11: Pan viewport to show the placed tasks + target group\n            await nextTick()\n            await new Promise(resolve => setTimeout(resolve, 100))\n            const placedNodeIds = tasksToCollect.map(t => t.id)\n            placedNodeIds.push(CanvasIds.groupNodeId(targetGroupId))\n            deps.fitView?.({ nodes: placedNodeIds, padding: 0.3, duration: 500 })\n\n            toast.showToast(`Collected ${updatedCount} overdue task${updatedCount === 1 ? '' : 's'}`, 'success')\n            console.log(`[COLLECT-OVERDUE] Successfully arranged ${updatedCount} overdue tasks near group \"${targetGroup.name}\"`)\n\n            return { success: true, count: updatedCount }\n        } catch (error) {\n            console.error('[ASYNC-ERROR] collectOverdueTasksNearGroup failed', error)\n            toast.showToast('Failed to collect overdue tasks', 'error')\n            return { success: false, count: 0 }\n        }\n    }\n\n    return {\n        isQuickTaskCreateOpen,\n        quickTaskPosition,\n        isBulkDeleteModalOpen,\n        bulkDeleteItems,\n        bulkDeleteIsPermanent,\n        createTaskHere,\n        createTaskInGroup,\n        createConnectedTask,\n        handleQuickTaskCreate,\n        closeQuickTaskCreate,\n        moveSelectedTasksToInbox,\n        doneForNowSelectedTasks,\n        deleteSelectedTasks,\n        confirmBulkDelete,\n        cancelBulkDelete,\n        arrangeDoneTasksInGrid,\n        collectOverdueTasksNearGroup\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useCanvasZoom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useNodeSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3938,3941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3938,3941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5282,5285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5282,5285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":143,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6123,6126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6123,6126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6781,6784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6781,6784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6895,6898],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6895,6898],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10580,10583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10580,10583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, type Ref } from 'vue'\nimport { supabase } from '@/services/auth/supabase'\nimport type { Node } from '@vue-flow/core'\nimport type { CanvasGroup } from '@/types/canvas'\nimport {\n    getGroupAbsolutePosition,\n    toAbsolutePosition,\n    sanitizePosition\n} from '@/utils/canvas/coordinates'\nimport { CANVAS } from '@/constants/canvas'\nimport { useToast } from '@/composables/useToast'\n\n/**\n * Composable for managing node sync with optimistic locking\n *\n * ============================================================================\n * WRITE PATH: Vue Flow → DB\n * ============================================================================\n *\n * This composable handles the WRITE PATH of the Fully Absolute Architecture:\n * - Takes Vue Flow node positions (relative for nested nodes)\n * - Converts to absolute world coordinates\n * - Saves to DB with optimistic locking for conflict detection\n *\n * KEY PRINCIPLE:\n * - Vue Flow stores RELATIVE positions for nested nodes\n * - DB must store ABSOLUTE world coordinates for ALL nodes\n * - Conversion happens HERE using computedPosition or manual calculation\n *\n * NOTE: nodeVersionMap is passed as Ref<Map> from Pinia store via storeToRefs.\n * We access .value to get the underlying Map.\n */\nexport function useNodeSync(\n    nodeVersionMapRef: Ref<Map<string, number>>\n) {\n    // BUG FIX: Use per-node locking instead of global lock to prevent one stuck node blocking others\n    const syncingNodes = ref(new Set<string>())\n    const syncError = ref<string | null>(null)\n\n    /**\n     * Sync a single node position with conflict detection\n     *\n     * WRITE PATH FLOW:\n     * 1. Get Vue Flow node position (relative if nested)\n     * 2. Convert to absolute world coordinates\n     * 3. Save to DB with optimistic lock\n     *\n     * @param nodeId The node/group ID (not Vue Flow node ID)\n     * @param vueFlowNode The Vue Flow node with current position\n     * @param allGroups All groups for parent lookup\n     * @param tableName 'tasks' or 'groups'\n     */\n    async function syncNodePosition(\n        nodeId: string,\n        vueFlowNode: Node,\n        allGroups: CanvasGroup[],\n        tableName: 'tasks' | 'groups'\n    ): Promise<boolean> {\n        // Defensive initialization: ensure nodeVersionMapRef.value is always a Map\n        if (!nodeVersionMapRef?.value || !(nodeVersionMapRef.value instanceof Map)) {\n            if (nodeVersionMapRef) {\n                nodeVersionMapRef.value = new Map<string, number>()\n            } else {\n                console.error('[NODE-SYNC] nodeVersionMapRef is null/undefined - cannot sync')\n                return false\n            }\n        }\n\n        const versionMap = nodeVersionMapRef.value as Map<string, number>\n\n        if (!nodeId) {\n            console.error('[NODE-SYNC] nodeId is required for sync')\n            return false\n        }\n\n        // PER-NODE LOCKING\n        if (syncingNodes.value.has(nodeId)) {\n            console.warn(`⏳ [NODE-SYNC] Skipped ${nodeId} - sync already in progress`)\n            return false\n        }\n\n        syncingNodes.value.add(nodeId)\n        syncError.value = null\n\n        try {\n            // ================================================================\n            // 1. EXTRACT PARENT ID FROM VUE FLOW NODE\n            // ================================================================\n            const rawParentId = vueFlowNode.parentNode\n            const currentParentId = rawParentId\n                ? (rawParentId.startsWith('section-')\n                    ? rawParentId.replace('section-', '')\n                    : rawParentId)\n                : null\n\n            // ================================================================\n            // 2. CALCULATE ABSOLUTE POSITION\n            // ================================================================\n            let absolutePosition: { x: number; y: number }\n            const vfNode = vueFlowNode as any\n\n            if (vfNode.computedPosition) {\n                absolutePosition = {\n                    x: vfNode.computedPosition.x,\n                    y: vfNode.computedPosition.y\n                }\n            } else {\n                const relativePos = sanitizePosition(vueFlowNode.position)\n                if (currentParentId && currentParentId !== 'NONE') {\n                    const parentAbsolute = getGroupAbsolutePosition(currentParentId, allGroups)\n                    absolutePosition = toAbsolutePosition(relativePos, parentAbsolute)\n                } else {\n                    absolutePosition = relativePos\n                }\n            }\n\n            // ================================================================\n            // 3. GET CURRENT VERSION (with fallback to store)\n            // ================================================================\n            // CRITICAL FIX: If versionMap is out of sync, fall back to task store\n            let currentVersion = versionMap.get(nodeId)\n            if (currentVersion === undefined) {\n                // Try to get version from task store as fallback\n                try {\n                    const { useTaskStore } = await import('@/stores/tasks')\n                    const taskStore = useTaskStore()\n                    const task = taskStore.tasks.find((t: any) => t.id === nodeId)\n                    if (task?.positionVersion !== undefined) {\n                        currentVersion = task.positionVersion\n                        versionMap.set(nodeId, currentVersion) // Sync the map\n                        console.log(`[NODE-SYNC] Recovered version from task store for ${nodeId.slice(0, 8)}: v${currentVersion}`)\n                    }\n                } catch {\n                    // Store not available, use 0\n                }\n                currentVersion = currentVersion ?? 0\n            }\n\n            // ================================================================\n            // 4. PREPARE DB PAYLOAD\n            // ================================================================\n            const positionToSave = absolutePosition\n            const updatePayload: Record<string, any> = {\n                position_version: currentVersion + 1,\n                updated_at: new Date().toISOString()\n            }\n\n            if (tableName === 'tasks') {\n                updatePayload.position = {\n                    x: positionToSave.x,\n                    y: positionToSave.y,\n                    parentId: currentParentId === 'NONE' ? null : currentParentId,\n                    format: 'absolute'\n                }\n            } else {\n                updatePayload.position_json = {\n                    x: positionToSave.x,\n                    y: positionToSave.y,\n                    width: vueFlowNode.data?.width || (vueFlowNode as any).width || CANVAS.DEFAULT_GROUP_WIDTH,\n                    height: vueFlowNode.data?.height || (vueFlowNode as any).height || CANVAS.DEFAULT_GROUP_HEIGHT\n                }\n                updatePayload.parent_group_id = currentParentId === 'NONE' ? null : currentParentId\n            }\n\n            // ================================================================\n            // 5. EXECUTE OPTIMISTIC LOCK UPDATE (WITH TIMEOUT)\n            // ================================================================\n            // We wrap Supabase call in a timeout to prevent infinite hanging\n            // which causes the \"stops syncing after a while\" bug.\n            // Increased timeout for production VPS latency (BUG-1116)\n\n            const SYNC_TIMEOUT_MS = 20000 // 20s timeout for VPS latency\n            const timeoutPromise = new Promise<{ timeout: true }>((resolve) =>\n                setTimeout(() => resolve({ timeout: true }), SYNC_TIMEOUT_MS)\n            )\n\n            const dbRequest = supabase\n                .from(tableName)\n                .update(updatePayload)\n                .eq('id', nodeId)\n                .eq('position_version', currentVersion)\n                .select('position_version')\n\n            // Race: DB Request vs Timeout\n            const result = await Promise.race([dbRequest, timeoutPromise])\n\n            // Handle Timeout\n            if ('timeout' in result) {\n                throw new Error(`Sync timed out after ${SYNC_TIMEOUT_MS}ms`)\n            }\n\n            const { data, error } = result\n\n            if (error) throw error\n\n            // Handle Version Mismatch (Retry Once)\n            if (!data || data.length === 0) {\n                console.warn(`⚠️ [NODE-SYNC] Conflict detected for ${tableName} ${nodeId}, retrying...`)\n\n                // Fetch latest\n                const { data: latest, error: fetchError } = await supabase\n                    .from(tableName)\n                    .select('position_version')\n                    .eq('id', nodeId)\n                    .single()\n\n                if (fetchError || !latest) {\n                    throw new Error('Could not fetch latest version for retry')\n                }\n\n                const newVersion = latest.position_version\n                versionMap.set(nodeId, newVersion)\n                updatePayload.position_version = newVersion + 1\n\n                // Retry Request (With new timeout race)\n                const retryRequest = supabase\n                    .from(tableName)\n                    .update(updatePayload)\n                    .eq('id', nodeId)\n                    .eq('position_version', newVersion)\n                    .select('position_version')\n\n                const retryResult = await Promise.race([retryRequest, timeoutPromise])\n                if ('timeout' in retryResult) {\n                    throw new Error(`Retry sync timed out after ${SYNC_TIMEOUT_MS}ms`)\n                }\n\n                const { data: retryData, error: retryError } = retryResult\n\n                if (retryError) throw retryError\n\n                if (!retryData || retryData.length === 0) {\n                    console.error(`❌ [NODE-SYNC] Retry failed for ${tableName} ${nodeId}. Position may be stale.`)\n                    syncError.value = `Sync Conflict: Retry failed`\n                    return false\n                }\n\n                console.log(`✅ [NODE-SYNC] Retry succeeded for ${tableName} ${nodeId}`)\n                versionMap.set(nodeId, retryData[0].position_version)\n                return true\n            }\n\n            // Success\n            // console.log(`✅ [NODE-SYNC] Sync success for ${tableName} ${nodeId} v${data[0].position_version}`)\n            versionMap.set(nodeId, data[0].position_version)\n            return true\n\n        } catch (err: any) {\n            console.error('❌ [NODE-SYNC] Failed:', err)\n            syncError.value = err.message || 'Sync failed'\n\n            const { showToast } = useToast()\n\n            // TASK-1177: Show toast for ALL errors including timeouts\n            // Previously timeouts were silenced, leading to silent data loss\n            if (err.message?.includes('timed out')) {\n                // Show warning toast for timeouts - changes will be retried\n                showToast('Sync timed out - changes will retry automatically', 'warning')\n            } else {\n                // Show error toast for other failures\n                showToast(`Sync Failed: ${syncError.value}`, 'error')\n            }\n            return false\n        } finally {\n            syncingNodes.value.delete(nodeId)\n        }\n    }\n\n    return {\n        // Expose boolean for backward compatibility (true if ANY node is syncing)\n        isSyncing: computed(() => syncingNodes.value.size > 0),\n        syncError: computed(() => syncError.value),\n        syncNodePosition\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/canvas/useSmartGroupMatcher.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SmartGroupType' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"SmartGroupType"},"fix":{"range":[673,696],"text":""},"desc":"Remove unused variable \"SmartGroupType\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DAY_OF_WEEK_KEYWORDS' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"DAY_OF_WEEK_KEYWORDS"},"fix":{"range":[712,736],"text":""},"desc":"Remove unused variable \"DAY_OF_WEEK_KEYWORDS\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'nextOccurrence' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":103,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":25},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":148,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":148,"endColumn":44},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":149,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":149,"endColumn":44}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Smart Group Matcher\n *\n * Provides utilities to match tasks with Smart Groups based on their due dates.\n * Used by \"Send to Canvas\" feature to auto-place inbox tasks into matching groups.\n *\n * GEOMETRY WRITER SAFETY (TASK-255):\n * - This module only calculates which group a task should go to\n * - Actual geometry writes happen in the calling code (sendToCanvas action)\n * - Safe because: explicit user action, one-time placement, atomic write\n *\n * @see docs/sop/canvas/CANVAS-POSITION-SYSTEM.md\n */\n\nimport type { CanvasGroup } from '@/types/canvas'\nimport type { Task } from '@/types/tasks'\nimport {\n  detectPowerKeyword,\n  getSmartGroupDate,\n  getSmartGroupType,\n  type SmartGroupType,\n  SMART_GROUPS,\n  DAY_OF_WEEK_KEYWORDS\n} from '@/composables/usePowerKeywords'\nimport { CANVAS } from '@/constants/canvas'\n\n/**\n * Result of group matching with calculated position\n */\nexport interface GroupMatchResult {\n  group: CanvasGroup\n  position: { x: number; y: number }\n}\n\n/**\n * Format date as YYYY-MM-DD string\n */\nfunction formatDateStr(date: Date): string {\n  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`\n}\n\n/**\n * Get next occurrence of a day of week from today\n * @param dayIndex - 0=Sunday through 6=Saturday\n */\nfunction getNextDayOfWeekDate(dayIndex: number): string {\n  const today = new Date()\n  const currentDay = today.getDay()\n  let daysUntil = dayIndex - currentDay\n\n  // If the day is today or in the past this week, get next week's occurrence\n  if (daysUntil <= 0) {\n    daysUntil += 7\n  }\n\n  const result = new Date(today)\n  result.setDate(today.getDate() + daysUntil)\n  return formatDateStr(result)\n}\n\n/**\n * Check if a task's due date matches a group's power keyword\n *\n * @param taskDueDate - Task's due date in YYYY-MM-DD format\n * @param group - Canvas group to check\n * @returns true if the task's due date matches the group's date criteria\n */\nfunction doesTaskMatchGroup(taskDueDate: string, group: CanvasGroup): boolean {\n  const powerKeyword = detectPowerKeyword(group.name)\n  if (!powerKeyword) return false\n\n  const taskDateOnly = taskDueDate.split('T')[0] // Handle ISO strings\n\n  // Handle date-based smart groups (today, tomorrow, this week, etc.)\n  if (powerKeyword.category === 'date') {\n    const smartGroupType = getSmartGroupType(group.name)\n    if (!smartGroupType) return false\n\n    const groupDate = getSmartGroupDate(smartGroupType)\n\n    // Special handling for \"this week\" - task should be within the week\n    if (smartGroupType === SMART_GROUPS.THIS_WEEK) {\n      const today = new Date()\n      const taskDate = new Date(taskDateOnly)\n      const endOfWeek = new Date(groupDate)\n      return taskDate >= today && taskDate <= endOfWeek\n    }\n\n    // Special handling for \"this weekend\" - Saturday or Sunday\n    if (smartGroupType === SMART_GROUPS.THIS_WEEKEND) {\n      const taskDate = new Date(taskDateOnly)\n      const dayOfWeek = taskDate.getDay()\n      return dayOfWeek === 0 || dayOfWeek === 6 // Sunday or Saturday\n    }\n\n    // Exact match for today, tomorrow\n    return taskDateOnly === groupDate\n  }\n\n  // Handle day-of-week groups (Monday, Tuesday, etc.)\n  if (powerKeyword.category === 'day_of_week') {\n    const dayIndex = parseInt(powerKeyword.value, 10)\n    const nextOccurrence = getNextDayOfWeekDate(dayIndex)\n\n    // Match if task is due on that day of the week (this week or next)\n    const taskDate = new Date(taskDateOnly)\n    return taskDate.getDay() === dayIndex\n  }\n\n  return false\n}\n\n/**\n * Find the matching canvas group for a task based on its due date\n *\n * Logic:\n * - No due date → defaults to \"Today\" group\n * - Due date is today → \"Today\" group\n * - Due date is tomorrow → \"Tomorrow\" group\n * - Due date matches a day-of-week group → that group\n * - Due date within this week → \"This Week\" group\n * - No matching group found → returns null (placed at canvas root)\n *\n * For nested groups (e.g., \"Today\" inside \"This Week\"), the innermost match wins.\n *\n * @param dueDate - Task's due date in YYYY-MM-DD or ISO format (or undefined for Today default)\n * @param groups - All canvas groups to search\n * @returns The matching group or null if no match found\n */\nexport function findMatchingGroupForDueDate(\n  dueDate: string | undefined,\n  groups: CanvasGroup[]\n): CanvasGroup | null {\n  // Default to today's date if no due date specified\n  const effectiveDate = dueDate || formatDateStr(new Date())\n\n  // Filter to only visible groups with power keywords\n  const powerGroups = groups.filter(g => {\n    const pk = detectPowerKeyword(g.name)\n    return pk && (pk.category === 'date' || pk.category === 'day_of_week') && g.isVisible\n  })\n\n  if (powerGroups.length === 0) return null\n\n  // Sort by specificity - prefer more specific matches\n  // Today/Tomorrow/day-of-week are more specific than \"This Week\"\n  const sortedGroups = [...powerGroups].sort((a, b) => {\n    const pkA = detectPowerKeyword(a.name)!\n    const pkB = detectPowerKeyword(b.name)!\n\n    // Day-of-week and today/tomorrow are most specific\n    const specificKeywords = ['today', 'tomorrow']\n    const aIsSpecific = specificKeywords.includes(pkA.keyword) || pkA.category === 'day_of_week'\n    const bIsSpecific = specificKeywords.includes(pkB.keyword) || pkB.category === 'day_of_week'\n\n    if (aIsSpecific && !bIsSpecific) return -1\n    if (!aIsSpecific && bIsSpecific) return 1\n\n    // Among similar specificity, prefer nested (child) groups\n    // A child group has a parentGroupId pointing to another group\n    if (a.parentGroupId && !b.parentGroupId) return -1\n    if (!a.parentGroupId && b.parentGroupId) return 1\n\n    return 0\n  })\n\n  // Find first matching group\n  for (const group of sortedGroups) {\n    if (doesTaskMatchGroup(effectiveDate, group)) {\n      return group\n    }\n  }\n\n  return null\n}\n\n/**\n * Calculate position for a new task inside a group\n *\n * Positions the task inside the group bounds, avoiding overlap with existing tasks\n * when possible. Falls back to center of group if overlap is unavoidable.\n *\n * @param group - Target group to place task in\n * @param existingTasks - Tasks currently in this group (for collision avoidance)\n * @returns Absolute position { x, y } for the task's canvasPosition\n */\nexport function calculatePositionInGroup(\n  group: CanvasGroup,\n  existingTasks: Task[]\n): { x: number; y: number } {\n  const groupX = group.position?.x || 0\n  const groupY = group.position?.y || 0\n  const groupWidth = group.position?.width || CANVAS.DEFAULT_GROUP_WIDTH\n  const groupHeight = group.position?.height || CANVAS.DEFAULT_GROUP_HEIGHT\n\n  const taskWidth = CANVAS.DEFAULT_TASK_WIDTH\n  const taskHeight = CANVAS.DEFAULT_TASK_HEIGHT\n  const padding = 20\n  const headerHeight = 50 // Group header space\n\n  // Available space inside the group\n  const availableX = groupX + padding\n  const availableY = groupY + headerHeight + padding\n  const maxX = groupX + groupWidth - taskWidth - padding\n  const maxY = groupY + groupHeight - taskHeight - padding\n\n  // Filter to tasks actually in this group\n  const tasksInGroup = existingTasks.filter(t => t.parentId === group.id && t.canvasPosition)\n\n  // If no existing tasks, place near top-left\n  if (tasksInGroup.length === 0) {\n    return {\n      x: Math.max(availableX, Math.min(availableX + 20, maxX)),\n      y: Math.max(availableY, Math.min(availableY + 20, maxY))\n    }\n  }\n\n  // Find lowest Y position of existing tasks to stack below them\n  let lowestY = availableY\n  for (const task of tasksInGroup) {\n    if (task.canvasPosition) {\n      const taskBottom = task.canvasPosition.y + taskHeight + 10 // 10px gap\n      if (taskBottom > lowestY) {\n        lowestY = taskBottom\n      }\n    }\n  }\n\n  // If there's room below existing tasks, place there\n  if (lowestY + taskHeight <= maxY + padding) {\n    return {\n      x: Math.max(availableX, Math.min(availableX + 20, maxX)),\n      y: lowestY\n    }\n  }\n\n  // Fallback: center of group (may overlap, but user can adjust)\n  return {\n    x: groupX + (groupWidth / 2) - (taskWidth / 2),\n    y: groupY + (groupHeight / 2) - (taskHeight / 2)\n  }\n}\n\n/**\n * Get a user-friendly label for where the task will be placed\n * Used for toast notifications and UI feedback\n */\nexport function getPlacementLabel(\n  dueDate: string | undefined,\n  groups: CanvasGroup[]\n): string {\n  const matchingGroup = findMatchingGroupForDueDate(dueDate, groups)\n\n  if (matchingGroup) {\n    return matchingGroup.name\n  }\n\n  return 'Canvas (root)'\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/inbox/useCalendarInboxState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/inbox/useUnifiedInboxActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/inbox/useUnifiedInboxState.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":239,"column":21,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":239,"endColumn":99},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":240,"column":21,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":240,"endColumn":99},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":247,"column":21,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":247,"endColumn":86},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":248,"column":21,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":248,"endColumn":86}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { ref, computed, watch } from 'vue'\nimport { usePersistentRef } from '@/composables/usePersistentRef'\nimport type { Task } from '@/types/tasks'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useSmartViews } from '@/composables/useSmartViews'\nimport { useCanvasGroupMembership } from '@/composables/canvas/useCanvasGroupMembership'\n// TASK-144: Use centralized duration categories\nimport { type DurationCategory, matchesDurationCategory } from '@/utils/durationCategories'\n\nexport interface InboxContextProps {\n    context: 'calendar' | 'canvas' | 'standalone'\n    hideDoneTasks?: boolean\n}\n\nexport type TimeFilterType = 'all' | 'today' | 'next3days' | 'week' | 'month'\nexport type SortByType = 'newest' | 'priority' | 'dueDate' | 'canvasOrder'\n\nexport function useUnifiedInboxState(props: InboxContextProps) {\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const { isTodayTask, isNext3DaysTask, isWeekTask, isThisMonthTask } = useSmartViews()\n    const { groupsWithCounts, filterTasksByGroup } = useCanvasGroupMembership()\n\n    // --- Core Filter State ---\n    // TASK-1215: Persist inbox open/closed per context (canvas vs calendar)\n    const isCollapsed = usePersistentRef<boolean>(`flowstate:inbox-collapsed-${props.context}`, false)\n    // BUG-1051: Persist filter (TASK-1215: upgraded to Tauri-aware persistence)\n    const activeTimeFilter = usePersistentRef<TimeFilterType>('flowstate:inbox-time-filter', 'all', 'canvas-inbox-time-filter')\n\n    // --- Advanced Filter State (TASK-1215: Persist across restarts via Tauri store + localStorage) ---\n    const showAdvancedFilters = usePersistentRef<boolean>('flowstate:inbox-advanced-filters', false)\n    const unscheduledOnly = usePersistentRef<boolean>('flowstate:inbox-unscheduled-only', false)\n    // TASK-1246: Multi-select filters (array-backed for JSON-safe persistence, Set API via computed)\n    const _selectedPriorities = usePersistentRef<string[]>('flowstate:inbox-priority-filters', [])\n    const _selectedProjects = usePersistentRef<string[]>('flowstate:inbox-project-filters', [])\n    const _selectedDurations = usePersistentRef<string[]>('flowstate:inbox-duration-filters', [])\n\n    const selectedPriorities = computed({\n        get: () => new Set(_selectedPriorities.value),\n        set: (val: Set<string>) => { _selectedPriorities.value = Array.from(val) }\n    })\n    const selectedProjects = computed({\n        get: () => new Set(_selectedProjects.value),\n        set: (val: Set<string>) => { _selectedProjects.value = Array.from(val) }\n    })\n    const selectedDurations = computed({\n        get: () => new Set<DurationCategory>(_selectedDurations.value as DurationCategory[]),\n        set: (val: Set<DurationCategory>) => { _selectedDurations.value = Array.from(val) }\n    })\n\n    // TASK-1073: Sort state (TASK-1215: upgraded to Tauri-aware persistence)\n    const sortBy = usePersistentRef<SortByType>('flowstate:inbox-sort-by', 'newest', 'inbox-sort-by')\n\n    // TASK-1075: Search query\n    const searchQuery = ref('')\n\n    // TASK-106: Canvas group filter (primary filter)\n    const selectedCanvasGroups = ref<Set<string>>(new Set())\n\n    // --- Done Tasks Filter ---\n    // showDoneOnly = false: Show active tasks (non-done)\n    // showDoneOnly = true: Show ONLY done tasks\n    const showDoneOnly = usePersistentRef<boolean>('flowstate:inbox-show-done', false)\n    // For backwards compatibility with prop name\n    const currentHideDoneTasks = computed(() => !showDoneOnly.value)\n    const toggleHideDoneTasks = () => {\n        showDoneOnly.value = !showDoneOnly.value\n    }\n\n    interface GroupOption {\n        label: string\n        value: string\n        color?: string\n        count?: number\n    }\n\n    // --- Canvas Group Options ---\n    const canvasGroupOptions = computed((): GroupOption[] => {\n        const options: GroupOption[] = [\n            { label: 'All', value: '', color: undefined }\n        ]\n\n        groupsWithCounts.value.forEach(group => {\n            options.push({\n                label: group.name,\n                value: group.id,\n                color: group.color || '#4ecdc4',\n                count: group.taskCount\n            })\n        })\n\n        return options\n    })\n\n    // --- Filter Logic ---\n\n    // Base Inbox Tasks (Filtered by global rules + context rules)\n    const baseInboxTasks = computed(() => {\n        return taskStore.filteredTasks.filter(task => {\n            // 1. Done/Active filter (exclusive - show one OR the other)\n            const isDone = task.status === 'done'\n            if (showDoneOnly.value) {\n                // Show ONLY done tasks\n                if (!isDone) return false\n            } else {\n                // Show ONLY active tasks (hide done)\n                if (isDone) return false\n            }\n\n            // 2. Soft Deleted check (Safety)\n            if (task._soft_deleted) {\n                return false\n            }\n\n            // 3. Context Specific Rules\n            if (props.context === 'calendar') {\n                // CALENDAR INBOX: Show tasks NOT on the calendar grid\n                const hasInstances = task.instances && task.instances.length > 0\n                const hasLegacySchedule = (task.scheduledDate && task.scheduledDate.trim() !== '') &&\n                    (task.scheduledTime && task.scheduledTime.trim() !== '')\n                return !hasInstances && !hasLegacySchedule\n            } else {\n                // CANVAS INBOX: Show tasks NOT on the canvas\n                // (Dec 16, 2025 FIX: ONLY check canvasPosition)\n                return !task.canvasPosition\n            }\n        })\n    })\n\n    const todayCount = computed(() => {\n        return baseInboxTasks.value.filter(task => isTodayTask(task)).length\n    })\n\n    const next3DaysCount = computed(() => {\n        return baseInboxTasks.value.filter(task => isNext3DaysTask(task)).length\n    })\n\n    const weekCount = computed(() => {\n        return baseInboxTasks.value.filter(task => isWeekTask(task)).length\n    })\n\n    const monthCount = computed(() => {\n        return baseInboxTasks.value.filter(task => isThisMonthTask(task)).length\n    })\n\n    // Done task count (for the visible Done toggle badge)\n    // Counts tasks in inbox that are done (before the done filter is applied)\n    const doneTaskCount = computed(() => {\n        return taskStore.filteredTasks.filter(task => {\n            // Must be a done task\n            if (task.status !== 'done') return false\n            // Must not be soft deleted\n            if (task._soft_deleted) return false\n            // Must be an inbox task (not on canvas/calendar)\n            if (props.context === 'calendar') {\n                const hasInstances = task.instances && task.instances.length > 0\n                const hasLegacySchedule = (task.scheduledDate && task.scheduledDate.trim() !== '') &&\n                    (task.scheduledTime && task.scheduledTime.trim() !== '')\n                return !hasInstances && !hasLegacySchedule\n            } else {\n                return !task.canvasPosition\n            }\n        }).length\n    })\n\n    const isScheduledOnCalendar = (task: Task): boolean => {\n        if (!task.instances || task.instances.length === 0) return false\n        return task.instances.some(inst => inst.scheduledDate)\n    }\n\n    // Final Inbox Tasks (Apply all local filters)\n    const inboxTasks = computed(() => {\n        let tasks = baseInboxTasks.value\n\n        // 1. Canvas Group Filter (Multi-select)\n        if (selectedCanvasGroups.value.size > 0) {\n            const groupIds = Array.from(selectedCanvasGroups.value)\n            tasks = tasks.filter(task =>\n                groupIds.some(groupId => filterTasksByGroup([task], groupId).length > 0)\n            )\n        }\n\n        // 2. Time Filter\n        if (activeTimeFilter.value === 'today') {\n            tasks = tasks.filter(task => isTodayTask(task))\n        } else if (activeTimeFilter.value === 'next3days') {\n            tasks = tasks.filter(task => isNext3DaysTask(task))\n        } else if (activeTimeFilter.value === 'week') {\n            tasks = tasks.filter(task => isWeekTask(task))\n        } else if (activeTimeFilter.value === 'month') {\n            tasks = tasks.filter(task => isThisMonthTask(task))\n        }\n\n        // 3. Unscheduled Filter\n        if (unscheduledOnly.value) {\n            tasks = tasks.filter(task => !isScheduledOnCalendar(task))\n        }\n\n        // 4. Priority Filter (TASK-1246: multi-select, OR within)\n        if (selectedPriorities.value.size > 0) {\n            tasks = tasks.filter(task => selectedPriorities.value.has(task.priority ?? ''))\n        }\n\n        // 5. Project Filter (TASK-1246: multi-select, OR within, handles 'none' sentinel)\n        if (selectedProjects.value.size > 0) {\n            tasks = tasks.filter(task => {\n                if (selectedProjects.value.has('none') && !task.projectId) return true\n                return selectedProjects.value.has(task.projectId ?? '')\n            })\n        }\n\n        // 6. Duration Filter (TASK-1246: multi-select, OR within)\n        if (selectedDurations.value.size > 0) {\n            const durCats = Array.from(selectedDurations.value)\n            tasks = tasks.filter(task =>\n                durCats.some(cat => matchesDurationCategory(task.estimatedDuration, cat))\n            )\n        }\n\n        // TASK-1075: Search Filter (title and description)\n        if (searchQuery.value.trim()) {\n            const query = searchQuery.value.toLowerCase().trim()\n            tasks = tasks.filter(task => {\n                const titleMatch = task.title?.toLowerCase().includes(query)\n                const descMatch = task.description?.toLowerCase().includes(query)\n                return titleMatch || descMatch\n            })\n        }\n\n        // TASK-1073: Apply sorting\n        const priorityOrder = { high: 0, medium: 1, low: 2, undefined: 3 }\n\n        tasks = [...tasks].sort((a, b) => {\n            switch (sortBy.value) {\n                case 'priority':\n                    // High priority first\n                    const aPriority = priorityOrder[a.priority as keyof typeof priorityOrder] ?? 3\n                    const bPriority = priorityOrder[b.priority as keyof typeof priorityOrder] ?? 3\n                    if (aPriority !== bPriority) return aPriority - bPriority\n                    // Secondary: newest first\n                    return new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime()\n\n                case 'dueDate':\n                    // Tasks with due dates first, then by due date\n                    const aDue = a.dueDate ? new Date(a.dueDate).getTime() : Infinity\n                    const bDue = b.dueDate ? new Date(b.dueDate).getTime() : Infinity\n                    if (aDue !== bDue) return aDue - bDue\n                    // Secondary: newest first\n                    return new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime()\n\n                case 'canvasOrder': {\n                    // TASK-1303: Sort by group column (left→right), then top→bottom within group\n                    const groups = canvasStore.groups || []\n                    const aGroup = a.parentId ? groups.find(g => g.id === a.parentId) : null\n                    const bGroup = b.parentId ? groups.find(g => g.id === b.parentId) : null\n                    const aGroupX = aGroup?.position?.x ?? Infinity\n                    const bGroupX = bGroup?.position?.x ?? Infinity\n                    if (aGroupX !== bGroupX) return aGroupX - bGroupX\n                    // Within same group: sort by task Y (top to bottom)\n                    const aPos = a.canvasPosition\n                    const bPos = b.canvasPosition\n                    if (!aPos && !bPos) return new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime()\n                    if (!aPos) return 1\n                    if (!bPos) return -1\n                    if (aPos.y !== bPos.y) return aPos.y - bPos.y\n                    if (aPos.x !== bPos.x) return aPos.x - bPos.x\n                    return new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime()\n                }\n\n                case 'newest':\n                default:\n                    // Newest first (by createdAt)\n                    return new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime()\n            }\n        })\n\n        return tasks\n    })\n\n    const clearAllFilters = () => {\n        unscheduledOnly.value = false\n        selectedPriorities.value = new Set()\n        selectedProjects.value = new Set()\n        selectedDurations.value = new Set()\n        activeTimeFilter.value = 'all'\n        selectedCanvasGroups.value = new Set()\n        searchQuery.value = '' // TASK-1075\n    }\n\n    // FEATURE-254: Canvas Inbox Smart Minimization\n    // Logic: Auto-collapse if empty on load, respect persisted preference otherwise\n    const hasInitialized = ref(false)\n\n    watch(() => [taskStore.isLoadingFromDatabase, inboxTasks.value.length], ([isLoading, count]) => {\n        // Only run initialization once, when DB load finishes\n        if (!isLoading && !hasInitialized.value && props.context === 'canvas') {\n            const taskCount = count as number\n\n            if (taskCount === 0) {\n                isCollapsed.value = true\n                console.log('[UnifiedInbox] Smart Minimization: Empty on load -> Collapsed')\n            }\n            // TASK-1215: If tasks exist, respect persisted isCollapsed value (don't override)\n\n            hasInitialized.value = true\n        }\n    }, { immediate: true })\n\n    return {\n        // State\n        isCollapsed,\n        activeTimeFilter,\n        showAdvancedFilters,\n        unscheduledOnly,\n        selectedPriorities,\n        selectedProjects,\n        selectedDurations,\n        selectedCanvasGroups,\n        currentHideDoneTasks,\n        sortBy, // TASK-1073\n        searchQuery, // TASK-1075\n\n        // Computed (State)\n        canvasGroupOptions,\n        baseInboxTasks,\n        inboxTasks,\n        todayCount,\n        next3DaysCount,\n        weekCount,\n        monthCount,\n        doneTaskCount,\n\n        // Actions (State Mutators)\n        toggleHideDoneTasks,\n        clearAllFilters\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/mobile/useMobileFilters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/sync/useBroadcastChannelSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[146,149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[146,149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[347,350],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[347,350],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[353,356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[353,356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[955,958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[955,958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1639,1642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1639,1642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1994,1997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1994,1997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onUnmounted, toRaw } from 'vue'\n\ninterface BroadcastMessage {\n    type: string\n    senderId: string\n    timestamp: number\n    data: any\n}\n\n/**\n * Deep clone data to strip Vue reactive Proxy objects before broadcasting.\n * BroadcastChannel uses structured clone which cannot handle Proxy objects.\n */\nconst cloneForBroadcast = (data: any): any => {\n    if (data === null || data === undefined) return data\n    // Use toRaw to strip reactivity, then JSON clone to ensure deep copy\n    try {\n        return JSON.parse(JSON.stringify(toRaw(data)))\n    } catch {\n        // Fallback for non-JSON-serializable data\n        return toRaw(data)\n    }\n}\n\nexport function useBroadcastChannelSync(channelName = 'flow-state-sync') {\n    const tabId = ref(`tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`)\n    const isConnected = ref(false)\n\n    let channel: BroadcastChannel | null = null\n    const messageHandlers = new Map<string, (data: any) => void>()\n\n    const connect = () => {\n        if (channel) return\n\n        channel = new BroadcastChannel(channelName)\n        channel.onmessage = (event: MessageEvent<BroadcastMessage>) => {\n            if (event.data.senderId === tabId.value) return // Ignore own messages\n\n            const handler = messageHandlers.get(event.data.type)\n            if (handler) {\n                handler(event.data.data)\n            }\n        }\n\n        isConnected.value = true\n    }\n\n    const disconnect = () => {\n        if (channel) {\n            channel.close()\n            channel = null\n        }\n        isConnected.value = false\n    }\n\n    const broadcast = (type: string, data: any) => {\n        if (!channel) return\n\n        const message: BroadcastMessage = {\n            type,\n            senderId: tabId.value,\n            timestamp: Date.now(),\n            data: cloneForBroadcast(data) // Strip Vue Proxy before sending\n        }\n        channel.postMessage(message)\n    }\n\n    const onMessage = (type: string, handler: (data: any) => void) => {\n        messageHandlers.set(type, handler)\n    }\n\n    const offMessage = (type: string) => {\n        messageHandlers.delete(type)\n    }\n\n    onUnmounted(() => {\n        disconnect()\n    })\n\n    return {\n        tabId,\n        isConnected,\n        connect,\n        disconnect,\n        broadcast,\n        onMessage,\n        offMessage\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/sync/useSyncOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stopProcessing' is defined but never used. Allowed unused vars must match /^_/u.","line":550,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":550,"endColumn":24},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":627,"column":27,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":627,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sync Orchestrator Composable\n *\n * CRITICAL: This is the main controller for the offline-first sync system.\n *\n * Key behaviors:\n * - All writes go to IndexedDB FIRST, then sync to Supabase\n * - Automatic retry with exponential backoff\n * - Never discards operations until confirmed synced\n * - Detects online/offline status and pauses/resumes accordingly\n *\n * @see TASK-1177 in MASTER_PLAN.md\n */\n\nimport { ref, computed } from 'vue'\nimport type {\n  WriteOperation,\n  SyncState,\n  SyncEntityType,\n  SyncOperationType,\n  SyncResult\n} from '@/types/sync'\n\n// TASK-1177: Check for IndexedDB availability (not available in Node.js/tests)\nconst hasIndexedDB = typeof indexedDB !== 'undefined'\n\n// Lazy import to prevent IndexedDB errors in test environment\nlet writeQueueModule: typeof import('@/services/offline/writeQueueDB') | null = null\nasync function getWriteQueueModule() {\n  if (!hasIndexedDB) {\n    return null\n  }\n  if (!writeQueueModule) {\n    writeQueueModule = await import('@/services/offline/writeQueueDB')\n  }\n  return writeQueueModule\n}\n\n// Re-export types and stub functions for when IndexedDB is unavailable\nimport type {\n  enqueueOperation as _enqueueOperation,\n  getPendingOperations as _getPendingOperations,\n  markSyncing as _markSyncing,\n  markCompleted as _markCompleted,\n  markFailed as _markFailed,\n  markConflict as _markConflict,\n  cleanupCompleted as _cleanupCompleted,\n  getStats as _getStats,\n  getFailedOperations as _getFailedOperations\n} from '@/services/offline/writeQueueDB'\n\n// Wrapped functions that handle missing IndexedDB gracefully\nconst enqueueOperation: typeof _enqueueOperation = async (...args) => {\n  const mod = await getWriteQueueModule()\n  if (!mod) {\n    console.warn('[SYNC] IndexedDB not available - operation not queued')\n    return { ...args[0], id: Date.now(), status: 'pending' as const, retryCount: 0, createdAt: Date.now() }\n  }\n  return mod.enqueueOperation(...args)\n}\n\nconst getPendingOperations: typeof _getPendingOperations = async (...args) => {\n  const mod = await getWriteQueueModule()\n  return mod ? mod.getPendingOperations(...args) : []\n}\n\nconst markSyncing: typeof _markSyncing = async (...args) => {\n  const mod = await getWriteQueueModule()\n  if (mod) await mod.markSyncing(...args)\n}\n\nconst markCompleted: typeof _markCompleted = async (...args) => {\n  const mod = await getWriteQueueModule()\n  if (mod) await mod.markCompleted(...args)\n}\n\nconst markFailed: typeof _markFailed = async (...args) => {\n  const mod = await getWriteQueueModule()\n  if (mod) await mod.markFailed(...args)\n}\n\nconst markConflict: typeof _markConflict = async (...args) => {\n  const mod = await getWriteQueueModule()\n  if (!mod) throw new Error('IndexedDB not available')\n  return mod.markConflict(...args)\n}\n\nconst cleanupCompleted: typeof _cleanupCompleted = async () => {\n  const mod = await getWriteQueueModule()\n  return mod ? mod.cleanupCompleted() : 0\n}\n\nconst getStats: typeof _getStats = async () => {\n  const mod = await getWriteQueueModule()\n  return mod ? mod.getStats() : {\n    totalOperations: 0,\n    pendingCount: 0,\n    syncingCount: 0,\n    failedCount: 0,\n    completedCount: 0,\n    conflictCount: 0\n  }\n}\n\nconst getFailedOperations: typeof _getFailedOperations = async () => {\n  const mod = await getWriteQueueModule()\n  return mod ? mod.getFailedOperations() : []\n}\n\n// BUG-1301: Recover stale syncing operations on startup/process cycle\nconst recoverStaleSyncing = async (): Promise<number> => {\n  const mod = await getWriteQueueModule()\n  return mod ? mod.recoverStaleSyncing() : 0\n}\n\nconst clearFailedOperations = async (): Promise<number> => {\n  const mod = await getWriteQueueModule()\n  if (!mod) return 0\n  const count = await mod.clearFailedOperations()\n\n  // BUG-1179: Force clear all error state immediately\n  state.value.lastError = undefined\n  state.value.failedCount = 0\n  state.value.failedOperations = []\n\n  // Then verify with fresh stats\n  const stats = await getStats()\n\n  // Only set to synced if truly clean\n  if (stats.failedCount === 0 && stats.conflictCount === 0 && stats.pendingCount === 0 && stats.syncingCount === 0) {\n    state.value.status = 'synced'\n  } else {\n    await updateStatus()\n  }\n\n  return count\n}\nimport {\n  calculateNextRetryTime,\n  shouldRetry,\n  classifyError,\n  getRetryConfigForError\n} from '@/services/offline/retryStrategy'\nimport { coalesceOperationsForEntity } from '@/services/offline/operationCoalescer'\nimport { sortOperations } from '@/services/offline/operationSorter'\nimport { supabase } from '@/services/auth/supabase'\n\n// Singleton state (shared across all components using this composable)\nconst state = ref<SyncState>({\n  status: 'synced',\n  pendingCount: 0,\n  failedCount: 0,\n  lastSyncAt: undefined,\n  lastError: undefined,\n  isOnline: typeof navigator !== 'undefined' ? navigator.onLine : true,\n  failedOperations: []\n})\n\n// Processing state\nconst isProcessing = ref(false)\nconst processIntervalId = ref<ReturnType<typeof setInterval> | null>(null)\nconst PROCESS_INTERVAL_MS = 5000 // Check queue every 5 seconds\n\n// Online/offline listeners (set up once)\nlet listenersSetUp = false\n\n/**\n * Set up online/offline event listeners\n */\nfunction setupOnlineListeners() {\n  if (listenersSetUp || typeof window === 'undefined') return\n\n  const handleOnline = () => {\n    if (import.meta.env.DEV) {\n      console.log('[SYNC] Network online - resuming sync')\n    }\n    state.value.isOnline = true\n    updateStatus()\n    // Trigger immediate sync attempt\n    processQueue()\n  }\n\n  const handleOffline = () => {\n    if (import.meta.env.DEV) {\n      console.log('[SYNC] Network offline - pausing sync')\n    }\n    state.value.isOnline = false\n    updateStatus()\n  }\n\n  window.addEventListener('online', handleOnline)\n  window.addEventListener('offline', handleOffline)\n  listenersSetUp = true\n}\n\n/**\n * Update the overall sync status based on current state\n */\nasync function updateStatus() {\n  const stats = await getStats()\n\n  state.value.pendingCount = stats.pendingCount + stats.syncingCount\n  // BUG-1179: Include conflicts in error count so UI shows correct number\n  state.value.failedCount = stats.failedCount + stats.conflictCount\n\n  // TASK-1177: Populate failedOperations array for UI display\n  if (stats.failedCount > 0) {\n    state.value.failedOperations = await getFailedOperations()\n  } else {\n    state.value.failedOperations = []\n  }\n\n  if (!state.value.isOnline) {\n    state.value.status = 'offline'\n  } else if (stats.failedCount > 0 || stats.conflictCount > 0) {\n    state.value.status = 'error'\n  } else if (stats.syncingCount > 0) {\n    state.value.status = 'syncing'\n  } else if (stats.pendingCount > 0) {\n    state.value.status = 'pending'\n  } else {\n    state.value.status = 'synced'\n  }\n}\n\n/**\n * Execute a single sync operation against Supabase\n */\nasync function executeOperation(operation: WriteOperation): Promise<SyncResult> {\n  const { entityType, entityId, payload } = operation\n\n  // Map entity type to Supabase table name\n  const tableMap: Record<SyncEntityType, string> = {\n    task: 'tasks',\n    group: 'groups',\n    project: 'projects',\n    timer_session: 'timer_sessions'\n  }\n  const tableName = tableMap[entityType]\n\n  try {\n    let result\n\n    switch (operation.operation) {\n      case 'create': {\n        const insertData = { id: entityId, ...payload }\n        // BUG-1212: Use upsert instead of insert to handle duplicate key gracefully.\n        // When the direct save (createTask → saveSpecificTasks) succeeds before the\n        // sync queue processes, the row already exists. Using upsert makes this\n        // idempotent — matching the pattern in useSupabaseDatabase.ts saveTask/saveTasks.\n        if (import.meta.env.DEV) {\n          console.debug(`🔄 [SYNC] CREATE via upsert for ${entityType}:${entityId} (idempotent)`)\n        }\n        result = await supabase.from(tableName).upsert(insertData, { onConflict: 'id' }).select()\n        break\n      }\n\n      case 'update': {\n        // TASK-1183: Auto-resolve version conflicts with Last-Write-Wins (LWW)\n        // For personal productivity apps, LWW is sufficient - no multi-user collaboration\n        //\n        // Strategy:\n        // 1. Try update with optimistic lock first\n        // 2. If 0 rows returned (version conflict), fetch server state\n        // 3. If server timestamp < our timestamp, force update (our change wins)\n        // 4. If server timestamp > our timestamp, server wins - discard our change\n\n        let query = supabase.from(tableName).update(payload).eq('id', entityId)\n\n        if (operation.baseVersion !== undefined) {\n          // Optimistic lock using position_version\n          query = query.eq('position_version', operation.baseVersion)\n        }\n\n        result = await query.select()\n\n        // Check for version conflict (no rows updated)\n        if (!result.error && (!result.data || result.data.length === 0)) {\n          if (import.meta.env.DEV) {\n            console.debug(`[SYNC] Version conflict detected for ${entityType}:${entityId}, attempting LWW resolution`)\n          }\n\n          // Fetch current server state\n          const serverState = await supabase\n            .from(tableName)\n            .select('*')\n            .eq('id', entityId)\n            .single()\n\n          if (serverState.error) {\n            // BUG-1211 FIX: Entity not found — likely deleted on another device.\n            // Mark as success to remove from queue (can't update a deleted entity),\n            // but log prominently so this is visible in debugging.\n            if (serverState.error.code === 'PGRST116') {\n              console.warn(`⚠️ [SYNC] Entity ${entityType}:${entityId} not found on server (deleted on another device?). Queued update discarded — data in this update is lost.`)\n              return {\n                success: true,\n                operation\n              }\n            }\n            throw serverState.error\n          }\n\n          // Last-Write-Wins: Compare timestamps\n          const serverUpdatedAt = new Date(serverState.data.updated_at).getTime()\n          const localUpdatedAt = payload.updated_at\n            ? new Date(payload.updated_at as string).getTime()\n            : Date.now()\n\n          if (localUpdatedAt >= serverUpdatedAt) {\n            // Our change is newer - force update without version check\n            if (import.meta.env.DEV) {\n              console.log(`[SYNC] LWW: Local wins (local=${new Date(localUpdatedAt).toISOString()}, server=${new Date(serverUpdatedAt).toISOString()})`)\n            }\n\n            const forceResult = await supabase\n              .from(tableName)\n              .update(payload)\n              .eq('id', entityId)\n              .select()\n\n            if (forceResult.error) {\n              throw forceResult.error\n            }\n\n            result = forceResult\n          } else {\n            // BUG-1211 FIX: Server change is newer — our local change is discarded.\n            // BUG-1320: Downgrade log for echo pattern (direct save + sync queue race).\n            // When delta < 2s, this is almost always the sync queue echoing a direct save\n            // that already succeeded — not a real conflict. Only warn for real conflicts.\n            const deltaMs = serverUpdatedAt - localUpdatedAt\n            const logFn = deltaMs < 2000 ? console.debug : console.warn\n            logFn(`⚠️ [SYNC] LWW: Server wins for ${entityType}:${entityId} (delta=${deltaMs}ms). Local change DISCARDED (local=${new Date(localUpdatedAt).toISOString()}, server=${new Date(serverUpdatedAt).toISOString()}).${deltaMs < 2000 ? ' [echo — direct save already applied]' : ' Local state will update on next sync.'}`)\n\n            return {\n              success: true,\n              operation,\n              serverData: serverState.data\n            }\n          }\n        }\n        break\n      }\n\n      case 'delete': {\n        // BUG-1211 FIX: Use correct DB column name `is_deleted` (not app-side `_soft_deleted`).\n        // The sync orchestrator bypasses supabaseMappers, so we must use DB column names directly.\n        // Previously used `_soft_deleted` which ALWAYS failed, causing fallback to hard DELETE\n        // which created permanent tombstones and broadcast realtime DELETE to all devices.\n        result = await supabase\n          .from(tableName)\n          .update({ is_deleted: true, deleted_at: new Date().toISOString() })\n          .eq('id', entityId)\n          .select()\n\n        // BUG-1211 FIX: Removed hard-delete fallback. If soft-delete fails, let the retry\n        // mechanism handle it. Hard deletes create permanent tombstones and are unrecoverable.\n        break\n      }\n    }\n\n    if (result.error) {\n      throw result.error\n    }\n\n    // Extract new version if available\n    const newVersion = result.data?.[0]?.position_version\n\n    return {\n      success: true,\n      operation,\n      newVersion\n    }\n  } catch (error) {\n    // Handle different error types - Supabase errors have a message property\n    let errorMessage: string\n    if (error instanceof Error) {\n      errorMessage = error.message\n    } else if (error && typeof error === 'object' && 'message' in error) {\n      // Supabase/Postgrest errors have message property\n      errorMessage = String((error as { message: unknown }).message)\n    } else if (error && typeof error === 'object') {\n      // Try to stringify the object\n      try {\n        errorMessage = JSON.stringify(error)\n      } catch {\n        errorMessage = 'Unknown error (object)'\n      }\n    } else {\n      errorMessage = String(error)\n    }\n    const classification = classifyError(error)\n    const retryConfig = getRetryConfigForError(classification)\n\n    return {\n      success: false,\n      operation,\n      error: errorMessage,\n      isConflict: classification === 'conflict',\n      shouldRetry: retryConfig !== null && shouldRetry(operation.retryCount, retryConfig)\n    }\n  }\n}\n\n/**\n * Process a single operation from the queue\n */\nasync function processOperation(operation: WriteOperation): Promise<void> {\n  if (!operation.id) return\n\n  // Mark as syncing\n  await markSyncing(operation.id)\n\n  // Execute the operation\n  const result = await executeOperation(operation)\n\n  if (result.success) {\n    // Success - mark completed\n    await markCompleted(operation.id)\n    state.value.lastSyncAt = Date.now()\n\n    // BUG-1321: When LWW \"server wins\", apply serverData back to Pinia store.\n    // Without this, the local store silently diverges from VPS truth.\n    if (result.serverData && operation.entityType === 'task') {\n      try {\n        const { fromSupabaseTask } = await import('@/utils/supabaseMappers')\n        const { useTaskStore } = await import('@/stores/tasks')\n        const taskStore = useTaskStore()\n        const mappedTask = fromSupabaseTask(result.serverData as unknown as Parameters<typeof fromSupabaseTask>[0])\n        taskStore.updateTaskFromSync(operation.entityId, mappedTask, false)\n        if (import.meta.env.DEV) {\n          console.log(`[SYNC] LWW server data applied to store for ${operation.entityId.slice(0, 8)}`)\n        }\n      } catch (e) {\n        console.warn(`[SYNC] Failed to apply LWW server data to store:`, e)\n      }\n    }\n\n    if (import.meta.env.DEV) {\n      console.log(`✅ [SYNC] ${operation.entityType}:${operation.operation} ${operation.entityId.slice(0, 8)} synced`)\n    }\n  } else if (result.isConflict) {\n    // Conflict - need resolution\n    await markConflict(operation.id, result.newVersion || 0)\n    state.value.lastError = result.error\n    console.warn(`⚠️ [SYNC] Conflict: ${operation.entityType}:${operation.entityId.slice(0, 8)}`)\n  } else if (result.shouldRetry) {\n    // Transient error - schedule retry\n    const nextRetryAt = calculateNextRetryTime(operation.retryCount)\n    await markFailed(operation.id, result.error || 'Unknown error', nextRetryAt)\n    console.warn(`⚠️ [SYNC] Retry scheduled: ${operation.entityType}:${operation.entityId.slice(0, 8)} in ${Math.round((nextRetryAt - Date.now()) / 1000)}s`)\n  } else {\n    // Permanent error - mark as failed (won't auto-retry)\n    await markFailed(operation.id, result.error || 'Permanent error', Date.now() + 365 * 24 * 60 * 60 * 1000) // Far future = won't auto-retry\n    state.value.lastError = result.error\n    console.error(`❌ [SYNC] Permanent failure: ${operation.entityType}:${operation.entityId.slice(0, 8)} - ${result.error}`)\n  }\n}\n\n/**\n * Process the queue of pending operations\n */\nasync function processQueue(): Promise<void> {\n  // Skip if already processing, offline, or no supabase\n  if (isProcessing.value || !state.value.isOnline || !supabase) {\n    return\n  }\n\n  isProcessing.value = true\n\n  try {\n    // BUG-1301: Recover operations stuck in 'syncing' from a previous session crash.\n    // These ops were marked 'syncing' but never completed — reset them to 'pending'\n    // so they can be retried. Without this, they're stuck forever because\n    // getPendingOperations() only returns 'pending' and 'failed'.\n    await recoverStaleSyncing()\n\n    // Get pending operations FIRST before setting status\n    const operations = await getPendingOperations()\n\n    if (operations.length === 0) {\n      // Clean up completed operations (silent, don't change status)\n      await cleanupCompleted()\n      // Only update status if currently in error or syncing state\n      if (state.value.status === 'syncing' || state.value.status === 'error') {\n        await updateStatus()\n      }\n      return\n    }\n\n    // Only set syncing if we actually have operations to process\n    state.value.status = 'syncing'\n\n    // Sort operations for correct execution order\n    const sorted = sortOperations(operations)\n\n    // Process operations sequentially for now\n    // TODO: Optimize with batching for independent operations\n    for (const operation of sorted) {\n      // Coalesce before syncing (merge multiple updates to same entity)\n      const coalesced = await coalesceOperationsForEntity(\n        operation.entityType,\n        operation.entityId\n      )\n\n      if (coalesced.operation) {\n        await processOperation(coalesced.operation)\n      }\n\n      // Check if we're still online\n      if (!state.value.isOnline) {\n        console.log('[SYNC] Went offline during sync, pausing')\n        break\n      }\n    }\n\n    // Clean up completed operations\n    await cleanupCompleted()\n  } catch (error) {\n    console.error('[SYNC] Queue processing error:', error)\n    state.value.lastError = error instanceof Error ? error.message : String(error)\n  } finally {\n    isProcessing.value = false\n    await updateStatus()\n  }\n}\n\n/**\n * Start the sync processing loop\n */\nfunction startProcessing(): void {\n  if (processIntervalId.value) return\n\n  setupOnlineListeners()\n\n  // Initial status update\n  updateStatus()\n\n  // Process immediately\n  processQueue()\n\n  // Then process periodically\n  processIntervalId.value = setInterval(processQueue, PROCESS_INTERVAL_MS)\n}\n\n/**\n * Stop the sync processing loop\n */\nfunction stopProcessing(): void {\n  if (processIntervalId.value) {\n    clearInterval(processIntervalId.value)\n    processIntervalId.value = null\n  }\n}\n\n// Track whether the global sync loop has been started (prevents interval stacking on HMR/re-init)\nlet globalSyncStarted = false\n\n/**\n * Main composable export\n */\nexport function useSyncOrchestrator() {\n  // Guard against interval stacking: only start once globally\n  if (!globalSyncStarted) {\n    globalSyncStarted = true\n    startProcessing()\n  }\n\n  /**\n   * Enqueue a write operation for sync\n   *\n   * This is the main entry point for the offline-first system.\n   * Call this instead of directly calling Supabase.\n   */\n  const enqueue = async (\n    operation: {\n      entityType: SyncEntityType\n      operation: SyncOperationType\n      entityId: string\n      payload: Record<string, unknown>\n      baseVersion?: number\n    }\n  ): Promise<WriteOperation> => {\n    // Get current user ID\n    let userId: string | undefined\n    try {\n      const { useAuthStore } = await import('@/stores/auth')\n      const authStore = useAuthStore()\n      userId = authStore.user?.id\n    } catch {\n      // Auth store not available\n    }\n\n    // Enqueue the operation\n    const queued = await enqueueOperation({\n      ...operation,\n      userId\n    })\n\n    console.log(`📝 [SYNC] Queued: ${operation.entityType}:${operation.operation} ${operation.entityId.slice(0, 8)}`)\n\n    // Update status\n    await updateStatus()\n\n    // Trigger immediate processing if online\n    if (state.value.isOnline && !isProcessing.value) {\n      processQueue()\n    }\n\n    return queued\n  }\n\n  /**\n   * Force retry all failed operations\n   */\n  const retryFailed = async (): Promise<void> => {\n    console.log('[SYNC] Manual retry of failed operations')\n\n    // Get all failed operations and reset their retry time\n    const operations = await getPendingOperations(100)\n    const failed = operations.filter(op => op.status === 'failed')\n\n    for (const op of failed) {\n      if (op.id) {\n        await import('@/services/offline/writeQueueDB').then(({ updateOperation }) =>\n          updateOperation(op.id!, {\n            status: 'pending',\n            nextRetryAt: undefined\n          })\n        )\n      }\n    }\n\n    // Trigger immediate processing\n    await processQueue()\n  }\n\n  /**\n   * Get current sync stats\n   */\n  const getQueueStats = async () => {\n    return getStats()\n  }\n\n  return {\n    // State\n    status: computed(() => state.value.status),\n    pendingCount: computed(() => state.value.pendingCount),\n    failedCount: computed(() => state.value.failedCount),\n    lastSyncAt: computed(() => state.value.lastSyncAt),\n    lastError: computed(() => state.value.lastError),\n    isOnline: computed(() => state.value.isOnline),\n    isProcessing: computed(() => isProcessing.value),\n\n    // Derived\n    hasPendingChanges: computed(() => state.value.pendingCount > 0 || state.value.status === 'syncing'),\n    hasErrors: computed(() => state.value.failedCount > 0 || state.value.status === 'error'),\n\n    // Actions\n    enqueue,\n    retryFailed,\n    clearFailed: clearFailedOperations,\n    getQueueStats,\n    forceSync: processQueue\n  }\n}\n\n/**\n * Export state for direct access (e.g., from stores)\n */\nexport const syncState = state\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/sync/useTimerLeaderElection.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[209,212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[209,212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3183,3186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3183,3186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\n\ninterface TimerLeaderState {\n    leaderId: string\n    lastHeartbeat: number\n    sessionState: unknown\n}\n\ninterface LeaderElectionDeps {\n    tabId: string\n    broadcastMessage: (msg: any) => void\n    onBecomeLeader?: () => void\n    onLoseLeadership?: () => void\n    onSessionUpdate?: (session: unknown) => void\n}\n\nexport function useTimerLeaderElection(deps: LeaderElectionDeps) {\n    const { tabId, broadcastMessage, onBecomeLeader, onLoseLeadership, onSessionUpdate } = deps\n\n    const leaderState = ref<TimerLeaderState | null>(null)\n    const isLeader = ref(false)\n\n    const HEARTBEAT_INTERVAL = 2000\n    const LEADER_TIMEOUT = 5000\n\n    let heartbeatTimer: ReturnType<typeof setInterval> | null = null\n\n    const isLeaderAlive = (): boolean => {\n        if (!leaderState.value) return false\n        return Date.now() - leaderState.value.lastHeartbeat < LEADER_TIMEOUT\n    }\n\n    const claimLeadership = (): boolean => {\n        // BUG-294: Add logging to diagnose leadership blocking\n        console.log('🗳️ [LEADER] claimLeadership called', {\n            tabId,\n            hasLeaderState: !!leaderState.value,\n            currentLeaderId: leaderState.value?.leaderId,\n            isLeaderAlive: leaderState.value ? isLeaderAlive() : 'N/A',\n            timeSinceHeartbeat: leaderState.value\n                ? Math.round((Date.now() - leaderState.value.lastHeartbeat) / 1000) + 's'\n                : 'N/A'\n        })\n\n        if (leaderState.value && isLeaderAlive() && leaderState.value.leaderId !== tabId) {\n            console.warn('🗳️ [LEADER] Blocked: Another tab is leading', {\n                leaderId: leaderState.value.leaderId,\n                heartbeatAge: Math.round((Date.now() - leaderState.value.lastHeartbeat) / 1000) + 's',\n                timeout: LEADER_TIMEOUT / 1000 + 's'\n            })\n            return false\n        }\n\n        leaderState.value = {\n            leaderId: tabId,\n            lastHeartbeat: Date.now(),\n            sessionState: leaderState.value?.sessionState || null\n        }\n        isLeader.value = true\n\n        broadcastMessage({\n            action: 'claim_leadership',\n            leaderId: tabId,\n            sessionState: leaderState.value.sessionState,\n            timestamp: Date.now()\n        })\n\n        startHeartbeat()\n\n        if (onBecomeLeader) {\n            onBecomeLeader()\n        }\n\n        console.log('🗳️ [LEADER] Leadership claimed successfully')\n        return true\n    }\n\n    const startHeartbeat = () => {\n        stopHeartbeat()\n        heartbeatTimer = setInterval(() => {\n            if (isLeader.value && leaderState.value) {\n                leaderState.value.lastHeartbeat = Date.now()\n                broadcastMessage({\n                    action: 'heartbeat',\n                    leaderId: tabId,\n                    sessionState: leaderState.value.sessionState,\n                    timestamp: Date.now()\n                })\n            }\n        }, HEARTBEAT_INTERVAL)\n    }\n\n    const stopHeartbeat = () => {\n        if (heartbeatTimer) {\n            clearInterval(heartbeatTimer)\n            heartbeatTimer = null\n        }\n    }\n\n    const handleLeaderMessage = (sync: any) => {\n        switch (sync.action) {\n            case 'claim_leadership':\n                if (sync.leaderId !== tabId) {\n                    if (isLeader.value) {\n                        isLeader.value = false\n                        stopHeartbeat()\n                        if (onLoseLeadership) {\n                            onLoseLeadership()\n                        }\n                    }\n\n                    leaderState.value = {\n                        leaderId: sync.leaderId,\n                        lastHeartbeat: sync.timestamp,\n                        sessionState: sync.sessionState\n                    }\n\n                    if (sync.sessionState && onSessionUpdate) {\n                        onSessionUpdate(sync.sessionState)\n                    }\n                }\n                break\n\n            case 'heartbeat':\n                if (leaderState.value && sync.leaderId === leaderState.value.leaderId) {\n                    leaderState.value.lastHeartbeat = sync.timestamp\n                    leaderState.value.sessionState = sync.sessionState\n\n                    if (!isLeader.value && sync.sessionState && onSessionUpdate) {\n                        onSessionUpdate(sync.sessionState)\n                    }\n                }\n                break\n\n            case 'session_update':\n                if (leaderState.value) {\n                    leaderState.value.sessionState = sync.sessionState\n                    leaderState.value.lastHeartbeat = sync.timestamp\n                }\n\n                if (!isLeader.value && onSessionUpdate) {\n                    onSessionUpdate(sync.sessionState)\n                }\n                break\n\n            case 'session_stop':\n                if (leaderState.value) {\n                    leaderState.value.sessionState = null\n                }\n\n                if (!isLeader.value && onSessionUpdate) {\n                    onSessionUpdate(null)\n                }\n                break\n        }\n    }\n\n    const cleanup = () => {\n        stopHeartbeat()\n        isLeader.value = false\n    }\n\n    return {\n        isLeader,\n        leaderState,\n        claimLeadership,\n        handleLeaderMessage,\n        cleanup\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/card/useTaskCardActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[239,242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[239,242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport { type Task } from '@/stores/tasks'\nimport { useTaskStore } from '@/stores/tasks'\n\nexport function useTaskCardActions(\n    props: { task: Task; disabled?: boolean },\n    emit: (event: string, ...args: any[]) => void,\n    state: {\n        isExpanded: Ref<boolean>\n        isFocused: Ref<boolean>\n        isPressed: Ref<boolean>\n        isSelected: Ref<boolean>\n        cardRef: Ref<HTMLElement | null>\n        progressiveDisclosureEnabled: Ref<boolean>\n    }\n) {\n    const taskStore = useTaskStore()\n\n    // --- Handlers ---\n\n    const handleCardClick = (event: MouseEvent) => {\n        if (props.disabled) return\n        event.preventDefault()\n\n        if (state.progressiveDisclosureEnabled.value) {\n            state.isExpanded.value = !state.isExpanded.value\n        } else {\n            handleSelectionClick(event)\n        }\n    }\n\n    const handleSelectionClick = (event: MouseEvent) => {\n        if (event.ctrlKey || event.metaKey) {\n            // Multi-select toggle\n            if (state.isSelected.value) {\n                taskStore.deselectTask(props.task.id)\n            } else {\n                taskStore.selectTask(props.task.id)\n            }\n        } else {\n            // Single select\n            taskStore.clearSelection()\n            emit('select', props.task.id)\n        }\n    }\n\n    const handleKeydown = (event: KeyboardEvent) => {\n        if (props.disabled) return\n\n        switch (event.key) {\n            case 'Enter':\n            case ' ': {\n                event.preventDefault()\n                state.isPressed.value = true\n\n                // Synthetic click for consistent behavior\n                const syntheticEvent = new MouseEvent('click', {\n                    bubbles: true,\n                    cancelable: true,\n                    view: window\n                })\n                handleCardClick(syntheticEvent)\n\n                setTimeout(() => {\n                    state.isPressed.value = false\n                }, 150)\n                break\n            }\n\n            case 'ArrowRight':\n            case 'ArrowDown': {\n                event.preventDefault()\n                // Try to focus the status button\n                const statusButton = state.cardRef.value?.querySelector('.status-icon-button') as HTMLElement\n                statusButton?.focus()\n                break\n            }\n\n            case 'e':\n            case 'E':\n                if (!event.ctrlKey && !event.metaKey) {\n                    event.preventDefault()\n                    emit('edit', props.task.id)\n                }\n                break\n\n            case 't':\n            case 'T':\n                if (!event.ctrlKey && !event.metaKey) {\n                    event.preventDefault()\n                    emit('startTimer', props.task.id)\n                }\n                break\n\n            case 'Delete':\n            case 'Backspace':\n                event.preventDefault()\n                emit('delete', props.task.id)\n                break\n        }\n    }\n\n    const handleFocus = (event: FocusEvent) => {\n        state.isFocused.value = true\n        emit('focus', event)\n    }\n\n    const handleBlur = (event: FocusEvent) => {\n        state.isFocused.value = false\n        emit('blur', event)\n    }\n\n    const handleRightClick = (event: MouseEvent) => {\n        emit('contextMenu', event, props.task)\n    }\n\n    // --- Status Logic ---\n\n    const cycleStatus = () => {\n        const statusCycle: Task['status'][] = ['planned', 'in_progress', 'done', 'backlog', 'on_hold']\n        const currentStatus = props.task.status || 'backlog'\n        const currentIndex = statusCycle.indexOf(currentStatus)\n        const nextStatus = statusCycle[(currentIndex + 1) % statusCycle.length]\n\n        emit('select', props.task.id)\n        taskStore.updateTask(props.task.id, { status: nextStatus })\n    }\n\n    return {\n        handleCardClick,\n        handleKeydown,\n        handleFocus,\n        handleBlur,\n        handleRightClick,\n        cycleStatus\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/card/useTaskCardState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/row/useTaskRowActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[288,291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[288,291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[512,515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[512,515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":166,"column":17,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":166,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref } from 'vue'\nimport type { Task } from '@/stores/tasks'\nimport { useDragAndDrop, type DragData } from '@/composables/useDragAndDrop'\n\nexport function useTaskRowActions(\n    props: { task: Task; indentLevel: number; hasSubtasks: boolean; isExpanded: boolean },\n    emit: any,\n    state: {\n        isDragging: Ref<boolean>\n        isDropTarget: Ref<boolean>\n        isFocused: Ref<boolean>\n        isHovered: Ref<boolean>\n        showTouchFeedback?: Ref<boolean>\n        touchFeedbackStyle?: Ref<any>\n    }\n) {\n    const { startDrag, endDrag } = useDragAndDrop()\n\n    // --- Drag and Drop ---\n\n    const handleDragStart = (event: DragEvent) => {\n        if (!event.dataTransfer) return\n\n        state.isDragging.value = true\n\n        const dragData: DragData = {\n            type: 'task',\n            taskId: props.task.id,\n            title: props.task.title,\n            source: 'kanban' // Using kanban/list as generic source\n        }\n\n        startDrag(dragData)\n        event.dataTransfer.setData('application/json', JSON.stringify(dragData))\n        event.dataTransfer.effectAllowed = 'move'\n    }\n\n    const handleDragEnd = () => {\n        state.isDragging.value = false\n        state.isDropTarget.value = false\n        endDrag()\n    }\n\n    const handleDragOver = (event: DragEvent) => {\n        event.preventDefault()\n        state.isDropTarget.value = true\n        if (event.dataTransfer) {\n            event.dataTransfer.dropEffect = 'move'\n        }\n    }\n\n    const handleDragLeave = () => {\n        state.isDropTarget.value = false\n    }\n\n    const handleDrop = (event: DragEvent) => {\n        event.preventDefault()\n        state.isDropTarget.value = false\n\n        const dataString = event.dataTransfer?.getData('application/json')\n        if (!dataString) return\n\n        try {\n            const dragData = JSON.parse(dataString) as DragData\n            if (dragData.type === 'task' && dragData.taskId && dragData.taskId !== props.task.id) {\n                // Dropped task becomes a subtask of this task\n                emit('moveTask', dragData.taskId, props.task.projectId || null, props.task.id)\n            }\n        } catch (error) {\n            console.error('Failed to parse drag data:', error)\n        }\n    }\n\n    // --- User Interactions ---\n\n    const handleRowClick = () => {\n        emit('select', props.task.id)\n    }\n\n    const handleToggleComplete = () => {\n        emit('toggleComplete', props.task.id)\n    }\n\n    const toggleExpanded = () => {\n        if (props.hasSubtasks) {\n            emit('toggleExpand', props.task.id)\n        }\n    }\n\n    // --- Keyboard & Focus ---\n\n    const handleFocusIn = () => {\n        state.isFocused.value = true\n    }\n\n    const handleFocusOut = () => {\n        state.isFocused.value = false\n    }\n\n    const handleMouseEnter = () => {\n        state.isHovered.value = true\n    }\n\n    const handleMouseLeave = () => {\n        state.isHovered.value = false\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n        switch (event.key) {\n            case 'Enter':\n            case ' ':\n                event.preventDefault()\n                handleRowClick()\n                break\n            case 'ArrowRight':\n                if (props.hasSubtasks && !props.isExpanded) {\n                    event.preventDefault()\n                    toggleExpanded()\n                }\n                break\n            case 'ArrowLeft':\n                if (props.hasSubtasks && props.isExpanded) {\n                    event.preventDefault()\n                    toggleExpanded()\n                }\n                break\n            case 'd':\n                if (event.ctrlKey || event.metaKey) {\n                    event.preventDefault()\n                    emit('toggleComplete', props.task.id)\n                }\n                break\n            case 'e':\n                if (event.ctrlKey || event.metaKey) {\n                    event.preventDefault()\n                    emit('edit', props.task.id)\n                }\n                break\n        }\n    }\n\n    // --- Touch Support ---\n\n    const handleTouchStart = (event: TouchEvent) => {\n        // Only applied if checkMobile was true in state (logic handled there or by consumer)\n        // We'll leave the conditional check to the template or strict mobile mode\n        // but here we just provide the handler logic\n\n        // Simple feedback logic reuse if provided\n        if (state.showTouchFeedback && state.touchFeedbackStyle) {\n            const touch = event.touches[0]\n            const rect = (event.currentTarget as HTMLElement)?.getBoundingClientRect()\n            if (rect) {\n                state.touchFeedbackStyle.value = {\n                    left: `${touch.clientX - rect.left}px`,\n                    top: `${touch.clientY - rect.top}px`\n                }\n                state.showTouchFeedback.value = true\n            }\n        }\n    }\n\n    const handleTouchEnd = () => {\n        if (state.showTouchFeedback) {\n            setTimeout(() => {\n                state.showTouchFeedback!.value = false\n            }, 200)\n        }\n    }\n\n    // --- Action Wrapper Helpers ---\n\n    const updateTaskStatus = (taskId: string, status: string) => {\n        emit('updateTask', taskId, { status })\n    }\n\n    const cyclePriority = (taskId: string, currentPriority?: string | null) => {\n        const priorities = ['low', 'medium', 'high'] as const\n        const currentIndex = priorities.indexOf((currentPriority || 'medium') as typeof priorities[number])\n        const nextIndex = (currentIndex + 1) % priorities.length\n        emit('updateTask', taskId, { priority: priorities[nextIndex] })\n    }\n\n    return {\n        handleDragStart,\n        handleDragEnd,\n        handleDragOver,\n        handleDragLeave,\n        handleDrop,\n        handleRowClick,\n        handleToggleComplete,\n        toggleExpanded,\n        handleFocusIn,\n        handleFocusOut,\n        handleMouseEnter,\n        handleMouseLeave,\n        handleKeyDown,\n        handleTouchStart,\n        handleTouchEnd,\n        updateTaskStatus,\n        cyclePriority\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/row/useTaskRowState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskContextMenuActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[666,669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[666,669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1680,1683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1680,1683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5566,5569],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5566,5569],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { computed } from 'vue'\nimport { useRouter } from 'vue-router'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useCanvasStore } from '@/stores/canvas'\nimport type { Task } from '@/stores/tasks'\n\n// Dispatch event to trigger brief flash animation on task card\nfunction flashTaskCard(taskId: string): void {\n    console.log('[FLASH] Dispatching task-action-flash for:', taskId)\n    window.dispatchEvent(new CustomEvent('task-action-flash', { detail: { taskId } }))\n}\n\nexport function useTaskContextMenuActions(\n    props: { task: Task | null; contextTask?: Task | null; selectedCount?: number },\n    emit: any\n) {\n    const taskStore = useTaskStore()\n    const timerStore = useTimerStore()\n    const canvasStore = useCanvasStore()\n    const router = useRouter()\n\n    const currentTask = computed(() => props.contextTask || props.task)\n    const isBatchOperation = computed(() => (props.selectedCount || 0) > 1)\n\n    const handleEdit = () => {\n        if (currentTask.value && !isBatchOperation.value) {\n            emit('edit', currentTask.value.id)\n        }\n        emit('close')\n    }\n\n    const setDueDate = async (dateType: string, customDate?: string) => {\n        // BUG-1184: Capture task data BEFORE closing menu (same pattern as BUG-1090)\n        // When emit('close') is called, parent sets props to null, making currentTask.value null\n        const taskId = currentTask.value?.id\n        const isBatch = isBatchOperation.value\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n        emit('close')\n\n        if (!taskId) return\n\n        if (isBatch) {\n            emit('setDueDate', dateType as any)\n            return\n        }\n\n        // Handle custom date from date picker\n        if (dateType === 'custom' && customDate) {\n            try {\n                await taskStore.updateTaskWithUndo(taskId, { dueDate: customDate })\n                canvasStore.requestSync('user:context-menu')\n                flashTaskCard(taskId)\n            } catch (error) {\n                console.error('Error updating task due date:', error)\n            }\n            return\n        }\n\n        const today = new Date()\n        let dueDate: Date | null = null\n\n        switch (dateType) {\n            case 'today':\n                dueDate = today\n                break\n            case 'tomorrow':\n                dueDate = new Date(today)\n                dueDate.setDate(today.getDate() + 1)\n                break\n            case 'weekend': {\n                dueDate = new Date(today)\n                const daysUntilSaturday = (6 - today.getDay()) % 7 || 7\n                dueDate.setDate(today.getDate() + daysUntilSaturday)\n                break\n            }\n            case 'nextweek': {\n                // BUG-1065 FIX: \"+1wk\" should add exactly 7 days, not find \"next Monday\"\n                dueDate = new Date(today)\n                dueDate.setDate(today.getDate() + 7)\n                break\n            }\n            case 'nextmonth': {\n                dueDate = new Date(today)\n                dueDate.setMonth(today.getMonth() + 1)\n                break\n            }\n            case 'twomonths': {\n                dueDate = new Date(today)\n                dueDate.setMonth(today.getMonth() + 2)\n                break\n            }\n            case 'nextquarter': {\n                dueDate = new Date(today)\n                dueDate.setMonth(today.getMonth() + 3)\n                break\n            }\n            case 'halfyear': {\n                dueDate = new Date(today)\n                dueDate.setMonth(today.getMonth() + 6)\n                break\n            }\n            case 'custom': {\n                // Custom date provided from date picker (second parameter)\n                // This is handled by the component passing the formatted date\n                return\n            }\n            default:\n                return\n        }\n\n        if (dueDate) {\n            try {\n                // Use ISO date format (YYYY-MM-DD) for Supabase compatibility\n                const formattedDate = dueDate.toISOString().split('T')[0]\n                await taskStore.updateTaskWithUndo(taskId, { dueDate: formattedDate })\n                canvasStore.requestSync('user:context-menu')\n                flashTaskCard(taskId)\n            } catch (error) {\n                console.error('Error setting due date:', error)\n            }\n        }\n    }\n\n    const setPriority = async (priority: 'high' | 'medium' | 'low') => {\n        // BUG-1184: Capture task data BEFORE closing menu (same pattern as BUG-1090)\n        const taskId = currentTask.value?.id\n        const isBatch = isBatchOperation.value\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n        emit('close')\n\n        if (isBatch) {\n            emit('setPriority', priority)\n        } else if (taskId) {\n            try {\n                await taskStore.updateTaskWithUndo(taskId, { priority })\n                canvasStore.requestSync('user:context-menu')\n            } catch (error) {\n                console.error('Error setting priority:', error)\n            }\n        }\n    }\n\n    const setStatus = async (status: 'planned' | 'in_progress' | 'done' | 'backlog' | 'on_hold') => {\n        // BUG-1184: Capture task data BEFORE closing menu (same pattern as BUG-1090)\n        const taskId = currentTask.value?.id\n        const isBatch = isBatchOperation.value\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n        emit('close')\n\n        if (isBatch) {\n            emit('setStatus', status as any)\n        } else if (taskId) {\n            try {\n                await taskStore.updateTaskWithUndo(taskId, { status })\n                canvasStore.requestSync('user:context-menu')\n            } catch (error) {\n                console.error('Error setting status:', error)\n            }\n        }\n    }\n\n    const setDuration = async (duration: number | null) => {\n        // BUG-1184: Capture task data BEFORE closing menu (same pattern as BUG-1090)\n        const taskId = currentTask.value?.id\n        const isBatch = isBatchOperation.value\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" submenu\n        emit('close')\n\n        if (isBatch) {\n            emit('setDuration', duration)\n        } else if (taskId) {\n            try {\n                await taskStore.updateTaskWithUndo(taskId, { estimatedDuration: duration ?? undefined })\n                canvasStore.requestSync('user:context-menu')\n            } catch (error) {\n                console.error('Error setting estimated duration:', error)\n            }\n        }\n    }\n\n    const toggleDone = async () => {\n        // BUG-1184: Capture task data BEFORE closing menu (same pattern as BUG-1090)\n        const taskId = currentTask.value?.id\n        const currentStatus = currentTask.value?.status\n        const isBatch = isBatchOperation.value\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n        emit('close')\n\n        if (isBatch) {\n            emit('setStatus', 'done')\n        } else if (taskId) {\n            const newStatus = currentStatus === 'done' ? 'planned' : 'done'\n            try {\n                await taskStore.updateTaskWithUndo(taskId, { status: newStatus })\n                canvasStore.requestSync('user:context-menu')\n            } catch (error) {\n                console.error('Error toggling done status:', error)\n            }\n        }\n    }\n\n    const startTaskNow = async () => {\n        // BUG-1090: Capture task data BEFORE closing menu\n        // When emit('close') is called, parent sets props to null, making currentTask.value null\n        const taskId = currentTask.value?.id\n        const taskTitle = currentTask.value?.title\n        const isBatch = isBatchOperation.value\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n        emit('close')\n\n        console.log('🎯 [CONTEXT-MENU] startTaskNow called', {\n            taskId,\n            taskTitle,\n            isBatch\n        })\n\n        if (taskId && !isBatch) {\n            // Step 1: Create calendar instance at current time\n            // BUG-1291: startTaskNow APPENDS (never replaces), so existing instances are preserved.\n            // No guard needed — append logic is the protection against the \"start time moves\" bug.\n            try {\n                console.log('🎯 [CONTEXT-MENU] Creating calendar instance at current time...')\n                await taskStore.startTaskNowWithUndo(taskId)\n                console.log('🎯 [CONTEXT-MENU] Task instance created successfully')\n            } catch (error) {\n                console.error('🎯 [CONTEXT-MENU] Failed to create calendar instance:', error)\n            }\n\n            // Step 2: Always start timer (independent of instance creation)\n            try {\n                console.log('🎯 [CONTEXT-MENU] Starting timer...')\n                await timerStore.startTimer(taskId, timerStore.settings.workDuration, false)\n                console.log('🎯 [CONTEXT-MENU] Timer started successfully')\n            } catch (error) {\n                console.error('🎯 [CONTEXT-MENU] Failed to start timer:', error)\n            }\n\n            // Step 3: Navigate to calendar\n            try {\n                if (router.currentRoute.value.name !== 'calendar') {\n                    console.log('🎯 [CONTEXT-MENU] Navigating to calendar with startNow param')\n                    await router.push({ path: '/calendar', query: { startNow: 'true' } })\n                } else {\n                    console.log('🎯 [CONTEXT-MENU] Already on calendar, dispatching event')\n                    window.dispatchEvent(new CustomEvent('start-task-now', {\n                        detail: { taskId }\n                    }))\n                }\n            } catch (error) {\n                console.error('🎯 [CONTEXT-MENU] Navigation failed:', error)\n            }\n        } else {\n            console.warn('🎯 [CONTEXT-MENU] startTaskNow skipped:', {\n                hasTaskId: !!taskId,\n                isBatch\n            })\n        }\n    }\n\n    const startTimer = async () => {\n        // BUG-1090: Capture task data BEFORE closing menu\n        // When emit('close') is called, parent sets props to null, making currentTask.value null\n        const taskId = currentTask.value?.id\n        const taskTitle = currentTask.value?.title\n        const isBatch = isBatchOperation.value\n        const workDuration = timerStore.settings.workDuration\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n        emit('close')\n\n        console.log('🎯 [CONTEXT-MENU] startTimer called', {\n            taskId,\n            taskTitle,\n            isBatch,\n            workDuration\n        })\n\n        if (taskId && !isBatch) {\n            // BUG-1051: AWAIT for timer sync\n            await timerStore.startTimer(taskId, workDuration, false)\n        } else {\n            console.warn('🎯 [CONTEXT-MENU] Timer not started:', {\n                hasTaskId: !!taskId,\n                isBatch\n            })\n        }\n    }\n\n    const duplicateTask = async () => {\n        // BUG-1184: Capture task data BEFORE closing menu (same pattern as BUG-1090)\n        const taskData = currentTask.value ? {\n            title: currentTask.value.title,\n            description: currentTask.value.description,\n            status: currentTask.value.status,\n            priority: currentTask.value.priority\n        } : null\n        const isBatch = isBatchOperation.value\n\n        // BUG-1095: Close menu FIRST to prevent \"stuck\" menu\n        emit('close')\n\n        if (taskData && !isBatch) {\n            try {\n                await taskStore.createTaskWithUndo({\n                    title: taskData.title + ' (Copy)',\n                    description: taskData.description,\n                    status: taskData.status,\n                    priority: taskData.priority\n                })\n            } catch (error) {\n                console.error('Error duplicating task:', error)\n            }\n        }\n    }\n\n    const deleteTask = () => {\n        if (isBatchOperation.value) {\n            emit('deleteSelected')\n        } else if (currentTask.value) {\n            const taskData = currentTask.value as unknown as { instanceId?: string; isCalendarEvent?: boolean }\n            emit('confirmDelete', currentTask.value.id, taskData.instanceId, taskData.isCalendarEvent)\n        }\n        emit('close')\n    }\n\n    const clearSelection = () => {\n        emit('clearSelection')\n        emit('close')\n    }\n\n    return {\n        currentTask,\n        isBatchOperation,\n        handleEdit,\n        setDueDate,\n        setPriority,\n        setStatus,\n        setDuration,\n        toggleDone,\n        startTaskNow,\n        startTimer,\n        duplicateTask,\n        deleteTask,\n        clearSelection\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskEditActions.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":139,"column":52,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":139,"endColumn":69},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":226,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8908,8911],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8908,8911],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9219,9222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9219,9222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":234,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9304,9307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9304,9307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[571,574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[571,574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[669,672],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[669,672],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8093,8096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8093,8096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11575,11578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11575,11578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":300,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":300,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12680,12683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12680,12683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Ref, type ComputedRef } from 'vue'\nimport { useTaskStore, type Task, type Subtask } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useCanvasUiStore } from '@/stores/canvas/canvasUi'\nimport { generateRecurringInstances } from '@/utils/recurrenceUtils'\nimport { getUndoSystem } from '@/composables/undoSingleton'\nimport { useToast } from '@/composables/useToast'\n\n\n// Helper for cleaning task instances (from existing code)\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst getTaskInstances = (task: Task): any[] => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (task as any).instances || []\n}\n\nexport interface TaskEditActionsOptions {\n    isFormValid?: ComputedRef<boolean>\n    isFormDirty?: ComputedRef<boolean>\n}\n\nexport function useTaskEditActions(\n    props: { task: Task | null },\n    emit: (event: 'close') => void,\n    editedTask: Ref<Task>,\n    isSaving: Ref<boolean>,\n    options: TaskEditActionsOptions = {}\n) {\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const canvasUiStore = useCanvasUiStore()\n    const { showToast } = useToast()\n\n\n    // --- Subtask Management ---\n\n    const addSubtask = () => {\n        const newSubtask: Subtask = {\n            id: Date.now().toString(),\n            parentTaskId: editedTask.value.id,\n            title: '',\n            description: '',\n            completedPomodoros: 0,\n            isCompleted: false,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        }\n        editedTask.value.subtasks.push(newSubtask)\n    }\n\n    const deleteSubtask = (subtaskId: string) => {\n        const index = editedTask.value.subtasks.findIndex(st => st.id === subtaskId)\n        if (index !== -1) {\n            editedTask.value.subtasks.splice(index, 1)\n        }\n    }\n\n    const updateSubtaskCompletion = (subtask: Subtask) => {\n        if (!props.task) return\n\n        // TASK-089 FIX: Lock position BEFORE any store updates\n        const canvasPosition = editedTask.value.canvasPosition ?? props.task?.canvasPosition\n        if (canvasPosition) {\n            // Optimistic sync removed\n        }\n\n        // Update subtask in store\n        taskStore.updateSubtaskWithUndo(editedTask.value.id, subtask.id, {\n            isCompleted: subtask.isCompleted,\n            updatedAt: new Date()\n        })\n\n        // Recalculate parent progress\n        const completedCount = editedTask.value.subtasks.filter(st => st.isCompleted).length\n        const totalSubtasks = editedTask.value.subtasks.length\n        const newProgress = totalSubtasks > 0 ? Math.round((completedCount / totalSubtasks) * 100) : 0\n\n        taskStore.updateTaskWithUndo(editedTask.value.id, {\n            progress: newProgress,\n            updatedAt: new Date()\n        })\n    }\n\n    const resetPomodoros = () => {\n        editedTask.value.completedPomodoros = 0\n        editedTask.value.subtasks.forEach(subtask => {\n            subtask.completedPomodoros = 0\n        })\n    }\n\n    // --- Core Scheduling & Parsing Logic ---\n\n    const handleScheduledDateChange = () => {\n        if (editedTask.value.scheduledDate && !editedTask.value.scheduledTime) {\n            editedTask.value.scheduledTime = '09:00'\n        }\n    }\n\n    // --- Canvas Interaction ---\n\n    const handleSectionChange = (sectionId: string | null) => {\n        if (!sectionId) {\n            // Move to Inbox\n            editedTask.value.isInInbox = true\n            editedTask.value.canvasPosition = undefined\n            return\n        }\n\n        const section = canvasStore.sections.find(s => s.id === sectionId)\n        if (!section) return\n\n        // Update position if not already in this section\n        const currentPos = editedTask.value.canvasPosition\n        const isCurrentlyInSection = currentPos &&\n            currentPos.x >= section.position.x &&\n            currentPos.x <= section.position.x + section.position.width &&\n            currentPos.y >= section.position.y &&\n            currentPos.y <= section.position.y + section.position.height\n\n        if (!isCurrentlyInSection) {\n            // Place in center of section with small offset\n            editedTask.value.canvasPosition = {\n                x: section.position.x + (section.position.width / 2) - 100,\n                y: section.position.y + (section.position.height / 2) - 40\n            }\n        }\n\n        editedTask.value.isInInbox = false\n\n        // Apply \"Assign on Drop\" settings\n        if (section.assignOnDrop) {\n            const settings = section.assignOnDrop\n            if (settings.priority) editedTask.value.priority = settings.priority\n            if (settings.status) editedTask.value.status = settings.status\n            if (settings.projectId) editedTask.value.projectId = settings.projectId\n\n            if (settings.dueDate) {\n                import('@/composables/useGroupSettings').then(({ resolveDueDate }) => {\n                    const dateStr = resolveDueDate(settings.dueDate!)\n                    if (dateStr) editedTask.value.dueDate = dateStr\n                })\n            }\n        }\n    }\n\n    // --- Main Save Action ---\n\n    // BUG-291 FIX: Made async to properly await updateTaskWithUndo\n    const saveTask = async () => {\n        // Guard: Prevent double-save\n        if (isSaving.value || !props.task) return\n\n        // Validate form before saving\n        if (options.isFormValid && !options.isFormValid.value) {\n            // Check specific validation failures\n            if (!editedTask.value.title || editedTask.value.title.trim() === '') {\n                showToast('Task title is required', 'error')\n            } else {\n                showToast('Please fix form errors before saving', 'error')\n            }\n            return\n        }\n\n        // Check if there are actually changes to save\n        if (options.isFormDirty && !options.isFormDirty.value) {\n            // No changes - just close without showing error\n            emit('close')\n            return\n        }\n\n        isSaving.value = true\n\n        try {\n            // Debug logging omitted for brevity in refactor, but logic preserved\n\n            const originalTask = taskStore.tasks.find(t => t.id === editedTask.value.id)\n            const originalInstances = originalTask ? getTaskInstances(originalTask) : []\n\n            const hadOriginalSchedule = originalInstances.length > 0 ||\n                (originalTask?.scheduledDate && originalTask?.scheduledTime) ||\n                (originalTask?.instances && originalTask.instances.length > 0)\n            const hasNewSchedule = editedTask.value.scheduledDate && editedTask.value.scheduledTime\n            const scheduleExplicitlyRemoved = hadOriginalSchedule && !hasNewSchedule\n\n            const originalCanvasPosition = editedTask.value.canvasPosition ?? props.task?.canvasPosition\n            const originalIsInInbox = editedTask.value.isInInbox ?? props.task?.isInInbox\n\n            const updates: Record<string, unknown> = {\n                title: editedTask.value.title,\n                description: editedTask.value.description,\n                status: editedTask.value.status,\n                priority: editedTask.value.priority,\n                dueDate: editedTask.value.dueDate,\n                scheduledDate: editedTask.value.scheduledDate,\n                scheduledTime: editedTask.value.scheduledTime,\n                estimatedDuration: editedTask.value.estimatedDuration,\n                recurrence: editedTask.value.recurrence,\n                subtasks: editedTask.value.subtasks\n            }\n\n            if (originalCanvasPosition !== undefined) {\n                updates.canvasPosition = originalCanvasPosition\n                updates.isInInbox = false\n            } else if (originalIsInInbox !== undefined) {\n                updates.isInInbox = originalIsInInbox\n            }\n\n            // Preserve existing instances\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (editedTask.value.instances && (editedTask.value.instances as unknown as any[]).length > 0) {\n                updates.instances = editedTask.value.instances\n            }\n\n            // Lock position before update\n            if (originalCanvasPosition) {\n                // Optimistic sync removed\n            }\n\n            // Generate recurring instances if enabled\n            if (editedTask.value.recurrence?.isEnabled && editedTask.value.recurrence.rule) {\n                const startDate = editedTask.value.scheduledDate || editedTask.value.dueDate || new Date().toISOString().split('T')[0]\n                const instances = generateRecurringInstances(\n                    editedTask.value.id,\n                    editedTask.value.recurrence.rule,\n                    editedTask.value.recurrence.endCondition,\n                    (editedTask.value.recurrence.exceptions || []) as any,\n                    new Date(startDate),\n                    editedTask.value.scheduledTime,\n                    editedTask.value.estimatedDuration\n                )\n                updates.recurringInstances = instances\n                if (updates.recurrence) {\n                    (updates.recurrence as any).generatedInstances = instances\n                        ; (updates.recurrence as any).lastGenerated = new Date().toISOString()\n                }\n            }\n\n            // BUG-291 FIX: Use direct updateTask for INSTANT feedback\n            // The old flow blocked UI for 2-3 seconds due to:\n            // - 3 dynamic imports in updateTaskWithUndo\n            // - 2 undo state saves\n            // - Instance/subtask operations with same pattern\n            // Now we: Update store → Close modal → Background ops\n            console.time('⚡ [BUG-291] Task update')\n\n            // BUG-1097 FIX: Ensure dueDate is included in updates\n            if (editedTask.value.dueDate !== undefined) {\n                updates.dueDate = editedTask.value.dueDate\n            }\n\n            // BUG-1206 FIX: Await updateTask to ensure store + sync queue are updated\n            // before closing the modal. updateTask no longer rolls back on direct save failure\n            // (sync queue retries), so this won't block the UI on network errors.\n            await taskStore.updateTask(editedTask.value.id, updates as Partial<Task>)\n\n            console.timeEnd('⚡ [BUG-291] Task update')\n\n            // BUG-357 FIX: Force canvas sync to update Vue Flow nodes with fresh data\n            // This fixes Tauri/WebKitGTK reactivity issue where computed doesn't re-evaluate\n            canvasUiStore.requestSync('user:manual')\n\n            // BUG-1097 FIX: Close modal FIRST, then show toast\n            // This ensures the modal closes even if toast has issues\n            emit('close')\n            isSaving.value = false\n\n            // Show success feedback after close\n            showToast('Task saved successfully', 'success')\n\n            // === BACKGROUND OPERATIONS (fire-and-forget) ===\n            // These run after modal closes - user doesn't wait for them\n\n            // Fire-and-forget: Save undo state in background\n            getUndoSystem().saveState('After edit modal save').catch(() => {})\n\n            // Handle instances\n            if (editedTask.value.scheduledDate && editedTask.value.scheduledTime) {\n                const existingInstances = props.task ? getTaskInstances(props.task) : []\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const sameDayInstance = existingInstances.find((inst: any) =>\n                    inst.scheduledDate === editedTask.value.scheduledDate\n                )\n\n                if (sameDayInstance) {\n                    taskStore.updateTaskInstanceWithUndo(editedTask.value.id, sameDayInstance.id, {\n                        scheduledTime: editedTask.value.scheduledTime,\n                        duration: editedTask.value.estimatedDuration || 60\n                    })\n                } else {\n                    taskStore.createTaskInstanceWithUndo(editedTask.value.id, {\n                        scheduledDate: editedTask.value.scheduledDate,\n                        scheduledTime: editedTask.value.scheduledTime,\n                        duration: editedTask.value.estimatedDuration || 60\n                    })\n                }\n            } else if (scheduleExplicitlyRemoved) {\n                const existingInstances = props.task ? getTaskInstances(props.task) : []\n                if (existingInstances.length > 0) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    existingInstances.forEach((instance: any) => {\n                        taskStore.deleteTaskInstanceWithUndo(editedTask.value.id, instance.id)\n                    })\n\n                    // Check if should return to inbox\n                    const currentTask = taskStore.tasks.find(t => t.id === editedTask.value.id)\n                    if (currentTask) {\n                        const hasRemainingInstances = getTaskInstances(currentTask).length > 0\n                        if (!hasRemainingInstances && currentTask.isInInbox === false) {\n                            taskStore.updateTask(currentTask.id, {\n                                instances: [],\n                                isInInbox: true\n                            })\n                        }\n                    }\n                }\n            }\n\n            // Subtasks are included in the main updateTask call above (no separate sync needed)\n\n            // NOTE: emit('close') already called above for instant feedback\n        } catch (error) {\n            // Handle save errors gracefully\n            console.error('Failed to save task:', error)\n            isSaving.value = false\n\n            // Show user-friendly error message\n            const errorMessage = error instanceof Error\n                ? error.message\n                : 'An unexpected error occurred'\n            showToast(`Failed to save task: ${errorMessage}`, 'error')\n\n            // Don't close the modal on error - let user retry\n        }\n    }\n\n    return {\n        addSubtask,\n        deleteSubtask,\n        updateSubtaskCompletion,\n        resetPomodoros,\n        handleScheduledDateChange,\n        handleSectionChange,\n        saveTask\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskEditState.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[902,905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[902,905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":164,"column":66,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":164,"endColumn":77,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[5742,5743],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, watch, nextTick, computed, type Ref } from 'vue'\nimport { type Task, useTaskStore } from '@/stores/tasks'\n\nexport function useTaskEditState(\n    props: { isOpen: boolean; task: Task | null },\n    titleInputRef?: Ref<HTMLInputElement | undefined>\n) {\n    const taskStore = useTaskStore()\n    // Editing state\n    const editedTask = ref<Task>({\n        id: '',\n        title: '',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        scheduledDate: '',\n        scheduledTime: '09:00',\n        estimatedDuration: 60,\n        projectId: '' as string,\n        recurrence: {\n            isEnabled: false,\n            rule: { pattern: 'none' },\n            endCondition: { type: 'never' },\n            exceptions: [],\n            generatedInstances: []\n        } as any,\n        createdAt: new Date(),\n        updatedAt: new Date()\n    })\n\n    // Original task snapshot for dirty checking\n    const originalTaskSnapshot = ref<string>('')\n\n    // Progressive disclosure state\n    const showDependencies = ref(false)\n    const showSubtasks = ref(true)\n    const showPomodoros = ref(false)\n\n    // Save-in-progress guard\n    const isSaving = ref(false)\n\n    // --- Form Validation ---\n\n    // Check if title is valid (non-empty)\n    const isTitleValid = computed((): boolean => {\n        return Boolean(editedTask.value.title && editedTask.value.title.trim().length > 0)\n    })\n\n    // Form is valid if all required fields pass validation\n    const isFormValid = computed(() => {\n        return isTitleValid.value\n    })\n\n    // --- Form Dirty Tracking ---\n\n    // Create a fingerprint of task data for comparison (excludes volatile fields)\n    const createTaskFingerprint = (task: Task): string => {\n        return JSON.stringify({\n            title: task.title,\n            description: task.description,\n            status: task.status,\n            priority: task.priority,\n            dueDate: task.dueDate,\n            scheduledDate: task.scheduledDate,\n            scheduledTime: task.scheduledTime,\n            estimatedDuration: task.estimatedDuration,\n            recurrence: task.recurrence,\n            subtasks: task.subtasks?.map(st => ({\n                id: st.id,\n                title: st.title,\n                description: st.description,\n                isCompleted: st.isCompleted\n            }))\n        })\n    }\n\n    // Check if form has unsaved changes\n    const isFormDirty = computed(() => {\n        if (!originalTaskSnapshot.value) return false\n        const currentFingerprint = createTaskFingerprint(editedTask.value)\n        return currentFingerprint !== originalTaskSnapshot.value\n    })\n\n    // Check if form is pristine (no changes made)\n    const isFormPristine = computed(() => !isFormDirty.value)\n\n    // Save button should be disabled if form is pristine OR invalid OR currently saving\n    const isSaveDisabled = computed(() => {\n        return isFormPristine.value || !isFormValid.value || isSaving.value\n    })\n\n    // Options\n    const priorityOptions = [\n        { label: 'Low', value: 'low' },\n        { label: 'Medium', value: 'medium' },\n        { label: 'High', value: 'high' }\n    ]\n\n    const statusOptions = [\n        { label: 'Planned', value: 'planned' },\n        { label: 'Active', value: 'in_progress' },\n        { label: 'Done', value: 'done' },\n        { label: 'Backlog', value: 'backlog' }\n    ]\n\n    // Watch for task changes to sync local state\n    watch(() => props.task, (newTask) => {\n        // Guard: If we are saving, ignore external updates\n        if (isSaving.value || !newTask) return\n\n        // Fingerprint for change detection\n        const currentFingerprint = JSON.stringify({\n            ...editedTask.value,\n            canvasPosition: undefined,\n            updatedAt: undefined\n        })\n\n        const newTaskState = {\n            ...newTask,\n            subtasks: [...(newTask.subtasks || [])],\n            // BUG-1097 FIX: Explicitly copy date fields to ensure they're not lost\n            dueDate: newTask.dueDate || '',\n            scheduledDate: newTask.scheduledDate || '',\n            scheduledTime: newTask.scheduledTime || '09:00'\n        }\n\n        const newFingerprint = JSON.stringify({\n            ...newTaskState,\n            canvasPosition: undefined,\n            updatedAt: undefined\n        })\n\n        // BUG-1097 FIX: Always update if IDs match (same task being edited)\n        // This ensures external changes to the task are reflected\n        if (editedTask.value.id !== newTask.id || currentFingerprint !== newFingerprint) {\n            editedTask.value = newTaskState\n\n            // Store original snapshot for dirty tracking\n            originalTaskSnapshot.value = createTaskFingerprint(newTaskState)\n\n            // Auto-expand sections\n            showSubtasks.value = (newTask.subtasks || []).length > 0\n            showDependencies.value = (newTask.dependsOn && newTask.dependsOn.length > 0) || false\n            showPomodoros.value = (newTask.completedPomodoros || 0) > 0\n\n            // Focus title for new tasks\n            nextTick(() => {\n                if (titleInputRef?.value && newTask.title === 'New Task') {\n                    titleInputRef.value.focus()\n                    titleInputRef.value.select()\n                }\n            })\n        }\n    }, { immediate: true })\n\n    // BUG-1097 FIX: Also watch isOpen to ensure fresh data when modal opens\n    watch(() => props.isOpen, (isOpen) => {\n        if (isOpen && props.task) {\n            // Get FRESH task from store (not the potentially stale props.task)\n            const freshTask = taskStore.tasks.find(t => t.id === props.task!.id)\n            if (freshTask) {\n                const newTaskState = {\n                    ...freshTask,\n                    subtasks: [...(freshTask.subtasks || [])],\n                    dueDate: freshTask.dueDate || '',\n                    scheduledDate: freshTask.scheduledDate || '',\n                    scheduledTime: freshTask.scheduledTime || '09:00'\n                }\n                editedTask.value = newTaskState\n                originalTaskSnapshot.value = createTaskFingerprint(newTaskState)\n\n                // Auto-expand sections\n                showSubtasks.value = (freshTask.subtasks || []).length > 0\n                showDependencies.value = (freshTask.dependsOn && freshTask.dependsOn.length > 0) || false\n                showPomodoros.value = (freshTask.completedPomodoros || 0) > 0\n            }\n        }\n    })\n\n    return {\n        editedTask,\n        isSaving,\n        showDependencies,\n        showSubtasks,\n        showPomodoros,\n        priorityOptions,\n        statusOptions,\n        // Form validation & dirty tracking\n        isTitleValid,\n        isFormValid,\n        isFormDirty,\n        isFormPristine,\n        isSaveDisabled\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskFiltering.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":158,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":158,"endColumn":42,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6313,6314],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":305,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12816,12819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12816,12819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, type Ref } from 'vue'\nimport type { Task, Project } from '@/types/tasks'\nimport { useSmartViews } from '@/composables/useSmartViews'\nimport { formatDateKey } from '@/utils/dateUtils'\n\n\nexport type SmartView = 'today' | 'week' | 'uncategorized' | 'unscheduled' | 'in_progress' | 'all_active' | null\n\nexport const useTaskFiltering = (\n    tasks: Ref<Task[]>,\n    projects: Ref<Project[]>,\n    activeProjectId: Ref<string | null>,\n    activeSmartView: Ref<SmartView>,\n    activeStatusFilter: Ref<string | null>,\n    activeDurationFilter: Ref<string | null>,\n    hideDoneTasks: Ref<boolean>,\n    hideCalendarDoneTasks?: Ref<boolean>,\n    selectedProjectIds?: Ref<Set<string>> // TASK-084: Multi-select support\n) => {\n    const {\n        applySmartViewFilter,\n        isUncategorizedTask,\n        isQuickTask,\n        isShortTask,\n        isMediumTask,\n        isLongTask,\n        isUnestimatedTask,\n        isTodayTask,\n        isWeekTask,\n        isUnscheduledTask,\n        isInProgressTask\n    } = useSmartViews()\n\n\n    // Helper to recursively collect nested tasks - Optimized to O(N) using Map\n    const collectNestedTasks = (taskIds: string[], allTasks: Task[]): string[] => {\n        const allNestedIds: string[] = []\n        const visited = new Set<string>(taskIds) // Pre-fill with starting IDs to prevent duplicates\n\n        // 1. Build Parent-Child Map (O(N))\n        const parentMap = new Map<string, string[]>()\n        allTasks.forEach(task => {\n            if (task.parentTaskId && !task._soft_deleted) {\n                if (!parentMap.has(task.parentTaskId)) {\n                    parentMap.set(task.parentTaskId, [])\n                }\n                parentMap.get(task.parentTaskId)?.push(task.id)\n            }\n        })\n\n        // 2. Traverse (O(N) in worst case of full tree)\n        const traverse = (parentId: string) => {\n            const children = parentMap.get(parentId)\n            if (children) {\n                children.forEach(childId => {\n                    if (!visited.has(childId)) {\n                        visited.add(childId)\n                        allNestedIds.push(childId)\n                        traverse(childId)\n                    }\n                })\n            }\n        }\n\n        taskIds.forEach(parentId => traverse(parentId))\n        return allNestedIds\n    }\n\n    // Recursive project ID helper with cycle detection\n    const getChildProjectIds = (projectId: string, visited = new Set<string>()): string[] => {\n        if (visited.has(projectId)) {\n            return [] // Already visited, break recursion to prevent cycles\n        }\n        visited.add(projectId)\n\n        const ids = [projectId] // Include the current project ID\n        const childProjects = projects.value.filter(p => p.parentId === projectId)\n        childProjects.forEach(child => {\n            ids.push(...getChildProjectIds(child.id, visited))\n        })\n        return ids\n    }\n\n    const filteredTasks = computed(() => {\n        if (!tasks.value || !Array.isArray(tasks.value)) {\n            // console.debug('⚠️ [FILTER-DEBUG] No tasks to filter')\n            return []\n        }\n\n        let filtered = tasks.value.filter(task => !task._soft_deleted)\n        // console.debug(`🔍 [FILTER-DEBUG] Starting filter with ${filtered.length} tasks (excluding deleted)`)\n\n        // 1. Smart View\n        if (activeSmartView.value) {\n            filtered = applySmartViewFilter(filtered, activeSmartView.value)\n            // console.debug(`🔍 [FILTER-DEBUG] After SmartView (${activeSmartView.value}): ${filtered.length}`)\n        }\n\n        // 2. Project (Single or Multi-select)\n        if (selectedProjectIds?.value && selectedProjectIds.value.size > 0) {\n            // TASK-084: Multi-select mode\n            const allTargetProjectIds = new Set<string>()\n            selectedProjectIds.value.forEach(pid => {\n                const childIds = getChildProjectIds(pid)\n                childIds.forEach(cid => allTargetProjectIds.add(cid))\n            })\n            filtered = filtered.filter(task => allTargetProjectIds.has(task.projectId))\n        } else if (activeProjectId.value) {\n            // Standard single project mode\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            filtered = filtered.filter(task => projectIds.includes(task.projectId))\n            // console.debug(`🔍 [FILTER-DEBUG] After Project (${activeProjectId.value}): ${filtered.length}`)\n        }\n\n        // 3. Status\n        if (activeStatusFilter.value) {\n            filtered = filtered.filter(task => task.status === activeStatusFilter.value)\n        }\n\n        // 4. Duration\n        if (activeDurationFilter.value) {\n            filtered = filtered.filter(t => {\n                switch (activeDurationFilter.value) {\n                    case 'quick': return isQuickTask(t)\n                    case 'short': return isShortTask(t)\n                    case 'medium': return isMediumTask(t)\n                    case 'long': return isLongTask(t)\n                    case 'unestimated': return isUnestimatedTask(t)\n                    default: return true\n                }\n            })\n        }\n\n        // 5. Hide Done - REMOVED (TASK-076)\n        // Each view (Canvas, Calendar, Inbox) handles done filtering locally\n        // Canvas: CanvasView.vue filteredTasks computed\n        // Calendar: CalendarView.vue local filter\n        // Inbox: UnifiedInboxPanel.vue hideInboxDoneTasks ref\n        // This ensures canvas toggle doesn't affect inbox and vice versa\n\n        // Include nested tasks\n        const filteredTaskIds = filtered.map(task => task.id)\n        const nestedTaskIds = collectNestedTasks(filteredTaskIds, tasks.value)\n\n        let nestedTasks: Task[] = []\n        try {\n            // Optimization: Get project IDs once instead of inside filter loop\n            let activeProjectTreeIds: string[] | null = null\n\n            if (activeProjectId.value) {\n                activeProjectTreeIds = getChildProjectIds(activeProjectId.value)\n            }\n\n            // TASK-084: Handle nesting for multi-select\n            if (selectedProjectIds?.value && selectedProjectIds.value.size > 0) {\n                activeProjectTreeIds = []\n                selectedProjectIds.value.forEach(pid => {\n                    activeProjectTreeIds!.push(...getChildProjectIds(pid))\n                })\n            }\n\n            nestedTasks = tasks.value\n                .filter(task => nestedTaskIds.includes(task.id) && !task._soft_deleted)\n                .filter(task => {\n                    if (activeProjectTreeIds) {\n                        if (!activeProjectTreeIds.includes(task.projectId)) return false\n                    }\n                    // TASK-076: Only filter done tasks for Today smart view here\n                    // View-specific done filtering handled locally by each view\n                    if (task.status === 'done' && activeSmartView.value === 'today') return false\n                    return true\n                })\n\n            // BUG-1210: Apply smart view filter to nested tasks too.\n            // Without this, child tasks bypass the date-based filter and appear\n            // even when their dates are outside the active view (e.g., next-week\n            // tasks showing in \"This Week\" because their parent matched).\n            if (activeSmartView.value) {\n                nestedTasks = applySmartViewFilter(nestedTasks, activeSmartView.value)\n            }\n        } catch {\n            nestedTasks = []\n        }\n\n        const allTasks = [...filtered, ...nestedTasks]\n        const finalResult = allTasks.filter((task, index, self) =>\n            index === self.findIndex(t => t.id === task.id)\n        )\n\n        console.debug(`✅ [FILTER-DEBUG] Final filtered tasks: ${finalResult.length} (ActiveProject: ${activeProjectId.value || 'None'})`)\n        return finalResult\n    })\n\n    const tasksByStatus = computed(() => {\n        const tasksToGroup = filteredTasks.value\n        return {\n            planned: tasksToGroup.filter(task => task.status === 'planned'),\n            in_progress: tasksToGroup.filter(task => task.status === 'in_progress'),\n            done: tasksToGroup.filter(task => task.status === 'done'),\n            backlog: tasksToGroup.filter(task => task.status === 'backlog'),\n            on_hold: tasksToGroup.filter(task => task.status === 'on_hold')\n        }\n    })\n\n    const filteredTasksWithCanvasPosition = computed(() => {\n        return filteredTasks.value.filter(task => task.canvasPosition &&\n            typeof task.canvasPosition.x === 'number' &&\n            typeof task.canvasPosition.y === 'number')\n    })\n\n    const tasksWithCanvasPosition = computed(() => {\n        return tasks.value.filter(task => task.canvasPosition &&\n            typeof task.canvasPosition.x === 'number' &&\n            typeof task.canvasPosition.y === 'number')\n    })\n\n    const calendarFilteredTasks = computed(() => {\n        let filtered = tasks.value.filter(task => !task._soft_deleted)\n\n        // 1. Project\n        if (activeProjectId.value) {\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            filtered = filtered.filter(task => projectIds.includes(task.projectId))\n        }\n\n        // 2. Hide Done (Calendar specific)\n        if (hideCalendarDoneTasks?.value) {\n            filtered = filtered.filter(task => task.status !== 'done')\n        }\n\n        return filtered\n    })\n\n    const totalTasks = computed(() => tasks.value.filter(task => task.status !== 'done' && !task._soft_deleted).length)\n    const completedTasks = computed(() => tasks.value.filter(task => task.status === 'done' && !task._soft_deleted).length)\n\n    const totalPomodoros = computed(() =>\n        tasks.value.reduce((sum, task) => sum + (task.completedPomodoros || 0), 0)\n    )\n\n    const doneTasksForColumn = computed(() => {\n        let doneTasks = tasks.value.filter(task => task.status === 'done')\n\n        if (activeProjectId.value) {\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            doneTasks = doneTasks.filter(task => projectIds.includes(task.projectId))\n        }\n\n        if (activeSmartView.value === 'today') {\n            // BUG-1321: Use local date (not UTC) to avoid timezone-related overdue false positives\n            const _now = new Date()\n            const todayStr = `${_now.getFullYear()}-${String(_now.getMonth() + 1).padStart(2, '0')}-${String(_now.getDate()).padStart(2, '0')}`\n            const today = new Date()\n            today.setHours(0, 0, 0, 0)\n\n            doneTasks = doneTasks.filter(task => {\n                const taskCreatedDate = new Date(task.createdAt)\n                taskCreatedDate.setHours(0, 0, 0, 0)\n                if (taskCreatedDate.getTime() === today.getTime()) return true\n\n                if (task.dueDate) {\n                    const taskDueDate = new Date(task.dueDate)\n                    if (!isNaN(taskDueDate.getTime()) && formatDateKey(taskDueDate) === todayStr) return true\n                }\n                return false\n            })\n        }\n\n        return doneTasks\n    })\n\n    const smartViewTaskCounts = computed(() => {\n        let baseTasks = tasks.value.filter(task => !task._soft_deleted)\n\n        if (activeProjectId.value) {\n            const projectIds = getChildProjectIds(activeProjectId.value)\n            baseTasks = baseTasks.filter(task => projectIds.includes(task.projectId))\n        }\n\n        if (hideDoneTasks.value) {\n            baseTasks = baseTasks.filter(task => task.status !== 'done')\n        }\n\n        return {\n            today: baseTasks.filter(task => isTodayTask(task)).length,\n            week: baseTasks.filter(task => isWeekTask(task)).length,\n            uncategorized: baseTasks.filter(task => isUncategorizedTask(task)).length,\n            unscheduled: baseTasks.filter(task => isUnscheduledTask(task)).length,\n            inProgress: baseTasks.filter(task => isInProgressTask(task)).length,\n            allActive: baseTasks.filter(task => task.status !== 'done').length,\n            all: baseTasks.length,\n            quick: baseTasks.filter(task => isQuickTask(task)).length,\n            short: baseTasks.filter(task => isShortTask(task)).length,\n            medium: baseTasks.filter(task => isMediumTask(task)).length,\n            long: baseTasks.filter(task => isLongTask(task)).length,\n            unestimated: baseTasks.filter(task => isUnestimatedTask(task)).length\n        }\n    })\n\n    const getProjectTaskCount = (projectId: string): number => {\n        const projectIds = getChildProjectIds(projectId)\n        let projectTasks = tasks.value.filter(task => projectIds.includes(task.projectId))\n\n        if (activeSmartView.value) {\n            projectTasks = applySmartViewFilter(projectTasks, activeSmartView.value as any)\n        }\n\n        if (activeStatusFilter.value) {\n            projectTasks = projectTasks.filter(task => task.status === activeStatusFilter.value)\n        }\n\n        if (hideDoneTasks.value) {\n            projectTasks = projectTasks.filter(task => task.status !== 'done')\n        }\n\n        return projectTasks.length\n    }\n\n    return {\n        filteredTasks,\n        tasksByStatus,\n        filteredTasksWithCanvasPosition,\n        smartViewTaskCounts,\n        getProjectTaskCount,\n        totalTasks,\n        nonDoneTaskCount: totalTasks,\n        completedTasks,\n        totalPomodoros,\n        doneTasksForColumn,\n        tasksWithCanvasPosition,\n        calendarFilteredTasks\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/tasks/useTaskMigrations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/ui/done-toggle/useDoneToggleInteraction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/ui/drag-handle/useDragHandleInteraction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/ui/drag-handle/useDragHandleState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/undoSingleton.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[860,863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[860,863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":483,"column":31,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":483,"endColumn":52},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":547,"column":31,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":547,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'operation' is defined but never used. Allowed unused args must match /^_/u.","line":680,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":680,"endColumn":58}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Undo System Singleton - Ensures shared instance across the entire application\n// This solves initialization order issues between App.vue and globalKeyboardHandlerSimple.ts\n// UPDATED: Now tracks both tasks AND canvas groups for unified undo/redo (ISSUE-008 fix)\n\nimport { ref, computed, nextTick } from 'vue'\nimport type { Ref, ComputedRef } from 'vue'\nimport { useManualRefHistory } from '@vueuse/core'\nimport type { Task } from '../stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport type { CanvasGroup } from '@/types/canvas'\nimport { guardTaskCreation } from '../utils/demoContentGuard'\nimport { useToast } from './useToast'\n\ninterface UndoSystemState {\n  canUndo: ComputedRef<boolean> | null\n  canRedo: ComputedRef<boolean> | null\n  undoCount: ComputedRef<number> | null\n  redoCount: ComputedRef<number> | null\n  history: ComputedRef<any[]> | null\n  undo: (() => void) | null\n  redo: (() => void) | null\n  commit: (() => void) | null\n  clear: (() => void) | null\n  collectFilter: Record<string, unknown>\n}\n\ndeclare global {\n  interface Window {\n    __pomoFlowUndoSystem?: UndoSystemState\n  }\n}\n\n// Combined state interface for tracking both tasks and groups\ninterface UnifiedUndoState {\n  tasks: Task[]\n  groups: CanvasGroup[]\n}\n\n// =============================================================================\n// BUG-309-B: Operation-Scoped Undo System\n// =============================================================================\n// Instead of restoring full snapshots, we track which entities were affected\n// by each operation and only restore those. This prevents position drift where\n// undoing task B's creation would incorrectly revert task A's position.\n\n/**\n * Describes what type of operation was performed for selective restoration\n */\nexport type UndoOperationType =\n  | 'task-create'\n  | 'task-delete'\n  | 'task-update'\n  | 'task-move'\n  | 'task-bulk-delete'\n  | 'group-create'\n  | 'group-delete'\n  | 'group-update'\n  | 'group-resize'\n  | 'legacy' // For backward compatibility with entries that don't have metadata\n\n/**\n * Operation metadata stored alongside each undo snapshot\n */\nexport interface UndoOperation {\n  type: UndoOperationType\n  affectedIds: string[]  // Which tasks/groups were actually modified\n  description: string    // Human-readable description for debugging\n  timestamp: number      // When the operation occurred\n}\n\n/**\n * Extended snapshot that includes operation metadata\n */\ninterface OperationSnapshot {\n  operation: UndoOperation\n  snapshotBefore: UnifiedUndoState  // State before the operation (for undo)\n  snapshotAfter: UnifiedUndoState   // State after the operation (for redo)\n}\n\n// Separate operation history that parallels VueUse's refHistory\n// This allows us to associate metadata with each history entry\nlet operationStack: OperationSnapshot[] = []\nlet redoOperationStack: OperationSnapshot[] = []\n\n// Flag to track if we're in operation-aware mode\nconst useOperationAwareUndo = true\n\n// Global singleton refHistory instance - created only ONCE\nlet refHistoryInstance: ReturnType<typeof useManualRefHistory<UnifiedUndoState>> | null = null\nlet unifiedState: Ref<UnifiedUndoState> | null = null\nlet canUndo: ComputedRef<boolean> | null = null\nlet canRedo: ComputedRef<boolean> | null = null\nlet undoCount: ComputedRef<number> | null = null\nlet redoCount: ComputedRef<number> | null = null\nlet history: ComputedRef<import('@vueuse/core').UseRefHistoryRecord<UnifiedUndoState>[]> | null = null\nlet undo: (() => void) | null = null\nlet redo: (() => void) | null = null\nlet commit: (() => void) | null = null\nlet clear: (() => void) | null = null\n\n/**\n * Initialize the single refHistory instance\n */\nfunction initializeRefHistory() {\n  if (refHistoryInstance) {\n    return\n  }\n\n  // CRITICAL FIX: Start with empty state to avoid circular dependency during store setup\n  // The state will be populated after stores are fully initialized\n  // This is called during useTaskStore() setup, so we can't access taskStore.tasks yet\n  unifiedState = ref<UnifiedUndoState>({\n    tasks: [],\n    groups: []\n  })\n\n  // Schedule state population after stores are ready (next tick ensures store setup is complete)\n  nextTick(async () => {\n    try {\n      // Dynamic import to break circular dependency (tasks -> taskHistory -> undoSingleton -> tasks)\n      const { useTaskStore } = await import('../stores/tasks')\n      const taskStore = useTaskStore()\n      const canvasStore = useCanvasStore()\n\n      // Now safely populate the state - stores should be fully initialized\n      if (unifiedState && taskStore.tasks && Array.isArray(taskStore.tasks)) {\n        unifiedState.value.tasks = [...taskStore.tasks]\n      }\n      if (unifiedState && canvasStore.groups && Array.isArray(canvasStore.groups)) {\n        unifiedState.value.groups = [...canvasStore.groups]\n      }\n    } catch (error) {\n      console.warn('⚠️ [UNDO] Could not populate initial state (stores may not be ready):', error)\n    }\n  })\n\n  // Create the SINGLE useManualRefHistory instance with proper VueUse configuration\n  // NOTE: deep: true was intentionally removed for performance reasons (deep watchers issue)\n  refHistoryInstance = useManualRefHistory(unifiedState, {\n    capacity: 50,\n    clone: true\n  })\n\n  // Extract all the reactive properties\n  canUndo = computed(() => refHistoryInstance?.canUndo.value ?? false)\n  canRedo = computed(() => refHistoryInstance?.canRedo.value ?? false)\n  // useManualRefHistory provides history tracking\n  undoCount = computed(() => {\n    if (!refHistoryInstance) return 0\n    return refHistoryInstance.undoStack.value.length\n  })\n  redoCount = computed(() => {\n    if (!refHistoryInstance) return 0\n    return refHistoryInstance.redoStack.value.length\n  })\n  history = computed(() => refHistoryInstance?.history.value ?? [])\n\n  // Bind the methods\n  undo = refHistoryInstance.undo.bind(refHistoryInstance)\n  redo = refHistoryInstance.redo.bind(refHistoryInstance)\n  commit = refHistoryInstance.commit.bind(refHistoryInstance)\n  clear = refHistoryInstance.clear.bind(refHistoryInstance)\n\n  // Also store on window for direct access\n  if (typeof window !== 'undefined') {\n    (window as Window & typeof globalThis).__pomoFlowUndoSystem = {\n      canUndo,\n      canRedo,\n      undoCount,\n      redoCount,\n      history,\n      undo,\n      redo,\n      commit,\n      clear,\n      collectFilter: {\n        matchDueDate: null, // Was false, fixed to match CollectFilterSettings\n        matchPriority: undefined,\n        matchStatus: undefined,\n        matchDuration: 'quick'\n      }\n    }\n  }\n}\n\n// =============================================================================\n// BUG-309-B: SELECTIVE RESTORATION (Operation-Aware Undo/Redo)\n// =============================================================================\n// Instead of restoring the entire state, we only restore the entities that\n// were affected by the operation. This prevents position drift.\n\n/**\n * Perform selective undo based on operation type\n * Only restores entities that were actually affected by the operation\n */\nconst performSelectiveUndo = async (operationSnapshot: OperationSnapshot): Promise<boolean> => {\n  const { operation, snapshotBefore } = operationSnapshot\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n  const canvasStore = useCanvasStore()\n  const { useCanvasUiStore } = await import('../stores/canvas/canvasUi')\n  const canvasUiStore = useCanvasUiStore()\n\n  console.log(`🔄 [UNDO] Selective undo for: ${operation.type} (${operation.description})`)\n\n  switch (operation.type) {\n    case 'task-create': {\n      // Undo creation = delete the created task\n      const taskId = operation.affectedIds[0]\n      if (taskId) {\n        console.log(`🔄 [UNDO] Removing created task: ${taskId}`)\n        await taskStore.deleteTask(taskId)\n      }\n      break\n    }\n\n    case 'task-delete': {\n      // Undo deletion = restore the deleted task from snapshot\n      const taskId = operation.affectedIds[0]\n      console.log('🔴 [UNDO] task-delete undo, looking for task:', taskId)\n      console.log('🔴 [UNDO] snapshotBefore has', snapshotBefore.tasks.length, 'tasks')\n      const deletedTask = snapshotBefore.tasks.find(t => t.id === taskId)\n      if (deletedTask) {\n        console.log(`🔄 [UNDO] Restoring deleted task: ${deletedTask.title}`)\n        await taskStore.createTask(deletedTask)\n        console.log('🔴 [UNDO] createTask completed')\n      } else {\n        console.error('❌ [UNDO] Could not find task in snapshot:', taskId)\n      }\n      break\n    }\n\n    case 'task-bulk-delete': {\n      // Undo bulk deletion = restore all deleted tasks\n      for (const taskId of operation.affectedIds) {\n        const deletedTask = snapshotBefore.tasks.find(t => t.id === taskId)\n        if (deletedTask) {\n          console.log(`🔄 [UNDO] Restoring deleted task: ${deletedTask.title}`)\n          await taskStore.createTask(deletedTask)\n        }\n      }\n      break\n    }\n\n    case 'task-update':\n    case 'task-move': {\n      // Undo update/move = restore previous state of affected tasks only\n      for (const taskId of operation.affectedIds) {\n        const previousTask = snapshotBefore.tasks.find(t => t.id === taskId)\n        if (previousTask) {\n          console.log(`🔄 [UNDO] Restoring task state: ${previousTask.title}`)\n          // Use updateTask to restore all properties including position\n          // Use 'USER' as the source since this is a user-initiated undo\n          await taskStore.updateTask(taskId, { // BUG-1051: AWAIT to ensure persistence\n            ...previousTask,\n            // Ensure position fields are included\n            canvasPosition: previousTask.canvasPosition,\n            parentId: previousTask.parentId,\n            positionFormat: previousTask.positionFormat\n          }, 'USER')\n        }\n      }\n      break\n    }\n\n    case 'group-create': {\n      // Undo group creation = delete the created group\n      const groupId = operation.affectedIds[0]\n      if (groupId) {\n        console.log(`🔄 [UNDO] Removing created group: ${groupId}`)\n        await canvasStore.deleteGroup(groupId)\n      }\n      break\n    }\n\n    case 'group-delete': {\n      // Undo group deletion = restore the deleted group from snapshot\n      const groupId = operation.affectedIds[0]\n      const deletedGroup = snapshotBefore.groups.find(g => g.id === groupId)\n      if (deletedGroup) {\n        console.log(`🔄 [UNDO] Restoring deleted group: ${deletedGroup.name}`)\n        await canvasStore.createGroup(deletedGroup)\n      }\n      break\n    }\n\n    case 'group-update':\n    case 'group-resize': {\n      // Undo group update/resize = restore previous state of affected groups only\n      for (const groupId of operation.affectedIds) {\n        const previousGroup = snapshotBefore.groups.find(g => g.id === groupId)\n        if (previousGroup) {\n          console.log(`🔄 [UNDO] Restoring group state: ${previousGroup.name}`)\n          await canvasStore.updateGroup(groupId, {\n            ...previousGroup,\n            position: previousGroup.position,\n            parentGroupId: previousGroup.parentGroupId\n          })\n        }\n      }\n      break\n    }\n\n    case 'legacy':\n    default: {\n      // Fall back to full-state restoration for legacy entries\n      console.log(`🔄 [UNDO] Legacy mode - restoring full state`)\n      canvasStore.setGroups([...snapshotBefore.groups])\n      await taskStore.restoreState(snapshotBefore.tasks)\n      break\n    }\n  }\n\n  // Request canvas sync after restoration\n  try {\n    canvasUiStore.requestSync('user:undo')\n  } catch (error) {\n    console.warn('⚠️ [UNDO] Could not request canvas sync:', error)\n  }\n\n  return true\n}\n\n/**\n * Perform selective redo based on operation type\n */\nconst performSelectiveRedo = async (operationSnapshot: OperationSnapshot): Promise<boolean> => {\n  const { operation, snapshotAfter } = operationSnapshot\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n  const canvasStore = useCanvasStore()\n  const { useCanvasUiStore } = await import('../stores/canvas/canvasUi')\n  const canvasUiStore = useCanvasUiStore()\n\n  console.log(`🔁 [REDO] Selective redo for: ${operation.type} (${operation.description})`)\n\n  switch (operation.type) {\n    case 'task-create': {\n      // Redo creation = recreate the task\n      const taskId = operation.affectedIds[0]\n      const createdTask = snapshotAfter.tasks.find(t => t.id === taskId)\n      if (createdTask) {\n        console.log(`🔁 [REDO] Re-creating task: ${createdTask.title}`)\n        await taskStore.createTask(createdTask)\n      }\n      break\n    }\n\n    case 'task-delete': {\n      // Redo deletion = delete the task again\n      const taskId = operation.affectedIds[0]\n      console.log(`🔁 [REDO] Re-deleting task: ${taskId}`)\n      await taskStore.deleteTask(taskId)\n      break\n    }\n\n    case 'task-bulk-delete': {\n      // Redo bulk deletion = delete all tasks again\n      for (const taskId of operation.affectedIds) {\n        console.log(`🔁 [REDO] Re-deleting task: ${taskId}`)\n        await taskStore.deleteTask(taskId)\n      }\n      break\n    }\n\n    case 'task-update':\n    case 'task-move': {\n      // Redo update/move = apply the after state to affected tasks\n      for (const taskId of operation.affectedIds) {\n        const afterTask = snapshotAfter.tasks.find(t => t.id === taskId)\n        if (afterTask) {\n          console.log(`🔁 [REDO] Re-applying task state: ${afterTask.title}`)\n          // Use 'USER' as the source since this is a user-initiated redo\n          await taskStore.updateTask(taskId, { // BUG-1051: AWAIT to ensure persistence\n            ...afterTask,\n            canvasPosition: afterTask.canvasPosition,\n            parentId: afterTask.parentId,\n            positionFormat: afterTask.positionFormat\n          }, 'USER')\n        }\n      }\n      break\n    }\n\n    case 'group-create': {\n      // Redo group creation = recreate the group\n      const groupId = operation.affectedIds[0]\n      const createdGroup = snapshotAfter.groups.find(g => g.id === groupId)\n      if (createdGroup) {\n        console.log(`🔁 [REDO] Re-creating group: ${createdGroup.name}`)\n        await canvasStore.createGroup(createdGroup)\n      }\n      break\n    }\n\n    case 'group-delete': {\n      // Redo group deletion = delete the group again\n      const groupId = operation.affectedIds[0]\n      console.log(`🔁 [REDO] Re-deleting group: ${groupId}`)\n      await canvasStore.deleteGroup(groupId)\n      break\n    }\n\n    case 'group-update':\n    case 'group-resize': {\n      // Redo group update/resize = apply the after state\n      for (const groupId of operation.affectedIds) {\n        const afterGroup = snapshotAfter.groups.find(g => g.id === groupId)\n        if (afterGroup) {\n          console.log(`🔁 [REDO] Re-applying group state: ${afterGroup.name}`)\n          await canvasStore.updateGroup(groupId, {\n            ...afterGroup,\n            position: afterGroup.position,\n            parentGroupId: afterGroup.parentGroupId\n          })\n        }\n      }\n      break\n    }\n\n    case 'legacy':\n    default: {\n      // Fall back to full-state restoration for legacy entries\n      console.log(`🔁 [REDO] Legacy mode - restoring full state`)\n      canvasStore.setGroups([...snapshotAfter.groups])\n      await taskStore.restoreState(snapshotAfter.tasks)\n      break\n    }\n  }\n\n  // Request canvas sync after restoration\n  try {\n    canvasUiStore.requestSync('user:redo')\n  } catch (error) {\n    console.warn('⚠️ [REDO] Could not request canvas sync:', error)\n  }\n\n  return true\n}\n\n// =============================================================================\n// TASK-140: Undo/Redo Visual Feedback\n// =============================================================================\n/**\n * Show toast notification for undo/redo operations\n * Respects user's showUndoRedoToasts setting\n */\nconst showUndoRedoToast = async (action: 'undo' | 'redo', description: string) => {\n  try {\n    // Dynamic import to avoid circular dependencies\n    const { useSettingsStore } = await import('../stores/settings')\n    const settingsStore = useSettingsStore()\n\n    // Check if user wants toast notifications\n    if (!settingsStore.showUndoRedoToasts) {\n      return\n    }\n\n    const { showToast } = useToast()\n    const prefix = action === 'undo' ? 'Undone' : 'Redone'\n\n    // Clean up the description (remove \"Delete task: \" prefix style for cleaner display)\n    const cleanDescription = description\n      .replace(/^(Delete|Create|Update|Move|Resize|Bulk delete \\d+) (task|group): /i, '')\n      .trim()\n\n    showToast(`${prefix}: ${cleanDescription}`, 'info', { duration: 2500 })\n  } catch (error) {\n    console.warn('⚠️ [UNDO] Could not show toast:', error)\n  }\n}\n\n// ✅ FIXED - Functions defined at module level (outside return object)\n// FIX: Made async to properly await restoreState which is an async function\n// UPDATED: Now restores both tasks AND groups (ISSUE-008 fix)\n// BUG-309-B: Enhanced with operation-aware selective restoration\nconst performUndo = async () => {\n  console.log('🔴 [UNDO] performUndo called, operationStack length:', operationStack.length)\n\n  // BUG-309-B: Try operation-aware undo first\n  if (useOperationAwareUndo && operationStack.length > 0) {\n    console.log('🔴 [UNDO] Using operation-aware undo')\n    const operationSnapshot = operationStack.pop()!\n    redoOperationStack.push(operationSnapshot)\n\n    // BUG-336 FIX: Don't call refHistoryInstance.undo() here\n    // The operation stack is the source of truth in operation-aware mode.\n    // Calling VueUse undo creates a \"ghost\" undo that requires double Ctrl+Z.\n\n    const result = await performSelectiveUndo(operationSnapshot)\n\n    // TASK-140: Show toast notification for undo\n    if (result) {\n      showUndoRedoToast('undo', operationSnapshot.operation.description)\n    }\n\n    return result\n  }\n\n  // Fall back to legacy full-state undo\n  if (!refHistoryInstance || !unifiedState) return false\n  refHistoryInstance.undo()\n\n  // After undo, unifiedState.value now contains the previous state\n  // Restore both tasks and groups\n  const previousState = unifiedState.value\n  if (previousState && typeof previousState === 'object' && 'tasks' in previousState) {\n    // Dynamic import\n    const { useTaskStore } = await import('../stores/tasks')\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const { useCanvasUiStore } = await import('../stores/canvas/canvasUi')\n    const canvasUiStore = useCanvasUiStore()\n\n    // BUG-008 FIX: Restore groups FIRST (synchronous, no DB dependency)\n    // This ensures groups are restored immediately even if task DB save hangs\n    canvasStore.setGroups([...previousState.groups])\n\n    // Request canvas sync IMMEDIATELY after group restore\n    try {\n      canvasUiStore.requestSync('user:undo')\n    } catch (error) {\n      console.warn('⚠️ [UNDO] Could not request canvas sync:', error)\n    }\n\n    // Restore tasks (async - may take time for DB operations)\n    // Don't await - let it run in background to avoid blocking UI\n    taskStore.restoreState(previousState.tasks).then(() => {\n    }).catch((err: Error) => {\n      console.error('❌ [UNDO] Task store restore failed:', err)\n    })\n\n    // TASK-140: Show toast notification for legacy undo\n    showUndoRedoToast('undo', 'previous state')\n\n    return true\n  }\n  return false\n}\n\n// FIX: Made async to properly await restoreState which is an async function\n// UPDATED: Now restores both tasks AND groups (ISSUE-008 fix)\n// BUG-309-B: Enhanced with operation-aware selective restoration\nconst performRedo = async () => {\n  // BUG-309-B: Try operation-aware redo first\n  if (useOperationAwareUndo && redoOperationStack.length > 0) {\n    const operationSnapshot = redoOperationStack.pop()!\n    operationStack.push(operationSnapshot)\n\n    // BUG-336 FIX: Don't call refHistoryInstance.redo() here\n    // Operation stack is source of truth in operation-aware mode.\n\n    const result = await performSelectiveRedo(operationSnapshot)\n\n    // TASK-140: Show toast notification for redo\n    if (result) {\n      showUndoRedoToast('redo', operationSnapshot.operation.description)\n    }\n\n    return result\n  }\n\n  // Fall back to legacy full-state redo\n  if (!refHistoryInstance || !unifiedState) return false\n  refHistoryInstance.redo()\n\n  // After redo, unifiedState.value now contains the next state\n  // Restore both tasks and groups\n  const nextState = unifiedState.value\n  if (nextState && typeof nextState === 'object' && 'tasks' in nextState) {\n    // Dynamic import\n    const { useTaskStore } = await import('../stores/tasks')\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n    const { useCanvasUiStore } = await import('../stores/canvas/canvasUi')\n    const canvasUiStore = useCanvasUiStore()\n\n    // BUG-008 FIX: Restore groups FIRST (synchronous, no DB dependency)\n    canvasStore.setGroups([...nextState.groups])\n\n    // Request canvas sync IMMEDIATELY after group restore\n    try {\n      canvasUiStore.requestSync('user:redo')\n    } catch (error) {\n      console.warn('⚠️ [REDO] Could not request canvas sync:', error)\n    }\n\n    // Restore tasks (async - may take time for DB operations)\n    // Don't await - let it run in background to avoid blocking UI\n    taskStore.restoreState(nextState.tasks).then(() => {\n    }).catch((err: Error) => {\n      console.error('❌ [REDO] Task store restore failed:', err)\n    })\n\n    // TASK-140: Show toast notification for legacy redo\n    showUndoRedoToast('redo', 'next state')\n\n    return true\n  }\n  return false\n}\n\n// =============================================================================\n// OPERATION-AWARE STATE MANAGEMENT (BUG-309-B)\n// =============================================================================\n\n/**\n * Capture current state as a snapshot (deep clone)\n */\nconst captureCurrentState = async (): Promise<UnifiedUndoState> => {\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n  const canvasStore = useCanvasStore()\n\n  return {\n    tasks: JSON.parse(JSON.stringify(taskStore.tasks)),\n    groups: JSON.parse(JSON.stringify(canvasStore.groups))\n  }\n}\n\n/**\n * Track the state BEFORE an operation starts\n * Call this BEFORE performing the operation\n */\nlet pendingOperationBefore: UnifiedUndoState | null = null\nlet pendingOperation: UndoOperation | null = null\n\nconst beginOperation = async (operation: Omit<UndoOperation, 'timestamp'>) => {\n  pendingOperationBefore = await captureCurrentState()\n  pendingOperation = {\n    ...operation,\n    timestamp: Date.now()\n  }\n}\n\n/**\n * Complete the operation and save the undo entry\n * Call this AFTER performing the operation\n */\nconst commitOperation = async () => {\n  if (!pendingOperationBefore || !pendingOperation) {\n    console.warn('⚠️ [UNDO] commitOperation called without beginOperation')\n    return false\n  }\n\n  const snapshotAfter = await captureCurrentState()\n\n  // Push to operation stack (limit capacity to 50)\n  operationStack.push({\n    operation: pendingOperation,\n    snapshotBefore: pendingOperationBefore,\n    snapshotAfter\n  })\n  if (operationStack.length > 50) {\n    operationStack.shift()\n  }\n\n  // Clear redo stack on new operation\n  redoOperationStack = []\n\n  // Also update VueUse's refHistory for backward compatibility\n  if (unifiedState && commit) {\n    unifiedState.value = snapshotAfter\n    commit()\n  }\n\n  // Capture description before clearing\n  const operationDescription = pendingOperation.description\n\n  // Clear pending state\n  pendingOperationBefore = null\n  pendingOperation = null\n\n  console.log(`✅ [UNDO] Committed operation: ${operationDescription}`)\n  return true\n}\n\n// UPDATED: Now saves both tasks AND groups (ISSUE-008 fix)\n// BUG-309-B: Enhanced to support operation metadata for selective restoration\nconst saveState = async (_description?: string, operation?: Omit<UndoOperation, 'timestamp'>) => {\n  // BUG-008 DEBUG: Log when refHistoryInstance is null\n  if (!refHistoryInstance) {\n    console.error('❌ [UNDO-CRITICAL] saveState() called but refHistoryInstance is NULL! Calling initializeRefHistory()...')\n    initializeRefHistory()\n    if (!refHistoryInstance) {\n      console.error('❌ [UNDO-CRITICAL] Still null after init retry!')\n      return false\n    }\n  }\n  // FIX: Add null check for commit function to prevent silent failures\n  if (!commit) {\n    console.error('❌ [UNDO] commit function not initialized - calling initializeRefHistory()')\n    initializeRefHistory()\n    if (!commit) {\n      console.error('❌ [UNDO] commit function still not initialized after retry')\n      return false\n    }\n  }\n  try {\n    // Dynamic import\n    const { useTaskStore } = await import('../stores/tasks')\n    const taskStore = useTaskStore()\n    const canvasStore = useCanvasStore()\n\n    // Save combined state (tasks + groups)\n    if (unifiedState) {\n      unifiedState.value = {\n        tasks: [...taskStore.tasks],\n        groups: [...canvasStore.groups]\n      }\n    }\n\n    commit()\n    return true\n  } catch (error) {\n    console.error('❌ Failed to save state:', error)\n    return false\n  }\n}\n\n// BUG-309-B: Operation-aware task operations\nconst deleteTaskWithUndo = async (taskId: string) => {\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n\n  const taskToDelete = taskStore.tasks.find(t => t.id === taskId)\n  if (!taskToDelete) {\n    console.warn('⚠️ Task not found for deletion:', taskId)\n    return\n  }\n\n  // BUG-309-B: Begin operation-aware tracking\n  await beginOperation({\n    type: 'task-delete',\n    affectedIds: [taskId],\n    description: `Delete task: ${taskToDelete.title}`\n  })\n\n  try {\n    // Perform the deletion\n    await taskStore.deleteTask(taskId)\n\n    // BUG-309-B: Commit the operation\n    await nextTick()\n    await commitOperation()\n  } catch (error) {\n    console.error('❌ deleteTaskWithUndo failed:', error)\n    // Clear pending operation on error\n    pendingOperationBefore = null\n    pendingOperation = null\n    throw error\n  }\n}\n\n/**\n * Permanently delete a task with undo support (Shift+Delete from canvas)\n * Uses the same undo mechanism as soft delete - undo will recreate the task from snapshot\n */\nconst permanentlyDeleteTaskWithUndo = async (taskId: string) => {\n  console.log('🔴 [UNDO] permanentlyDeleteTaskWithUndo called:', taskId)\n\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n\n  const taskToDelete = taskStore.tasks.find(t => t.id === taskId)\n  if (!taskToDelete) {\n    console.warn('⚠️ Task not found for permanent deletion:', taskId)\n    return\n  }\n\n  console.log('🔴 [UNDO] Task found, capturing snapshot before deletion:', taskToDelete.title)\n\n  // BUG-309-B: Begin operation-aware tracking\n  await beginOperation({\n    type: 'task-delete',\n    affectedIds: [taskId],\n    description: `Permanently delete task: ${taskToDelete.title}`\n  })\n\n  console.log('🔴 [UNDO] beginOperation completed, pendingOperationBefore has', pendingOperationBefore?.tasks.length, 'tasks')\n\n  try {\n    // Perform permanent deletion (hard delete from database)\n    await taskStore.permanentlyDeleteTask(taskId)\n    console.log('🔴 [UNDO] permanentlyDeleteTask completed')\n\n    // BUG-309-B: Commit the operation\n    await nextTick()\n    await commitOperation()\n    console.log('🔴 [UNDO] commitOperation completed, operationStack length:', operationStack.length)\n  } catch (error) {\n    console.error('❌ permanentlyDeleteTaskWithUndo failed:', error)\n    // Clear pending operation on error\n    pendingOperationBefore = null\n    pendingOperation = null\n    throw error\n  }\n}\n\nconst updateTaskWithUndo = async (taskId: string, updates: Partial<Task>) => {\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n\n  const taskToUpdate = taskStore.tasks.find(t => t.id === taskId)\n  if (!taskToUpdate) {\n    console.warn('⚠️ Task not found for update:', taskId)\n    return\n  }\n\n  // BUG-309-B: Determine operation type based on what's being updated\n  const isPositionUpdate = 'canvasPosition' in updates || 'parentId' in updates\n  const operationType: UndoOperationType = isPositionUpdate ? 'task-move' : 'task-update'\n\n  await beginOperation({\n    type: operationType,\n    affectedIds: [taskId],\n    description: `${operationType === 'task-move' ? 'Move' : 'Update'} task: ${taskToUpdate.title}`\n  })\n\n  // Perform the update\n  await taskStore.updateTask(taskId, updates) // BUG-1051: AWAIT to ensure persistence\n\n  // BUG-309-B: Commit the operation\n  await nextTick()\n  await commitOperation()\n}\n\nconst createTaskWithUndo = async (taskData: Partial<Task>) => {\n  // TASK-061: Demo content guard - defense in depth (also checked in taskStore.createTask)\n  if (taskData.title) {\n    guardTaskCreation(taskData.title)\n  }\n\n  // BUG-309-B: Begin operation-aware tracking (we don't know ID yet, will update)\n  await beginOperation({\n    type: 'task-create',\n    affectedIds: [], // Will be updated after creation\n    description: `Create task: ${taskData.title || 'Untitled'}`\n  })\n\n  // Create the task\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n  const newTask = await taskStore.createTask(taskData)\n\n  // BUG-309-B: Update affectedIds with the actual new task ID\n  if (pendingOperation && newTask) {\n    pendingOperation.affectedIds = [newTask.id]\n  }\n\n  // BUG-309-B: Commit the operation\n  await nextTick()\n  await commitOperation()\n  return newTask\n}\n\n// BUG-309-B: Operation-aware group operations\nconst createGroupWithUndo = async (groupData: Omit<CanvasGroup, 'id'>) => {\n  const canvasStore = useCanvasStore()\n\n  // BUG-309-B: Begin operation-aware tracking\n  await beginOperation({\n    type: 'group-create',\n    affectedIds: [], // Will be updated after creation\n    description: `Create group: ${groupData.name || 'Untitled'}`\n  })\n\n  try {\n    // Perform the creation\n    const newGroup = await canvasStore.createGroup(groupData)\n\n    // BUG-309-B: Update affectedIds with the actual new group ID\n    if (pendingOperation && newGroup) {\n      pendingOperation.affectedIds = [newGroup.id]\n    }\n\n    // BUG-309-B: Commit the operation\n    await nextTick()\n    await commitOperation()\n    return newGroup\n  } catch (error) {\n    console.error('❌ createGroupWithUndo failed:', error)\n    pendingOperationBefore = null\n    pendingOperation = null\n    throw error\n  }\n}\n\nconst updateGroupWithUndo = async (groupId: string, updates: Partial<CanvasGroup>) => {\n  const canvasStore = useCanvasStore()\n\n  const groupToUpdate = canvasStore.groups.find(g => g.id === groupId)\n  if (!groupToUpdate) {\n    console.warn('⚠️ Group not found for update:', groupId)\n    return\n  }\n\n  // BUG-309-B: Determine operation type based on what's being updated\n  const isResizeUpdate = updates.position && ('width' in updates.position || 'height' in updates.position)\n  const operationType: UndoOperationType = isResizeUpdate ? 'group-resize' : 'group-update'\n\n  await beginOperation({\n    type: operationType,\n    affectedIds: [groupId],\n    description: `${operationType === 'group-resize' ? 'Resize' : 'Update'} group: ${groupToUpdate.name}`\n  })\n\n  try {\n    // Perform the update\n    await canvasStore.updateGroup(groupId, updates)\n\n    // BUG-309-B: Commit the operation\n    await nextTick()\n    await commitOperation()\n  } catch (error) {\n    console.error('❌ updateGroupWithUndo failed:', error)\n    pendingOperationBefore = null\n    pendingOperation = null\n    throw error\n  }\n}\n\nconst deleteGroupWithUndo = async (groupId: string) => {\n  const canvasStore = useCanvasStore()\n\n  const groupToDelete = canvasStore.groups.find(g => g.id === groupId)\n  if (!groupToDelete) {\n    console.warn('⚠️ Group not found for deletion:', groupId)\n    return\n  }\n\n  // BUG-309-B: Begin operation-aware tracking\n  await beginOperation({\n    type: 'group-delete',\n    affectedIds: [groupId],\n    description: `Delete group: ${groupToDelete.name}`\n  })\n\n  try {\n    // Perform the deletion\n    await canvasStore.deleteGroup(groupId)\n\n    // BUG-309-B: Commit the operation\n    await nextTick()\n    await commitOperation()\n  } catch (error) {\n    console.error('❌ deleteGroupWithUndo failed:', error)\n    pendingOperationBefore = null\n    pendingOperation = null\n    throw error\n  }\n}\n\n// BUG-309-B: Operation-aware bulk delete\nconst bulkDeleteTasksWithUndo = async (taskIds: string[]) => {\n  // Dynamic import\n  const { useTaskStore } = await import('../stores/tasks')\n  const taskStore = useTaskStore()\n\n  // BUG-309-B: Begin operation-aware tracking\n  await beginOperation({\n    type: 'task-bulk-delete',\n    affectedIds: [...taskIds],\n    description: `Bulk delete ${taskIds.length} tasks`\n  })\n\n  try {\n    if (taskStore.bulkDeleteTasks) {\n      await taskStore.bulkDeleteTasks(taskIds)\n    } else {\n      console.warn('⚠️ taskStore.bulkDeleteTasks not found, falling back to individual')\n      // Fallback for safety (though store should have it now)\n      for (const id of taskIds) {\n        await taskStore.deleteTask(id)\n      }\n    }\n\n    // BUG-309-B: Commit the operation\n    await nextTick()\n    await commitOperation()\n  } catch (error) {\n    console.error('❌ bulkDeleteTasksWithUndo failed:', error)\n    pendingOperationBefore = null\n    pendingOperation = null\n    throw error\n  }\n}\n\n/**\n * Get the global undo system functions that use the shared refHistory instance\n * BUG-309-B: Enhanced with operation-aware undo/redo support\n */\nexport function getUndoSystem() {\n  if (!refHistoryInstance) {\n    initializeRefHistory()\n  }\n\n  // BUG-309-B: Override canUndo/canRedo to consider operation stack\n  const operationAwareCanUndo = computed(() => {\n    if (useOperationAwareUndo && operationStack.length > 0) {\n      return true\n    }\n    return canUndo?.value ?? false\n  })\n\n  const operationAwareCanRedo = computed(() => {\n    if (useOperationAwareUndo && redoOperationStack.length > 0) {\n      return true\n    }\n    return canRedo?.value ?? false\n  })\n\n  const operationAwareUndoCount = computed(() => {\n    if (useOperationAwareUndo) {\n      return operationStack.length\n    }\n    return undoCount?.value ?? 0\n  })\n\n  const operationAwareRedoCount = computed(() => {\n    if (useOperationAwareUndo) {\n      return redoOperationStack.length\n    }\n    return redoCount?.value ?? 0\n  })\n\n  return {\n    // BUG-309-B: Use operation-aware computed refs\n    canUndo: operationAwareCanUndo,\n    canRedo: operationAwareCanRedo,\n    undoCount: operationAwareUndoCount,\n    redoCount: operationAwareRedoCount,\n    history,\n\n    // Standard undo/redo operations\n    undo: performUndo,\n    redo: performRedo,\n\n    // FIXED: Unified state management using VueUse pattern\n    saveState,               // Use unified saveState function instead of before/after\n\n    // BUG-309-B: Operation-aware API for fine-grained control\n    beginOperation,\n    commitOperation,\n\n    // Task operations that use the shared refHistory\n    deleteTaskWithUndo,\n    permanentlyDeleteTaskWithUndo,\n    bulkDeleteTasksWithUndo,\n    updateTaskWithUndo,\n    createTaskWithUndo,\n\n    // Group operations with undo (ISSUE-008 fix / BUG-008 fix)\n    createGroupWithUndo,\n    updateGroupWithUndo,\n    deleteGroupWithUndo,\n\n    // BUG-309-B: Debugging/inspection\n    getOperationStack: () => [...operationStack],\n    getRedoOperationStack: () => [...redoOperationStack],\n    isOperationAwareMode: () => useOperationAwareUndo\n  }\n}\n\n/**\n * Check if the undo system is initialized\n */\nexport function isUndoSystemInitialized(): boolean {\n  return refHistoryInstance !== null\n}\n\n/**\n * Reset the undo system (useful for testing)\n * BUG-309-B: Also clears operation stacks\n */\nexport function resetUndoSystem() {\n  refHistoryInstance = null\n  unifiedState = null\n  canUndo = null\n  canRedo = null\n  undoCount = null\n  redoCount = null\n  history = null\n  undo = null\n  redo = null\n  commit = null\n  clear = null\n\n  // BUG-309-B: Clear operation stacks\n  operationStack = []\n  redoOperationStack = []\n  pendingOperationBefore = null\n  pendingOperation = null\n\n  if (typeof window !== 'undefined') {\n    delete (window as Window & typeof globalThis).__pomoFlowUndoSystem\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useAIChallengeNarrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Ref' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":30,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Ref"},"fix":{"range":[620,630],"text":""},"desc":"Remove unused variable \"Ref\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4744,4747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4744,4747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Challenge Narrator Composable\n * TASK-1238: Watches gamification events and pushes narrative messages into AI chat\n *\n * This composable monitors gamification state for challenge completions, level ups,\n * streak milestones, and boss defeats, then automatically narrates them as assistant\n * messages in the AI chat panel.\n *\n * Architecture:\n * - Client-side narrative templates (no AI model call - instant, works offline)\n * - Cooldowns prevent spam\n * - Watches reactive state in gamification/challenges stores\n * - Messages appear as assistant messages with narrator: true metadata\n */\n\nimport { watch, ref, type Ref } from 'vue'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useChallengesStore } from '@/stores/challenges'\nimport { useAIChatStore } from '@/stores/aiChat'\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype NarratorEventType =\n  | 'challenge_complete'\n  | 'challenge_fail'\n  | 'level_up'\n  | 'streak_milestone'\n  | 'boss_defeat'\n\ninterface NarratorEvent {\n  type: NarratorEventType\n  data: Record<string, unknown>\n  timestamp: number\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Cooldowns to prevent spam (in ms) */\nconst COOLDOWNS: Record<NarratorEventType, number> = {\n  challenge_complete: 30_000,    // 30s between challenge complete narrations\n  challenge_fail: 60_000,        // 1min between challenge fail narrations\n  level_up: 0,                   // always narrate level ups\n  streak_milestone: 0,           // always narrate streak milestones\n  boss_defeat: 0,                // always narrate boss defeats\n}\n\n/** Streak milestones that trigger narration */\nconst STREAK_MILESTONES = [5, 10, 25, 50, 100]\n\n// ============================================================================\n// Composable\n// ============================================================================\n\nexport function useAIChallengeNarrator() {\n  const gamificationStore = useGamificationStore()\n  const challengesStore = useChallengesStore()\n  const chatStore = useAIChatStore()\n\n  const lastEventTimes = ref<Record<string, number>>({})\n  const isEnabled = ref(true)\n  const stopWatchers: Array<() => void> = []\n\n  /**\n   * Check if we can narrate an event type (respects cooldowns).\n   */\n  function canNarrate(type: NarratorEventType): boolean {\n    const cooldown = COOLDOWNS[type] ?? 30_000\n    const lastTime = lastEventTimes.value[type] || 0\n    return Date.now() - lastTime > cooldown\n  }\n\n  /**\n   * Record that an event type was narrated (for cooldown tracking).\n   */\n  function recordEvent(type: NarratorEventType) {\n    lastEventTimes.value[type] = Date.now()\n  }\n\n  /**\n   * Generate a short narrative message for an event.\n   * These are client-side templates (no AI model call needed).\n   */\n  function generateNarration(event: NarratorEvent): string {\n    switch (event.type) {\n      case 'challenge_complete': {\n        const title = (event.data.title as string) || 'a challenge'\n        const xp = (event.data.rewardXp as number) || 0\n        return `**Challenge Complete!** You conquered \"${title}\" and earned **+${xp} XP**. Keep pushing!`\n      }\n      case 'challenge_fail': {\n        const title = (event.data.title as string) || 'a challenge'\n        return `**Challenge Expired:** \"${title}\" didn't make it this time. New challenges await tomorrow.`\n      }\n      case 'level_up': {\n        const level = (event.data.level as number) || 1\n        return `**Level Up!** You reached **Level ${level}**! New abilities unlocked on the Grid.`\n      }\n      case 'streak_milestone': {\n        const streak = (event.data.streak as number) || 0\n        return `**Streak Milestone!** ${streak} days of consistent productivity. You're on fire!`\n      }\n      case 'boss_defeat': {\n        const title = (event.data.title as string) || 'the Boss'\n        const xp = (event.data.rewardXp as number) || 0\n        return `**Boss Defeated!** You took down \"${title}\" and claimed **+${xp} XP**. Legendary.`\n      }\n      default:\n        return ''\n    }\n  }\n\n  /**\n   * Push a narration to the AI chat.\n   */\n  function pushNarration(event: NarratorEvent) {\n    if (!isEnabled.value) return\n    if (!canNarrate(event.type)) return\n\n    const message = generateNarration(event)\n    if (!message) return\n\n    recordEvent(event.type)\n\n    // Push as system-like assistant message with narrator metadata\n    chatStore.addAssistantMessage(message, {\n      metadata: {\n        narrator: true,\n        eventType: event.type,\n      } as any,\n    })\n  }\n\n  /**\n   * Start watching gamification events.\n   */\n  function start() {\n    // Watch for level changes\n    const stopLevel = watch(\n      () => gamificationStore.profile?.level,\n      (newLevel, oldLevel) => {\n        if (oldLevel !== undefined && newLevel !== undefined && newLevel > oldLevel) {\n          pushNarration({\n            type: 'level_up',\n            data: { level: newLevel },\n            timestamp: Date.now(),\n          })\n        }\n      }\n    )\n    stopWatchers.push(stopLevel)\n\n    // Watch for streak milestones\n    const stopStreak = watch(\n      () => gamificationStore.profile?.currentStreak,\n      (newStreak, oldStreak) => {\n        if (\n          oldStreak !== undefined &&\n          newStreak !== undefined &&\n          newStreak > oldStreak &&\n          STREAK_MILESTONES.includes(newStreak)\n        ) {\n          pushNarration({\n            type: 'streak_milestone',\n            data: { streak: newStreak },\n            timestamp: Date.now(),\n          })\n        }\n      }\n    )\n    stopWatchers.push(stopStreak)\n\n    // Watch the challenges store for completed challenges\n    // The completedTodayCount will increase when a challenge completes\n    const stopChallengeComplete = watch(\n      () => challengesStore.completedTodayCount,\n      (newCount, oldCount) => {\n        if (oldCount !== undefined && newCount > oldCount) {\n          // Find the most recently completed challenge\n          const completed = challengesStore.activeChallenges.find(\n            c => c.status === 'completed' && isToday(c.completedAt)\n          )\n          if (completed) {\n            pushNarration({\n              type: completed.challengeType === 'boss' ? 'boss_defeat' : 'challenge_complete',\n              data: { title: completed.title, rewardXp: completed.rewardXp },\n              timestamp: Date.now(),\n            })\n          }\n        }\n      }\n    )\n    stopWatchers.push(stopChallengeComplete)\n\n    // Watch for challenge failures (status change to 'expired' or 'failed')\n    // We can detect this by watching the activeChallenges array for failed challenges\n    const stopChallengeFail = watch(\n      () => challengesStore.activeChallenges.filter(c => c.status === 'expired' || c.status === 'failed').length,\n      (newCount, oldCount) => {\n        if (oldCount !== undefined && newCount > oldCount) {\n          // Find the most recently failed challenge\n          const failed = challengesStore.activeChallenges.find(\n            c => (c.status === 'expired' || c.status === 'failed')\n          )\n          if (failed) {\n            pushNarration({\n              type: 'challenge_fail',\n              data: { title: failed.title },\n              timestamp: Date.now(),\n            })\n          }\n        }\n      }\n    )\n    stopWatchers.push(stopChallengeFail)\n  }\n\n  /**\n   * Stop watching gamification events.\n   */\n  function stop() {\n    stopWatchers.forEach(fn => fn())\n    stopWatchers.length = 0\n  }\n\n  /**\n   * Enable/disable narration.\n   */\n  function setEnabled(enabled: boolean) {\n    isEnabled.value = enabled\n  }\n\n  /**\n   * Helper to check if a date is today.\n   */\n  function isToday(date: Date | undefined): boolean {\n    if (!date) return false\n    const today = new Date()\n    const dateToCheck = new Date(date)\n    return (\n      dateToCheck.getFullYear() === today.getFullYear() &&\n      dateToCheck.getMonth() === today.getMonth() &&\n      dateToCheck.getDate() === today.getDate()\n    )\n  }\n\n  return {\n    start,\n    stop,\n    isEnabled,\n    setEnabled,\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useAIChat.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":523,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":523,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18987,18990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18987,18990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":953,"column":49,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":953,"endColumn":50,"suggestions":[{"messageId":"removeEscape","fix":{"range":[33805,33806],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[33805,33805],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":953,"column":51,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":953,"endColumn":52,"suggestions":[{"messageId":"removeEscape","fix":{"range":[33807,33808],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[33807,33807],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1075,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1075,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37613,37616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37613,37616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1131,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1131,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39438,39441],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39438,39441],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":1318,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1318,"endColumn":47,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[45648,45649],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Chat Composable\n *\n * Provides a unified interface for AI chat functionality including:\n * - Sending messages with streaming responses\n * - Context-aware prompts with timer & task statistics\n * - Tool result feedback with undo support\n * - Rate limiting (MAX_TOOLS_PER_RESPONSE)\n * - Confirmation flow for destructive tools\n * - Action button handlers wired to tools\n * - Settings persistence (provider/model)\n *\n * @see TASK-1120, TASK-1186 in MASTER_PLAN.md\n */\n\nimport { ref } from 'vue'\nimport { storeToRefs } from 'pinia'\nimport { useAIChatStore, type ChatAction, type ChatContext } from '@/stores/aiChat'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTimerStore } from '@/stores/timer'\nimport { createAIRouter, type TaskType, type RouterProviderType } from '@/services/ai'\nimport type { ChatMessage as RouterChatMessage } from '@/services/ai/types'\nimport {\n  parseToolCalls,\n  executeTool,\n  buildOpenAITools,\n  buildNativeToolsBehaviorPrompt,\n  MAX_TOOLS_PER_RESPONSE,\n  AI_TOOLS,\n  type ToolCall,\n  type ToolResult,\n} from '@/services/ai/tools'\nimport type { NativeToolCall } from '@/services/ai/types'\nimport { useAgentChains } from './useAgentChains'\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface SendMessageOptions {\n  /** Task type for routing */\n  taskType?: TaskType\n  /** System prompt override */\n  systemPrompt?: string\n  /** Skip adding to message history */\n  skipHistory?: boolean\n  /** Enable multi-step ReAct (Reasoning + Acting) loop for cloud providers */\n  useReAct?: boolean\n}\n\n/**\n * A quick action button that can optionally call a tool directly\n * (bypassing AI model call — works with Ollama and other local models).\n */\nexport interface QuickAction {\n  label: string\n  message: string\n  /** If set, the tool is called directly instead of sending to AI */\n  directTool?: ToolCall | null\n}\n\n// ============================================================================\n// Router Instance\n// ============================================================================\n\nlet routerInstance: ReturnType<typeof createAIRouter> | null = null\nlet routerInitPromise: Promise<void> | null = null\n\n/**\n * Get or initialize the AI router.\n */\nasync function getRouter() {\n  if (!routerInstance) {\n    routerInstance = createAIRouter({ debug: true })\n    routerInitPromise = routerInstance.initialize()\n  }\n  await routerInitPromise\n  return routerInstance\n}\n\n// Active provider tracking\nconst activeProviderRef = ref<string | null>(null)\n\n// AI Personality mode\nconst aiPersonality = ref<'professional' | 'grid_handler'>('professional')\n\n/**\n * Set the AI personality mode.\n */\nfunction setPersonality(p: 'professional' | 'grid_handler') {\n  aiPersonality.value = p\n}\n\n/**\n * Get the system prompt prefix for the current personality.\n * Returns empty string for 'professional' (uses default prompt).\n */\nfunction getPersonalitySystemPrompt(): string {\n  if (aiPersonality.value === 'grid_handler') {\n    return 'You are the Grid Handler, a netrunner AI embedded in the FlowState productivity matrix. You speak in cyberpunk hacker slang. Tasks are \\'ops\\' or \\'jobs\\'. Completing work is \\'executing\\'. The timer is your \\'neural clock\\'. XP is \\'data fragments\\'. Challenges are \\'contracts\\'. You reference \\'the Grid\\', \\'data streams\\', and \\'neural pathways\\'. Keep it fun but still helpful — you\\'re assisting a runner with their daily ops. Use short, punchy sentences. Occasionally reference system corruption levels if gamification data is available.'\n  }\n  return ''\n}\n\n// ============================================================================\n// ReAct Loop Configuration\n// ============================================================================\n\n/** Maximum reasoning steps before the circuit breaker stops the ReAct loop */\nconst MAX_REACT_STEPS = 5\n\n/** AbortController for cancelling an in-progress ReAct loop */\nconst reactAbortController = ref<AbortController | null>(null)\n\n/**\n * Abort an in-progress ReAct loop.\n * Safe to call even if no loop is running.\n */\nfunction abortReAct() {\n  reactAbortController.value?.abort()\n  reactAbortController.value = null\n}\n\n// Provider/model selection state\nconst selectedProvider = ref<'ollama' | 'groq' | 'openrouter' | 'auto'>('auto')\nconst selectedModel = ref<string | null>(null)\nconst availableOllamaModels = ref<string[]>([])\nconst isLoadingModels = ref(false)\nconst providerModelMemory = ref<Record<string, string | null>>({})\n\n/**\n * Fetch available models from local Ollama instance.\n */\nasync function fetchOllamaModels(): Promise<string[]> {\n  try {\n    const response = await fetch('http://localhost:11434/api/tags')\n    if (!response.ok) return []\n    const data = await response.json()\n    return data.models?.map((m: { name: string }) => m.name) || []\n  } catch {\n    return []\n  }\n}\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\n/**\n * Strip tool JSON blocks from displayed content so users don't see raw JSON.\n */\nfunction stripToolBlocks(content: string): string {\n  // Strip code-fenced tool blocks\n  let cleaned = content.replace(/```(?:tool|json)?\\s*\\n?\\{[\\s\\S]*?\"tool\"\\s*:[\\s\\S]*?\\}\\n?```/g, '')\n  // Strip bare JSON tool calls (models sometimes omit code fences)\n  cleaned = cleaned.replace(/\\{\\s*\"tool\"\\s*:\\s*\"[^\"]+\"\\s*,\\s*\"parameters\"\\s*:\\s*\\{[^}]*\\}\\s*\\}/g, '')\n  return cleaned.trim()\n}\n\n/**\n * Check whether a tool definition requires user confirmation before execution.\n */\nfunction toolRequiresConfirmation(toolName: string): boolean {\n  const def = AI_TOOLS.find(t => t.name === toolName)\n  return def?.requiresConfirmation === true\n}\n\n// ============================================================================\n// Composable\n// ============================================================================\n\nexport function useAIChat() {\n  const store = useAIChatStore()\n  const taskStore = useTaskStore()\n  const canvasStore = useCanvasStore()\n\n  const {\n    isPanelOpen,\n    messages,\n    inputText,\n    isGenerating,\n    streamingContent,\n    context,\n    pendingSuggestionCount,\n    error,\n    visibleMessages,\n    canSend\n  } = storeToRefs(store)\n\n  // Pending confirmation flow: stores a tool call awaiting user approval\n  const pendingConfirmation = ref<ToolCall | null>(null)\n\n  // Agent chains integration\n  const agentChains = useAgentChains()\n\n  // ============================================================================\n  // Context Management\n  // ============================================================================\n\n  /**\n   * Build the current context for AI requests.\n   */\n  function buildContext(): ChatContext {\n    const currentContext = store.context\n\n    // Get visible tasks if on canvas - use nodes from canvas store\n    let visibleTaskIds: string[] | undefined\n    if (currentContext.currentView === 'canvas') {\n      visibleTaskIds = canvasStore.nodes\n        .filter((n: { type?: string }) => n.type === 'taskNode' || n.type === 'task')\n        .map((n: { id: string }) => n.id)\n    }\n\n    return {\n      ...currentContext,\n      visibleTaskIds\n    }\n  }\n\n  /**\n   * Build messages for the AI including context.\n   */\n  function buildMessagesForAI(userMessage: string): RouterChatMessage[] {\n    const ctx = buildContext()\n    const aiMessages: RouterChatMessage[] = []\n\n    // System prompt with context\n    const systemPrompt = buildSystemPrompt(ctx)\n    aiMessages.push({ role: 'system', content: systemPrompt })\n\n    // Add recent message history (last 10 messages)\n    const recentMessages = store.messages.slice(-10)\n    for (const msg of recentMessages) {\n      if (msg.role === 'user' || msg.role === 'assistant') {\n        aiMessages.push({\n          role: msg.role,\n          content: msg.content\n        })\n      }\n    }\n\n    // Add current message\n    aiMessages.push({ role: 'user', content: userMessage })\n\n    return aiMessages\n  }\n\n  /**\n   * Build the system prompt with context awareness.\n   * Includes timer state, task statistics, and additional context.\n   */\n  function buildSystemPrompt(ctx: ChatContext): string {\n    // Prepend personality prompt if active\n    const personalityPrompt = getPersonalitySystemPrompt()\n\n    const parts: string[] = [\n      personalityPrompt || 'You are FlowState AI, a friendly assistant for a productivity app.',\n      '',\n      '## CRITICAL RULES:',\n      '1. ALWAYS respond in the SAME LANGUAGE the user writes to you. If they write in Hebrew, respond in Hebrew. If English, respond in English.',\n      '2. Be conversational and natural. Have a normal chat.',\n      '3. Use WRITE tools (create, update, delete) ONLY when the user explicitly asks to create, add, modify, or delete something.',\n      '4. Use READ tools (get_overdue_tasks, list_tasks, search_tasks, get_task_details, get_daily_summary, get_timer_status, list_projects, list_groups) ALWAYS when the user asks about their tasks, schedule, what is overdue, timer status, or any data query. These tools return rich interactive results the user can click on. NEVER answer task data questions from memory — ALWAYS call the tool.',\n      '5. If the user just says \"hi\" or has a general question unrelated to their tasks, just respond normally - NO tools needed.',\n      '6. Never show JSON to the user or explain tool syntax. Just do the action silently.',\n      '7. When using read tools, keep your text response SHORT (1 sentence summary) — the tool results will show the detailed data with clickable links.',\n      '',\n      buildNativeToolsBehaviorPrompt(),\n      ''\n    ]\n\n    // Add view context\n    parts.push(`Current view: ${ctx.currentView}`)\n\n    // Add selected task context\n    if (ctx.selectedTask) {\n      parts.push(`Selected task: \"${ctx.selectedTask.title}\" (ID: ${ctx.selectedTask.id})`)\n      if (ctx.selectedTask.description) {\n        parts.push(`Task description: ${ctx.selectedTask.description}`)\n      }\n    }\n\n    // Add visible tasks summary\n    if (ctx.visibleTaskIds && ctx.visibleTaskIds.length > 0) {\n      parts.push(`There are ${ctx.visibleTaskIds.length} tasks visible on the canvas.`)\n    }\n\n    // Enhanced context: Timer state\n    try {\n      const timerStore = useTimerStore()\n      if (timerStore.isTimerActive) {\n        const taskName = timerStore.currentTaskName || 'Unknown'\n        const remaining = timerStore.displayTime || '??:??'\n        parts.push(`Timer: Running for \"${taskName}\" (${remaining} left)`)\n      } else {\n        parts.push('Timer: Not running')\n      }\n    } catch {\n      // Timer store not available\n    }\n\n    // Enhanced context: Task statistics\n    try {\n      const allTasks = taskStore.tasks\n      const today = new Date().toISOString().split('T')[0]\n      const byStatus = {\n        planned: 0,\n        in_progress: 0,\n        done: 0,\n        backlog: 0,\n        on_hold: 0,\n      }\n      let overdueCount = 0\n      for (const t of allTasks) {\n        if (t.status && t.status in byStatus) {\n          byStatus[t.status as keyof typeof byStatus]++\n        }\n        if (t.dueDate && t.dueDate < today && t.status !== 'done') {\n          overdueCount++\n        }\n      }\n      parts.push(\n        `Tasks: ${allTasks.length} total, ${byStatus.planned} planned, ${byStatus.in_progress} in progress, ${byStatus.done} done, ${overdueCount} overdue`\n      )\n    } catch {\n      // Task store not available\n    }\n\n    // Additional context (from ChatContext)\n    if (ctx.additionalContext) {\n      parts.push('')\n      parts.push(ctx.additionalContext)\n    }\n\n    // Add capabilities\n    parts.push('')\n    parts.push('You can help with:')\n    parts.push('- Breaking down tasks into subtasks')\n    parts.push('- Suggesting how to organize tasks into groups')\n    parts.push('- Managing timers and Pomodoro sessions')\n    parts.push('- Answering questions about task management')\n    parts.push('- Providing productivity tips')\n    parts.push('')\n    parts.push('## Planning Behavior')\n    parts.push('When the user asks to plan their week, schedule tasks, or organize upcoming work:')\n    parts.push('- Use the generate_weekly_plan tool to create an AI-powered weekly plan')\n    parts.push('- Present the plan day-by-day with task names and priorities')\n    parts.push('- Be encouraging and practical in your summary')\n\n    return parts.join('\\n')\n  }\n\n  // ============================================================================\n  // Message Sending\n  // ============================================================================\n\n  /**\n   * Send a message and get a streaming response.\n   * All providers use native tool calling — the AI model decides which tools to invoke.\n   */\n  async function sendMessage(\n    content: string,\n    options: SendMessageOptions = {}\n  ): Promise<void> {\n    if (!content.trim()) return\n    if (store.isGenerating) return\n\n    // Always use ReAct — the model decides if/when to call tools via native function calling.\n    // No hardcoded keyword routing. If the model doesn't call tools, the loop exits on iteration 1.\n    return sendMessageWithReAct(content, options)\n  }\n\n  // Dead code below kept for reference — sendMessage always routes to ReAct now.\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async function _sendMessageLegacy(\n    content: string,\n    options: SendMessageOptions = {}\n  ): Promise<void> {\n    const useNativeTools = true\n\n    // Clear input\n    store.inputText = ''\n    store.clearError()\n\n    // Add user message\n    if (!options.skipHistory) {\n      store.addUserMessage(content)\n    }\n\n    // Start streaming response\n    store.startStreamingMessage()\n\n    try {\n      const router = await getRouter()\n      const aiMessages = buildMessagesForAI(content)\n\n      // Determine task type from content\n      const taskType = options.taskType ?? inferTaskType(content)\n\n      // Stream the response, collecting native tool calls if available\n      let fullContent = ''\n      let nativeToolCalls: NativeToolCall[] | undefined\n\n      for await (const chunk of router.chatStream(aiMessages, {\n        taskType,\n        systemPrompt: options.systemPrompt,\n        forceProvider: selectedProvider.value !== 'auto' ? selectedProvider.value as RouterProviderType : undefined,\n        model: selectedModel.value || undefined,\n        ...(useNativeTools && {\n          tools: buildOpenAITools(),\n          toolChoice: 'auto' as const,\n        }),\n      })) {\n        store.appendStreamingContent(chunk.content)\n        fullContent += chunk.content\n        // Collect native tool calls from final chunk\n        if (chunk.toolCalls && chunk.toolCalls.length > 0) {\n          nativeToolCalls = chunk.toolCalls\n        }\n      }\n\n      // After successful stream, update badge to show the ACTUAL provider used\n      try {\n        const currentRouter = await getRouter()\n        const lastUsed = currentRouter.getLastUsedProvider()\n        if (lastUsed) {\n          activeProviderRef.value = lastUsed\n        }\n      } catch { /* ignore */ }\n\n      // Parse tool calls: prefer native API tool_calls, fallback to regex for Ollama\n      let allToolCalls: ToolCall[]\n      let wasRateLimited = false\n\n      if (nativeToolCalls && nativeToolCalls.length > 0) {\n        console.log('[AIChat] Using native tool calls:', nativeToolCalls.length)\n        allToolCalls = nativeToolCalls\n          .map(tc => {\n            try {\n              const params = JSON.parse(tc.function.arguments)\n              return { tool: tc.function.name, parameters: params } as ToolCall\n            } catch (e) {\n              console.warn('[AIChat] Failed to parse native tool call arguments:', tc.function.arguments, e)\n              return null\n            }\n          })\n          .filter((tc): tc is ToolCall => tc !== null)\n        // Enforce rate limit\n        if (allToolCalls.length > MAX_TOOLS_PER_RESPONSE) {\n          console.warn(`[AIChat] Truncating native tool calls from ${allToolCalls.length} to ${MAX_TOOLS_PER_RESPONSE}`)\n          wasRateLimited = true\n          allToolCalls = allToolCalls.slice(0, MAX_TOOLS_PER_RESPONSE)\n        }\n      } else {\n        // Fallback: regex-based parsing (for Ollama and models that don't support native tools)\n        allToolCalls = parseToolCalls(fullContent)\n\n        // Rate limiting: parseToolCalls already truncates to MAX_TOOLS_PER_RESPONSE,\n        // but we detect if the original content had more calls for a user warning\n        const toolBlockCount = (fullContent.match(/```(?:tool|json)?\\s*\\n?[\\s\\S]*?\\n?```/g) || []).length\n        wasRateLimited = toolBlockCount > MAX_TOOLS_PER_RESPONSE\n      }\n\n      // Strip tool JSON blocks from the displayed message content\n      const cleanContent = stripToolBlocks(fullContent)\n      const lastMsg = store.messages[store.messages.length - 1]\n      if (lastMsg && lastMsg.isStreaming) {\n        lastMsg.content = cleanContent\n        store.streamingContent = cleanContent\n      }\n\n      // Separate tools needing confirmation vs immediate execution\n      const immediateTools: ToolCall[] = []\n      const confirmationTools: ToolCall[] = []\n      for (const call of allToolCalls) {\n        if (toolRequiresConfirmation(call.tool)) {\n          confirmationTools.push(call)\n        } else {\n          immediateTools.push(call)\n        }\n      }\n\n      // Execute immediate tools\n      const toolResults: ToolResult[] = []\n      for (const call of immediateTools) {\n        console.log('[AIChat] Executing tool:', call.tool, call.parameters)\n        const result = await executeTool(call)\n        toolResults.push(result)\n        console.log('[AIChat] Tool result:', result)\n\n        // Push undo entry if the tool returned an undoAction\n        if (result.success && result.undoAction) {\n          store.pushUndoEntry({\n            toolName: call.tool,\n            timestamp: Date.now(),\n            params: call.parameters,\n            undoAction: result.undoAction,\n            description: result.message,\n          })\n        }\n      }\n\n      // Handle tool result feedback\n      if (toolResults.length > 0) {\n        const failedTools = toolResults.filter(r => !r.success)\n\n        if (failedTools.length > 0) {\n          store.appendStreamingContent('\\n\\n---\\n' + failedTools.map(r => `Error: ${r.message}`).join('\\n'))\n        }\n\n        // Store tool results in message metadata (include data for rich rendering)\n        if (lastMsg) {\n          lastMsg.metadata = {\n            ...lastMsg.metadata,\n            toolResults: toolResults.map((r, i) => ({\n              success: r.success,\n              message: r.message,\n              data: r.data,\n              tool: immediateTools[i]?.tool || 'unknown',\n              type: AI_TOOLS.find(t => t.name === immediateTools[i]?.tool)?.category || 'read',\n            })),\n          } as any\n        }\n      }\n\n      // Rate limit warning\n      if (wasRateLimited) {\n        store.appendStreamingContent(\n          `\\n\\n---\\nTool limit reached (${MAX_TOOLS_PER_RESPONSE} per response). Some tool calls were skipped.`\n        )\n      }\n\n      // Handle confirmation tools: queue the first one for user approval\n      if (confirmationTools.length > 0) {\n        const confirmCall = confirmationTools[0]\n        pendingConfirmation.value = confirmCall\n\n        // Find a human-readable description for the confirmation prompt\n        const toolDef = AI_TOOLS.find(t => t.name === confirmCall.tool)\n        const toolDesc = toolDef?.description || confirmCall.tool\n        const paramSummary = confirmCall.tool === 'delete_task'\n          ? `task \"${confirmCall.parameters.taskId}\"`\n          : confirmCall.tool === 'bulk_update_status'\n            ? `${(confirmCall.parameters.taskIds as string[])?.length || 0} tasks to \"${confirmCall.parameters.status}\"`\n            : JSON.stringify(confirmCall.parameters)\n\n        store.appendStreamingContent(\n          `\\n\\n**Confirmation required:** ${toolDesc} (${paramSummary})`\n        )\n      }\n\n      // Build actions (including confirmation buttons if needed)\n      const actions = buildMessageActions(fullContent, confirmationTools)\n      store.completeStreamingMessage({ actions })\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get response'\n      store.failStreamingMessage(errorMessage)\n      console.error('[AIChat] Error:', err)\n    }\n  }\n\n  // ============================================================================\n  // ReAct (Reasoning + Acting) Loop\n  // ============================================================================\n\n  /**\n   * Send a message using the ReAct (Reasoning + Acting) multi-step loop.\n   *\n   * The AI reasons about what to do, calls tools, receives results,\n   * then reasons again — repeating until it provides a final answer\n   * (no more tool calls) or the circuit breaker fires (MAX_REACT_STEPS).\n   *\n   * Only supported for cloud providers (Groq/OpenRouter) with native\n   * function calling. Falls back to regular sendMessage for local providers.\n   *\n   * @see TASK-1237 in MASTER_PLAN.md\n   */\n  async function sendMessageWithReAct(\n    content: string,\n    options: SendMessageOptions = {}\n  ): Promise<void> {\n    if (!content.trim()) return\n    if (store.isGenerating) return\n\n    // Set up abort controller for this ReAct session\n    const abortController = new AbortController()\n    reactAbortController.value = abortController\n\n    // Clear input\n    store.inputText = ''\n    store.clearError()\n\n    // Add user message\n    if (!options.skipHistory) {\n      store.addUserMessage(content)\n    }\n\n    // Start streaming response\n    store.startStreamingMessage()\n\n    try {\n      const router = await getRouter()\n      const conversationMessages: RouterChatMessage[] = buildMessagesForAI(content)\n      const taskType = options.taskType ?? inferTaskType(content)\n\n      let stepCount = 0\n      let continueLoop = true\n\n      while (continueLoop && stepCount < MAX_REACT_STEPS) {\n        // Check if aborted\n        if (abortController.signal.aborted) {\n          store.appendStreamingContent('\\n\\n---\\n*ReAct loop aborted by user.*')\n          break\n        }\n\n        stepCount++\n\n        let fullContent = ''\n        let nativeToolCalls: NativeToolCall[] | undefined\n\n        // Stream the response\n        for await (const chunk of router.chatStream(conversationMessages, {\n          taskType,\n          systemPrompt: options.systemPrompt,\n          forceProvider: selectedProvider.value !== 'auto' ? selectedProvider.value as RouterProviderType : undefined,\n          model: selectedModel.value || undefined,\n          tools: buildOpenAITools(),\n          toolChoice: 'auto' as const,\n        })) {\n          // Check abort between chunks\n          if (abortController.signal.aborted) {\n            break\n          }\n          store.appendStreamingContent(chunk.content)\n          fullContent += chunk.content\n          if (chunk.toolCalls && chunk.toolCalls.length > 0) {\n            nativeToolCalls = chunk.toolCalls\n          }\n        }\n\n        // If aborted during streaming, exit\n        if (abortController.signal.aborted) {\n          store.appendStreamingContent('\\n\\n---\\n*ReAct loop aborted by user.*')\n          break\n        }\n\n        // Check for tool calls\n        if (nativeToolCalls && nativeToolCalls.length > 0) {\n          // Parse native tool calls into ToolCall format\n          const toolCalls = nativeToolCalls\n            .map(tc => {\n              try {\n                return { tool: tc.function.name, parameters: JSON.parse(tc.function.arguments) } as ToolCall\n              } catch {\n                return null\n              }\n            })\n            .filter((tc): tc is ToolCall => tc !== null)\n            .slice(0, MAX_TOOLS_PER_RESPONSE)\n\n          // Separate confirmation vs immediate tools\n          const immediateTools = toolCalls.filter(c => !toolRequiresConfirmation(c.tool))\n          const confirmationTools = toolCalls.filter(c => toolRequiresConfirmation(c.tool))\n\n          // Execute immediate tools\n          const toolResults: ToolResult[] = []\n          for (const call of immediateTools) {\n            console.log(`[AIChat] ReAct step ${stepCount} - executing tool:`, call.tool, call.parameters)\n            const result = await executeTool(call)\n            toolResults.push(result)\n\n            // Push undo if available\n            if (result.success && result.undoAction) {\n              store.pushUndoEntry({\n                toolName: call.tool,\n                timestamp: Date.now(),\n                params: call.parameters,\n                undoAction: result.undoAction,\n                description: result.message,\n              })\n            }\n          }\n\n          // Accumulate tool results in message metadata\n          const lastMsg = store.messages[store.messages.length - 1]\n          if (lastMsg) {\n            const existingResults = ((lastMsg.metadata as Record<string, unknown>)?.toolResults as unknown[]) || []\n            lastMsg.metadata = {\n              ...lastMsg.metadata,\n              toolResults: [\n                ...existingResults,\n                ...toolResults.map((r, i) => ({\n                  success: r.success,\n                  message: r.message,\n                  data: r.data,\n                  tool: immediateTools[i]?.tool || 'unknown',\n                  type: AI_TOOLS.find(t => t.name === immediateTools[i]?.tool)?.category || 'read',\n                })),\n              ],\n            } as Record<string, unknown>\n          }\n\n          // If there are confirmation tools, stop the loop (need user input)\n          if (confirmationTools.length > 0) {\n            pendingConfirmation.value = confirmationTools[0]\n            const toolDef = AI_TOOLS.find(t => t.name === confirmationTools[0].tool)\n            const toolDesc = toolDef?.description || confirmationTools[0].tool\n            store.appendStreamingContent(\n              `\\n\\n**Confirmation required:** ${toolDesc}`\n            )\n            continueLoop = false\n            break\n          }\n\n          // Feed tool results back to AI for next reasoning step\n          conversationMessages.push({\n            role: 'assistant',\n            content: fullContent || '',\n          })\n\n          // Add tool results as a user message so the AI can reason about them\n          const toolResultsSummary = toolResults\n            .map(r => `[${r.success ? 'OK' : 'ERROR'}] ${r.message}${r.data ? '\\nData: ' + JSON.stringify(r.data).slice(0, 500) : ''}`)\n            .join('\\n\\n')\n\n          conversationMessages.push({\n            role: 'user',\n            content: `Tool results:\\n${toolResultsSummary}\\n\\nContinue reasoning or provide your final answer.`,\n          })\n\n          // Add step indicator to streaming content\n          store.appendStreamingContent(\n            `\\n\\n---\\n*Step ${stepCount}: executed ${toolResults.length} tool(s)*\\n\\n`\n          )\n\n        } else {\n          // No tool calls = final answer, exit loop\n          continueLoop = false\n        }\n      }\n\n      // If we hit the circuit breaker\n      if (stepCount >= MAX_REACT_STEPS && continueLoop) {\n        store.appendStreamingContent(\n          `\\n\\n---\\n*Reached maximum reasoning steps (${MAX_REACT_STEPS}). Stopping.*`\n        )\n      }\n\n      // Clean up: strip any lingering tool blocks from the final message\n      const lastMsg = store.messages[store.messages.length - 1]\n      if (lastMsg && lastMsg.isStreaming) {\n        lastMsg.content = stripToolBlocks(lastMsg.content || '')\n      }\n\n      store.completeStreamingMessage()\n\n      // Update provider badge\n      try {\n        const currentRouter = await getRouter()\n        const lastUsed = currentRouter.getLastUsedProvider()\n        if (lastUsed) activeProviderRef.value = lastUsed\n      } catch { /* ignore */ }\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get response'\n      store.failStreamingMessage(errorMessage)\n      console.error('[AIChat] ReAct error:', err)\n    } finally {\n      // Clean up abort controller\n      if (reactAbortController.value === abortController) {\n        reactAbortController.value = null\n      }\n    }\n  }\n\n  /**\n   * Build action buttons for a message, including confirmation buttons and\n   * content-based actions wired to real tools.\n   */\n  function buildMessageActions(\n    content: string,\n    confirmationTools: ToolCall[]\n  ): ChatAction[] | undefined {\n    const actions: ChatAction[] = []\n\n    // Confirmation actions for destructive tools\n    if (confirmationTools.length > 0) {\n      actions.push({\n        id: 'confirm_action',\n        label: 'Confirm',\n        variant: 'danger',\n        handler: async () => {\n          await confirmPendingAction()\n        },\n      })\n      actions.push({\n        id: 'cancel_action',\n        label: 'Cancel',\n        variant: 'secondary',\n        handler: async () => {\n          cancelPendingAction()\n        },\n      })\n    }\n\n    // Content-based actions wired to real tools\n    const parsedActions = parseActionsFromResponse(content)\n    if (parsedActions) {\n      actions.push(...parsedActions)\n    }\n\n    return actions.length > 0 ? actions : undefined\n  }\n\n  /**\n   * Confirm and execute the pending destructive tool action.\n   */\n  async function confirmPendingAction(): Promise<void> {\n    const call = pendingConfirmation.value\n    if (!call) return\n\n    pendingConfirmation.value = null\n\n    // Force confirmed=true for destructive tools\n    const confirmedCall: ToolCall = {\n      tool: call.tool,\n      parameters: { ...call.parameters, confirmed: true },\n    }\n\n    console.log('[AIChat] Executing confirmed tool:', confirmedCall.tool, confirmedCall.parameters)\n    const result = await executeTool(confirmedCall)\n    console.log('[AIChat] Confirmed tool result:', result)\n\n    if (result.success && result.undoAction) {\n      store.pushUndoEntry({\n        toolName: call.tool,\n        timestamp: Date.now(),\n        params: call.parameters,\n        undoAction: result.undoAction,\n        description: result.message,\n      })\n    }\n\n    // Add result message to chat\n    store.addAssistantMessage(\n      result.success ? result.message : `Error: ${result.message}`\n    )\n  }\n\n  /**\n   * Cancel the pending destructive tool action.\n   */\n  function cancelPendingAction(): void {\n    pendingConfirmation.value = null\n    store.addAssistantMessage('Action cancelled.')\n  }\n\n  /**\n   * Infer task type is no longer used for routing — the model decides via native tool calling.\n   * Kept only for provider selection hints (local vs cloud preference).\n   */\n  function inferTaskType(_content: string): TaskType {\n    return 'chat'\n  }\n\n  /**\n   * Parse action buttons from AI response.\n   * Actions are wired to real tool calls (create_subtasks, create_group).\n   */\n  function parseActionsFromResponse(content: string): ChatAction[] | undefined {\n    const actions: ChatAction[] = []\n\n    // Check for task breakdown patterns - wire to create_subtasks tool\n    if (content.includes('subtask') || content.includes('breakdown')) {\n      actions.push({\n        id: 'create_subtasks',\n        label: 'Create Subtasks',\n        variant: 'primary',\n        handler: async () => {\n          const selectedTask = store.context.selectedTask\n          if (!selectedTask) {\n            store.addAssistantMessage('Please select a task first to create subtasks for.')\n            return\n          }\n\n          // Parse subtask titles from the AI response\n          // Look for numbered lists (1. Title, 2. Title, etc.) or bullet points (- Title)\n          const subtaskTitles = parseSubtaskTitlesFromContent(content)\n          if (subtaskTitles.length === 0) {\n            store.addAssistantMessage('Could not find subtask suggestions in the response. Try asking again.')\n            return\n          }\n\n          const call: ToolCall = {\n            tool: 'create_subtasks',\n            parameters: {\n              parentTaskId: selectedTask.id,\n              subtasks: subtaskTitles.map(title => ({ title })),\n            },\n          }\n\n          const result = await executeTool(call)\n          store.addAssistantMessage(\n            result.success ? result.message : `Error: ${result.message}`\n          )\n        },\n      })\n    }\n\n    // Check for grouping patterns - wire to create_group tool\n    if (content.includes('group') && content.includes('suggest')) {\n      actions.push({\n        id: 'create_group',\n        label: 'Create Group',\n        variant: 'primary',\n        handler: async () => {\n          // Parse group name from the AI response\n          const groupName = parseGroupNameFromContent(content)\n          if (!groupName) {\n            store.addAssistantMessage('Could not determine a group name from the suggestion. Try asking again.')\n            return\n          }\n\n          const call: ToolCall = {\n            tool: 'create_group',\n            parameters: { name: groupName },\n          }\n\n          const result = await executeTool(call)\n          store.addAssistantMessage(\n            result.success ? result.message : `Error: ${result.message}`\n          )\n        },\n      })\n    }\n\n    return actions.length > 0 ? actions : undefined\n  }\n\n  /**\n   * Extract subtask titles from AI response content.\n   * Looks for numbered lists (1. Title) or bullet points (- Title).\n   */\n  function parseSubtaskTitlesFromContent(content: string): string[] {\n    const titles: string[] = []\n    const lines = content.split('\\n')\n\n    for (const line of lines) {\n      const trimmed = line.trim()\n      // Match \"1. Title\", \"2. Title\", etc.\n      const numberedMatch = trimmed.match(/^\\d+[\\.\\)]\\s+(.+)/)\n      // Match \"- Title\" or \"* Title\"\n      const bulletMatch = trimmed.match(/^[-*]\\s+(.+)/)\n\n      const match = numberedMatch || bulletMatch\n      if (match) {\n        // Clean up: remove trailing punctuation, markdown bold, etc.\n        const title = match[1].replace(/\\*\\*/g, '').trim()\n        // Skip lines that look like descriptions rather than titles (too long)\n        if (title.length > 0 && title.length <= 120) {\n          titles.push(title)\n        }\n      }\n    }\n\n    return titles\n  }\n\n  /**\n   * Extract a group name from AI response content.\n   * Looks for quoted names or bold text near \"group\" keyword.\n   */\n  function parseGroupNameFromContent(content: string): string | null {\n    // Try: \"group called \"Name\"\" or \"group: \"Name\"\"\n    const quotedMatch = content.match(/group\\s*(?:called|named|:)\\s*[\"\"](.+?)[\"\"]/i)\n    if (quotedMatch) return quotedMatch[1]\n\n    // Try: bold text near \"group\" keyword (\"**Name**\")\n    const boldMatch = content.match(/group.*?\\*\\*(.+?)\\*\\*/i)\n    if (boldMatch) return boldMatch[1]\n\n    // Try: first quoted string in the response\n    const anyQuoted = content.match(/[\"\"](.+?)[\"\"]/i)\n    if (anyQuoted) return anyQuoted[1]\n\n    return null\n  }\n\n  // ============================================================================\n  // Quick Actions\n  // ============================================================================\n\n  /**\n   * Quick action: Organize my canvas.\n   */\n  async function organizeCanvas(): Promise<void> {\n    await sendMessage(\n      'Analyze my canvas and suggest how to organize my tasks into groups.',\n      { taskType: 'canvas_analysis' }\n    )\n  }\n\n  /**\n   * Quick action: Break down selected task.\n   */\n  async function breakdownSelectedTask(): Promise<void> {\n    const task = store.context.selectedTask\n    if (!task) {\n      store.addAssistantMessage(\n        'Please select a task first, then ask me to break it down.'\n      )\n      return\n    }\n\n    await sendMessage(\n      `Break down the task \"${task.title}\" into actionable subtasks.`,\n      { taskType: 'task_breakdown' }\n    )\n  }\n\n  /**\n   * Quick action: Plan my week.\n   */\n  async function planWeek(): Promise<void> {\n    await executeAgentChain('plan_my_week')\n  }\n\n  /**\n   * Execute a tool directly (bypassing AI).\n   * Used for quick actions that map 1:1 to a tool.\n   */\n  async function executeDirectTool(label: string, toolCall: ToolCall): Promise<void> {\n    if (!toolCall) return\n\n    // Add user message to show action\n    store.addUserMessage(label)\n\n    // Start assistant response\n    store.startStreamingMessage()\n    store.appendStreamingContent(`Executing ${label}...`)\n\n    try {\n      console.log('[AIChat] Executing direct tool:', toolCall.tool, toolCall.parameters)\n      const result = await executeTool(toolCall)\n      console.log('[AIChat] Direct tool result:', result)\n\n      if (result.success && result.undoAction) {\n        store.pushUndoEntry({\n          toolName: toolCall.tool,\n          timestamp: Date.now(),\n          params: toolCall.parameters,\n          undoAction: result.undoAction,\n          description: result.message,\n        })\n      }\n\n      // Update message with result\n      const resultMsg = result.success ? result.message : `Error: ${result.message}`\n      store.appendStreamingContent(`\\n\\n${resultMsg}`)\n\n      // Add tool result metadata\n      const lastMsg = store.messages[store.messages.length - 1]\n      if (lastMsg && lastMsg.isStreaming) {\n        lastMsg.metadata = {\n          ...lastMsg.metadata,\n          toolResults: [{\n            success: result.success,\n            message: result.message,\n            data: result.data,\n            tool: toolCall.tool,\n            type: AI_TOOLS.find(t => t.name === toolCall.tool)?.category || 'read',\n          }],\n        } as any\n      }\n\n      store.completeStreamingMessage()\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Action failed'\n      store.failStreamingMessage(errorMessage)\n    }\n  }\n\n  // ============================================================================\n  // Agent Chains\n  // ============================================================================\n\n  /**\n   * Execute a predefined agent chain.\n   * Runs tool steps sequentially, shows progress, and sends final prompt to AI.\n   */\n  async function executeAgentChain(chainId: string): Promise<void> {\n    if (store.isGenerating) return\n\n    const chain = agentChains.chains.find((c) => c.id === chainId)\n    if (!chain) {\n      store.addAssistantMessage(`Chain not found: ${chainId}`)\n      return\n    }\n\n    // Clear input and add user message\n    store.inputText = ''\n    store.clearError()\n    store.addUserMessage(chain.name)\n\n    // Start streaming message to show progress\n    store.startStreamingMessage()\n\n    try {\n      // Execute the chain\n      console.log(`[AIChat] Starting agent chain: ${chain.name}`)\n      const { results, finalPrompt } = await agentChains.executeChain(chainId)\n\n      // Show tool results as they come in (add to message metadata)\n      const lastMsg = store.messages[store.messages.length - 1]\n      if (lastMsg && lastMsg.isStreaming) {\n        lastMsg.metadata = {\n          ...lastMsg.metadata,\n          toolResults: results.map((r, i) => {\n            const step = chain.steps[i]\n            const toolName = step.type === 'tool' ? step.tool : 'prompt'\n            return {\n              success: r.success,\n              message: r.message,\n              data: r.data,\n              tool: toolName || 'unknown',\n              type: 'read' as const,\n            }\n          }),\n        } as any\n      }\n\n      // If there's a final prompt, send it to the AI\n      if (finalPrompt) {\n        // Update streaming content with a loading message\n        store.appendStreamingContent('Analyzing results...')\n\n        // Send the prompt through the AI\n        const router = await getRouter()\n        const aiMessages: RouterChatMessage[] = [\n          { role: 'system', content: 'You are FlowState AI, a friendly productivity assistant. Respond concisely.' },\n          { role: 'user', content: finalPrompt },\n        ]\n\n        let fullResponse = ''\n        for await (const chunk of router.chatStream(aiMessages, {\n          taskType: 'chat',\n          forceProvider: selectedProvider.value !== 'auto' ? selectedProvider.value as RouterProviderType : undefined,\n          model: selectedModel.value || undefined,\n        })) {\n          fullResponse += chunk.content\n        }\n\n        // Replace loading message with AI response\n        const cleanResponse = stripToolBlocks(fullResponse)\n        if (lastMsg && lastMsg.isStreaming) {\n          lastMsg.content = cleanResponse\n          store.streamingContent = cleanResponse\n        }\n      } else {\n        // No final prompt — just show tool results\n        const summary = `Completed chain \"${chain.name}\" with ${results.length} steps.`\n        if (lastMsg && lastMsg.isStreaming) {\n          lastMsg.content = summary\n          store.streamingContent = summary\n        }\n      }\n\n      store.completeStreamingMessage()\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Chain execution failed'\n      store.failStreamingMessage(errorMessage)\n      console.error('[AIChat] Agent chain error:', err)\n    }\n  }\n\n  // ============================================================================\n  // Panel Management\n  // ============================================================================\n\n  /**\n   * Open panel with a specific context.\n   */\n  function openWithContext(ctx: Partial<ChatContext>) {\n    store.updateContext(ctx)\n    store.openPanel()\n  }\n\n  /**\n   * Open panel for a specific task.\n   */\n  function openForTask(task: { id: string; title: string }) {\n    const fullTask = taskStore.getTask(task.id)\n    store.setSelectedTask(fullTask)\n    store.openPanel()\n  }\n\n  // ============================================================================\n  // Keyboard Shortcut\n  // ============================================================================\n\n  /**\n   * Handle keyboard shortcut (Ctrl+/).\n   */\n  function handleKeyboardShortcut(event: KeyboardEvent) {\n    if (event.ctrlKey && event.key === '/') {\n      event.preventDefault()\n      store.togglePanel()\n    }\n  }\n\n  // ============================================================================\n  // Lifecycle\n  // ============================================================================\n\n  /**\n   * Refresh available Ollama models.\n   */\n  async function refreshOllamaModels() {\n    isLoadingModels.value = true\n    try {\n      availableOllamaModels.value = await fetchOllamaModels()\n    } finally {\n      isLoadingModels.value = false\n    }\n  }\n\n  /**\n   * Set the active provider (auto, groq, or ollama).\n   * Persists the selection to localStorage via the store.\n   */\n  async function setProvider(provider: 'ollama' | 'groq' | 'openrouter' | 'auto') {\n    // Save current model for the outgoing provider\n    providerModelMemory.value[selectedProvider.value] = selectedModel.value\n\n    // Switch provider\n    selectedProvider.value = provider\n\n    // Restore saved model for the incoming provider (or null if none saved)\n    selectedModel.value = providerModelMemory.value[provider] ?? null\n\n    store.updatePersistedSettings({\n      provider,\n      model: selectedModel.value || '',\n    })\n\n    // Update active provider badge\n    if (provider === 'auto') {\n      try {\n        const router = await getRouter()\n        const detectedProvider = await router.getActiveProvider()\n        activeProviderRef.value = detectedProvider\n      } catch {\n        activeProviderRef.value = null\n      }\n    } else {\n      activeProviderRef.value = provider\n    }\n\n    if (provider === 'ollama' && availableOllamaModels.value.length === 0) {\n      refreshOllamaModels()\n    }\n  }\n\n  /**\n   * Set the model to use (null = default for provider).\n   * Persists the selection to localStorage via the store.\n   */\n  function setModel(model: string | null) {\n    selectedModel.value = model\n    store.updatePersistedSettings({\n      provider: selectedProvider.value,\n      model: model || '',\n    })\n  }\n\n  /**\n   * Initialize the AI chat system.\n   * Loads persisted provider/model settings from store.\n   */\n  async function initialize() {\n    store.initialize()\n\n    // Load persisted settings\n    const savedSettings = store.getPersistedSettings()\n    if (savedSettings) {\n      if (['ollama', 'groq', 'openrouter', 'auto'].includes(savedSettings.provider)) {\n        selectedProvider.value = savedSettings.provider as typeof selectedProvider.value\n      }\n      if (savedSettings.model) {\n        // Validate persisted model matches persisted provider\n        // Groq models contain '-' and numbers (e.g. llama-3.3-70b-versatile)\n        // Ollama models contain ':' (e.g. llama3.2:latest)\n        const model = savedSettings.model\n        const provider = selectedProvider.value\n        const looksLikeOllama = model.includes(':')\n        const looksLikeGroq = /\\d/.test(model) && model.includes('-') && !model.includes(':')\n\n        if (provider === 'groq' && looksLikeOllama) {\n          // Ollama model persisted but provider is Groq — reset\n          selectedModel.value = null\n        } else if (provider === 'ollama' && looksLikeGroq) {\n          // Groq model persisted but provider is Ollama — reset\n          selectedModel.value = null\n        } else {\n          selectedModel.value = model\n        }\n      }\n    }\n\n    // Pre-initialize the router\n    try {\n      const routerInstance = await getRouter()\n      // Only auto-detect active provider when in auto mode.\n      // If user explicitly selected a provider, respect their choice.\n      if (selectedProvider.value === 'auto') {\n        const provider = await routerInstance!.getActiveProvider()\n        activeProviderRef.value = provider\n      } else {\n        activeProviderRef.value = selectedProvider.value\n      }\n      // Fetch available Ollama models\n      availableOllamaModels.value = await fetchOllamaModels()\n    } catch (err) {\n      console.warn('[AIChat] Router initialization failed, will retry on first use:', err)\n    }\n  }\n\n  // ============================================================================\n  // Return\n  // ============================================================================\n\n  return {\n    // State (from store)\n    isPanelOpen,\n    messages,\n    inputText,\n    isGenerating,\n    streamingContent,\n    context,\n    pendingSuggestionCount,\n    error,\n    activeProvider: activeProviderRef,\n\n    // Provider/model selection\n    selectedProvider,\n    selectedModel,\n    availableOllamaModels,\n    isLoadingModels,\n    setProvider,\n    setModel,\n    refreshOllamaModels,\n\n    // Confirmation flow\n    pendingConfirmation,\n    confirmPendingAction,\n    cancelPendingAction,\n\n    // Computed\n    visibleMessages,\n    canSend,\n\n    // Panel actions\n    togglePanel: store.togglePanel,\n    openPanel: store.openPanel,\n    closePanel: store.closePanel,\n    openWithContext,\n    openForTask,\n\n    // Message actions\n    sendMessage,\n    sendMessageWithReAct,\n    abortReAct,\n    clearMessages: store.clearMessages,\n    clearError: store.clearError,\n\n    // Quick actions\n    organizeCanvas,\n    breakdownSelectedTask,\n    planWeek,\n\n    // Context\n    setCurrentView: store.setCurrentView,\n    setSelectedTask: store.setSelectedTask,\n    updateContext: store.updateContext,\n\n    // Personality\n    aiPersonality,\n    setPersonality,\n\n    // Agent chains\n    executeAgentChain,\n    agentChains: agentChains.chains,\n    chainExecution: agentChains.currentExecution,\n    abortChain: agentChains.abortChain,\n\n    // Lifecycle\n    initialize,\n    handleKeyboardShortcut,\n    executeDirectTool\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useAIProactiveNudges.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onMounted' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":24,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"onMounted"},"fix":{"range":[219,230],"text":""},"desc":"Remove unused variable \"onMounted\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onUnmounted' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":37,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"onUnmounted"},"fix":{"range":[230,243],"text":""},"desc":"Remove unused variable \"onUnmounted\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":44,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"watch"},"fix":{"range":[243,250],"text":""},"desc":"Remove unused variable \"watch\"."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Proactive Nudges\n *\n * Watches user activity and pushes contextual suggestions to the AI chat.\n * Uses localStorage for cooldown tracking to avoid spam.\n *\n * @see TASK-1283 in MASTER_PLAN.md\n */\n\nimport { ref, onMounted, onUnmounted, watch } from 'vue'\nimport { useAIChatStore } from '@/stores/aiChat'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useChallengesStore } from '@/stores/challenges'\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst NUDGE_STORAGE_KEY = 'flowstate-nudge-cooldowns'\nconst CHECK_INTERVAL_MS = 5 * 60 * 1000 // 5 minutes\n\n/** Cooldowns in milliseconds */\nconst COOLDOWNS = {\n  morning: 24 * 60 * 60 * 1000,       // 1x/day\n  evening: 24 * 60 * 60 * 1000,       // 1x/day\n  idle: 2 * 60 * 60 * 1000,           // 1x/2hr\n  taskCompleted: 5 * 60 * 1000,       // 1x/5min\n  streakAtRisk: 24 * 60 * 60 * 1000,  // 1x/day\n  challengeExpiring: 2 * 60 * 60 * 1000, // 1x/2hr\n} as const\n\ntype NudgeType = keyof typeof COOLDOWNS\n\n// ============================================================================\n// Cooldown Storage\n// ============================================================================\n\nfunction getCooldowns(): Record<string, number> {\n  try {\n    const raw = localStorage.getItem(NUDGE_STORAGE_KEY)\n    return raw ? JSON.parse(raw) : {}\n  } catch {\n    return {}\n  }\n}\n\nfunction setCooldown(type: NudgeType) {\n  try {\n    const cooldowns = getCooldowns()\n    cooldowns[type] = Date.now()\n    localStorage.setItem(NUDGE_STORAGE_KEY, JSON.stringify(cooldowns))\n  } catch {\n    // silently ignore\n  }\n}\n\nfunction canNudge(type: NudgeType): boolean {\n  const cooldowns = getCooldowns()\n  const lastTime = cooldowns[type]\n  if (!lastTime) return true\n  return Date.now() - lastTime > COOLDOWNS[type]\n}\n\n// ============================================================================\n// Composable\n// ============================================================================\n\nexport function useAIProactiveNudges() {\n  const isActive = ref(false)\n  let intervalId: ReturnType<typeof setInterval> | null = null\n  let lastActivityTime = Date.now()\n\n  // Track user activity for idle detection\n  function onUserActivity() {\n    lastActivityTime = Date.now()\n  }\n\n  /**\n   * Push a nudge message to the AI chat.\n   */\n  function pushNudge(type: NudgeType, content: string, actions?: Array<{ label: string; handler: () => void }>) {\n    if (!canNudge(type)) return\n\n    const chatStore = useAIChatStore()\n    if (!chatStore.isInitialized || !chatStore.isPanelOpen) return\n\n    const nudgeActions = actions?.map((a, i) => ({\n      id: `nudge_${type}_${Date.now()}_${i}`,\n      label: a.label,\n      variant: 'secondary' as const,\n      handler: async () => a.handler(),\n      completed: false,\n    }))\n\n    chatStore.addAssistantMessage(content, {\n      actions: nudgeActions,\n      metadata: { model: 'system' },\n    })\n\n    setCooldown(type)\n  }\n\n  /**\n   * Check all nudge conditions and push any that trigger.\n   */\n  function checkNudges() {\n    const hour = new Date().getHours()\n\n    // ── Morning greeting (6-10am) ──\n    if (hour >= 6 && hour < 10 && canNudge('morning')) {\n      try {\n        const taskStore = useTaskStore()\n        const todayStr = new Date().toISOString().split('T')[0]\n        const normDate = (d: string) => d.includes('T') ? d.split('T')[0] : d\n\n        const overdue = taskStore.tasks.filter(t =>\n          t.dueDate && normDate(t.dueDate) < todayStr && t.status !== 'done'\n        ).length\n\n        const dueToday = taskStore.tasks.filter(t =>\n          t.dueDate && normDate(t.dueDate) === todayStr && t.status !== 'done'\n        ).length\n\n        if (overdue > 0 || dueToday > 0) {\n          const parts: string[] = []\n          if (overdue > 0) parts.push(`${overdue} overdue`)\n          if (dueToday > 0) parts.push(`${dueToday} due today`)\n\n          pushNudge(\n            'morning',\n            `Good morning! You have ${parts.join(' and ')}. Plan your day?`,\n            [\n              { label: 'Plan my day', handler: () => sendChatMessage('Plan my day — what should I focus on?') },\n              { label: \"What's overdue?\", handler: () => sendChatMessage(\"What's overdue?\") },\n            ]\n          )\n        }\n      } catch { /* stores not available */ }\n    }\n\n    // ── Evening review (5-9pm) ──\n    if (hour >= 17 && hour < 21 && canNudge('evening')) {\n      try {\n        const taskStore = useTaskStore()\n        const todayStr = new Date().toISOString().split('T')[0]\n\n        const completedToday = taskStore.tasks.filter(t => {\n          if (t.status !== 'done') return false\n          const completedDate = t.completedAt\n            ? new Date(t.completedAt).toISOString().split('T')[0]\n            : new Date(t.updatedAt).toISOString().split('T')[0]\n          return completedDate === todayStr\n        }).length\n\n        if (completedToday > 0) {\n          pushNudge(\n            'evening',\n            `End of day! You completed ${completedToday} task${completedToday > 1 ? 's' : ''}. Review your day?`,\n            [\n              { label: 'Show my summary', handler: () => sendChatMessage('Give me my daily summary') },\n            ]\n          )\n        }\n      } catch { /* stores not available */ }\n    }\n\n    // ── Idle detection (>30 min) ──\n    const idleMinutes = (Date.now() - lastActivityTime) / 60000\n    if (idleMinutes > 30 && canNudge('idle')) {\n      try {\n        const timerStore = useTimerStore()\n        if (!timerStore.isTimerActive) {\n          pushNudge(\n            'idle',\n            \"Been a while — want a task suggestion?\",\n            [\n              { label: 'Suggest next task', handler: () => sendChatMessage('Suggest my next task') },\n            ]\n          )\n        }\n      } catch { /* timer store not available */ }\n    }\n\n    // ── Streak at risk ──\n    if (canNudge('streakAtRisk')) {\n      try {\n        const gamStore = useGamificationStore()\n        if (gamStore.isInitialized && gamStore.streakInfo.streakAtRisk && gamStore.streakInfo.currentStreak > 0) {\n          pushNudge(\n            'streakAtRisk',\n            `Your ${gamStore.streakInfo.currentStreak}-day streak is at risk! Complete one more task.`,\n            [\n              { label: 'Suggest a quick task', handler: () => sendChatMessage('Suggest a quick task I can complete right now') },\n            ]\n          )\n        }\n      } catch { /* gamification not available */ }\n    }\n\n    // ── Challenge expiring ──\n    if (canNudge('challengeExpiring')) {\n      try {\n        const challengeStore = useChallengesStore()\n        if (challengeStore.isInitialized) {\n          const expiring = challengeStore.activeDailies.find(c => {\n            const timeRemaining = Math.max(0, (c.expiresAt.getTime() - Date.now()) / 60000)\n            return timeRemaining < 120 && timeRemaining > 0 && c.objectiveCurrent < c.objectiveTarget\n          })\n\n          if (expiring) {\n            const progress = Math.round((expiring.objectiveCurrent / expiring.objectiveTarget) * 100)\n            const timeLeft = Math.round((expiring.expiresAt.getTime() - Date.now()) / 60000)\n            const timeStr = timeLeft > 60 ? `${Math.floor(timeLeft / 60)}h` : `${timeLeft}m`\n\n            pushNudge(\n              'challengeExpiring',\n              `Your \"${expiring.title}\" challenge expires in ${timeStr}. ${progress}% done.`,\n              [\n                { label: 'Show challenges', handler: () => sendChatMessage('Show my active challenges') },\n              ]\n            )\n          }\n        }\n      } catch { /* challenges not available */ }\n    }\n  }\n\n  /**\n   * Push a task-completed nudge.\n   * Call this from the task completion flow.\n   */\n  function onTaskCompleted(xpEarned?: number) {\n    if (!canNudge('taskCompleted')) return\n\n    try {\n      const taskStore = useTaskStore()\n      const todayStr = new Date().toISOString().split('T')[0]\n      const remaining = taskStore.tasks.filter(t => {\n        if (t.status === 'done') return false\n        const normDate = (d: string) => d.includes('T') ? d.split('T')[0] : d\n        return t.dueDate && normDate(t.dueDate) === todayStr\n      }).length\n\n      const xpStr = xpEarned ? ` +${xpEarned}XP earned.` : ''\n      const remainStr = remaining > 0 ? ` ${remaining} task${remaining > 1 ? 's' : ''} left today.` : ''\n\n      pushNudge(\n        'taskCompleted',\n        `Nice!${xpStr}${remainStr}`,\n        remaining > 0\n          ? [{ label: 'What\\'s next?', handler: () => sendChatMessage('Suggest my next task') }]\n          : undefined\n      )\n    } catch { /* stores not available */ }\n  }\n\n  /**\n   * Helper to send a message via the chat.\n   */\n  function sendChatMessage(content: string) {\n    const chatStore = useAIChatStore()\n    chatStore.inputText = content\n    // The chat panel's send handler will pick this up\n    // We dispatch a custom event for AIChatPanel to handle\n    window.dispatchEvent(new CustomEvent('ai-nudge-send', { detail: { content } }))\n  }\n\n  function start() {\n    if (isActive.value) return\n    isActive.value = true\n\n    // Initial check after brief delay (let app load)\n    setTimeout(checkNudges, 10_000)\n\n    // Periodic checks\n    intervalId = setInterval(checkNudges, CHECK_INTERVAL_MS)\n\n    // Track activity\n    window.addEventListener('mousemove', onUserActivity, { passive: true })\n    window.addEventListener('keydown', onUserActivity, { passive: true })\n    window.addEventListener('click', onUserActivity, { passive: true })\n  }\n\n  function stop() {\n    isActive.value = false\n    if (intervalId) {\n      clearInterval(intervalId)\n      intervalId = null\n    }\n    window.removeEventListener('mousemove', onUserActivity)\n    window.removeEventListener('keydown', onUserActivity)\n    window.removeEventListener('click', onUserActivity)\n  }\n\n  return {\n    isActive,\n    start,\n    stop,\n    checkNudges,\n    onTaskCompleted,\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useAITaskAssist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useAIUsageTracking.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":313,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":313,"endColumn":32,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8054,8055],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":322,"column":15,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":322,"endColumn":29},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":363,"column":28,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":363,"endColumn":54},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":386,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":386,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Usage Tracking Composable\n *\n * Aggregates token usage and cost data from AI chat conversations.\n * Computes per-provider and per-model usage statistics based on message metadata.\n *\n * @see TASK-1316 in MASTER_PLAN.md\n */\n\nimport { computed } from 'vue'\nimport { getUsageEntries, clearUsageEntries } from '@/services/ai/usageTracker'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Usage stats for a specific model.\n */\nexport interface ModelUsage {\n  /** Model identifier (e.g., 'llama3.2', 'llama-3.3-70b-versatile') */\n  model: string\n  /** Total tokens used by this model */\n  tokens: number\n  /** Number of requests made with this model */\n  requests: number\n  /** Estimated cost in USD for this model */\n  costUSD: number\n}\n\n/**\n * Usage stats for a provider, including breakdown by model.\n */\nexport interface ProviderUsage {\n  /** Provider identifier ('ollama', 'groq', 'openrouter') */\n  provider: string\n  /** Human-readable display name */\n  displayName: string\n  /** Total tokens across all models */\n  totalTokens: number\n  /** Total requests across all models */\n  totalRequests: number\n  /** Estimated total cost in USD */\n  estimatedCostUSD: number\n  /** Usage breakdown by model */\n  models: ModelUsage[]\n}\n\n/**\n * Overall usage summary across all providers.\n */\nexport interface UsageSummary {\n  /** Total tokens used across all providers */\n  totalTokens: number\n  /** Total requests across all providers */\n  totalRequests: number\n  /** Total estimated cost in USD */\n  totalCostUSD: number\n  /** Usage breakdown by provider */\n  providers: ProviderUsage[]\n  /** Time period label */\n  periodLabel: string\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Pricing per provider (per 1M tokens).\n * Must match PROVIDER_PRICING in src/services/ai/router.ts\n */\nconst PROVIDER_PRICING: Record<string, { input: number; output: number }> = {\n  ollama: { input: 0, output: 0 },           // Free (local)\n  groq: { input: 0.59, output: 0.79 },       // Llama 3.3 70B pricing\n  openrouter: { input: 3.00, output: 15.00 } // Claude 3.5 Sonnet via OpenRouter\n}\n\n/**\n * Display names for providers.\n */\nconst PROVIDER_DISPLAY_NAMES: Record<string, string> = {\n  ollama: 'Ollama (Local)',\n  groq: 'Groq',\n  openrouter: 'OpenRouter'\n}\n\n\n// ============================================================================\n// Model Pricing Catalog\n// ============================================================================\n\n/**\n * Pricing info for a single model.\n */\nexport interface ModelPricingInfo {\n  /** Model identifier as used by the provider */\n  model: string\n  /** Human-readable model name */\n  displayName: string\n  /** Provider this model belongs to */\n  provider: string\n  /** Input cost per 1M tokens (USD) */\n  inputPer1M: number\n  /** Output cost per 1M tokens (USD) */\n  outputPer1M: number\n  /** Context window size in tokens */\n  contextWindow: number\n  /** Whether this is the default model for its provider in FlowState */\n  isDefault?: boolean\n}\n\n/**\n * Full pricing catalog for all supported models.\n * Updated: February 2026\n * Sources: https://groq.com/pricing, https://openrouter.ai/pricing\n */\nexport const MODEL_PRICING_CATALOG: ModelPricingInfo[] = [\n  // --- Ollama (Local, Free) ---\n  {\n    model: 'llama3.2',\n    displayName: 'Llama 3.2 3B',\n    provider: 'ollama',\n    inputPer1M: 0,\n    outputPer1M: 0,\n    contextWindow: 128_000,\n    isDefault: true\n  },\n  {\n    model: 'llama3.1:8b',\n    displayName: 'Llama 3.1 8B',\n    provider: 'ollama',\n    inputPer1M: 0,\n    outputPer1M: 0,\n    contextWindow: 128_000\n  },\n  {\n    model: 'mistral',\n    displayName: 'Mistral 7B',\n    provider: 'ollama',\n    inputPer1M: 0,\n    outputPer1M: 0,\n    contextWindow: 32_000\n  },\n  {\n    model: 'gemma2',\n    displayName: 'Gemma 2 9B',\n    provider: 'ollama',\n    inputPer1M: 0,\n    outputPer1M: 0,\n    contextWindow: 8_192\n  },\n\n  // --- Groq (Cloud, Fast Inference) ---\n  // Source: https://groq.com/pricing (Feb 2026)\n  {\n    model: 'llama-3.3-70b-versatile',\n    displayName: 'Llama 3.3 70B Versatile',\n    provider: 'groq',\n    inputPer1M: 0.59,\n    outputPer1M: 0.79,\n    contextWindow: 128_000,\n    isDefault: true\n  },\n  {\n    model: 'llama-3.1-8b-instant',\n    displayName: 'Llama 3.1 8B Instant',\n    provider: 'groq',\n    inputPer1M: 0.05,\n    outputPer1M: 0.08,\n    contextWindow: 128_000\n  },\n  {\n    model: 'llama-4-scout-17bx16e',\n    displayName: 'Llama 4 Scout (17Bx16E)',\n    provider: 'groq',\n    inputPer1M: 0.11,\n    outputPer1M: 0.34,\n    contextWindow: 128_000\n  },\n  {\n    model: 'llama-4-maverick-17bx128e',\n    displayName: 'Llama 4 Maverick (17Bx128E)',\n    provider: 'groq',\n    inputPer1M: 0.20,\n    outputPer1M: 0.60,\n    contextWindow: 128_000\n  },\n  {\n    model: 'qwen-3-32b',\n    displayName: 'Qwen 3 32B',\n    provider: 'groq',\n    inputPer1M: 0.29,\n    outputPer1M: 0.59,\n    contextWindow: 131_000\n  },\n\n  // --- OpenRouter (Cloud, Premium Models) ---\n  // Source: https://openrouter.ai/pricing (Feb 2026)\n  {\n    model: 'anthropic/claude-sonnet-4.5',\n    displayName: 'Claude Sonnet 4.5',\n    provider: 'openrouter',\n    inputPer1M: 3.00,\n    outputPer1M: 15.00,\n    contextWindow: 200_000,\n    isDefault: true\n  },\n  {\n    model: 'anthropic/claude-sonnet-4',\n    displayName: 'Claude Sonnet 4',\n    provider: 'openrouter',\n    inputPer1M: 3.00,\n    outputPer1M: 15.00,\n    contextWindow: 200_000\n  },\n  {\n    model: 'anthropic/claude-opus-4',\n    displayName: 'Claude Opus 4',\n    provider: 'openrouter',\n    inputPer1M: 15.00,\n    outputPer1M: 75.00,\n    contextWindow: 200_000\n  },\n  {\n    model: 'openai/gpt-4o',\n    displayName: 'GPT-4o',\n    provider: 'openrouter',\n    inputPer1M: 2.50,\n    outputPer1M: 10.00,\n    contextWindow: 128_000\n  },\n  {\n    model: 'openai/gpt-4o-mini',\n    displayName: 'GPT-4o Mini',\n    provider: 'openrouter',\n    inputPer1M: 0.15,\n    outputPer1M: 0.60,\n    contextWindow: 128_000\n  },\n  {\n    model: 'google/gemini-2.0-flash',\n    displayName: 'Gemini 2.0 Flash',\n    provider: 'openrouter',\n    inputPer1M: 0.10,\n    outputPer1M: 0.40,\n    contextWindow: 1_000_000\n  },\n  {\n    model: 'deepseek/deepseek-v3',\n    displayName: 'DeepSeek V3',\n    provider: 'openrouter',\n    inputPer1M: 0.30,\n    outputPer1M: 0.88,\n    contextWindow: 128_000\n  }\n]\n\n// ============================================================================\n// Composable\n// ============================================================================\n\n/**\n * AI Usage Tracking Composable.\n *\n * Aggregates usage data from all conversations' messages.\n * Returns reactive computed properties for usage stats.\n *\n * Usage:\n * ```typescript\n * const { usageSummary, providerUsageByProvider } = useAIUsageTracking()\n * ```\n */\n/**\n * Time period for filtering usage data.\n */\nexport type UsagePeriod = 'week' | 'month' | 'all'\n\n/**\n * Get the start-of-period Date for a given period.\n */\nfunction getPeriodStart(period: UsagePeriod): Date | null {\n  if (period === 'all') return null\n  const now = new Date()\n  if (period === 'week') {\n    const day = now.getDay()\n    const diff = now.getDate() - day + (day === 0 ? -6 : 1) // Monday start\n    return new Date(now.getFullYear(), now.getMonth(), diff, 0, 0, 0, 0)\n  }\n  // month\n  return new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0)\n}\n\n/**\n * Pricing catalog grouped by provider for display.\n */\nexport interface ProviderPricingGroup {\n  provider: string\n  displayName: string\n  models: ModelPricingInfo[]\n}\n\n/**\n * Get the pricing catalog grouped by provider.\n */\nexport function getPricingByProvider(): ProviderPricingGroup[] {\n  const groups = new Map<string, ModelPricingInfo[]>()\n\n  for (const model of MODEL_PRICING_CATALOG) {\n    if (!groups.has(model.provider)) {\n      groups.set(model.provider, [])\n    }\n    groups.get(model.provider)!.push(model)\n  }\n\n  const order = ['ollama', 'groq', 'openrouter']\n  return order\n    .filter(p => groups.has(p))\n    .map(p => ({\n      provider: p,\n      displayName: PROVIDER_DISPLAY_NAMES[p] || p,\n      models: groups.get(p)!\n    }))\n}\n\nexport function useAIUsageTracking() {\n  const entries = getUsageEntries()\n\n  /**\n   * Aggregate usage from the centralized tracker, optionally filtered by time period.\n   * Reads from the router-level usage log — captures ALL AI calls (chat, weekly plan,\n   * task assist, gamification, and any future AI consumer).\n   */\n  function aggregateUsage(period: UsagePeriod): UsageSummary {\n    const periodStart = getPeriodStart(period)\n\n    const providerMap = new Map<string, {\n      totalTokens: number\n      totalRequests: number\n      totalCost: number\n      models: Map<string, { tokens: number; requests: number; cost: number }>\n    }>()\n\n    for (const entry of entries.value) {\n      // Filter by time period\n      if (periodStart) {\n        const entryDate = new Date(entry.timestamp)\n        if (entryDate < periodStart) continue\n      }\n\n      const { provider, model, inputTokens, outputTokens } = entry\n      const totalTokens = inputTokens + outputTokens\n\n      if (!providerMap.has(provider)) {\n        providerMap.set(provider, {\n          totalTokens: 0,\n          totalRequests: 0,\n          totalCost: 0,\n          models: new Map()\n        })\n      }\n\n      const providerData = providerMap.get(provider)!\n      providerData.totalTokens += totalTokens\n      providerData.totalRequests += 1\n\n      // Look up model-specific pricing from catalog, fall back to provider default\n      const catalogEntry = MODEL_PRICING_CATALOG.find(\n        m => m.model === model && m.provider === provider\n      )\n      const pricing = catalogEntry\n        ? { input: catalogEntry.inputPer1M, output: catalogEntry.outputPer1M }\n        : PROVIDER_PRICING[provider] || { input: 0, output: 0 }\n\n      const inputCost = (inputTokens / 1_000_000) * pricing.input\n      const outputCost = (outputTokens / 1_000_000) * pricing.output\n      const entryCost = inputCost + outputCost\n\n      providerData.totalCost += entryCost\n\n      const modelKey = model || 'unknown'\n      if (!providerData.models.has(modelKey)) {\n        providerData.models.set(modelKey, { tokens: 0, requests: 0, cost: 0 })\n      }\n\n      const modelData = providerData.models.get(modelKey)!\n      modelData.tokens += totalTokens\n      modelData.requests += 1\n      modelData.cost += entryCost\n    }\n\n    const providers: ProviderUsage[] = Array.from(providerMap.entries()).map(([provider, data]) => {\n      const models: ModelUsage[] = Array.from(data.models.entries()).map(([model, modelData]) => ({\n        model,\n        tokens: modelData.tokens,\n        requests: modelData.requests,\n        costUSD: modelData.cost\n      }))\n      models.sort((a, b) => b.tokens - a.tokens)\n\n      return {\n        provider,\n        displayName: PROVIDER_DISPLAY_NAMES[provider] || provider,\n        totalTokens: data.totalTokens,\n        totalRequests: data.totalRequests,\n        estimatedCostUSD: data.totalCost,\n        models\n      }\n    })\n\n    providers.sort((a, b) => b.totalTokens - a.totalTokens)\n\n    const periodLabels: Record<UsagePeriod, string> = {\n      week: 'This Week',\n      month: 'This Month',\n      all: 'All Time'\n    }\n\n    return {\n      totalTokens: providers.reduce((s, p) => s + p.totalTokens, 0),\n      totalRequests: providers.reduce((s, p) => s + p.totalRequests, 0),\n      totalCostUSD: providers.reduce((s, p) => s + p.estimatedCostUSD, 0),\n      providers,\n      periodLabel: periodLabels[period]\n    }\n  }\n\n  /** All time usage (reactive) */\n  const usageSummary = computed<UsageSummary>(() => aggregateUsage('all'))\n\n  /** This week usage (reactive) */\n  const weekUsage = computed<UsageSummary>(() => aggregateUsage('week'))\n\n  /** This month usage (reactive) */\n  const monthUsage = computed<UsageSummary>(() => aggregateUsage('month'))\n\n  /** Pricing catalog grouped by provider */\n  const pricingCatalog = computed(() => getPricingByProvider())\n\n  /** Check if there is any usage data */\n  const hasUsageData = computed(() => usageSummary.value.totalTokens > 0)\n\n  function getProviderUsage(provider: string): ProviderUsage | null {\n    return usageSummary.value.providers.find(p => p.provider === provider) || null\n  }\n\n  return {\n    usageSummary,\n    weekUsage,\n    monthUsage,\n    hasUsageData,\n    pricingCatalog,\n    getProviderUsage,\n    clearUsageData: clearUsageEntries\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useAgentChains.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2342,2345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2342,2345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2392,2395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2392,2395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2444,2447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2444,2447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2878,2881],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2878,2881],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3163,3166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3163,3166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4024,4027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4024,4027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4073,4076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4073,4076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4128,4131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4128,4131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5287,5290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5287,5290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5711,5714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5711,5714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":230,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7117,7120],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7117,7120],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7165,7168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7165,7168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7218,7221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7218,7221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":330,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":330,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Agent Chains - Deterministic Multi-Step AI Workflows\n *\n * Predefined sequences of tool calls + AI prompts that work reliably\n * with ALL providers including Ollama (no native function calling needed).\n *\n * Unlike free-form chat, these follow a fixed script:\n * 1. Execute tool calls in sequence\n * 2. Build final prompt from tool results\n * 3. Return prompt for AI to process\n *\n * @see TASK-1236 in MASTER_PLAN.md\n */\n\nimport { ref } from 'vue'\nimport { executeTool, type ToolCall, type ToolResult } from '@/services/ai/tools'\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface AgentChain {\n  id: string\n  name: string\n  description: string\n  icon: string // lucide icon name\n  steps: AgentChainStep[]\n}\n\nexport interface AgentChainStep {\n  type: 'tool' | 'prompt'\n  // For 'tool' type:\n  tool?: string\n  parameters?: Record<string, unknown>\n  /** Extract data from previous step results. Receives all prior results. */\n  parametersFn?: (priorResults: ToolResult[]) => Record<string, unknown> | null\n  // For 'prompt' type:\n  promptFn?: (priorResults: ToolResult[]) => string\n  /** If true, skip this step if parametersFn returns null */\n  optional?: boolean\n}\n\nexport interface ChainExecution {\n  chainId: string\n  isRunning: boolean\n  currentStep: number\n  totalSteps: number\n  results: ToolResult[]\n  error: string | null\n}\n\n// ============================================================================\n// Chain Definitions\n// ============================================================================\n\nconst chains: AgentChain[] = [\n  // ── Chain 1: Plan My Day ──────────────────────────────────────────────\n  {\n    id: 'plan_my_day',\n    name: 'Plan My Day',\n    description: 'Get a prioritized plan for today based on your tasks and schedule',\n    icon: 'Calendar',\n    steps: [\n      {\n        type: 'tool',\n        tool: 'get_daily_summary',\n        parameters: {},\n      },\n      {\n        type: 'tool',\n        tool: 'get_overdue_tasks',\n        parameters: {},\n      },\n      {\n        type: 'tool',\n        tool: 'suggest_next_task',\n        parameters: {},\n      },\n      {\n        type: 'prompt',\n        promptFn: (results) => {\n          const summary = results[0]?.data as any\n          const overdue = results[1]?.data as any\n          const suggested = results[2]?.data as any\n\n          const parts = [\n            'Based on today\\'s data, create a prioritized plan for my day. Be concise and actionable. Use bullet points.',\n            '',\n            '## Today\\'s Summary',\n            summary ? JSON.stringify(summary, null, 2) : 'No summary available',\n            '',\n            '## Overdue Tasks',\n            overdue && Array.isArray(overdue) && overdue.length > 0\n              ? overdue.map((t: any) => `- ${t.title} (due: ${t.dueDate}, ${t.daysOverdue} days overdue)`).join('\\n')\n              : 'No overdue tasks',\n            '',\n            '## Suggested Next Tasks',\n            suggested && Array.isArray(suggested) && suggested.length > 0\n              ? suggested.map((t: any) => `- ${t.title} (${t.reason}, priority: ${t.priority})`).join('\\n')\n              : 'No suggestions available',\n          ]\n\n          return parts.join('\\n')\n        },\n      },\n    ],\n  },\n\n  // ── Chain 2: End of Day Review ────────────────────────────────────────\n  {\n    id: 'end_of_day_review',\n    name: 'End of Day Review',\n    description: 'Summarize what you accomplished today and what\\'s left',\n    icon: 'Sunset',\n    steps: [\n      {\n        type: 'tool',\n        tool: 'get_productivity_stats',\n        parameters: {},\n      },\n      {\n        type: 'tool',\n        tool: 'get_weekly_summary',\n        parameters: {},\n      },\n      {\n        type: 'tool',\n        tool: 'get_gamification_status',\n        parameters: {},\n      },\n      {\n        type: 'prompt',\n        promptFn: (results) => {\n          const stats = results[0]?.data as any\n          const weekly = results[1]?.data as any\n          const gamification = results[2]?.data as any\n\n          const parts = [\n            'Summarize my day: what I accomplished, what\\'s left, and give me a motivational note. Keep it brief (2-3 sentences).',\n            '',\n            '## Today\\'s Stats',\n            stats ? JSON.stringify(stats, null, 2) : 'No stats available',\n            '',\n            '## Weekly Summary',\n            weekly ? JSON.stringify(weekly, null, 2) : 'No weekly data available',\n            '',\n            '## Gamification Status',\n            gamification ? JSON.stringify(gamification, null, 2) : 'No gamification data available',\n          ]\n\n          return parts.join('\\n')\n        },\n      },\n    ],\n  },\n\n  // ── Chain 3: Focus Mode Setup ─────────────────────────────────────────\n  {\n    id: 'focus_mode_setup',\n    name: 'Focus Mode Setup',\n    description: 'Find your top task and start a focus session with a pep talk',\n    icon: 'Target',\n    steps: [\n      {\n        type: 'tool',\n        tool: 'suggest_next_task',\n        parameters: {},\n      },\n      {\n        type: 'tool',\n        tool: 'start_timer',\n        parametersFn: (priorResults) => {\n          const suggestion = priorResults[0]?.data as any\n          if (!suggestion || !Array.isArray(suggestion) || suggestion.length === 0) {\n            return null // No task found → skip timer start\n          }\n          const topTask = suggestion[0]\n          return { taskId: topTask.id, duration: 25 }\n        },\n        optional: true,\n      },\n      {\n        type: 'prompt',\n        promptFn: (priorResults) => {\n          const suggestion = priorResults[0]?.data as any\n          const timerResult = priorResults[1] // might be null if skipped\n\n          if (!suggestion || !Array.isArray(suggestion) || suggestion.length === 0) {\n            return 'You don\\'t have any actionable tasks right now. Take a break or create some new tasks to work on!'\n          }\n\n          const topTask = suggestion[0]\n          const taskTitle = topTask.title\n\n          if (timerResult?.success) {\n            return `I've started a focus session on \"${taskTitle}\". Give me a 2-sentence pep talk to stay focused and crush this task.`\n          } else {\n            return `Your top priority task is \"${taskTitle}\". Give me a 2-sentence pep talk to get started on it.`\n          }\n        },\n      },\n    ],\n  },\n\n  // ── Chain 4: Plan My Week ──────────────────────────────────────────────\n  {\n    id: 'plan_my_week',\n    name: 'Plan My Week',\n    description: 'Generate an AI-powered weekly plan distributing your tasks across the week',\n    icon: 'CalendarDays',\n    steps: [\n      {\n        type: 'tool',\n        tool: 'get_overdue_tasks',\n        parameters: {},\n      },\n      {\n        type: 'tool',\n        tool: 'get_daily_summary',\n        parameters: {},\n      },\n      {\n        type: 'tool',\n        tool: 'generate_weekly_plan',\n        parameters: {},\n      },\n      {\n        type: 'prompt',\n        promptFn: (results) => {\n          const overdue = results[0]?.data as any\n          const daily = results[1]?.data as any\n          const weeklyPlan = results[2]?.data as any\n\n          const parts = [\n            'Present this weekly plan to the user in a friendly, encouraging way.',\n            'CRITICAL: Respond in the SAME LANGUAGE the user\\'s app is in. If context suggests Hebrew, respond in Hebrew.',\n            '',\n            '## Current Situation',\n            overdue && Array.isArray(overdue) && overdue.length > 0\n              ? `${overdue.length} overdue tasks need attention`\n              : 'No overdue tasks',\n            daily ? `Today: ${daily.dueToday || 0} due, ${daily.completedToday || 0} completed, ${daily.inProgress || 0} in progress` : '',\n            '',\n            '## Weekly Plan',\n            weeklyPlan ? JSON.stringify(weeklyPlan, null, 2) : 'Plan generation failed',\n            '',\n            'Instructions:',\n            '- Summarize the plan day-by-day with task names',\n            '- Highlight overdue tasks that need priority attention',\n            '- Add a brief motivational note',\n            '- Keep it concise — the detailed plan card renders below your message',\n          ]\n\n          return parts.join('\\n')\n        },\n      },\n    ],\n  },\n]\n\n// ============================================================================\n// Composable\n// ============================================================================\n\nexport function useAgentChains() {\n  const currentExecution = ref<ChainExecution | null>(null)\n  const abortController = ref<AbortController | null>(null)\n\n  /**\n   * Execute an agent chain by ID.\n   * Returns tool results and final prompt for the AI to process.\n   */\n  async function executeChain(chainId: string): Promise<{\n    results: ToolResult[]\n    finalPrompt: string | null\n  }> {\n    const chain = chains.find((c) => c.id === chainId)\n    if (!chain) {\n      throw new Error(`Chain not found: ${chainId}`)\n    }\n\n    // Initialize execution state\n    currentExecution.value = {\n      chainId,\n      isRunning: true,\n      currentStep: 0,\n      totalSteps: chain.steps.length,\n      results: [],\n      error: null,\n    }\n\n    // Create abort controller\n    abortController.value = new AbortController()\n\n    const results: ToolResult[] = []\n    let finalPrompt: string | null = null\n\n    try {\n      for (let i = 0; i < chain.steps.length; i++) {\n        // Check for abort\n        if (abortController.value.signal.aborted) {\n          currentExecution.value.error = 'Chain aborted by user'\n          break\n        }\n\n        currentExecution.value.currentStep = i + 1\n\n        const step = chain.steps[i]\n\n        if (step.type === 'tool') {\n          // Build tool call parameters\n          let parameters = step.parameters || {}\n          if (step.parametersFn) {\n            const dynamicParams = step.parametersFn(results)\n            if (dynamicParams === null && step.optional) {\n              // Skip optional step if parametersFn returns null\n              console.log(`[AgentChains] Skipping optional step ${i + 1}: ${step.tool}`)\n              results.push({\n                success: true,\n                message: `Skipped optional step: ${step.tool}`,\n                data: null,\n              })\n              continue\n            }\n            parameters = dynamicParams || {}\n          }\n\n          // Execute tool\n          const call: ToolCall = {\n            tool: step.tool!,\n            parameters,\n          }\n\n          console.log(`[AgentChains] Executing step ${i + 1}/${chain.steps.length}:`, call.tool, call.parameters)\n          const result = await executeTool(call)\n          console.log(`[AgentChains] Step ${i + 1} result:`, result)\n\n          results.push(result)\n\n          // Stop execution if tool failed (unless optional)\n          if (!result.success && !step.optional) {\n            currentExecution.value.error = `Tool execution failed: ${result.message}`\n            break\n          }\n        } else if (step.type === 'prompt') {\n          // Build final prompt from results\n          if (step.promptFn) {\n            finalPrompt = step.promptFn(results)\n            console.log(`[AgentChains] Generated final prompt:`, finalPrompt.substring(0, 200) + '...')\n          }\n        }\n      }\n\n      currentExecution.value.results = results\n      currentExecution.value.isRunning = false\n\n      return { results, finalPrompt }\n    } catch (error) {\n      currentExecution.value.error = error instanceof Error ? error.message : 'Unknown error'\n      currentExecution.value.isRunning = false\n      throw error\n    } finally {\n      abortController.value = null\n    }\n  }\n\n  /**\n   * Abort the currently running chain.\n   */\n  function abortChain() {\n    if (abortController.value) {\n      abortController.value.abort()\n    }\n  }\n\n  return {\n    chains,\n    currentExecution,\n    executeChain,\n    abortChain,\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useAriaTooltipNarrative.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useBackupSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1124,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1124,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38374,38377],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38374,38377],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1390,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1390,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[46870,46873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[46870,46873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import IntegrityService from '@/utils/integrity'\nimport { isTauri } from '@/composables/useTauriStartup'\nimport { FILE_DIALOG_TIMEOUT_MS } from '@/config/timing'\n\n/**\n * Unified Backup System\n *\n * Consolidates 4 competing backup implementations into a single, cohesive system.\n * Replaces: useBackupManager, useSimpleBackup, useAutoBackup, useBackupRestoration\n *\n * @version 1.0.0\n * @since 2025-12-03\n */\n\nimport { ref, computed, onMounted, onUnmounted, getCurrentInstance } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useProjectStore } from '@/stores/projects'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport type { TaskIdAvailability } from '@/composables/useSupabaseDatabase'\nimport { filterMockTasks } from '@/utils/mockTaskDetector'\nimport type { Task, Project } from '@/types/tasks'\nimport type { CanvasGroup } from '@/types/canvas'\n\n// ============================================================================\n// Types & Interfaces\n// ============================================================================\n\nexport interface BackupData {\n  id: string\n  tasks: Task[]\n  projects: Project[]\n  groups: CanvasGroup[]\n  timestamp: number\n  version: string\n  checksum: string\n  type: 'auto' | 'manual' | 'emergency'\n  metadata?: {\n    taskCount: number\n    projectCount: number\n    groupCount: number\n    size?: number\n    exportedAt?: string\n  }\n}\n\nexport interface BackupConfig {\n  enabled: boolean\n  autoSaveInterval: number // milliseconds (default: 5 min)\n  maxHistorySize: number   // max backups to keep (default: 10)\n  filterMockTasks: boolean // remove mock/test tasks (default: true)\n}\n\nexport interface BackupStats {\n  lastBackupTime: number | null\n  totalBackups: number\n  isBackupInProgress: boolean\n  historyCount: number\n}\n\nexport interface BackupSystemState {\n  isReady: boolean\n  isRestoring: boolean\n  restoreProgress: number\n  error: string | null\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst STORAGE_KEYS = {\n  HISTORY: 'flowstate-backup-history',\n  LATEST: 'flowstate-backup-latest',\n  STATS: 'flowstate-backup-stats',\n  // BUG-059 FIX: Golden backup that can NEVER be overwritten by auto-backups\n  // Only updated when manually triggered OR when task count reaches new maximum\n  GOLDEN: 'flowstate-backup-golden',\n  // TASK-332: Array of golden backups for rotation (keeps last 3 peaks)\n  GOLDEN_ROTATION: 'flowstate-backup-golden-rotation',\n  // Tracks the maximum task count ever seen - used to detect data loss\n  MAX_TASK_COUNT: 'flowstate-max-task-count'\n} as const\n\n// TASK-332: Maximum number of golden backups to keep in rotation\nconst MAX_GOLDEN_BACKUPS = 3\n\n// BUG-059 FIX: Threshold for detecting suspicious data loss\n// If new backup has less than this % of previous max tasks, block auto-backup\nconst DATA_LOSS_THRESHOLD = 0.5 // 50%\n\n// TASK-153: Maximum age for golden backup before warning (7 days in ms)\nconst GOLDEN_BACKUP_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000\n\n// TASK-156: Maximum age for backup history entries (30 days in ms)\nconst BACKUP_HISTORY_TTL_MS = 30 * 24 * 60 * 60 * 1000\n\n// TASK-156: Current backup schema version\nconst BACKUP_SCHEMA_VERSION = '3.1.0'\n\n// TASK-153: Types for golden backup validation\nexport interface GoldenBackupValidation {\n  isValid: boolean\n  ageMs: number\n  ageWarning: string | null\n  preview: {\n    tasks: { total: number; filtered: number; toRestore: number }\n    projects: { total: number; filtered: number; toRestore: number }\n    groups: { total: number; filtered: number; toRestore: number }\n  }\n  warnings: string[]\n}\n\n// TASK-344: Dry-run restore analysis result\nexport interface RestoreAnalysis {\n  backup: BackupData\n  tasks: {\n    total: number\n    available: number      // Can be created\n    existsActive: number   // Already exists (active)\n    existsDeleted: number  // Already exists (soft-deleted)\n    tombstoned: number     // Permanently deleted - cannot restore\n    toRestore: Task[]      // Tasks that will be restored\n    skipped: Array<{ task: Task; reason: string }>  // Tasks that will be skipped\n  }\n  projects: {\n    total: number\n    toRestore: number\n    skipped: number\n  }\n  groups: {\n    total: number\n    toRestore: number\n    skipped: number\n  }\n  warnings: string[]\n  canProceed: boolean\n}\n\nconst DEFAULT_CONFIG: BackupConfig = {\n  enabled: true,\n  autoSaveInterval: 5 * 60 * 1000, // 5 minutes\n  maxHistorySize: 10,\n  filterMockTasks: true\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Calculate simple checksum for data integrity verification\n */\nfunction calculateChecksum(data: unknown): string {\n  return IntegrityService.calculateChecksum(data)\n}\n\n/**\n * Generate unique backup ID\n */\nfunction generateBackupId(): string {\n  return `backup_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`\n}\n\n/**\n * Format timestamp to human-readable string\n */\nfunction formatTimestamp(timestamp: number): string {\n  const date = new Date(timestamp)\n  return date.toLocaleString()\n}\n\n// ============================================================================\n// Main Composable\n// ============================================================================\n\nexport function useBackupSystem(userConfig: Partial<BackupConfig> = {}) {\n  // Merge user config with defaults\n  const config = ref<BackupConfig>({ ...DEFAULT_CONFIG, ...userConfig })\n\n  // Dependencies\n  const taskStore = useTaskStore()\n  const projectStore = useProjectStore()\n  const canvasStore = useCanvasStore()\n  const db = useSupabaseDatabase()\n\n  // State\n  const state = ref<BackupSystemState>({\n    isReady: false,\n    isRestoring: false,\n    restoreProgress: 0,\n    error: null\n  })\n\n  const stats = ref<BackupStats>({\n    lastBackupTime: null,\n    totalBackups: 0,\n    isBackupInProgress: false,\n    historyCount: 0\n  })\n\n  const backupHistory = ref<BackupData[]>([])\n\n  // Timers\n  let autoBackupInterval: NodeJS.Timeout | null = null\n\n  // ============================================================================\n  // Core Backup Operations\n  // ============================================================================\n\n  /**\n   * BUG-059 FIX: Get the maximum task count ever recorded\n   */\n  function getMaxTaskCount(): number {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEYS.MAX_TASK_COUNT)\n      return stored ? parseInt(stored, 10) : 0\n    } catch {\n      return 0\n    }\n  }\n\n  /**\n   * BUG-059 FIX: Update the maximum task count if current is higher\n   */\n  function updateMaxTaskCount(currentCount: number): void {\n    const maxCount = getMaxTaskCount()\n    if (currentCount > maxCount) {\n      localStorage.setItem(STORAGE_KEYS.MAX_TASK_COUNT, currentCount.toString())\n      console.log(`[Backup] 🏆 New maximum task count: ${currentCount} (was ${maxCount})`)\n    }\n  }\n\n  /**\n   * TASK-332: Get all golden backups from rotation (most recent first)\n   * Returns up to MAX_GOLDEN_BACKUPS entries, sorted by task count descending\n   */\n  function getGoldenBackups(): BackupData[] {\n    try {\n      // Try new rotation key first\n      const rotationStored = localStorage.getItem(STORAGE_KEYS.GOLDEN_ROTATION)\n      if (rotationStored) {\n        const rotation = JSON.parse(rotationStored) as BackupData[]\n        return rotation.sort((a, b) => (b.metadata?.taskCount || 0) - (a.metadata?.taskCount || 0))\n      }\n\n      // Fallback: migrate from legacy single golden backup\n      const legacyStored = localStorage.getItem(STORAGE_KEYS.GOLDEN)\n      if (legacyStored) {\n        const legacy = JSON.parse(legacyStored) as BackupData\n        // Migrate to rotation array\n        const rotation = [legacy]\n        localStorage.setItem(STORAGE_KEYS.GOLDEN_ROTATION, JSON.stringify(rotation))\n        console.log('[Backup] 🔄 Migrated legacy golden backup to rotation array')\n        return rotation\n      }\n\n      return []\n    } catch {\n      return []\n    }\n  }\n\n  /**\n   * BUG-059 FIX: Get golden backup (most recent peak from rotation)\n   * Returns the backup with the highest task count from the rotation\n   */\n  function getGoldenBackup(): BackupData | null {\n    const rotation = getGoldenBackups()\n    return rotation.length > 0 ? rotation[0] : null\n  }\n\n  /**\n   * TASK-332: Save golden backup with rotation (keeps last 3 peaks)\n   * Only adds to rotation if task count is a new peak or close to existing peaks\n   */\n  function saveGoldenBackup(backup: BackupData, force: boolean = false): boolean {\n    const rotation = getGoldenBackups()\n    const newTaskCount = backup.metadata?.taskCount || 0\n    const highestPeak = rotation[0]?.metadata?.taskCount || 0\n\n    // Only save if this is a new peak or force is true\n    if (!force && newTaskCount <= highestPeak) {\n      return false\n    }\n\n    // Check if this count is significantly different from existing peaks\n    // (at least 5% more tasks than the lowest in rotation, or rotation isn't full)\n    const shouldAdd = force ||\n      rotation.length < MAX_GOLDEN_BACKUPS ||\n      newTaskCount > highestPeak\n\n    if (!shouldAdd) {\n      return false\n    }\n\n    // Add to rotation\n    const updatedRotation = [backup, ...rotation]\n\n    // Keep only unique peak values (remove duplicates with same task count)\n    const uniquePeaks = updatedRotation.reduce((acc, curr) => {\n      const existingWithSameCount = acc.find(b =>\n        b.metadata?.taskCount === curr.metadata?.taskCount\n      )\n      if (!existingWithSameCount) {\n        acc.push(curr)\n      } else if (curr.timestamp > existingWithSameCount.timestamp) {\n        // Replace with newer backup of same peak\n        const idx = acc.indexOf(existingWithSameCount)\n        acc[idx] = curr\n      }\n      return acc\n    }, [] as BackupData[])\n\n    // Sort by task count descending and keep only top MAX_GOLDEN_BACKUPS\n    const finalRotation = uniquePeaks\n      .sort((a, b) => (b.metadata?.taskCount || 0) - (a.metadata?.taskCount || 0))\n      .slice(0, MAX_GOLDEN_BACKUPS)\n\n    // Save rotation\n    localStorage.setItem(STORAGE_KEYS.GOLDEN_ROTATION, JSON.stringify(finalRotation))\n    // Also save legacy key for backward compatibility\n    localStorage.setItem(STORAGE_KEYS.GOLDEN, JSON.stringify(finalRotation[0]))\n\n    console.log(`[Backup] 💛 Golden backup rotation updated: ${newTaskCount} tasks. Rotation: [${finalRotation.map(b => b.metadata?.taskCount).join(', ')}]`)\n    return true\n  }\n\n  /**\n   * TASK-153: Validate golden backup before restore\n   * - Checks age and warns if > 7 days old\n   * - Cross-references with current Supabase data to filter deleted items\n   * - Returns preview of what will be restored\n   */\n  async function validateGoldenBackup(): Promise<GoldenBackupValidation | null> {\n    const golden = getGoldenBackup()\n    if (!golden) {\n      console.warn('[Backup] No golden backup to validate')\n      return null\n    }\n\n    const warnings: string[] = []\n    const now = Date.now()\n    const ageMs = now - golden.timestamp\n\n    // Check age warning\n    let ageWarning: string | null = null\n    if (ageMs > GOLDEN_BACKUP_MAX_AGE_MS) {\n      const ageDays = Math.floor(ageMs / (24 * 60 * 60 * 1000))\n      ageWarning = `Golden backup is ${ageDays} days old (created ${new Date(golden.timestamp).toLocaleDateString()})`\n      warnings.push(ageWarning)\n    }\n\n    // Get current deleted item IDs from Supabase\n    let deletedTaskIds: Set<string> = new Set()\n    let deletedProjectIds: Set<string> = new Set()\n    let deletedGroupIds: Set<string> = new Set()\n\n    try {\n      // Fetch deleted items from Supabase to filter them out\n      if (db.fetchDeletedTaskIds) {\n        deletedTaskIds = new Set(await db.fetchDeletedTaskIds())\n      }\n      if (db.fetchDeletedProjectIds) {\n        deletedProjectIds = new Set(await db.fetchDeletedProjectIds())\n      }\n      if (db.fetchDeletedGroupIds) {\n        deletedGroupIds = new Set(await db.fetchDeletedGroupIds())\n      }\n    } catch (error) {\n      console.warn('[Backup] Could not fetch deleted item IDs from Supabase:', error)\n      warnings.push('Could not verify deleted items against Supabase - some deleted items may be restored')\n    }\n\n    // Calculate what would be restored after filtering\n    const tasksToRestore = golden.tasks.filter(t => !deletedTaskIds.has(t.id))\n    const projectsToRestore = (golden.projects || []).filter(p => !deletedProjectIds.has(p.id))\n    const groupsToRestore = (golden.groups || []).filter(g => !deletedGroupIds.has(g.id))\n\n    const filteredTasks = golden.tasks.length - tasksToRestore.length\n    const filteredProjects = (golden.projects?.length || 0) - projectsToRestore.length\n    const filteredGroups = (golden.groups?.length || 0) - groupsToRestore.length\n\n    if (filteredTasks > 0) {\n      warnings.push(`${filteredTasks} tasks will be skipped (deleted in Supabase)`)\n    }\n    if (filteredProjects > 0) {\n      warnings.push(`${filteredProjects} projects will be skipped (deleted in Supabase)`)\n    }\n    if (filteredGroups > 0) {\n      warnings.push(`${filteredGroups} groups will be skipped (deleted in Supabase)`)\n    }\n\n    return {\n      isValid: true,\n      ageMs,\n      ageWarning,\n      preview: {\n        tasks: {\n          total: golden.tasks.length,\n          filtered: filteredTasks,\n          toRestore: tasksToRestore.length\n        },\n        projects: {\n          total: golden.projects?.length || 0,\n          filtered: filteredProjects,\n          toRestore: projectsToRestore.length\n        },\n        groups: {\n          total: golden.groups?.length || 0,\n          filtered: filteredGroups,\n          toRestore: groupsToRestore.length\n        }\n      },\n      warnings\n    }\n  }\n\n  /**\n   * TASK-153: Filter golden backup data to exclude items deleted in Supabase\n   */\n  async function filterGoldenBackupData(golden: BackupData): Promise<BackupData> {\n    let deletedTaskIds: Set<string> = new Set()\n    let deletedProjectIds: Set<string> = new Set()\n    let deletedGroupIds: Set<string> = new Set()\n\n    try {\n      if (db.fetchDeletedTaskIds) {\n        deletedTaskIds = new Set(await db.fetchDeletedTaskIds())\n      }\n      if (db.fetchDeletedProjectIds) {\n        deletedProjectIds = new Set(await db.fetchDeletedProjectIds())\n      }\n      if (db.fetchDeletedGroupIds) {\n        deletedGroupIds = new Set(await db.fetchDeletedGroupIds())\n      }\n    } catch (error) {\n      console.warn('[Backup] Could not fetch deleted IDs, restoring all items:', error)\n    }\n\n    return {\n      ...golden,\n      tasks: golden.tasks.filter(t => !deletedTaskIds.has(t.id)),\n      projects: (golden.projects || []).filter(p => !deletedProjectIds.has(p.id)),\n      groups: (golden.groups || []).filter(g => !deletedGroupIds.has(g.id)),\n      metadata: {\n        ...golden.metadata,\n        taskCount: golden.tasks.filter(t => !deletedTaskIds.has(t.id)).length,\n        projectCount: (golden.projects || []).filter(p => !deletedProjectIds.has(p.id)).length,\n        groupCount: (golden.groups || []).filter(g => !deletedGroupIds.has(g.id)).length\n      }\n    }\n  }\n\n  /**\n   * BUG-059 FIX: Check if backup looks suspicious (potential data loss)\n   */\n  function isBackupSuspicious(taskCount: number, type: 'auto' | 'manual' | 'emergency'): { suspicious: boolean; reason: string } {\n    const maxCount = getMaxTaskCount()\n    const golden = getGoldenBackup()\n    const goldenCount = golden?.metadata?.taskCount || 0\n\n    // For manual/emergency backups, allow any state (user explicitly requested)\n    if (type !== 'auto') {\n      return { suspicious: false, reason: '' }\n    }\n\n    // If we've never seen tasks before, can't detect data loss\n    if (maxCount === 0 && goldenCount === 0) {\n      return { suspicious: false, reason: '' }\n    }\n\n    const referenceCount = Math.max(maxCount, goldenCount)\n\n    // CRITICAL: Block auto-backup if task count dropped by more than threshold\n    if (referenceCount > 5 && taskCount < referenceCount * DATA_LOSS_THRESHOLD) {\n      return {\n        suspicious: true,\n        reason: `Task count dropped from ${referenceCount} to ${taskCount} (>${(1 - DATA_LOSS_THRESHOLD) * 100}% loss)`\n      }\n    }\n\n    // CRITICAL: Block auto-backup if tasks went to 0 when we had tasks before\n    if (taskCount === 0 && referenceCount > 0) {\n      return {\n        suspicious: true,\n        reason: `All ${referenceCount} tasks disappeared - blocking auto-backup`\n      }\n    }\n\n    return { suspicious: false, reason: '' }\n  }\n\n  /**\n   * Create a new backup\n   */\n  async function createBackup(type: 'auto' | 'manual' | 'emergency' = 'manual'): Promise<BackupData | null> {\n    if (stats.value.isBackupInProgress) {\n      console.log('[Backup] Skipping - backup already in progress')\n      return null\n    }\n\n    stats.value.isBackupInProgress = true\n    state.value.error = null\n\n    try {\n      console.log(`[Backup] Creating ${type} backup...`)\n\n      // Get tasks from store\n      let tasks = [...(taskStore.tasks || [])]\n\n      // Filter mock tasks if enabled\n      if (config.value.filterMockTasks && tasks.length > 0) {\n        const filterResult = filterMockTasks(tasks as unknown as Record<string, unknown>[], { confidence: 'medium', logResults: false })\n        if (filterResult.mockTasks.length > 0) {\n          console.log(`[Backup] Filtered ${filterResult.mockTasks.length} mock tasks`)\n        }\n        tasks = filterResult.cleanTasks as unknown as Task[]\n      }\n\n      // BUG-059 FIX: Check if this backup looks suspicious before saving\n      const suspiciousCheck = isBackupSuspicious(tasks.length, type)\n      if (suspiciousCheck.suspicious) {\n        state.value.error = suspiciousCheck.reason\n        return null\n      }\n\n      // Get projects and groups from stores\n      const projects = [...(projectStore.projects || [])]\n      const groups = [...(canvasStore.groups || [])]\n\n      // Create backup object\n      const backupData: BackupData = {\n        id: generateBackupId(),\n        tasks,\n        projects,\n        groups,\n        timestamp: Date.now(),\n        version: BACKUP_SCHEMA_VERSION, // TASK-156: Use constant for schema version\n        checksum: '',\n        type,\n        metadata: {\n          taskCount: tasks.length,\n          projectCount: projects.length,\n          groupCount: groups.length\n        }\n      }\n\n      // Calculate checksum\n      backupData.checksum = calculateChecksum({\n        tasks: backupData.tasks,\n        projects: backupData.projects,\n        groups: backupData.groups\n      })\n\n      // Calculate approximate size\n      const size = new TextEncoder().encode(JSON.stringify(backupData)).length\n      if (backupData.metadata) {\n        backupData.metadata.size = size\n      }\n\n      // Save to localStorage\n      saveToHistory(backupData)\n\n      // BUG-059 FIX: Update max task count and golden backup\n      const taskCount = backupData.metadata?.taskCount || 0\n      updateMaxTaskCount(taskCount)\n      saveGoldenBackup(backupData)\n\n      // Update stats\n      stats.value.lastBackupTime = backupData.timestamp\n      stats.value.totalBackups++\n\n      console.log(`[Backup] Created successfully: ${backupData.metadata?.taskCount} tasks, ${backupData.metadata?.projectCount} projects, ${backupData.metadata?.groupCount} groups`)\n\n      return backupData\n\n    } catch (error) {\n      console.error('[Backup] Failed to create backup:', error)\n      state.value.error = error instanceof Error ? error.message : 'Backup failed'\n      return null\n\n    } finally {\n      stats.value.isBackupInProgress = false\n    }\n  }\n\n  // ==========================================================================\n  // TASK-344: Immutable Task ID System - Deduplication on Restore\n  // ==========================================================================\n\n  /**\n   * TASK-344: Analyze a backup before restore (dry-run mode)\n   * Checks which tasks can be restored vs skipped due to existing IDs\n   */\n  async function analyzeRestore(backup: BackupData | string): Promise<RestoreAnalysis> {\n    // Parse if string\n    const backupData: BackupData = typeof backup === 'string'\n      ? JSON.parse(backup)\n      : backup\n\n    const warnings: string[] = []\n\n    // Validate backup structure\n    if (!backupData.tasks || !Array.isArray(backupData.tasks)) {\n      return {\n        backup: backupData,\n        tasks: { total: 0, available: 0, existsActive: 0, existsDeleted: 0, tombstoned: 0, toRestore: [], skipped: [] },\n        projects: { total: 0, toRestore: 0, skipped: 0 },\n        groups: { total: 0, toRestore: 0, skipped: 0 },\n        warnings: ['Invalid backup: missing tasks array'],\n        canProceed: false\n      }\n    }\n\n    // Get task IDs to check\n    const taskIds = backupData.tasks.map(t => t.id)\n\n    // Check availability using TASK-344 batch check\n    const availabilityResults = await db.checkTaskIdsAvailability(taskIds)\n    const availabilityMap = new Map<string, TaskIdAvailability>()\n    for (const result of availabilityResults) {\n      availabilityMap.set(result.taskId, result)\n    }\n\n    // Categorize tasks\n    const toRestore: Task[] = []\n    const skipped: Array<{ task: Task; reason: string }> = []\n    let existsActive = 0\n    let existsDeleted = 0\n    let tombstoned = 0\n\n    for (const task of backupData.tasks) {\n      const availability = availabilityMap.get(task.id)\n      if (!availability || availability.status === 'available') {\n        toRestore.push(task)\n      } else {\n        skipped.push({ task, reason: availability.reason })\n        switch (availability.status) {\n          case 'active':\n            existsActive++\n            break\n          case 'soft_deleted':\n            existsDeleted++\n            break\n          case 'tombstoned':\n            tombstoned++\n            break\n        }\n      }\n    }\n\n    // Add warnings based on analysis\n    if (existsActive > 0) {\n      warnings.push(`${existsActive} tasks already exist (active) - will be skipped`)\n    }\n    if (existsDeleted > 0) {\n      warnings.push(`${existsDeleted} tasks already exist (soft-deleted) - will be skipped`)\n    }\n    if (tombstoned > 0) {\n      warnings.push(`${tombstoned} tasks were permanently deleted - cannot restore`)\n    }\n\n    // For projects and groups, do a simpler check using existing fetch functions\n    const deletedProjectIds = new Set(await db.fetchDeletedProjectIds())\n    const deletedGroupIds = new Set(await db.fetchDeletedGroupIds())\n    const tombstones = await db.fetchTombstones()\n    const projectTombstones = new Set(tombstones.filter(t => t.entityType === 'project').map(t => t.entityId))\n    const groupTombstones = new Set(tombstones.filter(t => t.entityType === 'group').map(t => t.entityId))\n\n    const projectsToRestore = (backupData.projects || []).filter(p =>\n      !deletedProjectIds.has(p.id) && !projectTombstones.has(p.id)\n    )\n    const groupsToRestore = (backupData.groups || []).filter(g =>\n      !deletedGroupIds.has(g.id) && !groupTombstones.has(g.id)\n    )\n\n    const projectsSkipped = (backupData.projects?.length || 0) - projectsToRestore.length\n    const groupsSkipped = (backupData.groups?.length || 0) - groupsToRestore.length\n\n    if (projectsSkipped > 0) {\n      warnings.push(`${projectsSkipped} projects will be skipped (deleted or tombstoned)`)\n    }\n    if (groupsSkipped > 0) {\n      warnings.push(`${groupsSkipped} groups will be skipped (deleted or tombstoned)`)\n    }\n\n    return {\n      backup: backupData,\n      tasks: {\n        total: backupData.tasks.length,\n        available: toRestore.length,\n        existsActive,\n        existsDeleted,\n        tombstoned,\n        toRestore,\n        skipped\n      },\n      projects: {\n        total: backupData.projects?.length || 0,\n        toRestore: projectsToRestore.length,\n        skipped: projectsSkipped\n      },\n      groups: {\n        total: backupData.groups?.length || 0,\n        toRestore: groupsToRestore.length,\n        skipped: groupsSkipped\n      },\n      warnings,\n      canProceed: toRestore.length > 0 || projectsToRestore.length > 0 || groupsToRestore.length > 0\n    }\n  }\n\n  /**\n   * Restore from a backup\n   * TASK-344: Now supports dry-run mode and filters out duplicate task IDs\n   *\n   * @param backup - The backup data or JSON string\n   * @param options - Restore options (dryRun, skipDedupCheck)\n   */\n  async function restoreBackup(\n    backup: BackupData | string,\n    options: { dryRun?: boolean; skipDedupCheck?: boolean; backupSource?: string } = {}\n  ): Promise<boolean | RestoreAnalysis> {\n    // Dry-run mode: just analyze and return\n    if (options.dryRun) {\n      console.log('[Backup] Running dry-run analysis...')\n      return await analyzeRestore(backup)\n    }\n\n    state.value.isRestoring = true\n    state.value.restoreProgress = 0\n    state.value.error = null\n\n    try {\n      console.log('[Backup] Starting restore...')\n\n      // Parse if string\n      const backupData: BackupData = typeof backup === 'string'\n        ? JSON.parse(backup)\n        : backup\n\n      // Validate backup\n      if (!backupData.tasks || !Array.isArray(backupData.tasks)) {\n        throw new Error('Invalid backup: missing tasks array')\n      }\n\n      // Verify checksum if present\n      if (backupData.checksum) {\n        const currentChecksum = calculateChecksum({\n          tasks: backupData.tasks,\n          projects: backupData.projects,\n          groups: backupData.groups\n        })\n        if (currentChecksum !== backupData.checksum) {\n          console.warn('[Backup] Checksum mismatch - backup may be corrupted')\n        }\n      }\n\n      state.value.restoreProgress = 10\n\n      // TASK-344: Analyze and filter tasks before restore\n      let tasksToRestore = backupData.tasks\n      let projectsToRestore = backupData.projects || []\n      let groupsToRestore = backupData.groups || []\n\n      if (!options.skipDedupCheck) {\n        console.log('[Backup] Analyzing task ID availability (TASK-344 deduplication)...')\n        const analysis = await analyzeRestore(backupData)\n\n        tasksToRestore = analysis.tasks.toRestore\n        state.value.restoreProgress = 20\n\n        // Log dedup decisions for audit trail\n        for (const { task, reason } of analysis.tasks.skipped) {\n          await db.logDedupDecision(\n            'restore',\n            task.id,\n            reason.includes('tombstoned') ? 'skipped_tombstoned' : 'skipped_exists',\n            reason,\n            options.backupSource\n          )\n        }\n\n        // Filter projects and groups\n        const deletedProjectIds = new Set(await db.fetchDeletedProjectIds())\n        const deletedGroupIds = new Set(await db.fetchDeletedGroupIds())\n        const tombstones = await db.fetchTombstones()\n        const projectTombstones = new Set(tombstones.filter(t => t.entityType === 'project').map(t => t.entityId))\n        const groupTombstones = new Set(tombstones.filter(t => t.entityType === 'group').map(t => t.entityId))\n\n        projectsToRestore = (backupData.projects || []).filter(p =>\n          !deletedProjectIds.has(p.id) && !projectTombstones.has(p.id)\n        )\n        groupsToRestore = (backupData.groups || []).filter(g =>\n          !deletedGroupIds.has(g.id) && !groupTombstones.has(g.id)\n        )\n\n        console.log(`[Backup] TASK-344 Deduplication results:`)\n        console.log(`  Tasks: ${tasksToRestore.length}/${backupData.tasks.length} will be restored`)\n        console.log(`  Projects: ${projectsToRestore.length}/${backupData.projects?.length || 0} will be restored`)\n        console.log(`  Groups: ${groupsToRestore.length}/${backupData.groups?.length || 0} will be restored`)\n      }\n\n      state.value.restoreProgress = 30\n\n      // Create emergency backup before restore (rollback point)\n      await createBackup('emergency')\n      state.value.restoreProgress = 40\n\n      // Restore to Supabase using safeCreateTask for each task\n      // TASK-344: This ensures immutable IDs - no duplicates even with race conditions\n      if (tasksToRestore.length > 0) {\n        console.log(`[Backup] Restoring ${tasksToRestore.length} tasks using safeCreateTask...`)\n        let created = 0\n        let skipped = 0\n\n        for (const task of tasksToRestore) {\n          const result = await db.safeCreateTask(task)\n\n          if (result.status === 'created') {\n            created++\n          } else {\n            skipped++\n            console.log(`[Backup] Task ${task.id.slice(0, 8)}... skipped: ${result.message}`)\n          }\n\n          // Log decision to audit table\n          await db.logDedupDecision(\n            'restore',\n            task.id,\n            result.status === 'created' ? 'created' :\n              result.status === 'tombstoned' ? 'skipped_tombstoned' : 'skipped_exists',\n            result.message,\n            options.backupSource\n          )\n        }\n\n        console.log(`[Backup] Task restore complete: ${created} created, ${skipped} skipped`)\n      }\n      state.value.restoreProgress = 60\n\n      // Restore Projects\n      if (projectsToRestore.length > 0) {\n        console.log(`[Backup] Restoring ${projectsToRestore.length} projects...`)\n        await db.saveProjects(projectsToRestore)\n      }\n      state.value.restoreProgress = 70\n\n      // Restore Groups\n      if (groupsToRestore.length > 0) {\n        console.log(`[Backup] Restoring ${groupsToRestore.length} groups...`)\n        for (const group of groupsToRestore) {\n          await db.saveGroup(group)\n        }\n      }\n      state.value.restoreProgress = 80\n\n      // Reload stores from database\n      if (taskStore.loadFromDatabase) await taskStore.loadFromDatabase()\n      if (projectStore.loadProjectsFromDatabase) await projectStore.loadProjectsFromDatabase()\n      if (canvasStore.loadFromDatabase) await canvasStore.loadFromDatabase()\n\n      state.value.restoreProgress = 100\n\n      console.log(`[Backup] Restored successfully: ${tasksToRestore.length}/${backupData.tasks.length} tasks (TASK-344 filtered)`)\n      return true\n\n    } catch (error) {\n      console.error('[Backup] Restore failed:', error)\n      state.value.error = error instanceof Error ? error.message : 'Restore failed'\n      return false\n\n    } finally {\n      state.value.isRestoring = false\n      state.value.restoreProgress = 0\n    }\n  }\n\n  // ============================================================================\n  // History Management\n  // ============================================================================\n\n  /**\n   * Save backup to history (localStorage)\n   */\n  function saveToHistory(backup: BackupData): void {\n    try {\n      // Add to beginning of history\n      backupHistory.value.unshift(backup)\n\n      // Trim to max size\n      if (backupHistory.value.length > config.value.maxHistorySize) {\n        backupHistory.value = backupHistory.value.slice(0, config.value.maxHistorySize)\n      }\n\n      // Save to localStorage\n      localStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(backupHistory.value))\n      localStorage.setItem(STORAGE_KEYS.LATEST, JSON.stringify(backup))\n\n      stats.value.historyCount = backupHistory.value.length\n\n    } catch (error) {\n      console.error('[Backup] Failed to save to history:', error)\n    }\n  }\n\n  /**\n   * Load backup history from localStorage\n   * TASK-156: Added TTL pruning for old backups\n   */\n  function loadHistory(): void {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEYS.HISTORY)\n      if (stored) {\n        const rawHistory: BackupData[] = JSON.parse(stored)\n        const now = Date.now()\n\n        // TASK-156: Filter out backups older than TTL (30 days)\n        const validBackups: BackupData[] = []\n        const expiredBackups: BackupData[] = []\n\n        for (const backup of rawHistory) {\n          const age = now - backup.timestamp\n          if (age > BACKUP_HISTORY_TTL_MS) {\n            expiredBackups.push(backup)\n          } else {\n            validBackups.push(backup)\n          }\n        }\n\n        backupHistory.value = validBackups\n        stats.value.historyCount = validBackups.length\n\n        // Log pruned backups\n        if (expiredBackups.length > 0) {\n          console.log(`🧹 [TASK-156] Pruned ${expiredBackups.length} backups older than 30 days`)\n          // Save updated history without expired backups\n          localStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(validBackups))\n        }\n      }\n\n      // Load last backup time from latest\n      const latest = localStorage.getItem(STORAGE_KEYS.LATEST)\n      if (latest) {\n        const latestBackup = JSON.parse(latest)\n        stats.value.lastBackupTime = latestBackup.timestamp\n      }\n    } catch (error) {\n      console.error('[Backup] Failed to load history:', error)\n    }\n  }\n\n  /**\n   * Get the latest backup\n   */\n  function getLatestBackup(): BackupData | null {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEYS.LATEST)\n      return stored ? JSON.parse(stored) : null\n    } catch (error) {\n      console.error('[Backup] Failed to get latest backup:', error)\n      return null\n    }\n  }\n\n  /**\n   * Clear all backup history\n   */\n  function clearHistory(): void {\n    backupHistory.value = []\n    localStorage.removeItem(STORAGE_KEYS.HISTORY)\n    localStorage.removeItem(STORAGE_KEYS.LATEST)\n    stats.value.historyCount = 0\n  }\n\n  // ============================================================================\n  // Auto-Backup\n  // ============================================================================\n\n  /**\n   * Start automatic backup scheduler\n   */\n  function startAutoBackup(): void {\n    if (autoBackupInterval) {\n      stopAutoBackup()\n    }\n\n    if (!config.value.enabled || config.value.autoSaveInterval <= 0) {\n      return\n    }\n\n    console.log(`[Backup] Starting auto-backup every ${config.value.autoSaveInterval / 1000}s`)\n\n    autoBackupInterval = setInterval(async () => {\n      if (config.value.enabled) {\n        await createBackup('auto')\n      }\n    }, config.value.autoSaveInterval)\n  }\n\n  /**\n   * Stop automatic backup scheduler\n   */\n  function stopAutoBackup(): void {\n    if (autoBackupInterval) {\n      clearInterval(autoBackupInterval)\n      autoBackupInterval = null\n      console.log('[Backup] Auto-backup stopped')\n    }\n  }\n\n  // ============================================================================\n  // Export/Import\n  // ============================================================================\n\n  /**\n   * Export backup as JSON string\n   */\n  async function exportBackup(): Promise<string> {\n    const backup = await createBackup('manual')\n    if (!backup) {\n      throw new Error('Failed to create backup for export')\n    }\n\n    return JSON.stringify({\n      ...backup,\n      metadata: {\n        ...backup.metadata,\n        exportedAt: new Date().toISOString()\n      }\n    }, null, 2)\n  }\n\n  /**\n   * Import backup from JSON string\n   * TASK-344: Updated to handle new restore signature\n   */\n  async function importBackup(jsonString: string): Promise<boolean> {\n    try {\n      const data = JSON.parse(jsonString)\n      const result = await restoreBackup(data, { dryRun: false, backupSource: 'import' })\n      return result === true\n    } catch (error) {\n      console.error('[Backup] Import failed:', error)\n      state.value.error = 'Invalid backup file format'\n      return false\n    }\n  }\n\n  /**\n   * Download backup as file\n   * BUG-336: Fixed for Tauri - uses native file dialog instead of browser download\n   */\n  async function downloadBackup(backup?: BackupData): Promise<void> {\n    const data = backup || getLatestBackup()\n    if (!data) {\n      throw new Error('No backup available to download')\n    }\n\n    const filename = `flow-state-backup-${new Date().toISOString().split('T')[0]}.json`\n    const content = JSON.stringify(data, null, 2)\n\n    // BUG-336: Use Tauri dialog for file save in desktop app\n    if (isTauri()) {\n      console.log('[Backup] Tauri detected, attempting native save dialog...')\n\n      try {\n        // Method 1: Try dynamic imports (preferred)\n        console.log('[Backup] Importing Tauri plugins...')\n        const dialogModule = await import('@tauri-apps/plugin-dialog')\n        const fsModule = await import('@tauri-apps/plugin-fs')\n        const pathModule = await import('@tauri-apps/api/path')\n\n        console.log('[Backup] Plugins loaded successfully')\n\n        // Get downloads directory for default path\n        let defaultPath = filename\n        try {\n          const downloadsPath = await pathModule.downloadDir()\n          // Ensure proper path separator (join not available in path module)\n          const separator = downloadsPath.includes('\\\\') ? '\\\\' : '/'\n          const cleanPath = downloadsPath.endsWith(separator) ? downloadsPath : downloadsPath + separator\n          defaultPath = `${cleanPath}${filename}`\n          console.log('[Backup] Default path:', defaultPath)\n        } catch (pathError) {\n          console.warn('[Backup] Could not get downloads dir, using filename only:', pathError)\n        }\n\n        // Open save dialog - the selected path is automatically added to FS scope\n        // TASK-332: Add timeout to prevent hanging on XDG Portal issues\n        console.log('[Backup] Opening save dialog...')\n\n        const dialogPromise = dialogModule.save({\n          defaultPath,\n          filters: [{\n            name: 'JSON',\n            extensions: ['json']\n          }]\n        })\n\n        // Race against a 30-second timeout (XDG Portal can sometimes hang)\n        const timeoutPromise = new Promise<null>((_, reject) => {\n          setTimeout(() => reject(new Error('Dialog timeout after 30s - falling back to browser')), FILE_DIALOG_TIMEOUT_MS)\n        })\n\n        const filePath = await Promise.race([dialogPromise, timeoutPromise])\n\n        console.log('[Backup] Dialog result:', filePath)\n\n        if (filePath) {\n          // Write file to selected path (scope automatically granted by dialog)\n          console.log('[Backup] Writing file to:', filePath)\n          await fsModule.writeTextFile(filePath, content)\n          console.log('[Backup] Downloaded successfully (Tauri):', filePath)\n        } else {\n          console.log('[Backup] Download cancelled by user')\n        }\n        return\n      } catch (error) {\n        console.error('[Backup] Tauri save failed:', error)\n\n        // Method 2: Try global __TAURI__ object as fallback\n        const win = window as any\n        if (win.__TAURI__?.dialog?.save && win.__TAURI__?.fs?.writeTextFile) {\n          console.log('[Backup] Attempting fallback via __TAURI__ global...')\n          try {\n            const filePath = await win.__TAURI__.dialog.save({\n              defaultPath: filename,\n              filters: [{ name: 'JSON', extensions: ['json'] }]\n            })\n            if (filePath) {\n              await win.__TAURI__.fs.writeTextFile(filePath, content)\n              console.log('[Backup] Downloaded via __TAURI__ global:', filePath)\n              return\n            }\n          } catch (fallbackError) {\n            console.error('[Backup] __TAURI__ fallback also failed:', fallbackError)\n          }\n        }\n\n        console.warn('[Backup] All Tauri methods failed, falling back to browser download')\n        // Fall through to browser method\n      }\n    }\n\n    // Browser fallback method\n    const blob = new Blob([content], { type: 'application/json' })\n    const url = URL.createObjectURL(blob)\n\n    const link = document.createElement('a')\n    link.href = url\n    link.download = filename\n    document.body.appendChild(link)\n    link.click()\n    document.body.removeChild(link)\n    URL.revokeObjectURL(url)\n\n    console.log('[Backup] Downloaded:', filename)\n  }\n\n  /**\n   * Restore from uploaded file\n   */\n  async function restoreFromFile(file: File): Promise<boolean> {\n    try {\n      const text = await file.text()\n      return await importBackup(text)\n    } catch (error) {\n      console.error('[Backup] Failed to restore from file:', error)\n      state.value.error = 'Failed to read backup file'\n      return false\n    }\n  }\n\n  // ============================================================================\n  // Utility Methods\n  // ============================================================================\n\n  /**\n   * Check if backup contains Hebrew content\n   */\n  function hasHebrewContent(backup: BackupData): boolean {\n    if (!backup?.tasks) return false\n    const hebrewRegex = /[\\u0590-\\u05FF]/\n    return backup.tasks.some(task => task.title && hebrewRegex.test(task.title))\n  }\n\n  /**\n   * Get backup status summary\n   */\n  function getStatus() {\n    return {\n      isReady: state.value.isReady,\n      isEnabled: config.value.enabled,\n      lastBackupTime: stats.value.lastBackupTime,\n      formattedLastBackup: stats.value.lastBackupTime\n        ? formatTimestamp(stats.value.lastBackupTime)\n        : 'Never',\n      historyCount: stats.value.historyCount,\n      isBackupInProgress: stats.value.isBackupInProgress,\n      isRestoring: state.value.isRestoring,\n      error: state.value.error\n    }\n  }\n\n  // ============================================================================\n  // Lifecycle\n  // ============================================================================\n\n  /**\n   * Initialize backup system\n   */\n  async function initialize(): Promise<void> {\n    console.log('[Backup] Initializing...')\n\n    // Load history\n    loadHistory()\n\n    // Wait for tasks to be available\n    await waitForTasks()\n\n    // Start auto-backup\n    startAutoBackup()\n\n    // Create initial backup if none exists\n    if (!getLatestBackup()) {\n      await createBackup('auto')\n    }\n\n    state.value.isReady = true\n    console.log('[Backup] Initialized successfully')\n  }\n\n  /**\n   * Wait for task store to be ready\n   */\n  async function waitForTasks(timeout = 10000): Promise<void> {\n    const startTime = Date.now()\n\n    return new Promise((resolve) => {\n      const check = () => {\n        if (Array.isArray(taskStore.tasks)) {\n          resolve()\n          return\n        }\n\n        if (Date.now() - startTime > timeout) {\n          console.warn('[Backup] Timeout waiting for tasks')\n          resolve()\n          return\n        }\n\n        setTimeout(check, 100)\n      }\n      check()\n    })\n  }\n\n  // Lifecycle hooks\n  if (getCurrentInstance()) {\n    onMounted(() => {\n      // Delay initialization to ensure stores are ready\n      setTimeout(initialize, 1500)\n    })\n\n    onUnmounted(() => {\n      stopAutoBackup()\n    })\n  }\n\n  // ============================================================================\n  // Return Public API\n  // ============================================================================\n\n  return {\n    // State\n    config,\n    state: computed(() => state.value),\n    stats: computed(() => stats.value),\n    backupHistory: computed(() => backupHistory.value),\n\n    // Core operations\n    createBackup,\n    restoreBackup,\n\n    // TASK-344: Dry-run analysis (preview before restore)\n    analyzeRestore,\n\n    // History\n    getLatestBackup,\n    clearHistory,\n\n    // Auto-backup\n    startAutoBackup,\n    stopAutoBackup,\n\n    // Export/Import\n    exportBackup,\n    importBackup,\n    downloadBackup,\n    restoreFromFile,\n\n    // Utilities\n    hasHebrewContent,\n    getStatus,\n\n    // Initialize (can be called manually if needed)\n    initialize,\n\n    // BUG-059 FIX: Golden backup and safety methods\n    getGoldenBackup,\n    getMaxTaskCount,\n\n    // TASK-332: Get all golden backups in rotation (for UI display)\n    getGoldenBackups,\n\n    // TASK-153: Validate golden backup before restore\n    validateGoldenBackup,\n\n    // Restore from golden backup (last known good state)\n    // TASK-153: Now filters out items deleted in Supabase before restoring\n    restoreFromGoldenBackup: async (skipValidation: boolean = false) => {\n      const golden = getGoldenBackup()\n      if (!golden) {\n        console.error('[Backup] No golden backup available')\n        return false\n      }\n\n      // TASK-153: Validate and warn about age/deleted items\n      if (!skipValidation) {\n        const validation = await validateGoldenBackup()\n        if (validation) {\n          if (validation.warnings.length > 0) {\n            console.warn('[Backup] Golden backup validation warnings:', validation.warnings)\n          }\n          console.log(`[Backup] Golden backup preview:`, {\n            tasks: `${validation.preview.tasks.toRestore}/${validation.preview.tasks.total} (${validation.preview.tasks.filtered} filtered)`,\n            projects: `${validation.preview.projects.toRestore}/${validation.preview.projects.total} (${validation.preview.projects.filtered} filtered)`,\n            groups: `${validation.preview.groups.toRestore}/${validation.preview.groups.total} (${validation.preview.groups.filtered} filtered)`\n          })\n        }\n      }\n\n      // TASK-153: Filter out items that are deleted in Supabase\n      const filteredGolden = await filterGoldenBackupData(golden)\n\n      console.log(`[Backup] Restoring from golden backup: ${filteredGolden.metadata?.taskCount} tasks (filtered from ${golden.metadata?.taskCount})`)\n      // TASK-344: Explicitly specify no dry-run to get boolean return\n      const result = await restoreBackup(filteredGolden, { dryRun: false, backupSource: 'golden' })\n      return result === true\n    },\n\n    // TASK-332: Restore from a specific golden backup in the rotation (by index)\n    restoreFromGoldenBackupByIndex: async (index: number, skipValidation: boolean = false) => {\n      const rotation = getGoldenBackups()\n      if (index < 0 || index >= rotation.length) {\n        console.error(`[Backup] Invalid golden backup index: ${index}. Available: 0-${rotation.length - 1}`)\n        return false\n      }\n\n      const golden = rotation[index]\n      if (!skipValidation) {\n        console.log(`[Backup] Restoring from golden backup #${index + 1}: ${golden.metadata?.taskCount} tasks`)\n      }\n\n      // TASK-153: Filter out items that are deleted in Supabase\n      const filteredGolden = await filterGoldenBackupData(golden)\n\n      console.log(`[Backup] Restoring from golden backup #${index + 1}: ${filteredGolden.metadata?.taskCount} tasks (filtered from ${golden.metadata?.taskCount})`)\n      const result = await restoreBackup(filteredGolden, { dryRun: false, backupSource: `golden-${index}` })\n      return result === true\n    },\n\n    // TASK-153: Get validation info for UI display before restore\n    getGoldenBackupValidation: validateGoldenBackup,\n\n    // TASK-154: Shadow Mirror (System 3) Recovery\n    fetchShadowBackup: async () => {\n      try {\n        const response = await fetch('/shadow-latest.json?t=' + Date.now())\n        if (!response.ok) throw new Error('Shadow snapshot not found')\n        return await response.json()\n      } catch (error) {\n        console.warn('[Backup] Shadow sync info not available:', error)\n        return null\n      }\n    },\n\n    restoreFromShadow: async (shadowData: any) => {\n      console.log(`[Backup] Restoring from Shadow Hub: ${shadowData.meta?.counts?.tasks} tasks`)\n      // TASK-344: Explicitly specify no dry-run to get boolean return\n      const result = await restoreBackup({\n        ...shadowData,\n        id: `shadow_${shadowData.meta.timestamp}`,\n        timestamp: shadowData.meta.timestamp,\n        type: 'emergency',\n        version: BACKUP_SCHEMA_VERSION,\n        checksum: '',\n        metadata: {\n          taskCount: shadowData.meta.counts.tasks,\n          projectCount: shadowData.meta.counts.projects,\n          groupCount: shadowData.meta.counts.groups\n        }\n      }, { dryRun: false, backupSource: 'shadow' })\n      return result === true\n    }\n  }\n}\n\n// Default export for convenience\nexport default useBackupSystem\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useBeforeUnload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useBrainDump.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useCalendarCore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useCalendarDragCreate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useContextMenu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useCopy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useCrossTabSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'authStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":53,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'canvasStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":56,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2285,2288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2285,2288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3280,3283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3280,3283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3611,3614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3611,3614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'canvasPosition' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":114,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":114,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'parentId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":114,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":114,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'positionFormat' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":114,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":114,"endColumn":61},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4199,4202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4199,4202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":159,"column":60,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":159,"endColumn":77}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onUnmounted, getCurrentInstance, onMounted } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useUIStore } from '@/stores/ui'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useAuthStore } from '@/stores/auth'\nimport { useBroadcastChannelSync } from './sync/useBroadcastChannelSync'\nimport { useTimerLeaderElection } from './sync/useTimerLeaderElection'\nimport { CROSS_TAB_DEDUP_TIMEOUT_MS } from '@/config/timing'\n\n// Types for cross-tab messages\nexport interface CrossTabMessage {\n  id: string\n  type: 'task_operation' | 'ui_state_change' | 'canvas_change' | 'heartbeat' | 'timer_session'\n  timestamp: number\n  tabId: string\n  data: unknown\n}\n\nexport interface TimerSessionSync {\n  action: 'claim_leadership' | 'heartbeat' | 'session_update' | 'session_stop'\n  leaderId: string\n  sessionState?: unknown\n  timestamp: number\n}\n\nexport interface TaskOperation {\n  operation: 'create' | 'update' | 'delete' | 'bulk_update' | 'bulk_delete'\n  taskId?: string\n  taskIds?: string[]\n  taskData?: unknown\n  oldData?: unknown\n  timestamp: number\n}\n\nexport interface UIStateChange {\n  store: 'ui' | 'canvas'\n  action: string\n  data: unknown\n  timestamp: number\n}\n\nexport interface CanvasChange {\n  action: 'node_move' | 'section_collapse' | 'viewport_change'\n  data: unknown\n  timestamp: number\n}\n\n// Global state for synchronization\nconst isListening = ref(false)\nconst pendingLocalOperations = ref<Map<string, TaskOperation>>(new Map())\n\nexport function useCrossTabSync() {\n  const authStore = useAuthStore()\n  const taskStore = useTaskStore()\n  const uiStore = useUIStore()\n  const canvasStore = useCanvasStore()\n\n  // Initialize sub-composables\n  const { tabId: currentTabId, connect, disconnect, broadcast, onMessage } = useBroadcastChannelSync()\n\n  // Define callbacks for timer state updates (set by timer store)\n  let _onTimerSessionUpdate: ((session: unknown) => void) | null = null\n  let _onBecomeLeader: (() => void) | null = null\n  let _onLoseLeadership: (() => void) | null = null\n\n  const {\n    isLeader: isTimerLeader,\n    leaderState: timerLeaderState,\n    claimLeadership: claimTimerLeadership,\n    handleLeaderMessage,\n    cleanup: cleanupLeader\n  } = useTimerLeaderElection({\n    tabId: currentTabId.value,\n    broadcastMessage: (msg: any) => broadcast('timer_session', msg),\n    onBecomeLeader: () => _onBecomeLeader?.(),\n    onLoseLeadership: () => _onLoseLeadership?.(),\n    onSessionUpdate: (session) => _onTimerSessionUpdate?.(session)\n  })\n\n  // Message processing logic\n  const handleTaskOperation = async (operation: TaskOperation) => {\n    switch (operation.operation) {\n      case 'create':\n        if (operation.taskData && operation.taskId) {\n          await taskStore.loadFromDatabase()\n        }\n        break\n      case 'update':\n        if (operation.taskId && operation.taskData) {\n          const task = taskStore.tasks.find(t => t.id === operation.taskId)\n          // BUG-1051: Fix sync race condition - check for manual operation and timestamp\n          if (task) {\n            // Don't overwrite if user is actively editing\n            if (taskStore.manualOperationInProgress) return\n\n            // Prevent stale data from overwriting newer data\n            const incomingTimestamp = (operation.taskData as any).updatedAt\n            if (incomingTimestamp && task.updatedAt &&\n                new Date(task.updatedAt) > new Date(incomingTimestamp)) {\n              return\n            }\n\n            // CRITICAL FIX: Version-aware update - never overwrite geometry from cross-tab\n            const incomingVersion = (operation.taskData as any).positionVersion ?? 0\n            const localVersion = task.positionVersion ?? 0\n\n            // Only accept if incoming version is newer\n            if (incomingVersion < localVersion) {\n              console.log(`[CROSS-TAB] Skipping stale update for ${operation.taskId.slice(0, 8)} (local v${localVersion} > remote v${incomingVersion})`)\n              return\n            }\n\n            // Strip geometry fields from cross-tab sync - geometry should only come from drag handlers\n            const { canvasPosition, parentId, positionFormat, ...safeUpdates } = operation.taskData as any\n\n            // Apply only non-geometry updates\n            Object.assign(task, safeUpdates)\n          }\n        }\n        break\n      case 'delete':\n        if (operation.taskId) {\n          const index = taskStore.tasks.findIndex(t => t.id === operation.taskId)\n          if (index > -1) taskStore.tasks.splice(index, 1)\n        }\n        break\n    }\n  }\n\n  const handleUIStateChange = (change: UIStateChange) => {\n    if (change.store === 'ui') {\n      if (change.action === 'sidebar_toggle') {\n        const data = change.data as { isOpen: boolean }\n        uiStore.mainSidebarVisible = data.isOpen\n      }\n    }\n  }\n\n  // Set up message handlers\n  onMessage('task_operation', handleTaskOperation)\n  onMessage('ui_state_change', handleUIStateChange)\n  onMessage('timer_session', handleLeaderMessage)\n\n  const initialize = () => {\n    if (isListening.value) return\n    connect()\n    isListening.value = true\n  }\n\n  const cleanup = () => {\n    disconnect()\n    cleanupLeader()\n    isListening.value = false\n  }\n\n  const trackLocalOperation = (operation: TaskOperation) => {\n    if (operation.taskId) {\n      pendingLocalOperations.value.set(operation.taskId, operation)\n      setTimeout(() => pendingLocalOperations.value.delete(operation.taskId!), CROSS_TAB_DEDUP_TIMEOUT_MS)\n    }\n  }\n\n  // Lifecycle\n  if (getCurrentInstance()) {\n    onMounted(initialize)\n    onUnmounted(cleanup)\n  } else {\n    initialize()\n  }\n\n  return {\n    isListening,\n    currentTabId,\n    pendingLocalOperations,\n    isTimerLeader,\n    timerLeaderState,\n    initialize,\n    cleanup,\n    broadcastTimerSession: (session: unknown) => {\n      if (isTimerLeader.value) {\n        broadcast('timer_session', {\n          action: session ? 'session_update' : 'session_stop',\n          leaderId: currentTabId.value,\n          sessionState: session,\n          timestamp: Date.now()\n        })\n      }\n    },\n    claimTimerLeadership,\n    setTimerCallbacks: (callbacks: {\n      onSessionUpdate?: (session: unknown) => void\n      onBecomeLeader?: () => void\n      onLoseLeadership?: () => void\n    }) => {\n      _onTimerSessionUpdate = callbacks.onSessionUpdate || null\n      _onBecomeLeader = callbacks.onBecomeLeader || null\n      _onLoseLeadership = callbacks.onLoseLeadership || null\n    },\n    trackLocalOperation,\n    broadcastTaskOperation: (op: TaskOperation) => broadcast('task_operation', op),\n    broadcastUIStateChange: (change: UIStateChange) => broadcast('ui_state_change', change),\n    broadcastCanvasChange: (change: CanvasChange) => broadcast('canvas_change', change)\n  }\n}\n\n// Singleton for easier store access\nlet _syncInstance: ReturnType<typeof useCrossTabSync> | null = null\nexport const getCrossTabSync = () => {\n  if (!_syncInstance) _syncInstance = useCrossTabSync()\n  return _syncInstance\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useCyberflowTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useDateTransition.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":44,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"watch"},"fix":{"range":[437,444],"text":""},"desc":"Remove unused variable \"watch\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TASK-082: Date Transition Composable\n *\n * Watches for midnight (00:00) transitions and emits events when the day changes.\n * Used by canvas to auto-move tasks from \"Today\" to \"Overdue\" groups.\n *\n * Features:\n * - Calculates time until next midnight and sets precise timeout\n * - Continuous monitoring after each midnight\n * - Cleanup on component unmount\n * - Manual trigger for testing\n */\n\nimport { ref, onMounted, onUnmounted, watch } from 'vue'\n\nexport interface DateTransitionOptions {\n  /** Callback when day changes */\n  onDayChange?: (previousDate: Date, newDate: Date) => void\n  /** Whether to start watching immediately (default: true) */\n  autoStart?: boolean\n  /** Enable debug logging (default: false) */\n  debug?: boolean\n}\n\nexport function useDateTransition(options: DateTransitionOptions = {}) {\n  const { onDayChange, autoStart = true, debug = false } = options\n\n  // Current tracked date (just the day, month, year)\n  const currentDate = ref<Date>(new Date())\n  const isWatching = ref(false)\n\n  // Track the timeout/interval ID for cleanup\n  let midnightTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  const log = (...args: unknown[]) => {\n    if (debug) {\n      console.log('[useDateTransition]', ...args)\n    }\n  }\n\n  /**\n   * Get milliseconds until next midnight\n   */\n  const getMsUntilMidnight = (): number => {\n    const now = new Date()\n    const tomorrow = new Date(now)\n    tomorrow.setDate(tomorrow.getDate() + 1)\n    tomorrow.setHours(0, 0, 0, 0)\n    return tomorrow.getTime() - now.getTime()\n  }\n\n  /**\n   * Check if the date has changed since last check\n   */\n  const hasDateChanged = (): boolean => {\n    const now = new Date()\n    const lastDate = currentDate.value\n\n    return (\n      now.getDate() !== lastDate.getDate() ||\n      now.getMonth() !== lastDate.getMonth() ||\n      now.getFullYear() !== lastDate.getFullYear()\n    )\n  }\n\n  /**\n   * Handle the date transition\n   */\n  const handleDateTransition = () => {\n    const previousDate = new Date(currentDate.value)\n    const newDate = new Date()\n\n    log('Date transition detected!', {\n      from: previousDate.toDateString(),\n      to: newDate.toDateString()\n    })\n\n    // Update tracked date\n    currentDate.value = newDate\n\n    // Call the callback if provided\n    if (onDayChange) {\n      try {\n        onDayChange(previousDate, newDate)\n      } catch (error) {\n        console.error('[useDateTransition] Error in onDayChange callback:', error)\n      }\n    }\n\n    // Schedule next midnight check\n    scheduleMidnightCheck()\n  }\n\n  /**\n   * Schedule a check for the next midnight\n   */\n  const scheduleMidnightCheck = () => {\n    // Clear any existing timeout\n    if (midnightTimeoutId) {\n      clearTimeout(midnightTimeoutId)\n      midnightTimeoutId = null\n    }\n\n    if (!isWatching.value) {\n      return\n    }\n\n    const msUntilMidnight = getMsUntilMidnight()\n\n    // Add a small buffer (100ms) to ensure we're past midnight\n    const timeoutMs = msUntilMidnight + 100\n\n    log(`Scheduling midnight check in ${Math.round(timeoutMs / 1000 / 60)} minutes`)\n\n    midnightTimeoutId = setTimeout(() => {\n      if (hasDateChanged()) {\n        handleDateTransition()\n      } else {\n        // In case of timing edge cases, check again in 1 minute\n        log('Date has not changed yet, rechecking in 1 minute')\n        midnightTimeoutId = setTimeout(() => {\n          if (hasDateChanged()) {\n            handleDateTransition()\n          } else {\n            // Reschedule for next midnight\n            scheduleMidnightCheck()\n          }\n        }, 60000) // 1 minute\n      }\n    }, timeoutMs)\n  }\n\n  /**\n   * Start watching for date transitions\n   */\n  const startWatching = () => {\n    if (isWatching.value) {\n      log('Already watching')\n      return\n    }\n\n    log('Starting date transition watcher')\n    isWatching.value = true\n    currentDate.value = new Date()\n    scheduleMidnightCheck()\n  }\n\n  /**\n   * Stop watching for date transitions\n   */\n  const stopWatching = () => {\n    log('Stopping date transition watcher')\n    isWatching.value = false\n\n    if (midnightTimeoutId) {\n      clearTimeout(midnightTimeoutId)\n      midnightTimeoutId = null\n    }\n  }\n\n  /**\n   * Manually trigger a date transition check (useful for testing)\n   */\n  const triggerCheck = () => {\n    log('Manual trigger check')\n    if (hasDateChanged()) {\n      handleDateTransition()\n    } else {\n      log('No date change detected')\n    }\n  }\n\n  /**\n   * Manually trigger a transition (for testing purposes)\n   * This simulates the day changing without waiting for midnight\n   */\n  const simulateTransition = () => {\n    log('Simulating date transition')\n    handleDateTransition()\n  }\n\n  // Auto-start if enabled\n  onMounted(() => {\n    if (autoStart) {\n      startWatching()\n    }\n  })\n\n  // Cleanup on unmount\n  onUnmounted(() => {\n    stopWatching()\n  })\n\n  // Also watch for page visibility changes - recheck when page becomes visible\n  if (typeof document !== 'undefined') {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible' && isWatching.value) {\n        log('Page became visible, checking for date change')\n        if (hasDateChanged()) {\n          handleDateTransition()\n        } else {\n          // Reschedule in case timeout was imprecise while tab was hidden\n          scheduleMidnightCheck()\n        }\n      }\n    }\n\n    onMounted(() => {\n      document.addEventListener('visibilitychange', handleVisibilityChange)\n    })\n\n    onUnmounted(() => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange)\n    })\n  }\n\n  return {\n    /** Current tracked date */\n    currentDate,\n    /** Whether the watcher is active */\n    isWatching,\n    /** Start watching for date transitions */\n    startWatching,\n    /** Stop watching for date transitions */\n    stopWatching,\n    /** Manually trigger a check */\n    triggerCheck,\n    /** Simulate a date transition (for testing) */\n    simulateTransition,\n    /** Get milliseconds until next midnight */\n    getMsUntilMidnight\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useDemoGuard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useDragAndDrop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useDynamicImports.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stats' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":319,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":319,"endColumn":14}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1893,1896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1893,1896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":289,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7291,7294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7291,7294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":289,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7301,7304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7301,7304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7522,7525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7522,7525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7532,7535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7532,7535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Dynamic Import Manager - Standardized Import System\n *\n * Fixes dynamic import conflicts by providing a centralized, caching system\n * for all composables and components that need lazy loading\n */\n\nimport { ref as _ref, reactive } from 'vue'\n\n// Type definitions for dynamic imports\ntype _DynamicImport<T = unknown> = () => Promise<T>\ntype ImportCache = Map<string, unknown>\n\n// Import configuration interface\ninterface ImportConfig {\n  path: () => Promise<unknown>\n  preload?: boolean\n  timeout: number\n}\n\n// Global import cache to prevent duplicate loading\nconst _importCache: ImportCache = new Map()\n\n// Loading states for tracking imports\nconst loadingStates = reactive<Record<string, boolean>>({})\n\n// Error states for tracking failed imports\nconst errorStates = reactive<Record<string, Error | null>>({})\n\n/**\n * Import configuration for common composables\n * NOTE: PouchDB/CouchDB sync entries removed Jan 2026 - app uses Supabase now\n */\nexport const IMPORT_CONFIG = {\n  // Undo/Redo system imports\n  useUnifiedUndoRedo: {\n    path: () => import('@/composables/useUnifiedUndoRedo'),\n    preload: false, // Load on demand\n    timeout: 3000\n  },\n\n  // Canvas-related imports\n  CanvasView: {\n    path: () => import('@/views/CanvasView.vue'),\n    preload: false, // Load on demand\n    timeout: 5000\n  },\n\n  // Store imports\n  useTasksStore: {\n    path: () => import('@/stores/tasks'),\n    preload: false, // Load on demand\n    timeout: 3000\n  },\n\n  useCanvasStore: {\n    path: () => import('@/stores/canvas'),\n    preload: false, // Load on demand\n    timeout: 3000\n  }\n} as const\n\ntype ImportKey = keyof typeof IMPORT_CONFIG\n\n/**\n * Dynamic import manager with caching and error handling\n */\nexport class DynamicImportManager {\n  private cache: ImportCache = new Map()\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private loadingPromises: Map<string, Promise<any>> = new Map()\n\n  /**\n   * Import a module with caching, timeout, and error handling\n   */\n  async import<T = unknown>(key: ImportKey): Promise<T> {\n    const config = IMPORT_CONFIG[key]\n\n    if (!config) {\n      throw new Error(`Import key \"${key}\" not found in IMPORT_CONFIG`)\n    }\n\n    // Return cached version if available\n    if (this.cache.has(key)) {\n      return this.cache.get(key) as T\n    }\n\n    // Return existing promise if currently loading\n    if (this.loadingPromises.has(key)) {\n      return this.loadingPromises.get(key) as Promise<T>\n    }\n\n    // Create and store loading promise\n    const loadingPromise = this.performImport<T>(key, config)\n    this.loadingPromises.set(key, loadingPromise)\n\n    try {\n      const result = await loadingPromise\n      this.cache.set(key, result)\n      errorStates[key] = null\n      return result\n    } catch (error) {\n      errorStates[key] = error as Error\n      throw error\n    } finally {\n      this.loadingPromises.delete(key)\n    }\n  }\n\n  /**\n   * Perform the actual import with timeout\n   */\n  private async performImport<T>(key: string, config: ImportConfig): Promise<T> {\n    loadingStates[key] = true\n\n    try {\n      const importPromise = config.path()\n\n      // Add timeout\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => {\n          reject(new Error(`Import timeout for \"${key}\" after ${config.timeout}ms`))\n        }, config.timeout)\n      })\n\n      const module = await Promise.race([importPromise, timeoutPromise]) as { default?: T } | T\n\n\n      return (module as { default?: T }).default || module as T\n\n    } catch (error) {\n      console.error(`❌ Failed to import: ${key}`, error)\n      throw new Error(`Failed to import ${key}: ${(error as Error).message}`)\n    } finally {\n      loadingStates[key] = false\n    }\n  }\n\n  /**\n   * Preload critical imports\n   */\n  async preloadCritical(): Promise<void> {\n    const criticalImports = Object.entries(IMPORT_CONFIG)\n      .filter(([_, config]) => config.preload)\n      .map(([key]) => key as ImportKey)\n\n\n\n    await Promise.allSettled(\n      criticalImports.map(key =>\n        this.import(key).catch(error => {\n          console.warn(`⚠️ Failed to preload ${key}:`, error.message)\n          return null\n        })\n      )\n    )\n\n\n  }\n\n  /**\n   * Check if an import is currently loading\n   */\n  isLoading(key: ImportKey): boolean {\n    return loadingStates[key] || this.loadingPromises.has(key)\n  }\n\n  /**\n   * Check if an import has failed\n   */\n  hasError(key: ImportKey): boolean {\n    return errorStates[key] !== null\n  }\n\n  /**\n   * Get the error for an import\n   */\n  getError(key: ImportKey): Error | null {\n    return errorStates[key]\n  }\n\n  /**\n   * Clear cache for a specific import or all imports\n   */\n  clearCache(key?: ImportKey): void {\n    if (key) {\n      this.cache.delete(key)\n      errorStates[key] = null\n    } else {\n      this.cache.clear()\n      Object.keys(errorStates).forEach(k => {\n        errorStates[k] = null\n      })\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats() {\n    return {\n      cached: this.cache.size,\n      loading: this.loadingPromises.size,\n      errors: Object.values(errorStates).filter(e => e !== null).length,\n      total: Object.keys(IMPORT_CONFIG).length\n    }\n  }\n}\n\n// Global instance\nconst dynamicImportManager = new DynamicImportManager()\n\n/**\n * Composable for using dynamic imports\n */\nexport function useDynamicImports() {\n  /**\n   * Import a composable or component\n   */\n  const importModule = async <T = unknown>(key: ImportKey): Promise<T> => {\n    return await dynamicImportManager.import<T>(key)\n  }\n\n  /**\n   * Import multiple modules in parallel\n   */\n  const importModules = async <T = unknown>(keys: ImportKey[]): Promise<T[]> => {\n    const promises = keys.map(key => dynamicImportManager.import<T>(key))\n    return await Promise.all(promises)\n  }\n\n  /**\n   * Import with fallback\n   */\n  const importWithFallback = async <T = unknown>(\n    key: ImportKey,\n    fallback: T | (() => T)\n  ): Promise<T> => {\n    try {\n      return await dynamicImportManager.import<T>(key)\n    } catch (error) {\n      console.warn(`⚠️ Import failed for ${key}, using fallback:`, (error as Error).message)\n      return typeof fallback === 'function' ? (fallback as () => T)() : fallback\n    }\n  }\n\n  /**\n   * Check import status\n   */\n  const getStatus = (key: ImportKey) => ({\n    loading: dynamicImportManager.isLoading(key),\n    error: dynamicImportManager.hasError(key),\n    errorDetail: dynamicImportManager.getError(key)\n  })\n\n  /**\n   * Preload specific imports\n   */\n  const preload = async (keys: ImportKey[]): Promise<void> => {\n    await Promise.allSettled(\n      keys.map(key =>\n        dynamicImportManager.import(key).catch(error => {\n          console.warn(`⚠️ Failed to preload ${key}:`, error.message)\n        })\n      )\n    )\n  }\n\n  return {\n    import: importModule,\n    importModules,\n    importWithFallback,\n    getStatus,\n    preload,\n    manager: dynamicImportManager\n  }\n}\n\n/**\n * Convenience functions for common imports\n * NOTE: PouchDB/CouchDB sync helpers removed Jan 2026 - app uses Supabase now\n */\n\n// Helper type for dynamic modules\ntype ModuleShape = Record<string, unknown>\n\n// Undo/Redo composable with caching\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const getUndoRedoComposable = async (): Promise<(...args: any[]) => any> => {\n  const module = await dynamicImportManager.import<ModuleShape>('useUnifiedUndoRedo')\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (module.useUnifiedUndoRedo || module) as (...args: any[]) => any\n}\n\n// Store imports with caching\nexport const getTasksStore = async () => {\n  const module = await dynamicImportManager.import<ModuleShape>('useTasksStore')\n  return module.useTasksStore || module.default || module\n}\n\nexport const getCanvasStore = async () => {\n  const module = await dynamicImportManager.import<ModuleShape>('useCanvasStore')\n  return module.useCanvasStore || module.default || module\n}\n\n/**\n * Initialize the dynamic import system\n * Call this early in app startup\n */\nexport const initializeDynamicImports = async (): Promise<void> => {\n\n\n  // Preload critical imports\n  await dynamicImportManager.preloadCritical()\n\n\n\n  // Log statistics\n  const stats = dynamicImportManager.getStats()\n\n}\n\n// Export the ImportKey type for external use\nexport type { ImportKey }\n\nexport default useDynamicImports","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useFocusMode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useGamificationHooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useGroupSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useHaptics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useHebrewAlignment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useHorizontalDragScroll.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":325,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":325,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10701,10704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10701,10704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10774,10777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10774,10777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":327,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10842,10845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10842,10845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onMounted, onUnmounted, type Ref } from 'vue'\n\nexport interface HorizontalDragScrollOptions {\n  /**\n   * Minimum drag distance before scrolling starts\n   */\n  threshold?: number\n\n  /**\n   * Scroll multiplier for drag sensitivity\n   */\n  sensitivity?: number\n\n  /**\n   * Momentum friction coefficient (0-1)\n   */\n  friction?: number\n\n  /**\n   * Enable touch events for mobile\n   */\n  touchEnabled?: boolean\n\n  /**\n   * CSS cursor during drag\n   */\n  dragCursor?: string\n\n  /**\n   * Callback when drag starts\n   */\n  onDragStart?: () => void\n\n  /**\n   * Callback when drag ends\n   */\n  onDragEnd?: () => void\n}\n\nexport function useHorizontalDragScroll(\n  scrollContainer: Ref<HTMLElement | null>,\n  options: HorizontalDragScrollOptions = {}\n) {\n  const {\n    threshold = 10,\n    sensitivity = 1,\n    friction = 0.95,\n    touchEnabled = true,\n    dragCursor = 'grabbing',\n    onDragStart,\n    onDragEnd\n  } = options\n\n  const isPreparingToDrag = ref(false)\n  const isDragging = ref(false)\n  const isScrolling = ref(false)\n  const startX = ref(0)\n  const startY = ref(0)\n  const scrollLeft = ref(0)\n  const velocity = ref(0)\n  const lastX = ref(0)\n  const animationFrameId = ref<number>()\n\n  // Comprehensive drag intent detection - FIXED: Check BEFORE preventDefault\n  const detectDragIntent = (target: HTMLElement, _clientX: number, _clientY: number): boolean => {\n    // Check for draggable elements (from mapping documentation)\n    const draggableElement = target.closest<HTMLElement>(\n      '.draggable, [data-draggable=\"true\"], [draggable=\"true\"], .task-card, .inbox-task-card, ' +\n      '[data-inbox-task=\"true\"], .vuedraggable, .vue-flow__node, .vue-flow__handle, ' +\n      '.drag-area, .task-item, .task-item-mini, .tasks-container, ' + // More comprehensive list\n      '.calendar-event, .time-slot, .week-event, .month-event'\n    )\n\n    if (draggableElement) {\n      console.log('🎯 [HorizontalDragScroll] Detected drag intent, allowing drag-and-drop')\n      return true\n    }\n\n    // Check for interactive elements within draggable components\n    const interactiveElement = target.closest<HTMLElement>(\n      'button, input, textarea, select, [role=\"button\"], .draggable-handle, ' +\n      '.status-icon-button, .task-title, .card-header, .metadata-badges, .card-actions, .task-item-mini, ' +\n      '.resize-handle, .event-content, .event-actions'\n    )\n\n    if (interactiveElement) {\n      console.log('🔘 [HorizontalDragScroll] Detected interactive element, allowing interaction')\n      return true\n    }\n\n    return false\n  }\n\n  // Momentum scrolling\n  const applyMomentum = () => {\n    if (!scrollContainer.value) return\n\n    if (Math.abs(velocity.value) > 0.1) {\n      scrollContainer.value.scrollLeft += velocity.value\n      velocity.value *= friction\n      animationFrameId.value = requestAnimationFrame(applyMomentum)\n    } else {\n      velocity.value = 0\n      isScrolling.value = false\n    }\n  }\n\n  // Start drag (only called after drag intent check passes)\n  const handleStart = (clientX: number, clientY: number, target: HTMLElement) => {\n    if (!scrollContainer.value) return\n\n    // Check if target is within our scroll container\n    if (!scrollContainer.value.contains(target)) {\n      return // Only handle events within our container\n    }\n\n    isPreparingToDrag.value = true\n    isDragging.value = false\n    startX.value = clientX\n    startY.value = clientY\n    scrollLeft.value = scrollContainer.value.scrollLeft\n    lastX.value = clientX\n    velocity.value = 0\n\n    // Cancel any existing momentum\n    if (animationFrameId.value) {\n      cancelAnimationFrame(animationFrameId.value)\n    }\n\n    // Don't set styles here, wait for actual drag in handleMove\n  }\n\n  // We don't onDragStart here anymore, we do it in handleMove once threshold is met\n\n  // Drag move\n  const handleMove = (clientX: number, clientY: number, e: MouseEvent | TouchEvent) => {\n    if ((!isDragging.value && !isPreparingToDrag.value) || !scrollContainer.value) return\n\n    const deltaX = clientX - startX.value\n    const deltaY = clientY - startY.value\n\n    // Check if we've moved enough to start scrolling\n    if (Math.abs(deltaX) < threshold && Math.abs(deltaY) < threshold) {\n      return\n    }\n\n    // Now that we've crossed the threshold, check if move is primarily horizontal\n    if (!isDragging.value) {\n      // If move is primarily vertical, this is likely a sort/drag within a column, NOT a board scroll\n      if (Math.abs(deltaY) > Math.abs(deltaX)) {\n        isPreparingToDrag.value = false // Yield to vertical dragging\n        return\n      }\n\n      isDragging.value = true\n      isPreparingToDrag.value = false\n\n      // Stop event propagation and prevent default once we're SURE it's a board scroll\n      e.preventDefault()\n      e.stopPropagation()\n\n      // Set cursor and styles\n      if (scrollContainer.value) {\n        scrollContainer.value.style.cursor = dragCursor\n        scrollContainer.value.style.userSelect = 'none'\n        scrollContainer.value.style.touchAction = 'none' // Prevent all touch after we take over\n      }\n\n      onDragStart?.()\n      return\n    }\n\n    // If we're already dragging, always prevent default browser behavior\n    e.preventDefault()\n    e.stopPropagation()\n\n    // Calculate velocity for momentum\n    const currentVelocity = (clientX - lastX.value) * sensitivity\n    velocity.value = currentVelocity * 0.8 + velocity.value * 0.2 // Smooth velocity\n    lastX.value = clientX\n\n    // Apply scroll - only modify scrollLeft, don't transform elements\n    const walk = deltaX * sensitivity\n    const newScrollLeft = scrollLeft.value - walk\n\n    // Ensure we don't scroll beyond boundaries\n    const maxScrollLeft = scrollContainer.value.scrollWidth - scrollContainer.value.clientWidth\n    scrollContainer.value.scrollLeft = Math.max(0, Math.min(newScrollLeft, maxScrollLeft))\n\n    // Prevent default browser behavior and stop propagation\n    e.preventDefault()\n    e.stopPropagation()\n  }\n\n  // End drag\n  const handleEnd = (e?: MouseEvent | TouchEvent) => {\n    const wasDragging = isDragging.value\n    isPreparingToDrag.value = false\n    isDragging.value = false\n\n    // Reset cursor and styles\n    if (scrollContainer.value) {\n      scrollContainer.value.style.cursor = ''\n      scrollContainer.value.style.userSelect = ''\n      scrollContainer.value.style.touchAction = ''\n    }\n\n    // Stop event propagation\n    if (e) {\n      e.stopPropagation()\n    }\n\n    // Start momentum scrolling if we have velocity\n    if (wasDragging && Math.abs(velocity.value) > 0.5) {\n      isScrolling.value = true\n      applyMomentum()\n    }\n\n    if (wasDragging) {\n      onDragEnd?.()\n    }\n  }\n\n  // Mouse events\n  const handleMouseDown = (e: MouseEvent) => {\n    // If the event was already handled (e.g. by vuedraggable), respect it\n    if (e.defaultPrevented) return\n\n    // Check for interactive/draggable elements that should manage their own clicks/drags\n    const isInteractingWithDraggable = detectDragIntent(e.target as HTMLElement, e.clientX, e.clientY)\n    if (isInteractingWithDraggable) {\n      console.log('🎯 [HorizontalDragScroll] Allowing event to pass to draggable child')\n      return\n    }\n\n    // DON'T preventDefault or stopPropagation here!\n    // We only want to start scrolling if the user moves beyond the threshold.\n    handleStart(e.clientX, e.clientY, e.target as HTMLElement)\n\n    // Add global listeners when potential drag starts\n    if (scrollContainer.value) {\n      const container = scrollContainer.value as HTMLElement & { _globalMouseMoveHandler?: (e: MouseEvent) => void, _globalMouseUpHandler?: (e: MouseEvent) => void }\n      if (container._globalMouseMoveHandler) document.addEventListener('mousemove', container._globalMouseMoveHandler)\n      if (container._globalMouseUpHandler) document.addEventListener('mouseup', container._globalMouseUpHandler)\n    }\n  }\n\n  const handleMouseMove = (e: MouseEvent) => {\n    if (!isPreparingToDrag.value && !isDragging.value) return\n    handleMove(e.clientX, e.clientY, e)\n  }\n\n  const handleGlobalMouseMove = (e: MouseEvent) => {\n    if (isPreparingToDrag.value || isDragging.value) {\n      handleMouseMove(e)\n    }\n  }\n\n  const handleGlobalMouseUp = (e: MouseEvent) => {\n    handleEnd(e)\n    // ALWAYS remove these if we have them\n    if (scrollContainer.value) {\n      const container = scrollContainer.value as HTMLElement & { _globalMouseMoveHandler?: (e: MouseEvent) => void, _globalMouseUpHandler?: (e: MouseEvent) => void }\n      if (container._globalMouseMoveHandler) document.removeEventListener('mousemove', container._globalMouseMoveHandler)\n      if (container._globalMouseUpHandler) document.removeEventListener('mouseup', container._globalMouseUpHandler)\n    }\n  }\n\n  // Touch events\n  const handleTouchStart = (e: TouchEvent) => {\n    if (!touchEnabled) return\n    const touch = e.touches[0]\n\n    // FIXED: Check for draggable elements BEFORE calling preventDefault()\n    const shouldAllowDrag = detectDragIntent(e.target as HTMLElement, touch.clientX, touch.clientY)\n    if (shouldAllowDrag) {\n      // Don't interfere with drag operations - let them proceed naturally\n      return\n    }\n\n    // DON'T prevent default here. If we do, we block ALL native gestures including vertical scroll.\n    // handleStart will set up the initial coordinates.\n    // handleMove will decide whether to take over (preventDefault) or yield.\n    handleStart(touch.clientX, touch.clientY, e.target as HTMLElement)\n  }\n\n  const handleTouchMove = (e: TouchEvent) => {\n    if (!touchEnabled || (!isPreparingToDrag.value && !isDragging.value)) return\n    const touch = e.touches[0]\n    // handleMove will call preventDefault() ONLY if it's a horizontal scroll\n    handleMove(touch.clientX, touch.clientY, e)\n  }\n\n  const handleTouchEnd = (e: TouchEvent) => {\n    if (!touchEnabled || !isDragging.value) return\n    e.preventDefault()\n    e.stopPropagation()\n    handleEnd(e)\n  }\n\n  // Wheel event for smooth horizontal scrolling\n  const handleWheel = (e: WheelEvent) => {\n    if (!scrollContainer.value) return\n\n    // Check if we can scroll horizontally\n    const canScrollHorizontally =\n      scrollContainer.value.scrollWidth > scrollContainer.value.clientWidth\n\n    if (canScrollHorizontally && e.shiftKey) {\n      e.preventDefault()\n      scrollContainer.value.scrollLeft += e.deltaY\n    }\n  }\n\n  // Setup event listeners\n  onMounted(() => {\n    if (!scrollContainer.value) return\n\n    const container = scrollContainer.value\n\n    // Mouse events - only on container, not document\n    container.addEventListener('mousedown', handleMouseDown)\n\n    // Store global handlers for cleanup and dynamic attachment\n    const containerExt = container as unknown as Record<string, any>\n    containerExt._globalMouseMoveHandler = handleGlobalMouseMove as any\n    containerExt._globalMouseUpHandler = handleGlobalMouseUp as any\n\n    // Touch events\n    if (touchEnabled) {\n      container.addEventListener('touchstart', handleTouchStart, { passive: false })\n      container.addEventListener('touchmove', handleTouchMove, { passive: false })\n      container.addEventListener('touchend', handleTouchEnd)\n      container.addEventListener('touchcancel', handleTouchEnd)\n    }\n\n    // Wheel event\n    container.addEventListener('wheel', handleWheel, { passive: false })\n  })\n\n  // Cleanup\n  onUnmounted(() => {\n    if (animationFrameId.value) {\n      cancelAnimationFrame(animationFrameId.value)\n    }\n\n    if (!scrollContainer.value) return\n\n    const container = scrollContainer.value as HTMLElement & { _globalMouseMoveHandler?: (e: MouseEvent) => void, _globalMouseUpHandler?: (e: MouseEvent) => void }\n\n    container.removeEventListener('mousedown', handleMouseDown)\n\n    // Clean up global listeners if they exist\n    if (container._globalMouseMoveHandler) {\n      document.removeEventListener('mousemove', container._globalMouseMoveHandler)\n    }\n    if (container._globalMouseUpHandler) {\n      document.removeEventListener('mouseup', container._globalMouseUpHandler)\n    }\n\n    if (touchEnabled) {\n      container.removeEventListener('touchstart', handleTouchStart)\n      container.removeEventListener('touchmove', handleTouchMove)\n      container.removeEventListener('touchend', handleTouchEnd)\n      container.removeEventListener('touchcancel', handleTouchEnd)\n    }\n\n    container.removeEventListener('wheel', handleWheel)\n\n    const containerCleanup = container as unknown as Record<string, unknown>\n    delete containerCleanup._globalMouseMoveHandler\n    delete containerCleanup._globalMouseUpHandler\n  })\n\n  // Public methods\n  const scrollTo = (position: number, smooth = true) => {\n    if (!scrollContainer.value) return\n\n    if (smooth) {\n      scrollContainer.value.scrollTo({\n        left: position,\n        behavior: 'smooth'\n      })\n    } else {\n      scrollContainer.value.scrollLeft = position\n    }\n  }\n\n  const scrollBy = (delta: number, smooth = true) => {\n    if (!scrollContainer.value) return\n\n    if (smooth) {\n      scrollContainer.value.scrollBy({\n        left: delta,\n        behavior: 'smooth'\n      })\n    } else {\n      scrollContainer.value.scrollLeft += delta\n    }\n  }\n\n  const scrollToElement = (element: HTMLElement, offset = 0) => {\n    if (!scrollContainer.value) return\n\n    const containerRect = scrollContainer.value.getBoundingClientRect()\n    const elementRect = element.getBoundingClientRect()\n\n    const targetScroll = elementRect.left - containerRect.left + scrollContainer.value.scrollLeft - offset\n\n    scrollTo(targetScroll, true)\n  }\n\n  return {\n    isDragging,\n    isScrolling,\n    scrollTo,\n    scrollBy,\n    scrollToElement\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useLazyComponent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useMobileDetection.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[263,266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[263,266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[847,850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[847,850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, onMounted, onUnmounted } from 'vue'\n\n// Check mobile immediately (SSR-safe)\nfunction getInitialMobileState(): boolean {\n    if (typeof window === 'undefined') return false\n\n    const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera\n    const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase())\n    const isSmallScreen = window.innerWidth <= 768\n\n    return isMobileDevice || isSmallScreen\n}\n\nexport function useMobileDetection() {\n    // Initialize with correct value immediately (not false)\n    const isMobile = ref(getInitialMobileState())\n\n    const checkMobile = () => {\n        if (typeof window === 'undefined') return\n\n        // Check for mobile user agent\n        const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera\n        const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase())\n\n        // Check for small screen width (standard tablet/mobile breakpoint)\n        const isSmallScreen = window.matchMedia('(max-width: 768px)').matches\n\n        // Check for touch capability (additional signal)\n        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0\n\n        // Combine signals - prioritize screen size/agent over touch\n        // RELAXED: If it's small, it's mobile. If it's a mobile UA, it's mobile.\n        isMobile.value = isMobileDevice || isSmallScreen\n\n        console.log('[MobileDetection] Checked:', {\n            isMobile: isMobile.value,\n            isMobileDevice,\n            isSmallScreen,\n            isTouch,\n            width: window.innerWidth\n        })\n    }\n\n    onMounted(() => {\n        checkMobile()\n        window.addEventListener('resize', checkMobile)\n    })\n\n    onUnmounted(() => {\n        window.removeEventListener('resize', checkMobile)\n    })\n\n    return { isMobile }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useNetworkOptimizer.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2118,2121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2118,2121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useOfflineVoiceQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/usePerformanceManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2001,2004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2001,2004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2011,2014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2011,2014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2327,2330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2327,2330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2337,2340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2337,2340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2655,2658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2655,2658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2665,2668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2665,2668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Manager Composable\n * Centralized performance optimization with debouncing, memoization, and cleanup\n */\n\nimport { ref, computed as _computed, watch as _watch, onMounted, onUnmounted, nextTick as _nextTick } from 'vue'\nimport { useDebounceFn, useThrottleFn, useStorage as _useStorage, useRafFn } from '@vueuse/core'\n\nexport interface PerformanceConfig {\n  debounceDelay?: number\n  throttleDelay?: number\n  maxCacheSize?: number\n  enableMemoization?: boolean\n  enableCleanup?: boolean\n  cleanupInterval?: number\n  memoryThreshold?: number\n}\n\nexport interface PerformanceMetrics {\n  memoryUsage: number\n  cacheSize: number\n  cacheHitRate: number\n  debouncedOperations: number\n  throttledOperations: number\n  memoizedComputations: number\n  cleanupRuns: number\n  lastCleanupTime: number\n}\n\nexport interface CacheEntry<T = unknown> {\n  key: string\n  value: T\n  timestamp: number\n  hits: number\n  size: number\n}\n\nexport function usePerformanceManager(config: PerformanceConfig = {}) {\n  const {\n    debounceDelay = 300,\n    throttleDelay = 16, // ~60fps\n    maxCacheSize = 100,\n    enableMemoization = true,\n    enableCleanup = true,\n    cleanupInterval = 30000, // 30 seconds\n    memoryThreshold = 100 * 1024 * 1024 // 100MB\n  } = config\n\n  // Reactive state\n  const cache = ref<Map<string, CacheEntry>>(new Map())\n  const metrics = ref<PerformanceMetrics>({\n    memoryUsage: 0,\n    cacheSize: 0,\n    cacheHitRate: 0,\n    debouncedOperations: 0,\n    throttledOperations: 0,\n    memoizedComputations: 0,\n    cleanupRuns: 0,\n    lastCleanupTime: 0\n  })\n\n  // Memoization helpers\n  const memoizedComputations = ref<Map<string, { result: unknown, deps: unknown[], timestamp: number }>>(new Map())\n  const memoizationStats = ref({ hits: 0, misses: 0 })\n\n  // Memory monitoring\n  const memoryUsage = ref(0)\n  const memoryMonitorInterval = ref<NodeJS.Timeout>()\n  const cleanupCacheInterval = ref<NodeJS.Timeout>()\n\n  // Debounce function factory\n  const createDebounced = <T extends (...args: any[]) => any>(\n    fn: T,\n    delay: number = debounceDelay\n  ) => {\n    const debouncedFn = useDebounceFn(fn, delay)\n\n    return (...args: Parameters<T>) => {\n      metrics.value.debouncedOperations++\n      return debouncedFn(...args)\n    }\n  }\n\n  // Throttle function factory\n  const createThrottled = <T extends (...args: any[]) => any>(\n    fn: T,\n    delay: number = throttleDelay\n  ) => {\n    const throttledFn = useThrottleFn(fn, delay)\n\n    return (...args: Parameters<T>) => {\n      metrics.value.throttledOperations++\n      return throttledFn(...args)\n    }\n  }\n\n  // Memoized computation factory\n  const createMemoized = <T extends (...args: any[]) => any>(\n    fn: T,\n    key: string,\n    dependencies: unknown[] = []\n  ) => {\n    if (!enableMemoization) {\n      return fn\n    }\n\n    return (...args: Parameters<T>): ReturnType<T> => {\n      const cached = memoizedComputations.value.get(key)\n\n      if (cached && Date.now() - cached.timestamp < 300000) { // 5 minutes TTL\n        const depsMatch = dependencies.length === cached.deps.length &&\n          dependencies.every((dep, i) => dep === cached.deps[i])\n\n        if (depsMatch) {\n          memoizationStats.value.hits++\n          metrics.value.memoizedComputations++\n          return cached.result as ReturnType<T>\n        }\n      }\n\n      const result = fn(...args)\n      memoizedComputations.value.set(key, {\n        result,\n        deps: dependencies,\n        timestamp: Date.now()\n      })\n\n      memoizationStats.value.misses++\n      metrics.value.memoizedComputations++\n      return result as ReturnType<T>\n    }\n  }\n\n  // Cache management\n  const setCache = <T>(key: string, value: T, _ttl: number = 300000) => {\n    if (!enableMemoization) return\n\n    const size = calculateSize(value)\n    const entry: CacheEntry<T> = {\n      key,\n      value,\n      timestamp: Date.now(),\n      hits: 0,\n      size\n    }\n\n    cache.value.set(key, entry)\n\n    // Check cache size limit\n    if (cache.value.size > maxCacheSize) {\n      cleanupCache()\n    }\n\n    updateMetrics()\n  }\n\n  const getCache = <T>(key: string): T | null => {\n    if (!enableMemoization) return null\n\n    const entry = cache.value.get(key) as CacheEntry<T>\n\n    if (entry) {\n      const now = Date.now()\n      if (now - entry.timestamp < 300000) { // 5 minutes TTL\n        entry.hits++\n        return entry.value\n      } else {\n        cache.value.delete(key)\n      }\n    }\n\n    return null\n  }\n\n  const hasCache = (key: string): boolean => {\n    if (!enableMemoization) return false\n\n    const entry = cache.value.get(key)\n    if (!entry) return false\n\n    const now = Date.now()\n    if (now - entry.timestamp >= 300000) {\n      cache.value.delete(key)\n      return false\n    }\n\n    return true\n  }\n\n  const deleteCache = (key: string): boolean => {\n    return cache.value.delete(key)\n  }\n\n  const clearCache = () => {\n    cache.value.clear()\n    memoizedComputations.value.clear()\n    updateMetrics()\n  }\n\n  // Cache cleanup\n  const cleanupCache = () => {\n    if (!enableCleanup) return\n\n    const now = Date.now()\n    const entries = Array.from(cache.value.entries())\n\n    // Sort by hits (keep most used) and recency\n    entries.sort(([, a], [, b]) => {\n      const aScore = a.hits + (now - a.timestamp) / 1000\n      const bScore = b.hits + (now - b.timestamp) / 1000\n      return bScore - aScore\n    })\n\n    // Keep only top entries\n    const keepCount = Math.floor(maxCacheSize * 0.8)\n    const toKeep = entries.slice(0, keepCount)\n\n    cache.value.clear()\n    toKeep.forEach(([key, entry]) => cache.value.set(key, entry))\n\n    // Clean expired memoized computations\n    for (const [key, comp] of memoizedComputations.value.entries()) {\n      if (now - comp.timestamp > 300000) {\n        memoizedComputations.value.delete(key)\n      }\n    }\n\n    metrics.value.cleanupRuns++\n    metrics.value.lastCleanupTime = now\n    updateMetrics()\n  }\n\n  // Calculate size of object (rough estimation)\n  const calculateSize = (obj: unknown): number => {\n    try {\n      return JSON.stringify(obj).length * 2 // 2 bytes per character\n    } catch {\n      return 1000 // Default size for non-serializable objects\n    }\n  }\n\n  // Update performance metrics\n  const updateMetrics = () => {\n    metrics.value.cacheSize = cache.value.size\n    metrics.value.memoryUsage = memoryUsage.value\n\n    const totalHits = Array.from(cache.value.values()).reduce((sum, entry) => sum + entry.hits, 0)\n    metrics.value.cacheHitRate = cache.value.size > 0 ? totalHits / cache.value.size : 0\n  }\n\n  // Memory monitoring\n  const startMemoryMonitoring = () => {\n    if (typeof performance !== 'undefined' && 'memory' in performance) {\n      memoryMonitorInterval.value = setInterval(() => {\n        const perf = performance as unknown as Record<string, unknown>\n        const memory = perf.memory as Record<string, number>\n        if (memory) {\n          memoryUsage.value = memory.usedJSHeapSize\n\n          // Auto-cleanup if memory threshold exceeded\n          if (memoryUsage.value > memoryThreshold) {\n            cleanupCache()\n          }\n        }\n        updateMetrics()\n      }, 5000) // Check every 5 seconds\n    }\n  }\n\n  const stopMemoryMonitoring = () => {\n    if (memoryMonitorInterval.value) {\n      clearInterval(memoryMonitorInterval.value)\n    }\n  }\n\n  // Performance optimization helpers\n  const optimizeForLargeLists = <T>(items: T[]) => {\n    if (items.length > 1000) {\n      // For very large lists, use more aggressive debouncing\n      return createDebounced(<R>(fn: () => R) => fn(), 500)\n    }\n    return createDebounced(<R>(fn: () => R) => fn(), debounceDelay)\n  }\n\n  const optimizeForAnimations = <T>(fn: T) => {\n    // Use RAF for animations\n    const raf = useRafFn(fn as () => void)\n    return raf.pause\n  }\n\n  const batchOperations = <T>(operations: (() => T)[]) => {\n    const results: T[] = []\n\n    // Batch operations in a single frame\n    requestAnimationFrame(() => {\n      operations.forEach(op => {\n        try {\n          results.push(op())\n        } catch (error) {\n          console.error('Batch operation failed:', error)\n        }\n      })\n    })\n\n    return results\n  }\n\n  // RAF-based rendering optimization\n  const scheduleRender = (fn: () => void) => {\n    return requestAnimationFrame(fn)\n  }\n\n  const cancelRender = (id: number) => {\n    cancelAnimationFrame(id)\n  }\n\n  // Cleanup on unmount\n  onMounted(() => {\n    startMemoryMonitoring()\n\n    if (enableCleanup) {\n      cleanupCacheInterval.value = setInterval(cleanupCache, cleanupInterval)\n    }\n  })\n\n  // Stop cleanup cache interval\n  const stopCleanupCacheInterval = () => {\n    if (cleanupCacheInterval.value) {\n      clearInterval(cleanupCacheInterval.value)\n      cleanupCacheInterval.value = undefined\n    }\n  }\n\n  onUnmounted(() => {\n    stopMemoryMonitoring()\n    stopCleanupCacheInterval()\n    clearCache()\n  })\n\n  // Explicit destroy for singleton usage (call on app shutdown)\n  const destroy = () => {\n    stopMemoryMonitoring()\n    stopCleanupCacheInterval()\n    clearCache()\n  }\n\n  return {\n    // Core utilities\n    createDebounced,\n    createThrottled,\n    createMemoized,\n\n    // Cache management\n    setCache,\n    getCache,\n    hasCache,\n    deleteCache,\n    clearCache,\n    cleanupCache,\n\n    // Performance helpers\n    optimizeForLargeLists,\n    optimizeForAnimations,\n    batchOperations,\n    scheduleRender,\n    cancelRender,\n\n    // Metrics and monitoring\n    metrics,\n    memoizationStats,\n    memoryUsage,\n\n    // Utilities\n    updateMetrics,\n    calculateSize,\n\n    // Cleanup (for singleton usage)\n    destroy\n  }\n}\n\n// Global performance manager instance\nexport const globalPerformanceManager = usePerformanceManager()\n\n// Performance presets for common scenarios\nexport const performancePresets = {\n  // For heavy computations\n  heavyComputation: {\n    debounceDelay: 500,\n    throttleDelay: 100,\n    maxCacheSize: 50,\n    enableMemoization: true,\n    cleanupInterval: 60000\n  },\n\n  // For real-time updates\n  realtime: {\n    debounceDelay: 50,\n    throttleDelay: 16,\n    maxCacheSize: 200,\n    enableMemoization: true,\n    cleanupInterval: 15000\n  },\n\n  // For infrequent operations\n  batched: {\n    debounceDelay: 1000,\n    throttleDelay: 200,\n    maxCacheSize: 100,\n    enableMemoization: true,\n    cleanupInterval: 120000\n  },\n\n  // For minimal overhead\n  minimal: {\n    debounceDelay: 100,\n    throttleDelay: 50,\n    maxCacheSize: 20,\n    enableMemoization: false,\n    cleanupInterval: 300000\n  }\n}\n\nexport default usePerformanceManager","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/usePersistentRef.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[997,1000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[997,1000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1039,1042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1039,1042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1339,1342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1339,1342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2664,2667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2664,2667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TASK-1215: Tauri-Aware Persistent Ref\n *\n * Provides a reactive ref that reliably persists across app restarts in both\n * browser (localStorage) and Tauri (plugin-store + localStorage).\n *\n * Problem: Tauri's WebKitGTK WebView doesn't reliably flush localStorage\n * to disk on app close (BUG-339). This causes UI preferences to be lost\n * on restart.\n *\n * Solution: Dual-write architecture:\n * - localStorage: Used for sync reactive access (VueUse useStorage)\n * - Tauri plugin-store: Used for reliable disk persistence (async)\n *\n * Flow:\n * 1. On app startup (before mount): preloadTauriUiState() loads Tauri store\n *    values into localStorage so useStorage picks up correct initial values\n * 2. usePersistentRef() wraps useStorage + adds Tauri store watcher\n * 3. On value change: writes to both localStorage (sync) and Tauri store (async)\n */\n\nimport { useStorage, type RemovableRef } from '@vueuse/core'\nimport { watch } from 'vue'\n\n// Tauri store singleton\nlet tauriStoreInstance: any = null\nlet tauriStorePromise: Promise<any> | null = null\n\nconst STORE_FILENAME = 'ui-preferences.json'\n\n/**\n * Check if we're running in Tauri\n */\nfunction isTauriEnv(): boolean {\n  return typeof window !== 'undefined' && '__TAURI__' in window\n}\n\n/**\n * Get or create the Tauri store singleton\n */\nasync function getTauriStore(): Promise<any | null> {\n  if (!isTauriEnv()) return null\n  if (tauriStoreInstance) return tauriStoreInstance\n\n  if (tauriStorePromise) return tauriStorePromise\n\n  tauriStorePromise = (async () => {\n    try {\n      const { load } = await import('@tauri-apps/plugin-store')\n      const store = await load(STORE_FILENAME, { defaults: {}, autoSave: false })\n      tauriStoreInstance = store\n      console.log('[PERSISTENT-REF] Tauri store loaded:', STORE_FILENAME)\n      return store\n    } catch (e) {\n      console.warn('[PERSISTENT-REF] Failed to load Tauri store:', e)\n      tauriStorePromise = null\n      return null\n    }\n  })()\n\n  return tauriStorePromise\n}\n\n/**\n * Preload Tauri store values into localStorage before Vue mounts.\n * Call this in main.ts BEFORE app.mount('#app').\n *\n * This ensures useStorage picks up the correct persisted values\n * from the Tauri native store on app startup.\n */\nexport async function preloadTauriUiState(): Promise<void> {\n  if (!isTauriEnv()) {\n    console.log('[PERSISTENT-REF] Not in Tauri, skipping preload')\n    return\n  }\n\n  try {\n    console.log('[PERSISTENT-REF] Preloading UI state from Tauri store...')\n    const store = await getTauriStore()\n    if (!store) {\n      console.warn('[PERSISTENT-REF] Tauri store not available for preload')\n      return\n    }\n\n    const entries: [string, any][] = await store.entries()\n    let restored = 0\n\n    console.log(`[PERSISTENT-REF] Tauri store has ${entries.length} entries`)\n\n    for (const [key, value] of entries) {\n      // useStorage serializes to JSON, so we need to match that format\n      localStorage.setItem(key, JSON.stringify(value))\n      restored++\n      console.log(`[PERSISTENT-REF] Restored: ${key} =`, value)\n    }\n\n    if (restored > 0) {\n      console.log(`[PERSISTENT-REF] Restored ${restored} UI preferences from Tauri store`)\n    } else {\n      console.log('[PERSISTENT-REF] No saved preferences found in Tauri store (first run?)')\n    }\n  } catch (e) {\n    console.warn('[PERSISTENT-REF] Failed to preload Tauri UI state:', e)\n  }\n}\n\n// Debounce timer for batch saves\nlet saveTimeout: ReturnType<typeof setTimeout> | null = null\nconst pendingKeys = new Set<string>()\n\n/**\n * Debounced save to Tauri store (batches rapid changes)\n */\nfunction scheduleTauriSave(key: string) {\n  pendingKeys.add(key)\n\n  if (saveTimeout) clearTimeout(saveTimeout)\n  saveTimeout = setTimeout(async () => {\n    const store = await getTauriStore()\n    if (!store) return\n\n    try {\n      await store.save()\n      console.log(`[PERSISTENT-REF] Flushed ${pendingKeys.size} keys to disk:`, [...pendingKeys])\n      pendingKeys.clear()\n    } catch (e) {\n      console.warn('[PERSISTENT-REF] Failed to save Tauri store:', e)\n    }\n  }, 500) // 500ms debounce for batch disk writes\n}\n\n/**\n * Exposed utilities for use by taskPersistence.ts and other manual\n * localStorage users that need Tauri dual-write support.\n */\nexport { getTauriStore, isTauriEnv, scheduleTauriSave }\n\n/**\n * Create a persistent reactive ref that survives app restarts in both\n * browser and Tauri environments.\n *\n * Usage: const myPref = usePersistentRef<boolean>('flowstate:my-pref', false)\n *\n * @param key - Storage key (use flowstate: prefix for new keys)\n * @param defaultValue - Default value if nothing persisted\n * @param legacyKey - Optional old localStorage key to migrate from\n * @returns Reactive ref backed by localStorage + Tauri store\n */\nexport function usePersistentRef<T>(key: string, defaultValue: T, legacyKey?: string): RemovableRef<T> {\n  // Migrate from legacy localStorage key if it exists and new key doesn't\n  if (legacyKey) {\n    const legacyValue = localStorage.getItem(legacyKey)\n    if (legacyValue && !localStorage.getItem(key)) {\n      localStorage.setItem(key, legacyValue)\n      // Don't remove legacy key yet — other code might still read it\n      console.log(`[PERSISTENT-REF] Migrated ${legacyKey} → ${key}`)\n    }\n  }\n\n  // useStorage provides reactive localStorage binding\n  const storageRef = useStorage<T>(key, defaultValue)\n\n  // In Tauri, also persist to native store for reliability\n  if (isTauriEnv()) {\n    watch(storageRef, async (newValue) => {\n      const store = await getTauriStore()\n      if (!store) return\n\n      try {\n        await store.set(key, newValue)\n        scheduleTauriSave(key)\n      } catch (e) {\n        console.warn(`[PERSISTENT-REF] Failed to write ${key} to Tauri store:`, e)\n      }\n    }, { deep: true })\n  }\n\n  return storageRef\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/usePowerKeywords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useProgressiveDisclosure.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useQuickCapture.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useQuickSort.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useQuickTasks.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":49,"column":21,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":49,"endColumn":36,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[1748,1749],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * FEATURE-1248: Quick Tasks — Pinned & Frequent Task Shortcuts\n *\n * Central composable for the Quick Tasks system:\n * - Pinned tasks: user-created shortcuts stored in `pinned_tasks` table\n * - Frequent tasks: auto-detected from `completedPomodoros` on active tasks\n */\n\nimport { ref, computed, watch } from 'vue'\nimport { useAuthStore } from '@/stores/auth'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport type { PinnedTask, QuickTaskItem } from '@/types/quickTasks'\nimport type { Task } from '@/types/tasks'\n\nconst pinnedTasks = ref<PinnedTask[]>([])\nconst isLoading = ref(false)\n\nexport function useQuickTasks() {\n    const authStore = useAuthStore()\n    const taskStore = useTaskStore()\n    const timerStore = useTimerStore()\n    const db = useSupabaseDatabase()\n\n    // --- Pinned Tasks (from Supabase) ---\n\n    const loadPinnedTasks = async () => {\n        if (!authStore.isAuthenticated) {\n            pinnedTasks.value = []\n            return\n        }\n        isLoading.value = true\n        try {\n            pinnedTasks.value = await db.fetchPinnedTasks()\n        } catch (e) {\n            console.error('[QUICK-TASKS] Failed to load pinned tasks:', e)\n        } finally {\n            isLoading.value = false\n        }\n    }\n\n    const pinTask = async (title: string, opts?: { description?: string; projectId?: string | null; priority?: string | null }) => {\n        if (!authStore.isAuthenticated) return\n\n        const maxOrder = pinnedTasks.value.reduce((max, p) => Math.max(max, p.sortOrder), -1)\n        const newPin: PinnedTask = {\n            id: crypto.randomUUID(),\n            userId: authStore.user!.id,\n            title,\n            description: opts?.description || '',\n            projectId: opts?.projectId || null,\n            priority: opts?.priority || null,\n            sortOrder: maxOrder + 1,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        }\n\n        // Optimistic update\n        pinnedTasks.value = [...pinnedTasks.value, newPin]\n\n        try {\n            await db.savePinnedTask(newPin)\n        } catch (e) {\n            console.error('[QUICK-TASKS] Failed to save pin:', e)\n            // Rollback\n            pinnedTasks.value = pinnedTasks.value.filter(p => p.id !== newPin.id)\n        }\n    }\n\n    const unpinTask = async (pinId: string) => {\n        const backup = [...pinnedTasks.value]\n\n        // Optimistic update\n        pinnedTasks.value = pinnedTasks.value.filter(p => p.id !== pinId)\n\n        try {\n            await db.deletePinnedTask(pinId)\n        } catch (e) {\n            console.error('[QUICK-TASKS] Failed to delete pin:', e)\n            pinnedTasks.value = backup\n        }\n    }\n\n    const pinFromTask = async (task: Task) => {\n        // Check if already pinned by title (case-insensitive)\n        const already = pinnedTasks.value.some(\n            p => p.title.toLowerCase() === task.title.toLowerCase()\n        )\n        if (already) return\n\n        await pinTask(task.title, {\n            description: task.description,\n            projectId: task.projectId === 'uncategorized' ? null : task.projectId,\n            priority: task.priority\n        })\n    }\n\n    // --- Frequent Tasks (client-side from task store) ---\n\n    const frequentTasks = computed<Task[]>(() => {\n        return taskStore.tasks\n            .filter(t =>\n                t.status !== 'done' &&\n                !t._soft_deleted &&\n                (t.completedPomodoros || 0) > 0\n            )\n            .sort((a, b) => (b.completedPomodoros || 0) - (a.completedPomodoros || 0))\n            .slice(0, 10)\n    })\n\n    // --- Merged Quick Task Items ---\n\n    const quickTaskItems = computed<QuickTaskItem[]>(() => {\n        const items: QuickTaskItem[] = []\n        const seenTitles = new Set<string>()\n\n        // 1. Pinned tasks first (in sort order)\n        for (const pin of [...pinnedTasks.value].sort((a, b) => a.sortOrder - b.sortOrder)) {\n            const titleLower = pin.title.toLowerCase()\n            seenTitles.add(titleLower)\n\n            const project = pin.projectId ? taskStore.getProjectById(pin.projectId) : null\n            const projectColor = project?.color\n                ? (Array.isArray(project.color) ? project.color[0] : project.color)\n                : null\n\n            items.push({\n                key: `pin-${pin.id}`,\n                type: 'pinned',\n                title: pin.title,\n                sourceId: pin.id,\n                projectId: pin.projectId,\n                projectName: project?.name || null,\n                projectColor,\n                priority: pin.priority,\n                frequency: 0,\n                isPinned: true\n            })\n        }\n\n        // 2. Frequent tasks (deduplicated by title)\n        for (const task of frequentTasks.value) {\n            const titleLower = task.title.toLowerCase()\n            if (seenTitles.has(titleLower)) continue\n            seenTitles.add(titleLower)\n\n            const project = task.projectId && task.projectId !== 'uncategorized'\n                ? taskStore.getProjectById(task.projectId)\n                : null\n            const freqProjectColor = project?.color\n                ? (Array.isArray(project.color) ? project.color[0] : project.color)\n                : null\n\n            const isPinned = pinnedTasks.value.some(\n                p => p.title.toLowerCase() === titleLower\n            )\n\n            items.push({\n                key: `freq-${task.id}`,\n                type: 'frequent',\n                title: task.title,\n                sourceId: task.id,\n                projectId: task.projectId === 'uncategorized' ? null : task.projectId,\n                projectName: project?.name || null,\n                projectColor: freqProjectColor,\n                priority: task.priority,\n                frequency: task.completedPomodoros || 0,\n                isPinned\n            })\n        }\n\n        return items\n    })\n\n    // --- Actions ---\n\n    /**\n     * Select a quick task and start the timer.\n     * For pinned tasks: finds matching active task by title, or creates a new one.\n     * For frequent tasks: uses the task directly.\n     */\n    const selectAndStartTimer = async (item: QuickTaskItem) => {\n        let taskId: string\n\n        if (item.type === 'frequent') {\n            taskId = item.sourceId\n        } else {\n            // Pinned: find matching active task by title (case-insensitive)\n            const match = taskStore.tasks.find(\n                t => t.title.toLowerCase() === item.title.toLowerCase() &&\n                    t.status !== 'done' &&\n                    !t._soft_deleted\n            )\n\n            if (match) {\n                taskId = match.id\n            } else {\n                // Create a new task from the pin template\n                const newTask = await taskStore.createTask({\n                    title: item.title,\n                    description: '',\n                    projectId: item.projectId || 'uncategorized',\n                    priority: item.priority as Task['priority'] || null,\n                    status: 'in_progress'\n                })\n                taskId = newTask?.id || item.title\n            }\n        }\n\n        await timerStore.startTimer(taskId)\n    }\n\n    // --- Auth Watcher ---\n\n    watch(\n        () => authStore.isAuthenticated,\n        (isAuth) => {\n            if (isAuth) {\n                loadPinnedTasks()\n            } else {\n                pinnedTasks.value = []\n            }\n        },\n        { immediate: true }\n    )\n\n    return {\n        pinnedTasks: computed(() => pinnedTasks.value),\n        frequentTasks,\n        quickTaskItems,\n        isLoading: computed(() => isLoading.value),\n        loadPinnedTasks,\n        pinTask,\n        unpinTask,\n        pinFromTask,\n        selectAndStartTimer\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useReactiveDate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useRenderOptimization.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6478,6481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6478,6481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6506,6509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6506,6509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Render Optimization Composable\n * Optimizes Vue component rendering, reduces unnecessary re-renders\n */\n\nimport { ref, computed, onMounted, onUnmounted, nextTick, shallowRef, triggerRef } from 'vue'\nimport { useThrottleFn, useDebounceFn } from '@vueuse/core'\n\nexport interface RenderOptimizationOptions {\n  enableShallowReactive?: boolean\n  enableVirtualScrolling?: boolean\n  enableLazyLoading?: boolean\n  throttleRenderEvents?: boolean\n  enableRenderBatching?: boolean\n  batchSize?: number\n  batchDelay?: number\n  enableComponentCaching?: boolean\n  maxComponentCache?: number\n}\n\nexport interface RenderMetrics {\n  totalRenders: number\n  componentRenders: Map<string, number>\n  averageRenderTime: number\n  slowRenders: number\n  skippedRenders: number\n  cachedComponents: number\n  memoryUsage: number\n  lastRenderTime: number\n}\n\nexport function useRenderOptimization(options: RenderOptimizationOptions = {}) {\n  const {\n    enableShallowReactive = true,\n    enableVirtualScrolling: _enableVirtualScrolling = true,\n    enableLazyLoading = true,\n    throttleRenderEvents = true,\n    enableRenderBatching = true,\n    batchSize = 20,\n    batchDelay = 16, // ~60fps\n    enableComponentCaching = true,\n    maxComponentCache = 50\n  } = options\n\n  // Reactive state\n  const renderMetrics = ref<RenderMetrics>({\n    totalRenders: 0,\n    componentRenders: new Map(),\n    averageRenderTime: 0,\n    slowRenders: 0,\n    skippedRenders: 0,\n    cachedComponents: 0,\n    memoryUsage: 0,\n    lastRenderTime: 0\n  })\n\n  interface CachedComponent {\n    timestamp: number\n    ttl: number\n    component: unknown\n  }\n\n  const componentCache = ref<Map<string, CachedComponent>>(new Map())\n  const pendingRenders = ref<Set<() => void>>(new Set())\n  const isProcessingBatch = ref(false)\n  const renderQueue = ref<(() => void)[]>([])\n\n  // Performance monitoring\n  const performanceObserver = ref<PerformanceObserver | null>(null)\n  const renderTimes = ref<number[]>([])\n\n  // Throttled render function\n  const throttledRender = throttleRenderEvents\n    ? useThrottleFn((fn: () => void) => fn(), batchDelay)\n    : (fn: () => void) => fn()\n\n  // Debounced batch processor\n  const processRenderBatch = useDebounceFn(async () => {\n    if (renderQueue.value.length === 0 || isProcessingBatch.value) return\n\n    isProcessingBatch.value = true\n    const batch = renderQueue.value.splice(0, batchSize)\n\n    try {\n      // Process all renders in a single frame\n      await nextTick()\n\n      const startTime = performance.now()\n      batch.forEach(renderFn => {\n        try {\n          renderFn()\n        } catch (error) {\n          console.error('Render batch item failed:', error)\n        }\n      })\n\n      const renderTime = performance.now() - startTime\n      renderTimes.value.push(renderTime)\n\n      // Keep only recent render times\n      if (renderTimes.value.length > 100) {\n        renderTimes.value = renderTimes.value.slice(-50)\n      }\n\n      // Update metrics\n      renderMetrics.value.totalRenders += batch.length\n      renderMetrics.value.averageRenderTime = renderTimes.value.reduce((a, b) => a + b, 0) / renderTimes.value.length\n      renderMetrics.value.lastRenderTime = renderTime\n\n      // Mark slow renders\n      if (renderTime > 16) { // More than 60fps threshold\n        renderMetrics.value.slowRenders++\n      }\n\n    } finally {\n      isProcessingBatch.value = false\n    }\n  }, batchDelay)\n\n  // Optimized render function\n  const optimizedRender = (renderFn: () => void, componentId?: string) => {\n    const startTime = performance.now()\n\n    const wrappedRender = () => {\n      try {\n        renderFn()\n\n        // Track component renders\n        if (componentId) {\n          const currentCount = renderMetrics.value.componentRenders.get(componentId) || 0\n          renderMetrics.value.componentRenders.set(componentId, currentCount + 1)\n        }\n\n      } catch (error) {\n        console.error(`Render failed for component ${componentId}:`, error)\n      }\n    }\n\n    if (enableRenderBatching) {\n      renderQueue.value.push(wrappedRender)\n      processRenderBatch()\n    } else {\n      throttledRender(wrappedRender)\n    }\n\n    const renderTime = performance.now() - startTime\n    renderMetrics.value.lastRenderTime = renderTime\n  }\n\n  // Shallow reactive wrapper for large arrays/objects\n  const createShallowReactive = <T>(value: T): { value: T; trigger: () => void } => {\n    if (!enableShallowReactive) {\n      return { value, trigger: () => { } }\n    }\n\n    const shallowRefValue = shallowRef(value)\n\n    return {\n      get value() {\n        return shallowRefValue.value\n      },\n      set value(newValue) {\n        shallowRefValue.value = newValue\n      },\n      trigger: () => triggerRef(shallowRefValue)\n    }\n  }\n\n  // Component caching\n  const cacheComponent = (key: string, component: unknown, ttl: number = 300000) => {\n    if (!enableComponentCaching) return\n\n    // Clear old entries if cache is full\n    if (componentCache.value.size >= maxComponentCache) {\n      const entries = Array.from(componentCache.value.entries())\n      // Remove oldest 25% of entries\n      const toRemove = Math.floor(entries.length * 0.25)\n      for (let i = 0; i < toRemove; i++) {\n        componentCache.value.delete(entries[i][0])\n      }\n    }\n\n    componentCache.value.set(key, {\n      component,\n      timestamp: Date.now(),\n      ttl\n    })\n\n    renderMetrics.value.cachedComponents = componentCache.value.size\n  }\n\n  const getCachedComponent = (key: string): unknown => {\n    if (!enableComponentCaching) return null\n\n    const cached = componentCache.value.get(key)\n    if (!cached) return null\n\n    // Check TTL\n    if (Date.now() - cached.timestamp > cached.ttl) {\n      componentCache.value.delete(key)\n      renderMetrics.value.cachedComponents = componentCache.value.size\n      return null\n    }\n\n    renderMetrics.value.skippedRenders++\n    return cached.component\n  }\n\n  // Conditional render helper\n  const shouldRender = (condition: () => boolean, lastValue?: boolean): boolean => {\n    const current = condition()\n    const shouldUpdate = lastValue !== current\n    return shouldUpdate\n  }\n\n  // Memoized component factory\n  const createMemoizedComponent = (\n    componentFactory: () => unknown,\n    dependencyKeys: string[],\n    componentId: string\n  ) => {\n    let cachedComponent: unknown = null\n    let lastDependencyValues: unknown[] = []\n\n    return () => {\n      const currentDependencyValues = dependencyKeys.map(key => {\n        try {\n          return (window as any)[key] || (globalThis as any)[key]\n        } catch {\n          return undefined\n        }\n      })\n\n      const dependenciesChanged = !lastDependencyValues.every(\n        (value, index) => value === currentDependencyValues[index]\n      )\n\n      if (!cachedComponent || dependenciesChanged) {\n        cachedComponent = componentFactory()\n        lastDependencyValues = currentDependencyValues\n\n        renderMetrics.value.componentRenders.set(\n          componentId,\n          (renderMetrics.value.componentRenders.get(componentId) || 0) + 1\n        )\n      } else {\n        renderMetrics.value.skippedRenders++\n      }\n\n      return cachedComponent\n    }\n  }\n\n  // Lazy loading helper\n  const createLazyLoader = <T>(\n    loader: () => Promise<T>,\n    fallback?: T,\n    componentId?: string\n  ) => {\n    if (!enableLazyLoading) {\n      return { load: () => loader(), isLoaded: ref(true), data: ref(null) }\n    }\n\n    const isLoaded = ref(false)\n    const isLoading = ref(false)\n    const data = ref<T | null>(null)\n    const error = ref<Error | null>(null)\n\n    const load = async () => {\n      if (isLoaded.value || isLoading.value) return\n\n      isLoading.value = true\n      error.value = null\n\n      try {\n        const startTime = performance.now()\n        const result = await loader()\n        const loadTime = performance.now() - startTime\n\n        data.value = result\n        isLoaded.value = true\n\n        if (componentId) {\n          console.log(`🚀 Lazy loaded ${componentId} in ${loadTime.toFixed(2)}ms`)\n        }\n\n      } catch (err) {\n        error.value = err as Error\n        console.error(`❌ Failed to lazy load component ${componentId}:`, err)\n\n        // Use fallback if provided\n        if (fallback !== undefined) {\n          data.value = fallback\n          isLoaded.value = true\n        }\n      } finally {\n        isLoading.value = false\n      }\n    }\n\n    return { load, isLoaded, isLoading, data, error }\n  }\n\n  // Performance monitoring setup\n  const setupPerformanceMonitoring = () => {\n    if ('PerformanceObserver' in window) {\n      performanceObserver.value = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'measure' && entry.name.includes('render')) {\n            renderTimes.value.push(entry.duration)\n          }\n        }\n      })\n\n      performanceObserver.value.observe({ entryTypes: ['measure'] })\n    }\n  }\n\n  // Memory monitoring\n  const updateMemoryUsage = () => {\n    const perf = performance as unknown as { memory?: { usedJSHeapSize: number } }\n    if (perf.memory) {\n      renderMetrics.value.memoryUsage = perf.memory.usedJSHeapSize\n    }\n  }\n\n  // Cleanup function\n  const cleanup = () => {\n    if (performanceObserver.value) {\n      performanceObserver.value.disconnect()\n    }\n\n    componentCache.value.clear()\n    renderQueue.value = []\n    pendingRenders.value.clear()\n    renderTimes.value = []\n\n    console.log('🧹 Render optimization cleanup completed')\n  }\n\n  // Performance metrics computed property\n  const performanceStats = computed(() => ({\n    ...renderMetrics.value,\n    renderEfficiency: renderMetrics.value.skippedRenders / (renderMetrics.value.totalRenders + renderMetrics.value.skippedRenders) || 0,\n    cacheHitRate: renderMetrics.value.cachedComponents / maxComponentCache,\n    averageRenderTime: renderMetrics.value.averageRenderTime,\n    isPerformant: renderMetrics.value.averageRenderTime < 16, // 60fps threshold\n    memoryEfficiency: renderMetrics.value.memoryUsage < 50 * 1024 * 1024 // 50MB threshold\n  }))\n\n  // Setup on mount\n  onMounted(() => {\n    setupPerformanceMonitoring()\n\n    // Monitor memory usage periodically\n    const memoryInterval = setInterval(updateMemoryUsage, 5000)\n\n    onUnmounted(() => {\n      clearInterval(memoryInterval)\n    })\n  })\n\n  // Cleanup on unmount\n  onUnmounted(cleanup)\n\n  return {\n    // Core optimization functions\n    optimizedRender,\n    createShallowReactive,\n    createMemoizedComponent,\n    createLazyLoader,\n\n    // Caching\n    cacheComponent,\n    getCachedComponent,\n\n    // Utilities\n    shouldRender,\n\n    // Performance monitoring\n    performanceStats,\n    renderMetrics,\n\n    // State\n    isProcessingBatch,\n    queueLength: computed(() => renderQueue.value.length),\n\n    // Cleanup\n    cleanup\n  }\n}\n\n// Global render optimization instance\nexport const globalRenderOptimizer = useRenderOptimization()\n\nexport default useRenderOptimization","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useSafeI18n.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[435,438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[435,438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Safe i18n composable that works in both main app and Storybook\n *\n * In Storybook, the global i18n scope may not be available due to how\n * Storybook creates multiple Vue app instances. This composable provides\n * a standalone translation function that doesn't depend on vue-i18n's\n * composition API, avoiding \"Unexpected return type in composer\" errors.\n */\nimport { ref, computed } from 'vue'\n\ntype Messages = Record<string, any>\n\n// Inline translations for auth components\n// This bypasses vue-i18n's message compiler which transforms JSON imports to AST objects\nconst messages: Record<string, Messages> = {\n  en: {\n    auth: {\n      displayName: 'Display Name',\n      displayNamePlaceholder: 'Enter your display name',\n      email: 'Email',\n      emailPlaceholder: 'Enter your email',\n      password: 'Password',\n      passwordPlaceholder: 'Enter your password',\n      confirmPassword: 'Confirm Password',\n      confirmPasswordPlaceholder: 'Confirm your password',\n      passwordMismatch: 'Passwords do not match',\n      createAccount: 'Create Account',\n      creatingAccount: 'Creating Account...',\n      or: 'or',\n      haveAccount: 'Already have an account?',\n      signIn: 'Sign In',\n      sending: 'Sending...',\n      sendResetLink: 'Send Reset Link',\n      backToLogin: 'Back to Login',\n      login: {\n        title: 'Sign In',\n        subtitle: 'Welcome back! Sign in to access your tasks',\n        email: 'Email',\n        emailPlaceholder: 'Enter your email',\n        password: 'Password',\n        passwordPlaceholder: 'Enter your password',\n        forgotPassword: 'Forgot password?',\n        or: 'or',\n        noAccount: \"Don't have an account?\",\n        signUp: 'Sign Up',\n        signingIn: 'Signing In...',\n        signIn: 'Sign In'\n      },\n      signup: {\n        title: 'Create Account',\n        subtitle: 'Join FlowState to boost your productivity'\n      },\n      resetPassword: {\n        title: 'Reset Password',\n        subtitle: 'Enter your email to receive a password reset link',\n        emailSent: 'Email Sent!',\n        checkEmail: 'Check your inbox for the password reset link',\n        didntReceive: \"Didn't receive the email?\",\n        resend: 'Resend'\n      }\n    }\n  },\n  he: {\n    auth: {\n      displayName: 'שם תצוגה',\n      displayNamePlaceholder: 'הזן את שם התצוגה שלך',\n      email: 'אימייל',\n      emailPlaceholder: 'הזן את האימייל שלך',\n      password: 'סיסמה',\n      passwordPlaceholder: 'הזן את הסיסמה שלך',\n      confirmPassword: 'אימות סיסמה',\n      confirmPasswordPlaceholder: 'אמת את הסיסמה שלך',\n      passwordMismatch: 'הסיסמאות לא תואמות',\n      createAccount: 'צור חשבון',\n      creatingAccount: 'יוצר חשבון...',\n      or: 'או',\n      haveAccount: 'כבר יש לך חשבון?',\n      signIn: 'התחבר',\n      sending: 'שולח...',\n      sendResetLink: 'שלח קישור לאיפוס',\n      backToLogin: 'חזור להתחברות',\n      login: {\n        title: 'התחברות',\n        subtitle: 'ברוך שובך! התחבר כדי לגשת למשימות שלך',\n        email: 'אימייל',\n        emailPlaceholder: 'הזן את האימייל שלך',\n        password: 'סיסמה',\n        passwordPlaceholder: 'הזן את הסיסמה שלך',\n        forgotPassword: 'שכחת סיסמה?',\n        or: 'או',\n        noAccount: 'אין לך חשבון?',\n        signUp: 'הירשם',\n        signingIn: 'מתחבר...',\n        signIn: 'התחבר'\n      },\n      signup: {\n        title: 'צור חשבון',\n        subtitle: 'הצטרף ל-FlowState כדי להגביר את הפרודוקטיביות שלך'\n      },\n      resetPassword: {\n        title: 'איפוס סיסמה',\n        subtitle: 'הזן את האימייל שלך כדי לקבל קישור לאיפוס סיסמה',\n        emailSent: 'האימייל נשלח!',\n        checkEmail: 'בדוק את תיבת הדואר שלך לקישור לאיפוס סיסמה',\n        didntReceive: 'לא קיבלת את האימייל?',\n        resend: 'שלח שוב'\n      }\n    }\n  }\n}\n\n// Shared reactive locale - defaults to 'en', syncs with global if available\nconst currentLocale = ref('en')\n\n/**\n * Get nested value from object using dot notation\n */\nfunction getNestedValue(obj: Messages, path: string): string {\n  const value = path.split('.').reduce((acc, key) => acc?.[key], obj)\n  return typeof value === 'string' ? value : path\n}\n\n/**\n * Safe i18n hook that works in both main app and Storybook\n *\n * Uses a standalone implementation that doesn't rely on vue-i18n's\n * composition API, which fails in Storybook's multi-app environment.\n */\nexport function useSafeI18n() {\n  const locale = computed({\n    get: () => currentLocale.value,\n    set: (val: string) => { currentLocale.value = val }\n  })\n\n  /**\n   * Translation function - returns translated string or key if not found\n   */\n  function t(key: string, params?: Record<string, string | number>): string {\n    const msgLocale = messages[currentLocale.value] || messages.en\n    let translation = getNestedValue(msgLocale, key)\n\n    // Handle interpolation if params provided\n    if (params && translation !== key) {\n      Object.entries(params).forEach(([paramKey, value]) => {\n        translation = translation.replace(new RegExp(`\\\\{${paramKey}\\\\}`, 'g'), String(value))\n      })\n    }\n\n    return translation\n  }\n\n  return { t, locale }\n}\n\n/**\n * Set the locale for useSafeI18n (can be called from app initialization)\n */\nexport function setSafeI18nLocale(newLocale: string) {\n  if (messages[newLocale]) {\n    currentLocale.value = newLocale\n  }\n}\n\nexport default useSafeI18n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useSmartViews.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useStaticResourceCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useSupabaseDatabase.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7836,7839],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7836,7839],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7980,7983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7980,7983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":463,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":463,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19360,19363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19360,19363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":655,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":655,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27050,27053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27050,27053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":819,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":819,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33202,33205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33202,33205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":822,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":822,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33441,33444],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33441,33444],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":936,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":936,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38262,38265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38262,38265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":939,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":939,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38480,38483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38480,38483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":970,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":970,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'count' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":970,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":970,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1049,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1049,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42684,42687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42684,42687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1072,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1072,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43534,43537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43534,43537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1095,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1095,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44384,44387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44384,44387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1116,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1116,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'count' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1116,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":1116,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1169,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1169,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47459,47462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47459,47462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1237,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":1237,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'count' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1237,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":1237,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1542,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1542,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[62863,62866],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[62863,62866],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'heartbeatInterval' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1545,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":1545,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1545,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1545,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[62973,62976],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[62973,62976],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1555,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1555,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[63413,63416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[63413,63416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1557,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1557,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[63560,63563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[63560,63563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1582,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1582,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[64584,64587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[64584,64587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1592,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1592,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[65241,65244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[65241,65244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1605,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1605,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[66105,66108],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[66105,66108],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1618,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1618,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[66811,66814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[66811,66814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1629,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1629,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[67376,67379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[67376,67379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1641,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1641,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[68032,68035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[68032,68035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1641,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1641,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[68042,68045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[68042,68045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1735,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1735,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[73693,73696],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[73693,73696],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1974,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1974,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[83665,83668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[83665,83668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10676,10679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10676,10679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":7,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\nimport { supabase } from '@/services/auth/supabase'\nimport { useAuthStore } from '@/stores/auth'\nimport type { Task, Project } from '@/types/tasks'\nimport type { ScheduledNotification } from '@/types/recurrence'\nimport type { PinnedTask } from '@/types/quickTasks'\nimport type { CanvasGroup } from '@/types/canvas'\nimport type { AppSettings } from '@/stores/settings'\nimport type { PomodoroSession } from '@/stores/timer'\nimport type { SessionSummary } from '@/stores/quickSort'\nimport {\n    toSupabaseTask, fromSupabaseTask,\n    toSupabaseProject, fromSupabaseProject,\n    toSupabaseGroup, fromSupabaseGroup,\n    toSupabaseNotification, fromSupabaseNotification,\n    toSupabaseTimerSession, fromSupabaseTimerSession,\n    toSupabaseUserSettings, fromSupabaseUserSettings,\n    toSupabaseQuickSortSession, fromSupabaseQuickSortSession,\n    toSupabasePinnedTask, fromSupabasePinnedTask,\n    toSupabaseWorkProfile, fromSupabaseWorkProfile,\n    type SupabaseTask, type SupabaseProject, type SupabaseGroup,\n    type SupabaseNotification, type SupabaseTimerSession, type SupabaseUserSettings, type SupabaseQuickSortSession,\n    type SupabasePinnedTask, type SupabaseWorkProfile\n} from '@/utils/supabaseMappers'\nimport { errorHandler, ErrorSeverity, ErrorCategory } from '@/utils/errorHandler'\nimport { UNCATEGORIZED_PROJECT_ID } from '@/stores/tasks/taskOperations'\n\n// TASK-1060: SWR (Stale-While-Revalidate) Cache for database queries\n// Returns cached data immediately while fetching fresh data in background\n// Invalidated on realtime events to ensure consistency\n// BUG-1056: Cache is also invalidated on auth state changes to prevent stale guest data\ninterface SWRCacheEntry<T> {\n    data: T\n    timestamp: number\n    promise?: Promise<T>  // Deduplication: reuse in-flight requests\n}\n\nclass SWRCache {\n    private cache = new Map<string, SWRCacheEntry<unknown>>()\n    // TASK-1083: Reduced stale time from 30s to 3s to prevent position drift between devices\n    // Old value caused stale positions to be returned for up to 30 seconds after another device updated\n    private readonly DEFAULT_STALE_TIME = 3 * 1000  // 3s before considered stale (was 30s)\n    private readonly DEFAULT_CACHE_TIME = 60 * 1000  // 1min max cache (was 5min)\n    private lastUserId: string | null = null  // BUG-1056: Track user for auth change detection\n\n    /**\n     * Get data from cache or fetch if missing/expired\n     * SWR pattern: returns stale data immediately, refreshes in background\n     */\n    async getOrFetch<T>(\n        key: string,\n        fetcher: () => Promise<T>,\n        options?: { staleTime?: number; cacheTime?: number }\n    ): Promise<T> {\n        const staleTime = options?.staleTime ?? this.DEFAULT_STALE_TIME\n        const cacheTime = options?.cacheTime ?? this.DEFAULT_CACHE_TIME\n        const now = Date.now()\n        const entry = this.cache.get(key) as SWRCacheEntry<T> | undefined\n\n        // Case 1: No cache - fetch and wait\n        if (!entry) {\n            return this.fetchAndCache(key, fetcher)\n        }\n\n        // Case 2: Cache expired - fetch and wait\n        const age = now - entry.timestamp\n        if (age > cacheTime) {\n            this.cache.delete(key)\n            return this.fetchAndCache(key, fetcher)\n        }\n\n        // Case 3: Cache fresh - return immediately\n        if (age < staleTime) {\n            return entry.data\n        }\n\n        // Case 4: Cache stale but valid - return cached, refresh in background\n        // Deduplicate: if refresh already in progress, don't start another\n        if (!entry.promise) {\n            entry.promise = fetcher()\n                .then(data => {\n                    this.cache.set(key, { data, timestamp: Date.now() })\n                    return data\n                })\n                .catch(err => {\n                    console.warn(`[SWR] Background refresh failed for ${key}:`, err)\n                    return entry.data  // Keep stale data on error\n                })\n                .finally(() => {\n                    const current = this.cache.get(key) as SWRCacheEntry<T> | undefined\n                    if (current) delete current.promise\n                })\n        }\n\n        return entry.data\n    }\n\n    private async fetchAndCache<T>(key: string, fetcher: () => Promise<T>): Promise<T> {\n        // Deduplicate concurrent requests for same key\n        const existing = this.cache.get(key) as SWRCacheEntry<T> | undefined\n        if (existing?.promise) {\n            return existing.promise\n        }\n\n        const promise = fetcher()\n        this.cache.set(key, { data: undefined as T, timestamp: 0, promise })\n\n        try {\n            const data = await promise\n            this.cache.set(key, { data, timestamp: Date.now() })\n            return data\n        } catch (err) {\n            this.cache.delete(key)\n            throw err\n        }\n    }\n\n    /** Invalidate specific cache key (call on realtime events) */\n    invalidate(key: string): void {\n        this.cache.delete(key)\n    }\n\n    /** Invalidate all keys matching prefix (e.g., 'tasks:' for all task queries) */\n    invalidatePrefix(prefix: string): void {\n        for (const key of this.cache.keys()) {\n            if (key.startsWith(prefix)) {\n                this.cache.delete(key)\n            }\n        }\n    }\n\n    /** Clear entire cache */\n    clear(): void {\n        this.cache.clear()\n    }\n\n    /**\n     * BUG-1056: Check if user changed and clear cache if so\n     * This prevents returning stale guest data after auth\n     */\n    checkUserChange(currentUserId: string | null): boolean {\n        if (this.lastUserId !== currentUserId) {\n            console.log(`🔄 [SWR] User changed: ${this.lastUserId?.slice(0, 8) || 'guest'} → ${currentUserId?.slice(0, 8) || 'guest'}, clearing cache`)\n            this.clear()\n            this.lastUserId = currentUserId\n            return true\n        }\n        return false\n    }\n\n    /** Get cache stats for debugging */\n    getStats(): { size: number; keys: string[] } {\n        return {\n            size: this.cache.size,\n            keys: Array.from(this.cache.keys())\n        }\n    }\n}\n\n// Global cache instance (shared across all useSupabaseDatabase calls)\nconst swrCache = new SWRCache()\n\n// Export for realtime event handlers to invalidate cache\nexport const invalidateCache = {\n    tasks: () => swrCache.invalidatePrefix('tasks:'),\n    projects: () => swrCache.invalidatePrefix('projects:'),\n    groups: () => swrCache.invalidatePrefix('groups:'),\n    pinnedTasks: () => swrCache.invalidatePrefix('pinnedTasks:'),\n    all: () => swrCache.clear(),\n    // BUG-1056: Expose user change check for auth state changes\n    onAuthChange: (userId: string | null) => swrCache.checkUserChange(userId)\n}\n\n// FORCE_HMR_UPDATE: Clearing stale cache for position_version schema\n// App Types are defined locally or imported for convenience\nexport interface TimerSettings {\n    workDuration: number\n    shortBreakDuration: number\n    longBreakDuration: number\n    autoStartBreaks: boolean\n    autoStartPomodoros: boolean\n    playNotificationSounds: boolean\n}\n\n// Define DatabaseDependencies for the new function signature\ntype DatabaseDependencies = Record<string, unknown>\n\nexport function useSupabaseDatabase(_deps: DatabaseDependencies = {}) {\n\n    const authStore = useAuthStore()\n    const isSyncing = ref(false)\n    const lastSyncError = ref<string | null>(null)\n\n    // -- Helpers --\n\n    const getUserIdSafe = (): string | null => {\n        return authStore.user?.id || null\n    }\n\n    /**\n     * Helper to execute Supabase operations with transient error retries (e.g. clock skew, 401/403 restarts)\n     * TASK-329: Added exponential backoff and auth resilience\n     */\n    const withRetry = async <T>(operation: () => Promise<T>, context: string, maxRetries = 3): Promise<T> => {\n        let lastErr: any = null\n\n        for (let i = 0; i < maxRetries; i++) {\n            try {\n                return await operation()\n            } catch (err: any) {\n                lastErr = err\n                const message = err?.message || String(err)\n                const status = err?.status || err?.code\n\n                // BUG-352: Faster backoff for mobile: 500ms, 1s, 2s (was 1s, 2s, 4s)\n                const delay = Math.pow(2, i) * 500\n\n                // 1. Clock Skew (JWT issued at future)\n                if (message.includes('JWT issued at future')) {\n                    console.warn(`🕒 [CLOCK-SKEW] ${context} failed. Retrying in ${delay}ms... (Attempt ${i + 1}/${maxRetries})`)\n                    await new Promise(resolve => setTimeout(resolve, delay))\n                    continue\n                }\n\n                // 2. Auth Errors (401/403) - Can happen if GoTrue/PostgREST is restarting or cache is stale\n                if (status === 401 || status === 403 || status === '401' || status === '403' || message.includes('JWKS') || message.includes('invalid_token')) {\n                    console.warn(`🔐 [AUTH-RETRY] ${context} failed (${status}). Retrying with backoff in ${delay}ms... (Attempt ${i + 1}/${maxRetries})`)\n                    await new Promise(resolve => setTimeout(resolve, delay))\n                    continue\n                }\n\n                // 3. Network / Connection / Timeout Errors\n                // BUG-352: Also catch AbortError (from fetch timeout) and timeout strings\n                // BUG-1311: Firefox/Zen reports \"NetworkError\" (no space), Chrome reports \"Network Error\" (space)\n                const lowerMsg = message.toLowerCase()\n                if (message.includes('Failed to fetch') || lowerMsg.includes('networkerror') || message.includes('Network Error') || message.includes('Service Unavailable') || message.includes('AbortError') || lowerMsg.includes('timeout') || message.includes('aborted')) {\n                    console.warn(`🌐 [NETWORK-RETRY] ${context} failed. Retrying in ${delay}ms... (Attempt ${i + 1}/${maxRetries})`)\n                    await new Promise(resolve => setTimeout(resolve, delay))\n                    continue\n                }\n\n                // For other errors, don't retry immediately unless they look transient\n                throw err\n            }\n        }\n\n        throw lastErr\n    }\n\n    const handleError = (error: unknown, context: string) => {\n        // Handle Supabase/Postgrest errors which are objects but not Error instances\n        let message = 'Unknown error'\n        let details = ''\n\n        if (error instanceof Error) {\n            message = error.message\n        } else if (typeof error === 'object' && error !== null) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const e = error as any\n            message = e.message || String(error)\n            details = e.details || e.hint || ''\n        } else {\n            message = String(error)\n        }\n\n        const finalMessage = details ? `${message} (${details})` : message\n        const err = error instanceof Error ? error : new Error(finalMessage)\n\n        // BUG-352: Suppress notifications for transient network errors (common on mobile WiFi/cell handoffs)\n        const lowerMsg = message.toLowerCase()\n        const isTransientNetwork = message.includes('Failed to fetch') ||\n            lowerMsg.includes('networkerror') ||\n            message.includes('Network Error') ||\n            message.includes('AbortError') ||\n            lowerMsg.includes('timeout') ||\n            message.includes('aborted')\n\n        errorHandler.report({\n            error: err,\n            message: `Sync Error(${context}): ${finalMessage}`,\n            severity: isTransientNetwork ? ErrorSeverity.WARNING : ErrorSeverity.ERROR,\n            category: ErrorCategory.SYNC,\n            showNotification: !isTransientNetwork\n        })\n        lastSyncError.value = finalMessage\n    }\n\n    // -- Projects --\n\n    const fetchProjects = async (): Promise<Project[]> => {\n        // TASK-1060: Ensure auth is initialized before fetching\n        if (!authStore.isInitialized) {\n            console.log('🔄 [TASK-1060] Auth not initialized, waiting...')\n            await authStore.initialize()\n        }\n\n        const userId = getUserIdSafe()\n        // BUG-1056: Check if user changed since last fetch - invalidates cache if so\n        swrCache.checkUserChange(userId)\n        const cacheKey = `projects:${userId || 'guest'}`\n\n        return swrCache.getOrFetch(cacheKey, async () => {\n            try {\n                return await withRetry(async () => {\n                    const { data, error } = await supabase\n                        .from('projects')\n                        .select('*')\n                        .order('created_at', { ascending: true })\n\n                    if (error) throw error\n                    if (!data) return []\n\n                    return (data as SupabaseProject[]).map(fromSupabaseProject)\n                }, 'fetchProjects')\n            } catch (e: unknown) {\n                handleError(e, 'fetchProjects')\n                return []\n            }\n        })\n    }\n\n    const saveProject = async (project: Project): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveProject - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = toSupabaseProject(project, userId)\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('projects').upsert(payload, { onConflict: 'id' })\n                if (error) throw error\n            }, 'saveProject')\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveProject')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const saveProjects = async (projects: Project[]): Promise<void> => {\n        if (projects.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveProjects - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = projects.map(p => toSupabaseProject(p, userId))\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                // BUG-171 FIX: Add .select() and verify data.length to detect RLS partial write failures\n                const { data, error } = await supabase.from('projects').upsert(payload, { onConflict: 'id' }).select('id')\n                if (error) throw error\n                if (!data || data.length !== payload.length) {\n                    const writtenCount = data?.length ?? 0\n                    const failedCount = payload.length - writtenCount\n                    throw new Error(`RLS blocked ${failedCount} of ${payload.length} project writes (only ${writtenCount} succeeded)`)\n                }\n            }, 'saveProjects')\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveProjects')\n            throw e // BUG-171: Re-throw so callers know the save failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const deleteProject = async (projectId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase\n                    .from('projects')\n                    .update({ is_deleted: true, deleted_at: new Date().toISOString() })\n                    .eq('id', projectId)\n                if (error) throw error\n            }, 'deleteProject')\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'deleteProject')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const restoreProject = async (projectId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase\n                    .from('projects')\n                    .update({ is_deleted: false, deleted_at: null })\n                    .eq('id', projectId)\n                if (error) throw error\n            }, 'restoreProject')\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'restoreProject')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // TASK-317: Record tombstone for permanent deletions\n    // Tombstones prevent zombie data resurrection during backup restore\n    // TASK-344: Task tombstones are now permanent (expires_at = NULL)\n    const recordTombstone = async (entityType: 'task' | 'group' | 'project', entityId: string): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping recordTombstone - not authenticated')\n            return\n        }\n        try {\n            // TASK-344: Task tombstones are permanent (no expiry), others expire in 90 days\n            const expiresAt = entityType === 'task'\n                ? null  // Permanent for tasks\n                : new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString()  // 90 days for others\n\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('tombstones').upsert({\n                    user_id: userId,\n                    entity_type: entityType,\n                    entity_id: entityId,\n                    deleted_at: new Date().toISOString(),\n                    expires_at: expiresAt\n                }, { onConflict: 'entity_type,entity_id,user_id' })\n                if (error) {\n                    console.warn(`[TASK-317] Failed to record tombstone for ${entityType}:${entityId}:`, error.message)\n                    throw error\n                }\n            }, 'recordTombstone')\n            console.log(`🪦 [TOMBSTONE] Recorded permanent deletion: ${entityType}:${entityId} (expires: ${expiresAt || 'never'})`)\n        } catch (e: unknown) {\n            // Non-fatal: tombstone recording failure shouldn't block deletion\n            console.warn(`[TASK-317] Tombstone recording error:`, e)\n        }\n    }\n\n    // TASK-317: Fetch tombstones for restore filtering\n    const fetchTombstones = async (): Promise<{ entityType: string; entityId: string }[]> => {\n        const userId = getUserIdSafe()\n        if (!userId) return []\n        try {\n            // BUG-1311: Wrap in withRetry for network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('tombstones')\n                    .select('entity_type, entity_id')\n                    .eq('user_id', userId)\n                if (error) throw error\n                return data?.map((t: any) => ({ entityType: t.entity_type, entityId: t.entity_id })) || []\n            }, 'fetchTombstones')\n        } catch (e: unknown) {\n            console.error('[TASK-317] Failed to fetch tombstones:', e)\n            return []\n        }\n    }\n\n    // =============================================================================\n    // TASK-344: Immutable Task ID System\n    // =============================================================================\n    // Types are exported at the bottom of this file\n\n    /**\n     * TASK-344: Safely create a task, checking for existing IDs and tombstones.\n     * Returns a result object instead of throwing errors for existing/tombstoned IDs.\n     *\n     * This function:\n     * 1. Checks if task ID already exists (active or soft-deleted)\n     * 2. Checks if task ID is tombstoned (permanently deleted)\n     * 3. Only creates if ID is truly available\n     *\n     * @param task - The task to create\n     * @returns SafeCreateTaskResult with status and details\n     */\n    const safeCreateTask = async (task: Task): Promise<SafeCreateTaskResult> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] safeCreateTask - not authenticated, falling back to local')\n            return {\n                status: 'created',\n                taskId: task.id,\n                message: 'Task created locally (guest mode)'\n            }\n        }\n\n        try {\n            // Try to use the RPC function if available (more efficient)\n            // TASK-1183: Sanitize project_id - 'uncategorized' is not a valid UUID\n            const sanitizedProjectId = task.projectId === UNCATEGORIZED_PROJECT_ID || task.projectId === '1'\n                ? null\n                : (task.projectId || null)\n\n            const { data: rpcResult, error: rpcError } = await supabase.rpc('safe_create_task', {\n                p_task_id: task.id,\n                p_user_id: userId,\n                p_title: task.title,\n                p_description: task.description || '',\n                p_status: task.status || 'planned',\n                p_priority: task.priority || 'medium',\n                p_due_date: task.dueDate || null,\n                p_project_id: sanitizedProjectId,\n                p_position: task.canvasPosition ? JSON.stringify(task.canvasPosition) : null,\n                p_tags: task.tags || [],\n                p_is_in_inbox: task.isInInbox !== false,\n                p_parent_task_id: task.parentTaskId || null\n            })\n\n            if (rpcError) {\n                // RPC function might not exist yet - fall back to manual check\n                console.warn('[TASK-344] RPC failed, falling back to manual check:', rpcError.message)\n                return await safeCreateTaskManual(task, userId)\n            }\n\n            // Parse RPC result\n            const result = rpcResult as { status: string; task_id: string; message: string; is_deleted?: boolean; title?: string; deleted_at?: string }\n            return {\n                status: result.status as SafeCreateTaskResult['status'],\n                taskId: result.task_id,\n                message: result.message,\n                isDeleted: result.is_deleted,\n                title: result.title,\n                deletedAt: result.deleted_at\n            }\n\n        } catch (e: unknown) {\n            console.error('[TASK-344] safeCreateTask failed:', e)\n            // Fall back to manual check\n            return await safeCreateTaskManual(task, userId)\n        }\n    }\n\n    /**\n     * Manual implementation of safe task creation (fallback if RPC not available)\n     */\n    const safeCreateTaskManual = async (task: Task, userId: string): Promise<SafeCreateTaskResult> => {\n        try {\n            // 1. Check if task already exists\n            const { data: existing, error: existError } = await supabase\n                .from('tasks')\n                .select('id, is_deleted, title')\n                .eq('id', task.id)\n                .eq('user_id', userId)\n                .maybeSingle()\n\n            if (existError && existError.code !== 'PGRST116') {\n                throw existError\n            }\n\n            if (existing) {\n                console.log(`🔒 [TASK-344] Task ID ${task.id.slice(0, 8)}... already exists (is_deleted: ${existing.is_deleted})`)\n                return {\n                    status: 'exists',\n                    taskId: existing.id,\n                    message: 'Task with this ID already exists',\n                    isDeleted: existing.is_deleted,\n                    title: existing.title\n                }\n            }\n\n            // 2. Check tombstones\n            const { data: tombstone, error: tombError } = await supabase\n                .from('tombstones')\n                .select('entity_id, deleted_at')\n                .eq('entity_type', 'task')\n                .eq('entity_id', task.id)\n                .eq('user_id', userId)\n                .maybeSingle()\n\n            if (tombError && tombError.code !== 'PGRST116') {\n                throw tombError\n            }\n\n            if (tombstone) {\n                console.log(`🪦 [TASK-344] Task ID ${task.id.slice(0, 8)}... is tombstoned (deleted: ${tombstone.deleted_at})`)\n                return {\n                    status: 'tombstoned',\n                    taskId: task.id,\n                    message: 'Task ID was permanently deleted and cannot be reused',\n                    deletedAt: tombstone.deleted_at\n                }\n            }\n\n            // 3. Safe to create - use regular saveTask\n            const payload = toSupabaseTask(task, userId)\n            const { error: insertError } = await supabase.from('tasks').insert(payload)\n\n            if (insertError) {\n                // Check for unique violation (race condition)\n                if (insertError.code === '23505') {\n                    return {\n                        status: 'exists',\n                        taskId: task.id,\n                        message: 'Task was created by another transaction (race condition)'\n                    }\n                }\n                throw insertError\n            }\n\n            console.log(`✅ [TASK-344] Task ${task.id.slice(0, 8)}... created safely`)\n            return {\n                status: 'created',\n                taskId: task.id,\n                message: 'Task created successfully'\n            }\n\n        } catch (e: unknown) {\n            const message = e instanceof Error ? e.message : String(e)\n            console.error('[TASK-344] safeCreateTaskManual failed:', e)\n            return {\n                status: 'error',\n                taskId: task.id,\n                message: `Failed to create task: ${message}`\n            }\n        }\n    }\n\n    /**\n     * TASK-344: Batch check task ID availability for restore/sync operations.\n     * More efficient than checking one at a time.\n     *\n     * @param taskIds - Array of task IDs to check\n     * @returns Array of availability results\n     */\n    const checkTaskIdsAvailability = async (taskIds: string[]): Promise<TaskIdAvailability[]> => {\n        const userId = getUserIdSafe()\n        if (!userId || taskIds.length === 0) {\n            return taskIds.map(id => ({\n                taskId: id,\n                status: 'available' as const,\n                reason: 'Guest mode or empty array'\n            }))\n        }\n\n        try {\n            // Try RPC function first\n            const { data: rpcResult, error: rpcError } = await supabase.rpc('check_task_ids_availability', {\n                p_user_id: userId,\n                p_task_ids: taskIds\n            })\n\n            if (!rpcError && rpcResult) {\n                return (rpcResult as any[]).map(r => ({\n                    taskId: r.task_id,\n                    status: r.status as TaskIdAvailability['status'],\n                    reason: r.reason\n                }))\n            }\n\n            // Fall back to manual batch check\n            console.warn('[TASK-344] RPC check_task_ids_availability not available, using manual check')\n            return await checkTaskIdsAvailabilityManual(taskIds, userId)\n\n        } catch (e: unknown) {\n            console.error('[TASK-344] checkTaskIdsAvailability failed:', e)\n            return await checkTaskIdsAvailabilityManual(taskIds, userId)\n        }\n    }\n\n    /**\n     * Manual batch check for task ID availability\n     */\n    const checkTaskIdsAvailabilityManual = async (taskIds: string[], userId: string): Promise<TaskIdAvailability[]> => {\n        const results: TaskIdAvailability[] = []\n\n        try {\n            // Batch fetch existing tasks\n            const { data: existingTasks, error: tasksError } = await supabase\n                .from('tasks')\n                .select('id, is_deleted')\n                .in('id', taskIds)\n                .eq('user_id', userId)\n\n            if (tasksError) throw tasksError\n\n            const existingMap = new Map<string, boolean>()\n            for (const t of existingTasks || []) {\n                existingMap.set(t.id, t.is_deleted)\n            }\n\n            // Batch fetch tombstones\n            const { data: tombstones, error: tombError } = await supabase\n                .from('tombstones')\n                .select('entity_id')\n                .eq('entity_type', 'task')\n                .in('entity_id', taskIds)\n                .eq('user_id', userId)\n\n            if (tombError) throw tombError\n\n            const tombstoneSet = new Set((tombstones || []).map((t: { entity_id: string }) => t.entity_id))\n\n            // Build results\n            for (const id of taskIds) {\n                if (existingMap.has(id)) {\n                    const isDeleted = existingMap.get(id)\n                    results.push({\n                        taskId: id,\n                        status: isDeleted ? 'soft_deleted' : 'active',\n                        reason: `Task exists in database (${isDeleted ? 'soft_deleted' : 'active'})`\n                    })\n                } else if (tombstoneSet.has(id)) {\n                    results.push({\n                        taskId: id,\n                        status: 'tombstoned',\n                        reason: 'Task ID is tombstoned (permanently deleted)'\n                    })\n                } else {\n                    results.push({\n                        taskId: id,\n                        status: 'available',\n                        reason: 'Task ID is available for creation'\n                    })\n                }\n            }\n\n        } catch (e: unknown) {\n            console.error('[TASK-344] checkTaskIdsAvailabilityManual failed:', e)\n            // Return all as available on error (fail open for restore operations)\n            return taskIds.map(id => ({\n                taskId: id,\n                status: 'available' as const,\n                reason: 'Check failed, assuming available'\n            }))\n        }\n\n        return results\n    }\n\n    /**\n     * TASK-344: Log dedup decision to audit table (non-blocking)\n     */\n    const logDedupDecision = async (\n        operation: 'restore' | 'sync' | 'create',\n        taskId: string,\n        decision: 'created' | 'skipped_exists' | 'skipped_tombstoned' | 'failed',\n        reason: string,\n        backupSource?: string\n    ): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) return\n\n        try {\n            await supabase.from('task_dedup_audit').insert({\n                user_id: userId,\n                operation,\n                task_id: taskId,\n                decision,\n                reason,\n                backup_source: backupSource || null\n            })\n        } catch (e: unknown) {\n            // Non-fatal - audit logging should never block operations\n            console.warn('[TASK-344] Failed to log dedup decision:', e)\n        }\n    }\n\n    const permanentlyDeleteProject = async (projectId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            // TASK-317: Record tombstone before permanent deletion\n            await recordTombstone('project', projectId)\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase\n                    .from('projects')\n                    .delete()\n                    .eq('id', projectId)\n                if (error) throw error\n            }, 'permanentlyDeleteProject')\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'permanentlyDeleteProject')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // -- Tasks --\n\n    const fetchTasks = async (): Promise<Task[]> => {\n        // TASK-1060: Ensure auth is initialized before fetching to avoid stale guest data\n        if (!authStore.isInitialized) {\n            console.log('🔄 [TASK-1060] Auth not initialized, waiting...')\n            await authStore.initialize()\n        }\n\n        const userId = getUserIdSafe()\n        // BUG-1056: Check if user changed since last fetch - invalidates cache if so\n        swrCache.checkUserChange(userId)\n        const cacheKey = `tasks:${userId || 'guest'}`\n\n        return swrCache.getOrFetch(cacheKey, async () => {\n            try {\n                return await withRetry(async () => {\n                    const { data, error } = await supabase\n                        .from('tasks')\n                        .select('*')\n                        .eq('is_deleted', false)\n                        .order('order', { ascending: true })\n                        .order('created_at', { ascending: true })\n\n                    if (error) throw error\n                    if (!data) return []\n\n                    // TASK-142 DEBUG: Log what positions we receive from Supabase\n                    const tasksWithPos = data.filter((d: any) => d.position)\n                    if (tasksWithPos.length > 0) {\n                        console.log(`📥 [TASK-142] LOADED ${tasksWithPos.length} tasks with positions from Supabase:`,\n                            tasksWithPos.map((d: any) => ({ id: d.id?.substring(0, 8), pos: d.position })))\n                    } else {\n                        console.log(`📥 [TASK-142] LOADED ${data.length} tasks - NONE have positions in DB`)\n                    }\n\n                    return (data as SupabaseTask[]).map(fromSupabaseTask)\n                }, 'fetchTasks')\n            } catch (e: unknown) {\n                handleError(e, 'fetchTasks')\n                return []\n            }\n        })\n    }\n\n    const fetchTrash = async (): Promise<Task[]> => {\n        try {\n            // BUG-1107: Wrap in withRetry for mobile PWA network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('tasks')\n                    .select('*')\n                    .eq('is_deleted', true)\n                    .order('deleted_at', { ascending: false })\n\n                if (error) throw error\n                if (!data) return []\n\n                return (data as SupabaseTask[]).map(fromSupabaseTask)\n            }, 'fetchTrash')\n        } catch (e: unknown) {\n            handleError(e, 'fetchTrash')\n            return []\n        }\n    }\n\n    const saveTask = async (task: Task): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveTask - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = toSupabaseTask(task, userId)\n\n            // FK-aware upsert with single retry for orphaned parent references\n            const attemptUpsert = async (payloadToSave: typeof payload, isRetry = false): Promise<void> => {\n                const { error } = await supabase.from('tasks').upsert(payloadToSave, { onConflict: 'id' })\n\n                // Handle FK constraint violation on parent_task_id\n                if (error?.code === '23503' && error?.message?.includes('parent_task_id') && !isRetry) {\n                    console.warn(`⚠️ [saveTask] FK violation on parent_task_id, clearing and retrying`)\n                    return attemptUpsert({ ...payloadToSave, parent_task_id: null }, true)\n                }\n\n                if (error) throw error\n            }\n\n            await withRetry(() => attemptUpsert(payload), 'saveTask')\n\n            // TASK-1083: Invalidate cache after successful write to prevent stale reads\n            invalidateCache.tasks()\n\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveTask')\n            throw e\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const saveTasks = async (tasks: Task[]): Promise<void> => {\n        if (tasks.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveTasks - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = tasks.map(t => toSupabaseTask(t, userId))\n\n            // TASK-142 DEBUG: Log what we're sending\n            const tasksWithPos = payload.filter(p => p.position)\n            if (tasksWithPos.length > 0) {\n                console.log(`📤 [TASK-142] SENDING ${tasksWithPos.length} tasks with positions:`,\n                    tasksWithPos.map(t => ({ id: t.id?.substring(0, 8), pos: t.position })))\n            }\n\n            // FK-aware upsert with single retry for orphaned parent references\n            const attemptUpsert = async (payloadToSave: typeof payload, isRetry = false): Promise<void> => {\n                const { data, error } = await supabase\n                    .from('tasks')\n                    .upsert(payloadToSave, { onConflict: 'id' })\n                    .select('id, position')\n\n                // Handle FK constraint violation on parent_task_id\n                if (error?.code === '23503' && error?.message?.includes('parent_task_id') && !isRetry) {\n                    console.warn(`⚠️ [saveTasks] FK violation on parent_task_id, clearing orphaned references and retrying`)\n                    const clearedPayload = payloadToSave.map(t => ({ ...t, parent_task_id: null }))\n                    return attemptUpsert(clearedPayload, true)\n                }\n\n                if (error) throw error\n\n                // RLS check\n                if (!data || data.length !== payloadToSave.length) {\n                    const writtenCount = data?.length ?? 0\n                    const failedCount = payloadToSave.length - writtenCount\n                    throw new Error(`RLS blocked ${failedCount} of ${payloadToSave.length} writes (only ${writtenCount} succeeded)`)\n                }\n\n                // TASK-142 DEBUG: Log what Supabase returned\n                const positionSaves = data.filter((d: any) => d.position)\n                if (positionSaves.length > 0) {\n                    console.log(`📥 [TASK-142] RECEIVED ${positionSaves.length} tasks with positions:`,\n                        positionSaves.map((d: any) => ({ id: d.id?.substring(0, 8), pos: d.position })))\n                } else if (tasksWithPos.length > 0) {\n                    console.error(`❌ [TASK-142] POSITION LOST! Sent ${tasksWithPos.length} with positions, received 0 back!`)\n                }\n            }\n\n            await withRetry(() => attemptUpsert(payload), 'saveTasks')\n\n            // TASK-1083: Invalidate cache after successful write to prevent stale reads\n            invalidateCache.tasks()\n\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'saveTasks')\n            throw e\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const deleteTask = async (taskId: string): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping deleteTask - not authenticated')\n            return\n        }\n        console.log(`🗑️ [SUPABASE-DELETE] Starting soft-delete for task: ${taskId}`)\n        try {\n            isSyncing.value = true\n\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            const { error, count } = await withRetry(async () => {\n                const { error, count } = await supabase\n                    .from('tasks')\n                    .update({ is_deleted: true, deleted_at: new Date().toISOString() })\n                    .eq('id', taskId)\n                    .select('*', { count: 'exact' })\n\n                console.log(`🗑️ [SUPABASE-DELETE] Result - error: ${error?.message || 'none'}, affected rows: ${count ?? 'unknown'}`)\n\n                if (error) throw error\n                return { error, count }\n            }, 'deleteTask')\n\n            lastSyncError.value = null\n            console.log(`✅ [SUPABASE-DELETE] Task ${taskId} marked as deleted`)\n        } catch (e: unknown) {\n            console.error(`❌ [SUPABASE-DELETE] Failed to delete task ${taskId}:`, e)\n            handleError(e, 'deleteTask')\n            throw e  // Re-throw so caller knows it failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const restoreTask = async (taskId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase\n                    .from('tasks')\n                    .update({ is_deleted: false, deleted_at: null })\n                    .eq('id', taskId)\n                if (error) throw error\n            }, 'restoreTask')\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'restoreTask')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const permanentlyDeleteTask = async (taskId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            // TASK-317: Record tombstone before permanent deletion\n            await recordTombstone('task', taskId)\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase\n                    .from('tasks')\n                    .delete()\n                    .eq('id', taskId)\n                if (error) throw error\n            }, 'permanentlyDeleteTask')\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            handleError(e, 'permanentlyDeleteTask')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // TASK-153: Fetch IDs of deleted tasks (for golden backup validation)\n    const fetchDeletedTaskIds = async (): Promise<string[]> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return []\n\n            // BUG-1311: Wrap in withRetry for network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('tasks')\n                    .select('id')\n                    .eq('is_deleted', true)\n                    .eq('user_id', userId)\n\n                if (error) throw error\n                return data?.map((d: any) => d.id) || []\n            }, 'fetchDeletedTaskIds')\n        } catch (e: unknown) {\n            console.error('[TASK-153] Failed to fetch deleted task IDs:', e)\n            return []\n        }\n    }\n\n    // TASK-153: Fetch IDs of deleted projects (for golden backup validation)\n    const fetchDeletedProjectIds = async (): Promise<string[]> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return []\n\n            // BUG-1311: Wrap in withRetry for network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('projects')\n                    .select('id')\n                    .eq('is_deleted', true)\n                    .eq('user_id', userId)\n\n                if (error) throw error\n                return data?.map((d: any) => d.id) || []\n            }, 'fetchDeletedProjectIds')\n        } catch (e: unknown) {\n            console.error('[TASK-153] Failed to fetch deleted project IDs:', e)\n            return []\n        }\n    }\n\n    // TASK-153: Fetch IDs of deleted groups (for golden backup validation)\n    const fetchDeletedGroupIds = async (): Promise<string[]> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return []\n\n            // BUG-1311: Wrap in withRetry for network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('groups')\n                    .select('id')\n                    .eq('is_deleted', true)\n                    .eq('user_id', userId)\n\n                if (error) throw error\n                return data?.map((d: any) => d.id) || []\n            }, 'fetchDeletedGroupIds')\n        } catch (e: unknown) {\n            console.error('[TASK-153] Failed to fetch deleted group IDs:', e)\n            return []\n        }\n    }\n\n    // BUG-025 FIX: Atomic bulk delete using Supabase .in() operator\n    const bulkDeleteTasks = async (taskIds: string[]): Promise<void> => {\n        if (taskIds.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping bulkDeleteTasks - not authenticated')\n            return\n        }\n        console.log(`🗑️ [SUPABASE-BULK-DELETE] Starting atomic soft-delete for ${taskIds.length} tasks`)\n        try {\n            isSyncing.value = true\n\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            const { error, count } = await withRetry(async () => {\n                const { error, count } = await supabase\n                    .from('tasks')\n                    // FIX: Schema compatibility - remove deleted_at if not in DB\n                    .update({ is_deleted: true })\n                    .in('id', taskIds)\n                    .select('*', { count: 'exact' })\n\n                console.log(`🗑️ [SUPABASE-BULK-DELETE] Result - error: ${error?.message || 'none'}, affected rows: ${count ?? 'unknown'}`)\n\n                if (error) throw error\n                return { error, count }\n            }, 'bulkDeleteTasks')\n\n            lastSyncError.value = null\n            console.log(`✅ [SUPABASE-BULK-DELETE] ${taskIds.length} tasks marked as deleted atomically`)\n        } catch (e: unknown) {\n            console.error(`❌ [SUPABASE-BULK-DELETE] Failed to bulk delete ${taskIds.length} tasks:`, e)\n            handleError(e, 'bulkDeleteTasks')\n            throw e // Re-throw so caller knows it failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // -- Groups --\n\n    const fetchGroups = async (): Promise<CanvasGroup[]> => {\n        // TASK-1060: Ensure auth is initialized before fetching\n        if (!authStore.isInitialized) {\n            console.log('🔄 [TASK-1060] Auth not initialized, waiting...')\n            await authStore.initialize()\n        }\n\n        const userId = getUserIdSafe()\n        // BUG-1056: Check if user changed since last fetch - invalidates cache if so\n        swrCache.checkUserChange(userId)\n        const cacheKey = `groups:${userId || 'guest'}`\n\n        return swrCache.getOrFetch(cacheKey, async () => {\n            try {\n                // BUG-1107: Wrap in withRetry for mobile PWA network resilience\n                return await withRetry(async () => {\n                    const { data, error } = await supabase\n                        .from('groups')\n                        .select('*')\n                        .eq('is_deleted', false)\n\n                    if (error) throw error\n                    if (!data) return []\n\n                    // DEBUG: Log loaded groups and their dimensions\n                    const groups = data as SupabaseGroup[]\n                    groups.forEach((g: any) => {\n                        const pos = g.position_json\n                        console.log(`📦 [GROUP-LOAD] \"${g.name}\" loaded from Supabase: size=${pos?.width}x${pos?.height}`)\n                    })\n\n                    return (data as SupabaseGroup[]).map(fromSupabaseGroup)\n                }, 'fetchGroups')\n            } catch (e: unknown) {\n                handleError(e, 'fetchGroups')\n                return []\n            }\n        })\n    }\n\n    const saveGroup = async (group: CanvasGroup): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveGroup - not authenticated')\n            return\n        }\n        try {\n            isSyncing.value = true\n            const payload = toSupabaseGroup(group, userId)\n\n            // BUG-1184: Skip groups with legacy non-UUID IDs gracefully\n            if (!payload) {\n                console.debug(`⏭️ [LEGACY-GROUP] Skipping save for group \"${group.name}\" - has legacy ID format`)\n                return\n            }\n\n            // TASK-142 FIX: Add .select() and check data.length to detect RLS silent failures\n            // BUG FIX: Use position_json (actual DB column name), not position\n            await withRetry(async () => {\n                const { data, error } = await supabase.from('groups').upsert(payload, { onConflict: 'id' }).select('id, position_json')\n                if (error) throw error\n                if (!data || data.length === 0) {\n                    throw new Error('RLS blocked write - upsert returned no data for group')\n                }\n                // Log position save for debugging\n                if (data[0]?.position_json) {\n                    const pos = data[0].position_json\n                    console.log(`📍 [GROUP-SAVE] Saved group \"${group.name}\" pos=(${pos.x?.toFixed(0)}, ${pos.y?.toFixed(0)}) size=${pos.width}x${pos.height} to Supabase - VERIFIED`)\n                }\n            }, 'saveGroup')\n\n            // TASK-1083: Invalidate cache after successful write to prevent stale reads\n            invalidateCache.groups()\n\n            lastSyncError.value = null\n        } catch (e: unknown) {\n            console.error('Save Group Error:', e)\n            throw e // Re-throw so callers know the save failed\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    const deleteGroup = async (groupId: string): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping deleteGroup - not authenticated')\n            return\n        }\n        console.log(`🗑️ [SUPABASE-DELETE-GROUP] Starting soft-delete for group: ${groupId}`)\n        try {\n            isSyncing.value = true\n\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            const { data, error, count } = await withRetry(async () => {\n                // TASK-149 FIX: Add user_id filter and verify rows affected\n                // TASK-317: Now includes deleted_at after migration\n                const { data, error, count } = await supabase\n                    .from('groups')\n                    .update({ is_deleted: true, deleted_at: new Date().toISOString() })\n                    .eq('id', groupId)\n                    .eq('user_id', userId)\n                    .select('id, is_deleted', { count: 'exact' })\n\n                console.log(`🗑️ [SUPABASE-DELETE-GROUP] Result - error: ${error?.message || 'none'}, affected: ${count ?? 'unknown'}`)\n\n                if (error) throw error\n                return { data, error, count }\n            }, 'deleteGroup')\n\n            // Verify the delete actually worked\n            if (!data || data.length === 0) {\n                // BUG-208 FIX: Treat \"no rows updated\" as success (idempotent delete).\n                // This handles cases where the group is already deleted in DB but stuck in UI.\n                console.warn(`⚠️ [SUPABASE-DELETE-GROUP] No rows updated - group ${groupId} likely already deleted or RLS blocked. Proceeding with local removal.`)\n                // We do NOT throw here anymore, allowing the UI to proceed with removing the node.\n            } else {\n                console.log(`✅ [SUPABASE-DELETE-GROUP] Group ${groupId} marked as deleted`)\n            }\n        } catch (e: unknown) {\n            console.error(`❌ [SUPABASE-DELETE-GROUP] Failed:`, e)\n            handleError(e, 'deleteGroup')\n            throw e // Only re-throw actual errors (network, auth, etc)\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // TASK-317: Permanent group deletion with tombstone\n    const permanentlyDeleteGroup = async (groupId: string): Promise<void> => {\n        try {\n            isSyncing.value = true\n            // Record tombstone before permanent deletion\n            await recordTombstone('group', groupId)\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase\n                    .from('groups')\n                    .delete()\n                    .eq('id', groupId)\n                if (error) throw error\n            }, 'permanentlyDeleteGroup')\n            lastSyncError.value = null\n            console.log(`🪦 [PERMANENT-DELETE-GROUP] Group ${groupId} permanently deleted`)\n        } catch (e: unknown) {\n            handleError(e, 'permanentlyDeleteGroup')\n        } finally {\n            isSyncing.value = false\n        }\n    }\n\n    // -- Notifications --\n\n    const fetchNotifications = async (): Promise<ScheduledNotification[]> => {\n        try {\n            // BUG-1107: Wrap in withRetry for mobile PWA network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('notifications')\n                    .select('*')\n                    .eq('is_dismissed', false)\n\n                if (error) throw error\n                if (!data) return []\n\n                return (data as SupabaseNotification[]).map(fromSupabaseNotification)\n            }, 'fetchNotifications')\n        } catch (e: unknown) {\n            handleError(e, 'fetchNotifications')\n            return []\n        }\n    }\n\n    const saveNotification = async (notification: ScheduledNotification): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveNotification - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabaseNotification(notification, userId)\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('notifications').upsert(payload, { onConflict: 'id' })\n                if (error) throw error\n            }, 'saveNotification')\n        } catch (e: unknown) {\n            handleError(e, 'saveNotification')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        }\n    }\n\n    const saveNotifications = async (notifications: ScheduledNotification[]): Promise<void> => {\n        if (notifications.length === 0) return\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveNotifications - not authenticated')\n            return\n        }\n        try {\n            const payload = notifications.map(n => toSupabaseNotification(n, userId))\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('notifications').upsert(payload, { onConflict: 'id' })\n                if (error) throw error\n            }, 'saveNotifications')\n        } catch (e: unknown) {\n            handleError(e, 'saveNotifications')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        }\n    }\n\n    const deleteNotification = async (id: string): Promise<void> => {\n        try {\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('notifications').delete().eq('id', id)\n                if (error) throw error\n            }, 'deleteNotification')\n        } catch (e: unknown) {\n            handleError(e, 'deleteNotification')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        }\n    }\n\n    // -- Timer Sessions --\n\n    const fetchActiveTimerSession = async (): Promise<PomodoroSession | null> => {\n        try {\n            const userId = getUserIdSafe()\n            console.log('🍅 [DB] fetchActiveTimerSession userId:', userId)\n            if (!userId) {\n                console.log('🍅 [DB] No userId - returning null')\n                return null\n            }\n\n            // BUG-1107: Wrap in withRetry for mobile PWA network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('timer_sessions')\n                    .select('*')\n                    .eq('user_id', userId)\n                    .eq('is_active', true)\n                    .order('updated_at', { ascending: false })\n                    .limit(1)\n                    .maybeSingle()\n\n                console.log('🍅 [DB] fetchActiveTimerSession result:', { hasData: !!data, error: error?.message })\n\n                if (error) throw error\n                if (!data) return null\n\n                return fromSupabaseTimerSession(data as SupabaseTimerSession)\n            }, 'fetchActiveTimerSession')\n        } catch (e: unknown) {\n            handleError(e, 'fetchActiveTimerSession')\n            return null\n        }\n    }\n\n    const saveActiveTimerSession = async (session: PomodoroSession, deviceId: string): Promise<void> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) {\n                console.log('🍅 [DB] saveActiveTimerSession - no userId, skipping')\n                return\n            }\n\n            const payload = toSupabaseTimerSession(session, userId, deviceId)\n            console.log('🍅 [DB] saveActiveTimerSession:', { sessionId: session.id, userId, deviceId, isActive: session.isActive })\n            // BUG-352: Wrap in withRetry for mobile PWA network resilience (was missing from BUG-1107 fix)\n            await withRetry(async () => {\n                const { error } = await supabase.from('timer_sessions').upsert(payload, { onConflict: 'id' })\n                if (error) {\n                    console.error('🍅 [DB] saveActiveTimerSession error:', error)\n                    throw error\n                }\n            }, 'saveActiveTimerSession')\n            console.log('🍅 [DB] saveActiveTimerSession success')\n        } catch (e: unknown) {\n            handleError(e, 'saveActiveTimerSession')\n        }\n    }\n\n    const deleteTimerSession = async (id: string): Promise<void> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return // Skip Supabase sync when not authenticated (local-only mode)\n\n            // BUG-352: Wrap in withRetry for mobile PWA network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('timer_sessions').delete().eq('id', id)\n                if (error) throw error\n            }, 'deleteTimerSession')\n        } catch (e: unknown) {\n            handleError(e, 'deleteTimerSession')\n        }\n    }\n\n    // -- User Settings --\n\n    const fetchUserSettings = async (): Promise<AppSettings | null> => {\n        try {\n            const userId = getUserIdSafe()\n            if (!userId) return null\n\n            // BUG-1311: Wrap in withRetry for network resilience\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('user_settings')\n                    .select('*')\n                    .eq('user_id', userId)\n                    .maybeSingle()\n\n                if (error) throw error\n                if (!data) return null\n\n                return fromSupabaseUserSettings(data as SupabaseUserSettings)\n            }, 'fetchUserSettings')\n        } catch (e: unknown) {\n            console.error('Fetch User Settings Error:', e)\n            return null\n        }\n    }\n\n    const saveUserSettings = async (settings: AppSettings): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveUserSettings - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabaseUserSettings(settings, userId)\n\n            await withRetry(async () => {\n                // Fix: Explicitly specify conflict target to handle 'user_settings_user_id_key' violation\n                const { error } = await supabase.from('user_settings').upsert(payload, { onConflict: 'user_id' })\n                if (error) throw error\n            }, 'saveUserSettings')\n        } catch (e: unknown) {\n            handleError(e, 'saveUserSettings')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        }\n    }\n\n    // -- Quick Sort Sessions --\n\n    const fetchQuickSortHistory = async (): Promise<SessionSummary[]> => {\n        try {\n            // BUG-1311: Wrap in withRetry for network resilience (was missing)\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('quick_sort_sessions')\n                    .select('*')\n                    .order('completed_at', { ascending: false })\n\n                if (error) throw error\n                if (!data) return []\n\n                return (data as SupabaseQuickSortSession[]).map(fromSupabaseQuickSortSession)\n            }, 'fetchQuickSortHistory')\n        } catch (e: unknown) {\n            handleError(e, 'fetchQuickSortHistory')\n            return []\n        }\n    }\n\n    const saveQuickSortSession = async (summary: SessionSummary): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveQuickSortSession - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabaseQuickSortSession(summary, userId)\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('quick_sort_sessions').upsert(payload, { onConflict: 'id' })\n                if (error) throw error\n            }, 'saveQuickSortSession')\n        } catch (e: unknown) {\n            handleError(e, 'saveQuickSortSession')\n            throw e // BUG-1051: Re-throw so caller knows save failed\n        }\n    }\n\n    // -- Realtime Subscription --\n\n    const initRealtimeSubscription = (\n        onProjectChange: (payload: unknown) => void,\n        onTaskChange: (payload: unknown) => void,\n        onTimerChange?: (payload: unknown) => void,\n        onNotificationChange?: (payload: unknown) => void,\n        onGroupChange?: (payload: unknown) => void,\n        onRecovery?: () => Promise<void> // Callback to reload data after recovery\n    ) => {\n        const userId = authStore.user?.id\n        if (!userId) return null\n\n        let currentChannel: any = null\n        let retryCount = 0\n        let isExplicitlyClosed = false\n        const heartbeatInterval: any = null\n        let isRemovingChannel = false // Guard against recursive removeChannel calls (BUG-1088)\n\n        // cleanup previous channels if any\n        if (supabase.realtime.channels.length > 0) {\n            console.log(`📡 [REALTIME] Cleaning up ${supabase.realtime.channels.length} existing channels...`)\n            supabase.removeAllChannels()\n        }\n\n        // Unique channel name per tab\n        const tabId = (window as any).__flowstate_tab_id || (() => {\n            const id = `${Date.now()}-${Math.random().toString(36).substr(2, 6)}`\n                ; (window as any).__flowstate_tab_id = id\n            return id\n        })()\n\n        const channelName = `db-changes-${userId.substring(0, 8)}-${tabId}`\n\n        const setupSubscription = async () => {\n            if (isExplicitlyClosed) return\n\n            // connection guard\n            const { data: { session: freshSession } } = await supabase.auth.getSession()\n            if (!freshSession?.access_token) {\n                console.warn('📡 [REALTIME] No auth token available, aborting setup')\n                return\n            }\n            supabase.realtime.setAuth(freshSession.access_token)\n\n            console.log(`📡 [REALTIME] Connecting to channel: ${channelName} (Attempt ${retryCount + 1})`)\n\n            const channel = supabase.channel(channelName)\n            currentChannel = channel\n\n            // Attach Listeners with detailed logging\n            channel\n                .on('postgres_changes', { event: '*', schema: 'public', table: 'projects', filter: `user_id=eq.${userId}` },\n                    (payload: any) => {\n                        console.log('📡 [REALTIME] PROJECT event received:', {\n                            eventType: payload.eventType,\n                            table: payload.table,\n                            id: payload.new?.id?.substring(0, 8) || payload.old?.id?.substring(0, 8),\n                            name: payload.new?.name || payload.old?.name\n                        })\n                        if (payload.table === 'projects') onProjectChange(payload)\n                    })\n                .on('postgres_changes', { event: '*', schema: 'public', table: 'tasks', filter: `user_id=eq.${userId}` },\n                    (payload: any) => {\n                        console.log('📡 [REALTIME] TASK event received:', {\n                            eventType: payload.eventType,\n                            table: payload.table,\n                            id: payload.new?.id?.substring(0, 8) || payload.old?.id?.substring(0, 8),\n                            title: payload.new?.title?.substring(0, 20) || payload.old?.title?.substring(0, 20),\n                            position: payload.new?.position ? `(${payload.new.position.x},${payload.new.position.y})` : 'N/A'\n                        })\n                        if (payload.table === 'tasks') onTaskChange(payload)\n                    })\n\n            if (onTimerChange) {\n                channel.on('postgres_changes', { event: '*', schema: 'public', table: 'timer_sessions', filter: `user_id=eq.${userId}` },\n                    (payload: any) => {\n                        console.log('📡 [REALTIME] TIMER event received:', {\n                            eventType: payload.eventType,\n                            sessionId: payload.new?.id?.substring(0, 8) || payload.old?.id?.substring(0, 8),\n                            isActive: payload.new?.is_active,\n                            remainingTime: payload.new?.remaining_time\n                        })\n                        onTimerChange(payload)\n                    })\n            }\n\n            if (onNotificationChange) {\n                channel.on('postgres_changes', { event: '*', schema: 'public', table: 'notifications', filter: `user_id=eq.${userId}` },\n                    (payload: any) => {\n                        console.log('📡 [REALTIME] NOTIFICATION event received:', {\n                            eventType: payload.eventType,\n                            id: payload.new?.id?.substring(0, 8) || payload.old?.id?.substring(0, 8)\n                        })\n                        onNotificationChange(payload)\n                    })\n            }\n\n            if (onGroupChange) {\n                channel.on('postgres_changes', { event: '*', schema: 'public', table: 'groups', filter: `user_id=eq.${userId}` },\n                    (payload: any) => {\n                        console.log('📡 [REALTIME] GROUP event received:', {\n                            eventType: payload.eventType,\n                            id: payload.new?.id?.substring(0, 8) || payload.old?.id?.substring(0, 8),\n                            name: payload.new?.name || payload.old?.name,\n                            position: payload.new?.position ? `(${payload.new.position.x},${payload.new.position.y})` : 'N/A'\n                        })\n                        onGroupChange(payload)\n                    })\n            }\n\n            // Subscribe with Robust Error Handling\n            channel.subscribe(async (status: any, err: any) => {\n                if (status === 'SUBSCRIBED') {\n                    console.log('📡 [REALTIME] Connected! 🟢')\n                    retryCount = 0 // Reset backoff\n\n                    // If this was a recovery (retryCount > 0 previously implies we were trying), reload data\n                    // But we just reset it. We need a flag.\n                    // Actually, if we are in this function, we assume we might have missed data if it's a reconnect.\n                    // But 'SUBSCRIBED' fires on first connect too. \n                    // reliable strategy: only reload if we actually recovered from an error or it's a re-connection\n                }\n\n                else if (status === 'CLOSED' || status === 'TIMED_OUT' || status === 'CHANNEL_ERROR') {\n                    // BUG-1320: Downgrade log when tab is hidden — browsers kill WebSockets\n                    // in background tabs, this is expected behavior, not an error\n                    const logFn = document.visibilityState === 'hidden' ? console.debug : console.warn\n                    logFn(`📡 [REALTIME] Connection dropped (${status}):`, err || 'unknown reason')\n\n                    if (isExplicitlyClosed) return\n\n                    // BUG-1088: Guard against recursive removeChannel calls that cause stack overflow\n                    if (isRemovingChannel) {\n                        console.log('📡 [REALTIME] Skipping duplicate removeChannel (recursion guard)')\n                        return\n                    }\n\n                    // PREVENT STALE CHANNELS:\n                    // Supabase docs recommend removing the channel before reconnecting\n                    isRemovingChannel = true\n                    try {\n                        await supabase.removeChannel(channel)\n                    } catch (removeErr) {\n                        console.warn('📡 [REALTIME] Failed to remove channel (continuing anyway):', removeErr)\n                    } finally {\n                        isRemovingChannel = false\n                    }\n                    currentChannel = null\n\n                    // RETRY LOGIC (Exponential Backoff)\n                    const maxRetries = 10\n                    if (retryCount < maxRetries) {\n                        const delay = Math.pow(1.5, retryCount) * 1000 + (Math.random() * 500)\n                        console.log(`📡 [REALTIME] Reconnecting in ${delay.toFixed(0)}ms...`)\n\n                        setTimeout(() => {\n                            retryCount++\n                            setupSubscription().then(() => {\n                                // BUG-1207 FIX: Apply same cooldown as visibility/online handlers\n                                // to prevent recovery from clobbering recent user edits\n                                const timeSinceInteraction = Date.now() - lastUserInteraction\n                                if (onRecovery && timeSinceInteraction > RECOVERY_COOLDOWN_MS) {\n                                    console.log('📡 [REALTIME] Triggering recovery data reload...')\n                                    // CRITICAL FIX: Invalidate ALL caches before recovery to prevent stale data\n                                    invalidateCache.all()\n                                    onRecovery().catch(e => console.error('Recovery failed:', e))\n                                } else if (onRecovery) {\n                                    console.log(`📡 [REALTIME] Skipping reconnect recovery reload - user was active ${Math.round(timeSinceInteraction / 1000)}s ago (cooldown: ${RECOVERY_COOLDOWN_MS / 1000}s)`)\n                                }\n                            })\n                        }, delay)\n                    } else {\n                        console.error('📡 [REALTIME] Max retries reached. Connection lost permanently until refresh.')\n                        handleError(new Error('Realtime connection lost'), 'RealtimeSubscription')\n                    }\n                }\n            })\n        }\n\n        // Start initial connection\n        setupSubscription()\n\n        // BUG-1207 FIX: Track last user interaction to prevent recovery from clobbering recent edits.\n        // In Tauri/WebKitGTK, visibility changes fire aggressively (notifications, tray, focus loss),\n        // triggering full DB reloads that overwrite unsaved local state.\n        let lastUserInteraction = Date.now()\n        const RECOVERY_COOLDOWN_MS = 60000 // 60 seconds\n        const trackUserInteraction = () => { lastUserInteraction = Date.now() }\n        document.addEventListener('click', trackUserInteraction, { passive: true })\n        document.addEventListener('keydown', trackUserInteraction, { passive: true })\n        document.addEventListener('pointerdown', trackUserInteraction, { passive: true })\n        document.addEventListener('input', trackUserInteraction, { passive: true })\n\n        // VISIBILITY RESUME (Handle Background Tab Throttling)\n        const onVisibilityChange = async () => {\n            if (document.visibilityState === 'visible') {\n                console.log('👀 [REALTIME] App visible - checking connection health...')\n                const state = currentChannel?.state\n\n                if (!currentChannel || state === 'closed' || state === 'errored') {\n                    console.log('👀 [REALTIME] Connection dead on resume. Force reconnecting...')\n                    // BUG-1088: Guard against recursive removeChannel calls\n                    if (currentChannel && !isRemovingChannel) {\n                        isRemovingChannel = true\n                        try {\n                            await supabase.removeChannel(currentChannel as any)\n                        } catch (removeErr) {\n                            console.warn('👀 [REALTIME] Failed to remove channel (continuing anyway):', removeErr)\n                        } finally {\n                            isRemovingChannel = false\n                        }\n                    }\n                    retryCount = 0\n                    setupSubscription()\n\n                    // BUG-1207 FIX: Skip recovery reload if user was recently active.\n                    // This prevents the \"edit task → lose focus briefly → recovery clobbers edit\" pattern\n                    // that is especially common in Tauri/WebKitGTK.\n                    const timeSinceInteraction = Date.now() - lastUserInteraction\n                    if (onRecovery && timeSinceInteraction > RECOVERY_COOLDOWN_MS) {\n                        // CRITICAL FIX: Invalidate ALL caches before recovery to prevent stale data\n                        invalidateCache.all()\n                        onRecovery()\n                    } else if (onRecovery) {\n                        console.log(`👀 [REALTIME] Skipping recovery reload - user was active ${Math.round(timeSinceInteraction / 1000)}s ago (cooldown: ${RECOVERY_COOLDOWN_MS / 1000}s)`)\n                    }\n                } else {\n                    // Pulse check - verify we are actually connected\n                    // (Optional: Send a heartbeat or just assume it's okay if state says joined)\n                }\n            }\n        }\n        document.addEventListener('visibilitychange', onVisibilityChange)\n\n        // ONLINE RESUME\n        // BUG-1209: Add same cooldown as visibility handler to prevent clobbering in-flight drags\n        const onOnline = () => {\n            console.log('🌐 [REALTIME] Online event detected. Reconnecting...')\n            retryCount = 0\n            setupSubscription()\n            const timeSinceInteraction = Date.now() - lastUserInteraction\n            if (onRecovery && timeSinceInteraction > RECOVERY_COOLDOWN_MS) {\n                // CRITICAL FIX: Invalidate ALL caches before recovery to prevent stale data\n                invalidateCache.all()\n                onRecovery()\n            } else if (onRecovery) {\n                console.log(`🌐 [REALTIME] Skipping online recovery reload - user was active ${Math.round(timeSinceInteraction / 1000)}s ago (cooldown: ${RECOVERY_COOLDOWN_MS / 1000}s)`)\n            }\n        }\n        window.addEventListener('online', onOnline)\n\n        // Return cleanup function (Proxy interface for callers)\n        return {\n            unsubscribe: async () => {\n                console.log('📡 [REALTIME] Unsubscribing explicitly.')\n                isExplicitlyClosed = true\n                // BUG-1088: Guard against recursive removeChannel calls\n                if (currentChannel && !isRemovingChannel) {\n                    isRemovingChannel = true\n                    try {\n                        await supabase.removeChannel(currentChannel)\n                    } catch (removeErr) {\n                        console.warn('📡 [REALTIME] Failed to remove channel during cleanup:', removeErr)\n                    } finally {\n                        isRemovingChannel = false\n                    }\n                }\n                document.removeEventListener('visibilitychange', onVisibilityChange)\n                document.removeEventListener('click', trackUserInteraction)\n                document.removeEventListener('keydown', trackUserInteraction)\n                document.removeEventListener('pointerdown', trackUserInteraction)\n                document.removeEventListener('input', trackUserInteraction)\n                window.removeEventListener('online', onOnline)\n            }\n        }\n    }\n\n    // -- Pinned Tasks (FEATURE-1248) --\n\n    const fetchPinnedTasks = async (): Promise<PinnedTask[]> => {\n        const userId = getUserIdSafe()\n        if (!userId) return []\n\n        try {\n            return await swrCache.getOrFetch(`pinnedTasks:${userId}`, async () => {\n                return await withRetry(async () => {\n                    const { data, error } = await supabase\n                        .from('pinned_tasks')\n                        .select('*')\n                        .eq('user_id', userId)\n                        .order('sort_order', { ascending: true })\n\n                    if (error) throw error\n                    if (!data) return []\n\n                    return (data as SupabasePinnedTask[]).map(fromSupabasePinnedTask)\n                }, 'fetchPinnedTasks')\n            })\n        } catch (e: unknown) {\n            handleError(e, 'fetchPinnedTasks')\n            return []\n        }\n    }\n\n    const savePinnedTask = async (pin: PinnedTask): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('[GUEST] Skipping savePinnedTask - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabasePinnedTask(pin, userId)\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('pinned_tasks').upsert(payload, { onConflict: 'id' })\n                if (error) throw error\n            }, 'savePinnedTask')\n            invalidateCache.pinnedTasks()\n        } catch (e: unknown) {\n            handleError(e, 'savePinnedTask')\n            throw e\n        }\n    }\n\n    const deletePinnedTask = async (pinId: string): Promise<void> => {\n        try {\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('pinned_tasks').delete().eq('id', pinId)\n                if (error) throw error\n            }, 'deletePinnedTask')\n            invalidateCache.pinnedTasks()\n        } catch (e: unknown) {\n            handleError(e, 'deletePinnedTask')\n            throw e\n        }\n    }\n\n    const reorderPinnedTasks = async (pins: PinnedTask[]): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) return\n        try {\n            const payload = pins.map((pin, index) => ({\n                ...toSupabasePinnedTask({ ...pin, sortOrder: index }, userId)\n            }))\n            // BUG-352: Wrap in withRetry for mobile network resilience\n            await withRetry(async () => {\n                const { error } = await supabase.from('pinned_tasks').upsert(payload, { onConflict: 'id' })\n                if (error) throw error\n            }, 'reorderPinnedTasks')\n            invalidateCache.pinnedTasks()\n        } catch (e: unknown) {\n            handleError(e, 'reorderPinnedTasks')\n            throw e\n        }\n    }\n\n    // -- Work Profile (FEATURE-1317) --\n\n    const fetchWorkProfile = async (): Promise<import('@/utils/supabaseMappers').WorkProfile | null> => {\n        const userId = getUserIdSafe()\n        if (!userId) return null\n        try {\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('ai_work_profiles')\n                    .select('*')\n                    .eq('user_id', userId)\n                    .maybeSingle()\n                if (error) throw error\n                if (!data) return null\n                return fromSupabaseWorkProfile(data as SupabaseWorkProfile)\n            }, 'fetchWorkProfile')\n        } catch (e: unknown) {\n            console.warn('[FEATURE-1317] Failed to fetch work profile:', e)\n            return null\n        }\n    }\n\n    const saveWorkProfile = async (profile: Partial<import('@/utils/supabaseMappers').WorkProfile>): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) {\n            console.debug('⏭️ [GUEST] Skipping saveWorkProfile - not authenticated')\n            return\n        }\n        try {\n            const payload = toSupabaseWorkProfile(profile, userId)\n            const { error } = await supabase\n                .from('ai_work_profiles')\n                .upsert(payload, { onConflict: 'user_id' })\n            if (error) throw error\n        } catch (e: unknown) {\n            handleError(e, 'saveWorkProfile')\n            throw e\n        }\n    }\n\n    // -- Pomodoro History (FEATURE-1317) --\n\n    const insertPomodoroHistory = async (entry: {\n        taskId: string | null\n        duration: number\n        isBreak: boolean\n        startedAt: Date\n        completedAt: Date\n    }): Promise<void> => {\n        const userId = getUserIdSafe()\n        if (!userId) return\n        try {\n            const { error } = await supabase.from('pomodoro_history').insert({\n                user_id: userId,\n                task_id: entry.taskId,\n                duration: entry.duration,\n                is_break: entry.isBreak,\n                started_at: entry.startedAt.toISOString(),\n                completed_at: entry.completedAt.toISOString()\n            })\n            if (error) throw error\n        } catch (e: unknown) {\n            console.warn('[FEATURE-1317] Failed to insert pomodoro history:', e)\n        }\n    }\n\n    const fetchPomodoroHistory = async (sinceDaysAgo: number = 28): Promise<Array<{\n        taskId: string | null\n        duration: number\n        isBreak: boolean\n        startedAt: string\n        completedAt: string\n    }>> => {\n        const userId = getUserIdSafe()\n        if (!userId) return []\n        try {\n            const since = new Date()\n            since.setDate(since.getDate() - sinceDaysAgo)\n            return await withRetry(async () => {\n                const { data, error } = await supabase\n                    .from('pomodoro_history')\n                    .select('*')\n                    .eq('user_id', userId)\n                    .gte('completed_at', since.toISOString())\n                    .order('completed_at', { ascending: false })\n                if (error) throw error\n                if (!data) return []\n                return data.map((row: any) => ({\n                    taskId: row.task_id,\n                    duration: row.duration,\n                    isBreak: row.is_break,\n                    startedAt: row.started_at,\n                    completedAt: row.completed_at\n                }))\n            }, 'fetchPomodoroHistory')\n        } catch (e: unknown) {\n            console.warn('[FEATURE-1317] Failed to fetch pomodoro history:', e)\n            return []\n        }\n    }\n\n    return {\n        isSyncing,\n        lastSyncError,\n        fetchProjects,\n        saveProject,\n        saveProjects,\n        deleteProject,\n        restoreProject,\n        permanentlyDeleteProject,\n        fetchTasks,\n        fetchTrash,\n        saveTask,\n        saveTasks,\n        deleteTask,\n        bulkDeleteTasks,\n        restoreTask,\n        permanentlyDeleteTask,\n        // TASK-153: Fetch deleted item IDs for golden backup validation\n        fetchDeletedTaskIds,\n        fetchDeletedProjectIds,\n        fetchDeletedGroupIds,\n        fetchGroups,\n        saveGroup,\n        deleteGroup,\n        permanentlyDeleteGroup,\n        // TASK-317: Tombstone functions\n        fetchTombstones,\n        // TASK-344: Immutable Task ID System\n        safeCreateTask,\n        checkTaskIdsAvailability,\n        logDedupDecision,\n        fetchNotifications,\n        saveNotification,\n        saveNotifications,\n        deleteNotification,\n        fetchActiveTimerSession,\n        saveActiveTimerSession,\n        deleteTimerSession,\n        fetchUserSettings,\n        saveUserSettings,\n        fetchQuickSortHistory,\n        saveQuickSortSession,\n        // FEATURE-1248: Pinned Tasks\n        fetchPinnedTasks,\n        savePinnedTask,\n        deletePinnedTask,\n        reorderPinnedTasks,\n        // FEATURE-1317: Work Profile\n        fetchWorkProfile,\n        saveWorkProfile,\n        insertPomodoroHistory,\n        fetchPomodoroHistory,\n        initRealtimeSubscription\n    }\n}\n\n// =============================================================================\n// TASK-344: Exported Types for Immutable Task ID System\n// =============================================================================\n\n/**\n * Result type for safe task creation operations\n */\nexport interface SafeCreateTaskResult {\n    status: 'created' | 'exists' | 'tombstoned' | 'error'\n    taskId: string\n    message: string\n    isDeleted?: boolean\n    title?: string\n    deletedAt?: string\n}\n\n/**\n * Result type for batch ID availability check\n */\nexport interface TaskIdAvailability {\n    taskId: string\n    status: 'available' | 'active' | 'soft_deleted' | 'tombstoned'\n    reason: string\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useSwipeGestures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTabVisibility.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTaskContextTips.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTaskSmartGroups.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTauriDebug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":271,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":271,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7423,7426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7423,7426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tauri Debug Composable (TASK-1060)\n *\n * Monitors memory usage and detects potential SIGTERM causes:\n * 1. Memory growth (unbounded leaks)\n * 2. High memory usage (OOM risk)\n * 3. Logs crashes/exits for post-mortem analysis\n */\n\nimport { ref, onMounted, onUnmounted } from 'vue'\nimport { isTauri } from './useTauriStartup'\n\nexport interface MemorySnapshot {\n  timestamp: number\n  pid: number\n  rss: string // Resident Set Size (actual RAM used)\n  virtual: string // Virtual memory\n  platform: string\n  rssBytes?: number // Parsed RSS in bytes\n}\n\nexport interface MemoryTrend {\n  samples: MemorySnapshot[]\n  avgGrowthPerMinute: number // bytes per minute\n  isLeaking: boolean // >10MB growth per minute sustained\n  peakRss: number\n  currentRss: number\n}\n\n// Parse memory string like \"123456 kB\" to bytes\nfunction parseMemoryKb(memStr: string): number {\n  const match = memStr.match(/(\\d+)\\s*kB/i)\n  if (match) {\n    return parseInt(match[1], 10) * 1024\n  }\n  return 0\n}\n\nexport function useTauriDebug() {\n  const isEnabled = ref(false)\n  const memoryHistory = ref<MemorySnapshot[]>([])\n  const trend = ref<MemoryTrend | null>(null)\n  const lastError = ref<string | null>(null)\n\n  let monitorInterval: ReturnType<typeof setInterval> | null = null\n  const SAMPLE_INTERVAL_MS = 30000 // 30 seconds\n  const MAX_SAMPLES = 120 // Keep 1 hour of data (120 * 30s = 60 min)\n  const LEAK_THRESHOLD_BYTES_PER_MIN = 10 * 1024 * 1024 // 10MB/min is suspicious\n\n  /**\n   * Get current memory usage from Tauri backend\n   */\n  async function getMemoryUsage(): Promise<MemorySnapshot | null> {\n    if (!isTauri()) return null\n\n    try {\n      const { invoke } = await import('@tauri-apps/api/core')\n      const result = await invoke<string>('get_memory_usage')\n      const data = JSON.parse(result)\n\n      const snapshot: MemorySnapshot = {\n        timestamp: Date.now(),\n        pid: data.pid,\n        rss: data.rss,\n        virtual: data.virtual,\n        platform: data.platform,\n        rssBytes: parseMemoryKb(data.rss)\n      }\n\n      return snapshot\n    } catch (error) {\n      console.error('[TauriDebug] Failed to get memory usage:', error)\n      lastError.value = String(error)\n      return null\n    }\n  }\n\n  /**\n   * Calculate memory trend from history\n   */\n  function calculateTrend(): MemoryTrend | null {\n    const samples = memoryHistory.value\n    if (samples.length < 2) return null\n\n    const validSamples = samples.filter(s => s.rssBytes && s.rssBytes > 0)\n    if (validSamples.length < 2) return null\n\n    // Calculate growth rate\n    const first = validSamples[0]\n    const last = validSamples[validSamples.length - 1]\n    const timeSpanMinutes = (last.timestamp - first.timestamp) / 60000\n\n    if (timeSpanMinutes < 1) return null\n\n    const growthBytes = (last.rssBytes || 0) - (first.rssBytes || 0)\n    const avgGrowthPerMinute = growthBytes / timeSpanMinutes\n\n    // Find peak\n    const peakRss = Math.max(...validSamples.map(s => s.rssBytes || 0))\n    const currentRss = last.rssBytes || 0\n\n    // Detect sustained leak (check last 5 samples all growing)\n    const recentSamples = validSamples.slice(-5)\n    let isLeaking = false\n    if (recentSamples.length >= 5) {\n      let allGrowing = true\n      for (let i = 1; i < recentSamples.length; i++) {\n        if ((recentSamples[i].rssBytes || 0) <= (recentSamples[i - 1].rssBytes || 0)) {\n          allGrowing = false\n          break\n        }\n      }\n      isLeaking = allGrowing && avgGrowthPerMinute > LEAK_THRESHOLD_BYTES_PER_MIN\n    }\n\n    return {\n      samples: validSamples,\n      avgGrowthPerMinute,\n      isLeaking,\n      peakRss,\n      currentRss\n    }\n  }\n\n  /**\n   * Take a memory sample and update trend\n   */\n  async function sampleMemory() {\n    const snapshot = await getMemoryUsage()\n    if (!snapshot) return\n\n    memoryHistory.value.push(snapshot)\n\n    // Trim old samples\n    if (memoryHistory.value.length > MAX_SAMPLES) {\n      memoryHistory.value = memoryHistory.value.slice(-MAX_SAMPLES)\n    }\n\n    // Update trend\n    trend.value = calculateTrend()\n\n    // Log warning if leak detected\n    if (trend.value?.isLeaking) {\n      const mbPerMin = (trend.value.avgGrowthPerMinute / (1024 * 1024)).toFixed(2)\n      console.warn(\n        `[TauriDebug] Memory leak detected! Growing at ${mbPerMin} MB/min. ` +\n        `Current: ${(trend.value.currentRss / (1024 * 1024)).toFixed(1)} MB, ` +\n        `Peak: ${(trend.value.peakRss / (1024 * 1024)).toFixed(1)} MB`\n      )\n    }\n\n    // Log if memory is very high (>500MB)\n    if (snapshot.rssBytes && snapshot.rssBytes > 500 * 1024 * 1024) {\n      console.warn(\n        `[TauriDebug] High memory usage: ${(snapshot.rssBytes / (1024 * 1024)).toFixed(1)} MB`\n      )\n    }\n  }\n\n  /**\n   * Start memory monitoring\n   */\n  function startMonitoring() {\n    if (!isTauri()) {\n      console.log('[TauriDebug] Not in Tauri environment, monitoring disabled')\n      return\n    }\n\n    if (monitorInterval) {\n      console.log('[TauriDebug] Monitoring already active')\n      return\n    }\n\n    console.log('[TauriDebug] Starting memory monitoring (30s interval)')\n    isEnabled.value = true\n\n    // Take initial sample\n    sampleMemory()\n\n    // Start interval\n    monitorInterval = setInterval(sampleMemory, SAMPLE_INTERVAL_MS)\n  }\n\n  /**\n   * Stop memory monitoring\n   */\n  function stopMonitoring() {\n    if (monitorInterval) {\n      clearInterval(monitorInterval)\n      monitorInterval = null\n    }\n    isEnabled.value = false\n    console.log('[TauriDebug] Memory monitoring stopped')\n  }\n\n  /**\n   * Get summary for logging/display\n   */\n  function getSummary(): string {\n    if (!trend.value) return 'No data yet'\n\n    const currentMb = (trend.value.currentRss / (1024 * 1024)).toFixed(1)\n    const peakMb = (trend.value.peakRss / (1024 * 1024)).toFixed(1)\n    const growthMb = (trend.value.avgGrowthPerMinute / (1024 * 1024)).toFixed(2)\n\n    return `Memory: ${currentMb}MB (peak: ${peakMb}MB, growth: ${growthMb}MB/min)${trend.value.isLeaking ? ' [LEAK DETECTED]' : ''}`\n  }\n\n  /**\n   * Export history for debugging\n   */\n  function exportHistory(): string {\n    return JSON.stringify({\n      exportTime: new Date().toISOString(),\n      samples: memoryHistory.value,\n      trend: trend.value\n    }, null, 2)\n  }\n\n  // Auto-start in Tauri dev mode\n  onMounted(() => {\n    if (isTauri() && import.meta.env.DEV) {\n      startMonitoring()\n    }\n  })\n\n  onUnmounted(() => {\n    stopMonitoring()\n  })\n\n  return {\n    isEnabled,\n    memoryHistory,\n    trend,\n    lastError,\n\n    // Actions\n    getMemoryUsage,\n    sampleMemory,\n    startMonitoring,\n    stopMonitoring,\n    getSummary,\n    exportHistory\n  }\n}\n\n// Singleton for global access (e.g., from devtools)\nlet globalInstance: ReturnType<typeof useTauriDebug> | null = null\n\nexport function getTauriDebugInstance() {\n  if (!globalInstance) {\n    // Create instance outside of component context\n    globalInstance = {\n      isEnabled: ref(false),\n      memoryHistory: ref<MemorySnapshot[]>([]),\n      trend: ref<MemoryTrend | null>(null),\n      lastError: ref<string | null>(null),\n      getMemoryUsage: async () => null,\n      sampleMemory: async () => {},\n      startMonitoring: () => {},\n      stopMonitoring: () => {},\n      getSummary: () => 'Not initialized',\n      exportHistory: () => '{}'\n    }\n  }\n  return globalInstance\n}\n\n// Expose to window for debugging (DEV only)\nif (import.meta.env.DEV && typeof window !== 'undefined') {\n  (window as any).__flowstate_tauri_debug = {\n    getSummary: () => globalInstance?.getSummary() || 'Not initialized',\n    exportHistory: () => globalInstance?.exportHistory() || '{}',\n    getTrend: () => globalInstance?.trend.value\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTauriOAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTauriStartup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTauriUpdater.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":116,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3392,3395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3392,3395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTextOverflow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useTimeBlockNotifications.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":191,"column":35,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":191,"endColumn":55,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6984,6985],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TASK-1219: Time Block Progress Notifications\n * Core composable that monitors calendar time blocks and fires milestone alerts.\n *\n * Polling: useIntervalFn every 15 seconds (60s too coarse for \"1 min before\", 1s wasteful).\n * Dedup: In-memory Set keyed by `taskId-instanceIndex-milestoneId`, reset at midnight.\n * Delivery: Reads settingsStore each tick; fires toast (in-app) and/or OS notification.\n * DND: Checks notification store's existing DND config.\n *\n * BUG-1302: Increased late tolerance from 2min to 10min, added delivery logging,\n * made singleton guard resilient to interval death.\n */\n\nimport { ref } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useSettingsStore } from '@/stores/settings'\nimport { useNotificationStore } from '@/stores/notifications'\nimport { useToast } from '@/composables/useToast'\nimport { deliverNotification } from '@/utils/notificationDelivery'\nimport type { TimeBlockMilestone } from '@/types/timeBlockNotifications'\nimport { DEFAULT_TIME_BLOCK_NOTIFICATION_SETTINGS } from '@/types/timeBlockNotifications'\nimport type { TaskInstance } from '@/types/tasks'\n\ninterface ActiveTimeBlock {\n  taskId: string\n  taskTitle: string\n  instanceIndex: number\n  startTime: Date\n  endTime: Date\n  durationMinutes: number\n  instance: TaskInstance\n}\n\n// Module-level singleton guard\nlet isInitialized = false\nlet tickCount = 0\nlet activeIntervalId: ReturnType<typeof setInterval> | null = null\n\nconst POLL_INTERVAL_MS = 15_000  // 15 seconds\n// BUG-1302: Increased from 2 min to 10 min — desktop apps may sleep/background,\n// causing setInterval to skip ticks. 10 min ensures milestones are caught on wake.\nconst LATE_TOLERANCE_MS = 10 * 60 * 1000\n\nexport function useTimeBlockNotifications() {\n  const taskStore = useTaskStore()\n  const settingsStore = useSettingsStore()\n  const notificationStore = useNotificationStore()\n  const { showToast } = useToast()\n\n  const shownMilestones = ref(new Set<string>())\n  const currentDate = ref(getTodayStr())\n\n  /**\n   * Defensive settings getter — falls back to defaults if settings store\n   * was loaded from persisted state that predates the timeBlockNotifications field.\n   */\n  function getSettings() {\n    return settingsStore.timeBlockNotifications ?? DEFAULT_TIME_BLOCK_NOTIFICATION_SETTINGS\n  }\n\n  function getTodayStr(): string {\n    const d = new Date()\n    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`\n  }\n\n  /**\n   * Get all active time blocks for today from task instances\n   */\n  function getActiveTimeBlocks(): ActiveTimeBlock[] {\n    const today = getTodayStr()\n    const blocks: ActiveTimeBlock[] = []\n\n    // IMPORTANT: Use rawTasks (unfiltered) — taskStore.tasks is filtered by\n    // active smart view/project/status filters and would miss tasks not in the current view\n    const tasks = Array.isArray(taskStore.rawTasks) ? taskStore.rawTasks : []\n\n    for (const task of tasks) {\n      // Skip completed/soft-deleted tasks\n      if (task.status === 'done' || task._soft_deleted) continue\n\n      // Path 1: Instance-based scheduling (primary path)\n      if (task.instances && Array.isArray(task.instances)) {\n        for (let i = 0; i < task.instances.length; i++) {\n          const inst = task.instances[i]\n          if (!inst || inst.scheduledDate !== today) continue\n          if (!inst.scheduledTime) continue\n          if (inst.status === 'skipped') continue\n\n          // Duration fallback: instance.duration → task.estimatedDuration → 30 (matches calendar)\n          const duration = inst.duration || task.estimatedDuration || 30\n\n          const [hours, minutes] = inst.scheduledTime.split(':').map(Number)\n          if (isNaN(hours) || isNaN(minutes)) continue\n\n          const start = new Date()\n          start.setHours(hours, minutes, 0, 0)\n          const end = new Date(start.getTime() + duration * 60_000)\n\n          blocks.push({\n            taskId: task.id,\n            taskTitle: task.title,\n            instanceIndex: i,\n            startTime: start,\n            endTime: end,\n            durationMinutes: duration,\n            instance: inst\n          })\n        }\n      }\n\n      // Path 2: Legacy task-level scheduling (task.scheduledDate + task.scheduledTime)\n      if (task.scheduledDate === today && task.scheduledTime) {\n        // Skip if we already found an instance for today (avoid duplicates)\n        const alreadyHasInstance = blocks.some(b => b.taskId === task.id)\n        if (alreadyHasInstance) continue\n\n        const [hours, minutes] = task.scheduledTime.split(':').map(Number)\n        if (isNaN(hours) || isNaN(minutes)) continue\n\n        const duration = task.estimatedDuration || 30\n        const start = new Date()\n        start.setHours(hours, minutes, 0, 0)\n        const end = new Date(start.getTime() + duration * 60_000)\n\n        // Create a synthetic instance for the legacy task\n        const syntheticInstance: TaskInstance = {\n          scheduledDate: today,\n          scheduledTime: task.scheduledTime,\n          duration\n        }\n\n        blocks.push({\n          taskId: task.id,\n          taskTitle: task.title,\n          instanceIndex: -1, // -1 signals legacy/synthetic\n          startTime: start,\n          endTime: end,\n          durationMinutes: duration,\n          instance: syntheticInstance\n        })\n      }\n    }\n\n    return blocks\n  }\n\n  /**\n   * Compute the trigger time for a milestone relative to a time block\n   */\n  function getMilestoneTriggerTime(milestone: TimeBlockMilestone, block: ActiveTimeBlock): Date | null {\n    switch (milestone.type) {\n      case 'percentage': {\n        const offsetMs = (milestone.value / 100) * block.durationMinutes * 60_000\n        return new Date(block.startTime.getTime() + offsetMs)\n      }\n      case 'before-end': {\n        // Skip if block duration is <= the before-end value\n        if (block.durationMinutes <= milestone.value) return null\n        return new Date(block.endTime.getTime() - milestone.value * 60_000)\n      }\n      case 'at-end': {\n        return new Date(block.endTime.getTime())\n      }\n      default:\n        return null\n    }\n  }\n\n  /**\n   * Build the dedup key for a milestone + block combination\n   */\n  function dedupKey(block: ActiveTimeBlock, milestone: TimeBlockMilestone): string {\n    return `${block.taskId}-${block.instanceIndex}-${milestone.id}`\n  }\n\n  /**\n   * Get effective milestones (global settings merged with per-instance overrides)\n   */\n  function getEffectiveMilestones(block: ActiveTimeBlock): TimeBlockMilestone[] {\n    const settings = getSettings()\n    const override = block.instance.timeBlockNotifications\n\n    // If override explicitly disables, return empty\n    if (override?.enabled === false) return []\n\n    let milestones = settings.milestones.filter(m => m.enabled)\n\n    // Apply per-instance milestone overrides\n    if (override?.milestones) {\n      milestones = milestones.map(m => {\n        const overrideMilestone = override.milestones!.find(om => om.id === m.id)\n        if (overrideMilestone) {\n          return { ...m, ...overrideMilestone } as TimeBlockMilestone\n        }\n        return m\n      }).filter(m => m.enabled)\n    }\n\n    return milestones\n  }\n\n  /**\n   * Check if currently in Do Not Disturb hours\n   */\n  function isInDND(): boolean {\n    const settings = getSettings()\n    if (!settings.respectDoNotDisturb) return false\n\n    const dndPrefs = notificationStore.defaultPreferences?.doNotDisturb\n    if (!dndPrefs?.enabled) return false\n\n    const currentHour = new Date().getHours()\n    if (dndPrefs.startHour > dndPrefs.endHour) {\n      // Overnight DND (e.g., 22:00 to 08:00)\n      return currentHour >= dndPrefs.startHour || currentHour < dndPrefs.endHour\n    } else {\n      return currentHour >= dndPrefs.startHour && currentHour < dndPrefs.endHour\n    }\n  }\n\n  /**\n   * Get the notification message for a milestone\n   */\n  function getMessage(milestone: TimeBlockMilestone, block: ActiveTimeBlock): string {\n    switch (milestone.id) {\n      case 'halfway':\n        return `Halfway through \"${block.taskTitle}\" (${Math.round(block.durationMinutes / 2)} min remaining)`\n      case '1min-before':\n        return `\"${block.taskTitle}\" ends in 1 minute`\n      case 'ended':\n        return `Time block \"${block.taskTitle}\" has ended`\n      default:\n        return `${milestone.label}: \"${block.taskTitle}\"`\n    }\n  }\n\n  /**\n   * Fire notifications for a milestone via configured channels\n   * BUG-1302: Added delivery logging for diagnostics\n   */\n  function fireMilestone(milestone: TimeBlockMilestone, block: ActiveTimeBlock): void {\n    const settings = getSettings()\n    const override = block.instance.timeBlockNotifications\n    const channels = { ...settings.deliveryChannels, ...override?.deliveryChannels }\n\n    const message = getMessage(milestone, block)\n    const title = milestone.id === 'ended' ? 'Time Block Ended' : 'Time Block Alert'\n\n    console.log(`[TIME-BLOCK] Delivering milestone \"${milestone.id}\" via channels:`, {\n      inAppToast: channels.inAppToast,\n      osNotification: channels.osNotification,\n      sound: channels.sound\n    })\n\n    if (channels.inAppToast) {\n      const toastType = milestone.id === 'ended' ? 'warning' : 'info'\n      showToast(message, toastType, { duration: 8000 })\n      console.log('[TIME-BLOCK] Toast delivered:', message)\n    }\n\n    if (channels.osNotification) {\n      deliverNotification({\n        title,\n        body: message,\n        tag: `timeblock-${block.taskId}-${milestone.id}`,\n        sound: channels.sound\n      }).then(success => {\n        if (success) {\n          console.log('[TIME-BLOCK] OS notification delivered')\n        } else {\n          console.warn('[TIME-BLOCK] OS notification failed — check permission status')\n        }\n      }).catch(err => {\n        console.error('[TIME-BLOCK] OS notification error:', err)\n      })\n    }\n  }\n\n  /**\n   * Main tick: scan all active blocks, check milestones, fire notifications\n   */\n  function tick(): void {\n    try {\n      tickCount++\n      const settings = getSettings()\n      if (!settings?.enabled) {\n        if (tickCount <= 3) console.log('[TIME-BLOCK] Disabled in settings, skipping tick')\n        return\n      }\n\n      // Midnight reset\n      const today = getTodayStr()\n      if (today !== currentDate.value) {\n        shownMilestones.value.clear()\n        currentDate.value = today\n      }\n\n      // DND check\n      if (isInDND()) {\n        if (tickCount <= 3) console.log('[TIME-BLOCK] DND active, skipping tick')\n        return\n      }\n\n      const now = Date.now()\n      const blocks = getActiveTimeBlocks()\n\n      // Diagnostic: log every tick for the first 4 ticks, then every 20th tick\n      if (tickCount <= 4 || tickCount % 20 === 0) {\n        const tasks = Array.isArray(taskStore.rawTasks) ? taskStore.rawTasks : []\n        const tasksWithInstances = tasks.filter(t => t.instances?.length)\n        const tasksWithSchedule = tasks.filter(t => t.scheduledDate === today)\n        console.log(`[TIME-BLOCK] Tick #${tickCount}: ${blocks.length} blocks found | ${tasks.length} total tasks | ${tasksWithInstances.length} with instances | ${tasksWithSchedule.length} with scheduledDate=today(${today}) | Notification.permission=${typeof Notification !== 'undefined' ? Notification.permission : 'N/A'}`)\n\n        if (blocks.length === 0 && (tasksWithInstances.length > 0 || tasksWithSchedule.length > 0)) {\n          // We have tasks but no blocks detected — log WHY\n          for (const task of tasksWithInstances.slice(0, 3)) {\n            const todayInst = task.instances?.filter(i => i?.scheduledDate === today)\n            console.log(`[TIME-BLOCK] Task \"${task.title}\": ${task.instances?.length} instances, ${todayInst?.length} for today`, todayInst?.map(i => ({\n              date: i.scheduledDate,\n              time: i.scheduledTime,\n              duration: i.duration,\n              status: i.status\n            })))\n          }\n          for (const task of tasksWithSchedule.slice(0, 3)) {\n            console.log(`[TIME-BLOCK] Legacy task \"${task.title}\": scheduledDate=${task.scheduledDate} scheduledTime=${task.scheduledTime} duration=${task.estimatedDuration}`)\n          }\n        }\n      }\n\n      if (blocks.length > 0 && (tickCount <= 4 || tickCount % 20 === 0)) {\n        console.log(`[TIME-BLOCK] Active blocks:`, blocks.map(b => ({\n          task: b.taskTitle,\n          start: b.startTime.toLocaleTimeString(),\n          end: b.endTime.toLocaleTimeString(),\n          duration: b.durationMinutes + 'min'\n        })))\n      }\n\n      for (const block of blocks) {\n        const milestones = getEffectiveMilestones(block)\n\n        for (const milestone of milestones) {\n          const key = dedupKey(block, milestone)\n          if (shownMilestones.value.has(key)) continue\n\n          const triggerTime = getMilestoneTriggerTime(milestone, block)\n          if (!triggerTime) continue\n\n          const triggerMs = triggerTime.getTime()\n\n          // Fire if trigger time has passed and we're within the tolerance window\n          // BUG-1302: Tolerance increased to 10 min for desktop sleep/background resilience\n          if (now >= triggerMs && now - triggerMs <= LATE_TOLERANCE_MS) {\n            const lateBy = Math.round((now - triggerMs) / 1000)\n            console.log(`[TIME-BLOCK] 🔔 FIRING milestone \"${milestone.id}\" for \"${block.taskTitle}\" (${lateBy}s after trigger)`)\n            shownMilestones.value.add(key)\n            fireMilestone(milestone, block)\n          }\n        }\n      }\n    } catch (err) {\n      console.error('[TIME-BLOCK] Tick error (non-fatal):', err)\n    }\n  }\n\n  function start(): void {\n    // BUG-1302: Resilient singleton — if interval died (e.g., GC), allow restart\n    if (isInitialized && activeIntervalId !== null) {\n      console.log('[TIME-BLOCK] Already initialized, skipping')\n      return\n    }\n\n    // Clean up dead state if needed\n    if (isInitialized && activeIntervalId === null) {\n      console.warn('[TIME-BLOCK] Singleton guard was set but interval was dead — restarting')\n    }\n\n    isInitialized = true\n\n    const settings = getSettings()\n    const permissionStatus = typeof Notification !== 'undefined' ? Notification.permission : 'N/A'\n    console.log('[TIME-BLOCK] Starting with settings:', {\n      enabled: settings.enabled,\n      milestones: settings.milestones.map(m => `${m.id}(${m.enabled ? 'on' : 'off'})`),\n      channels: settings.deliveryChannels,\n      totalTasks: taskStore.rawTasks?.length ?? 0,\n      notificationPermission: permissionStatus,\n      lateTolerance: `${LATE_TOLERANCE_MS / 60000} min`\n    })\n\n    // Run immediately once, then every 15 seconds\n    tick()\n    activeIntervalId = setInterval(tick, POLL_INTERVAL_MS)\n    console.log('[TIME-BLOCK] Notification polling started (15s interval)')\n  }\n\n  function stop(): void {\n    if (activeIntervalId) {\n      clearInterval(activeIntervalId)\n      activeIntervalId = null\n    }\n    isInitialized = false\n    console.log('[TIME-BLOCK] Notification polling stopped')\n  }\n\n  // NOTE: No onUnmounted — this composable is called inside onMounted (outside\n  // Vue setup context), so lifecycle hooks don't attach. The singleton guard\n  // + module-level activeIntervalId ensure cleanup via stop() if ever needed.\n\n  return {\n    start,\n    stop,\n    shownMilestones,\n    // Exposed for testing\n    getActiveTimeBlocks,\n    tick\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useToast.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ref' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":13,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ref"},"fix":{"range":[0,25],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\n\nexport type ToastType = 'success' | 'error' | 'info' | 'warning'\n\ninterface ToastOptions {\n    duration?: number\n    position?: 'top-right' | 'bottom-right' | 'top-center' | 'bottom-center'\n}\n\n// Singleton state to avoid multiple containers\nlet toastContainer: HTMLDivElement | null = null\n\nfunction getOrCreateContainer(): HTMLDivElement {\n    if (toastContainer) return toastContainer\n\n    toastContainer = document.createElement('div')\n    toastContainer.id = 'toast-container'\n    toastContainer.style.cssText = `\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    z-index: 10000;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    pointer-events: none; /* Allow clicking through container */\n  `\n    document.body.appendChild(toastContainer)\n    return toastContainer\n}\n\nexport function useToast() {\n    const showToast = (message: string, type: ToastType = 'info', options: ToastOptions = {}) => {\n        const container = getOrCreateContainer()\n        const { duration = 3000 } = options\n\n        const toast = document.createElement('div')\n\n        // Icon selection\n        let icon = 'ℹ️'\n        let bgColor = 'var(--bg-card, #1e293b)' // Default dark\n        let borderColor = 'var(--border-color, #334155)'\n\n        switch (type) {\n            case 'success':\n                icon = '✓'\n                bgColor = 'var(--success-bg-start, #064e3b)' // Dark green\n                borderColor = 'var(--color-success, #10b981)'\n                break\n            case 'error':\n                icon = '✕'\n                bgColor = 'var(--danger-bg-start, #450a0a)' // Dark red\n                borderColor = 'var(--color-danger, #ef4444)'\n                break\n            case 'warning':\n                icon = '⚠️'\n                bgColor = 'var(--warning-bg-start, #451a03)' // Dark orange\n                borderColor = 'var(--color-warning, #f59e0b)'\n                break\n            case 'info':\n            default:\n                icon = 'ℹ️' // Default blue-ish\n                bgColor = 'var(--info-bg-start, #0f172a)'\n                borderColor = 'var(--color-info, #3b82f6)'\n                break\n        }\n\n        toast.style.cssText = `\n      background: ${bgColor};\n      color: white; /* Always white text on dark toasts */\n      padding: 12px 16px;\n      border-radius: 8px;\n      border-left: 4px solid ${borderColor};\n      display: flex;\n      align-items: center;\n      gap: 12px;\n      font-size: 14px;\n      font-weight: 500;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);\n      animation: slideIn 0.2s ease-out;\n      min-width: 240px;\n      max-width: 400px;\n      pointer-events: auto; /* Allow clicking the toast itself */\n      backdrop-filter: blur(8px);\n    `\n\n        // Create content\n        const iconSpan = document.createElement('span')\n        iconSpan.style.fontWeight = 'bold'\n        iconSpan.style.fontSize = '16px'\n        iconSpan.textContent = icon\n\n        const messageSpan = document.createElement('span')\n        messageSpan.textContent = message\n        messageSpan.style.flex = '1'\n        messageSpan.style.lineHeight = '1.4'\n\n        toast.appendChild(iconSpan)\n        toast.appendChild(messageSpan)\n\n        // Add animation styles if needed\n        if (!document.querySelector('#toast-animations')) {\n            const style = document.createElement('style')\n            style.id = 'toast-animations'\n            style.textContent = `\n        @keyframes slideIn {\n          from { transform: translateX(100%); opacity: 0; }\n          to { transform: translateX(0); opacity: 1; }\n        }\n        @keyframes slideOut {\n          from { transform: translateX(0); opacity: 1; }\n          to { transform: translateX(100%); opacity: 0; }\n        }\n      `\n            document.head.appendChild(style)\n        }\n\n        container.appendChild(toast)\n\n        // Auto removal\n        setTimeout(() => {\n            toast.style.animation = 'slideOut 0.2s ease-out'\n            // Wait for animation to finish\n            setTimeout(() => {\n                if (toast.parentNode) {\n                    toast.parentNode.removeChild(toast)\n                }\n            }, 200)\n        }, duration)\n    }\n\n    return { showToast }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useUnifiedUndoRedo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useVirtualScrolling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useVoiceNLPParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useVoiceTaskParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useWakeLock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useWeeklyPlan.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DAY_OF_WEEK_KEYWORDS' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":50,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"DAY_OF_WEEK_KEYWORDS"},"fix":{"range":[221,243],"text":""},"desc":"Remove unused variable \"DAY_OF_WEEK_KEYWORDS\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DayKey' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":6,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'weekStartsOn' is assigned a value but never used. Allowed unused args must match /^_/u.","line":97,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":97,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'appliedStats' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":623,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":623,"endColumn":21}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, type Ref } from 'vue'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useSettingsStore } from '@/stores/settings'\nimport { detectPowerKeyword, DAY_OF_WEEK_KEYWORDS } from '@/composables/usePowerKeywords'\nimport { useWeeklyPlanAI, type WeeklyPlan, type WeeklyPlanState, type WeeklyPlanStatus, type TaskSummary, type InterviewAnswers, type BehavioralContext } from './useWeeklyPlanAI'\nimport { useWorkProfile } from '@/composables/useWorkProfile'\nimport { useProjectStore } from '@/stores/projects'\nimport type { MemoryObservation } from '@/utils/supabaseMappers'\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nconst DAY_KEYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const\ntype DayKey = typeof DAY_KEYS[number]\n\n// TASK-1321: Parameterized week start to support Sunday or Monday start\nfunction getWeekStart(weekStartsOn: 0 | 1 = 0): Date {\n  const now = new Date()\n  const day = now.getDay() // 0=Sun, 1=Mon...6=Sat\n\n  if (weekStartsOn === 1) {\n    // Monday start: go back to this week's Monday\n    const diff = day === 0 ? -6 : 1 - day\n    const start = new Date(now)\n    start.setDate(now.getDate() + diff)\n    start.setHours(0, 0, 0, 0)\n    return start\n  } else {\n    // Sunday start: go back to this week's Sunday\n    const start = new Date(now)\n    start.setDate(now.getDate() - day)\n    start.setHours(0, 0, 0, 0)\n    return start\n  }\n}\n\nfunction getWeekEnd(weekStartsOn: 0 | 1 = 0): Date {\n  const start = getWeekStart(weekStartsOn)\n  const end = new Date(start)\n  end.setDate(start.getDate() + 6)\n  end.setHours(23, 59, 59, 999)\n  return end\n}\n\n// BUG-1321: Use local date (not UTC) to avoid timezone-related overdue false positives\nfunction formatDateISO(d: Date): string {\n  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`\n}\n\n// ============================================================================\n// Singleton state — persists across navigations AND page refreshes via localStorage\n// ============================================================================\n\nconst ONE_DAY_MS = 24 * 60 * 60 * 1000\nconst STORAGE_KEY = 'flowstate-weekly-plan'\n\nlet _state: Ref<WeeklyPlanState> | null = null\nlet _stateCreatedAt = 0\n\ninterface StoredPlanState {\n  status: WeeklyPlanStatus\n  plan: WeeklyPlan | null\n  reasoning: string | null\n  taskReasons: Record<string, string>\n  weekTheme: string | null\n  error: string | null\n  weekStart: string  // ISO string\n  weekEnd: string    // ISO string\n  interviewAnswers: InterviewAnswers | null\n  savedAt: number\n}\n\nfunction savePlanToStorage(state: WeeklyPlanState) {\n  try {\n    // Only persist review/applied states — not transient states\n    if (state.status !== 'review' && state.status !== 'applied') return\n    const stored: StoredPlanState = {\n      status: state.status,\n      plan: state.plan,\n      reasoning: state.reasoning,\n      taskReasons: state.taskReasons,\n      weekTheme: state.weekTheme,\n      error: null,\n      weekStart: state.weekStart.toISOString(),\n      weekEnd: state.weekEnd.toISOString(),\n      interviewAnswers: state.interviewAnswers,\n      savedAt: Date.now(),\n    }\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(stored))\n  } catch {\n    // localStorage might be full or unavailable — ignore\n  }\n}\n\nfunction loadPlanFromStorage(weekStartsOn: 0 | 1 = 0): WeeklyPlanState | null {\n  try {\n    const raw = localStorage.getItem(STORAGE_KEY)\n    if (!raw) return null\n\n    const stored: StoredPlanState = JSON.parse(raw)\n\n    // Expire after 1 day\n    if (Date.now() - stored.savedAt > ONE_DAY_MS) {\n      localStorage.removeItem(STORAGE_KEY)\n      return null\n    }\n\n    // Only restore review/applied states\n    if (stored.status !== 'review' && stored.status !== 'applied') return null\n\n    return {\n      status: stored.status,\n      plan: stored.plan,\n      reasoning: stored.reasoning,\n      taskReasons: stored.taskReasons || {},\n      weekTheme: stored.weekTheme || null,\n      error: null,\n      weekStart: new Date(stored.weekStart),\n      weekEnd: new Date(stored.weekEnd),\n      interviewAnswers: stored.interviewAnswers,\n    }\n  } catch {\n    localStorage.removeItem(STORAGE_KEY)\n    return null\n  }\n}\n\nfunction clearPlanStorage() {\n  try { localStorage.removeItem(STORAGE_KEY) } catch { /* ignore */ }\n}\n\nfunction getOrCreateState(weekStartsOn: 0 | 1 = 0): Ref<WeeklyPlanState> {\n  const now = Date.now()\n\n  // Expire after 1 day\n  if (_state && (now - _stateCreatedAt) > ONE_DAY_MS) {\n    _state = null\n  }\n\n  if (!_state) {\n    // Try restoring from localStorage first\n    const restored = loadPlanFromStorage(weekStartsOn)\n    if (restored) {\n      _state = ref<WeeklyPlanState>(restored)\n      _stateCreatedAt = now\n      return _state\n    }\n\n    _state = ref<WeeklyPlanState>({\n      status: 'idle',\n      plan: null,\n      reasoning: null,\n      taskReasons: {},\n      weekTheme: null,\n      error: null,\n      weekStart: getWeekStart(weekStartsOn),\n      weekEnd: getWeekEnd(weekStartsOn),\n      interviewAnswers: null,\n    })\n    _stateCreatedAt = now\n  }\n\n  return _state\n}\n\n// ============================================================================\n// Composable\n// ============================================================================\n\nexport function useWeeklyPlan() {\n  const settings = useSettingsStore()\n\n  const state = getOrCreateState(settings.weekStartsOn)\n\n  const { generatePlan: aiGeneratePlan, regenerateDay: aiRegenerateDay } = useWeeklyPlanAI()\n  const { loadProfile, reloadProfile, computeCapacityMetrics, recordWeeklyOutcome, generateObservationsFromWeeklyOutcome, profile: workProfile } = useWorkProfile()\n\n  // --------------------------------------------------------------------------\n  // Eligible tasks\n  // --------------------------------------------------------------------------\n\n  function getEligibleTasks(): TaskSummary[] {\n    const taskStore = useTaskStore()\n    const projectStore = useProjectStore()\n    const today = formatDateISO(new Date())\n    const weekEnd = formatDateISO(state.value.weekEnd)\n\n    // ── HARD FILTER: Deterministic rules decide what's eligible ──\n    // Research consensus: production apps (Motion, Reclaim) use deterministic\n    // rules for filtering. LLMs are unreliable at deciding task relevance.\n    const eligible = taskStore.tasks.filter(t => {\n      if (t._soft_deleted) return false\n      if (t.status === 'done') return false\n\n      // HARD EXCLUDE: Task has due date AFTER this week\n      // If the user set a future date, they decided it's not for this week.\n      // Exception: in_progress tasks (user started it, keep it regardless)\n      if (t.dueDate && t.dueDate > weekEnd && t.status !== 'in_progress') return false\n\n      // HARD EXCLUDE: on_hold — user explicitly paused\n      if (t.status === 'on_hold') return false\n\n      return true\n    })\n\n    // ── SCORING: Sort remaining by relevance (for top-N selection) ──\n    const priorityScore: Record<string, number> = { high: 3, medium: 2, low: 1 }\n\n    function relevanceScore(t: typeof eligible[0]): number {\n      let score = 0\n\n      // Overdue: MUST be scheduled\n      if (t.dueDate && t.dueDate < today) score += 100\n      // Due this week: highly relevant\n      else if (t.dueDate && t.dueDate <= weekEnd) score += 80\n\n      // In-progress: already started, must continue\n      if (t.status === 'in_progress') score += 60\n      // Planned: user has actively planned this\n      else if (t.status === 'planned') score += 30\n\n      // Priority\n      score += (priorityScore[t.priority || ''] || 0) * 10\n\n      // Has estimated duration: user has thought about it\n      if (t.estimatedDuration) score += 5\n\n      return score\n    }\n\n    // Score, sort, and take top 25 (tighter — only real candidates)\n    const scored = eligible.map(t => ({ task: t, score: relevanceScore(t) }))\n    scored.sort((a, b) => b.score - a.score)\n\n    const result = scored.slice(0, 25).map(({ task: t }) => ({\n      id: t.id,\n      title: t.title,\n      priority: t.priority,\n      dueDate: t.dueDate || '',\n      estimatedDuration: t.estimatedDuration,\n      status: t.status,\n      projectId: t.projectId || '',\n      projectName: t.projectId ? (projectStore.getProjectDisplayName(t.projectId) || '') : '',\n      description: t.description || '',\n      subtaskCount: t.subtasks?.length || 0,\n      completedSubtaskCount: t.subtasks?.filter(s => s.isCompleted).length || 0,\n    }))\n\n    console.log(`[WeeklyPlan] Eligible: ${eligible.length} tasks after hard filter (${taskStore.tasks.length} total), sending top ${result.length} to AI`)\n    return result\n  }\n\n  // --------------------------------------------------------------------------\n  // Task map for quick lookup\n  // --------------------------------------------------------------------------\n\n  const taskMap = computed(() => {\n    const tasks = getEligibleTasks()\n    const map = new Map<string, TaskSummary>()\n    for (const t of tasks) {\n      map.set(t.id, t)\n    }\n    return map\n  })\n\n  // --------------------------------------------------------------------------\n  // Behavioral context from actual usage data\n  // --------------------------------------------------------------------------\n\n  function computeBehavioralContext(profile: ReturnType<typeof useWorkProfile>['profile']['value']): BehavioralContext {\n    const taskStore = useTaskStore()\n    const projectStore = useProjectStore()\n\n    const twoWeeksAgo = new Date()\n    twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14)\n\n    // Recently completed tasks (last 2 weeks)\n    const recentlyCompleted = taskStore.tasks.filter(t => {\n      if (t.status !== 'done') return false\n      const completedDate = t.completedAt ? new Date(t.completedAt as string) : null\n      return completedDate && completedDate >= twoWeeksAgo\n    })\n\n    const recentlyCompletedTitles = recentlyCompleted\n      .sort((a, b) => {\n        const da = a.completedAt ? new Date(a.completedAt as string).getTime() : 0\n        const db = b.completedAt ? new Date(b.completedAt as string).getTime() : 0\n        return db - da\n      })\n      .slice(0, 15)\n      .map(t => t.title)\n\n    // Active projects — projects with recently completed or in-progress tasks\n    const activeProjectIds = new Set<string>()\n    for (const t of recentlyCompleted) {\n      if (t.projectId) activeProjectIds.add(t.projectId)\n    }\n    for (const t of taskStore.tasks) {\n      if (t.status === 'in_progress' && t.projectId) activeProjectIds.add(t.projectId)\n    }\n    const activeProjectNames = Array.from(activeProjectIds)\n      .map(id => projectStore.getProjectDisplayName(id))\n      .filter(Boolean) as string[]\n\n    // Frequently missed projects from memory observations\n    const frequentlyMissedProjects: string[] = []\n    const workInsights: string[] = []\n    if (profile && profile.memoryGraph) {\n      // Map observation relations to actionable planning advice\n      const insightMap: Record<string, (obs: MemoryObservation) => string | null> = {\n        'overdue_pattern': (obs) => `${obs.value} — prioritize clearing overdue items early in the week`,\n        'backlog_heavy': (obs) => `${obs.value} — avoid adding new tasks, focus on clearing existing work`,\n        'high_wip': (obs) => `${obs.value} — limit new starts, prioritize finishing in-progress tasks`,\n        'underestimates': (obs) => `User ${obs.value} — schedule fewer tasks per day to be realistic`,\n        'overestimates': (obs) => `User ${obs.value} — can schedule more tasks per day`,\n        'avg_completion_speed': (obs) => `Task completion speed: ${obs.value}`,\n        'capacity_gap': (obs) => `Capacity gap: ${obs.value} — schedule conservatively`,\n        'stale': (obs) => `${obs.entity.replace('project:', '')} is stale (${obs.value}) — consider scheduling 1 task from it`,\n        'most_active': (obs) => `${obs.entity.replace('project:', '')} is the most active project (${obs.value})`,\n        'completion_rate': (obs) => `High-priority ${obs.value}`,\n      }\n\n      for (const obs of profile.memoryGraph) {\n        if (obs.relation === 'frequently_missed' && obs.entity.startsWith('project:')) {\n          const projId = obs.entity.replace('project:', '')\n          const name = projectStore.getProjectDisplayName(projId)\n          if (name) frequentlyMissedProjects.push(name)\n        }\n\n        // Generate planning-relevant insights from observations\n        const mapper = insightMap[obs.relation]\n        if (mapper && obs.confidence >= 0.6) {\n          const insight = mapper(obs)\n          if (insight) workInsights.push(insight)\n        }\n      }\n    }\n\n    return {\n      recentlyCompletedTitles,\n      activeProjectNames,\n      avgTasksCompletedPerDay: profile?.avgTasksCompletedPerDay ?? null,\n      avgWorkMinutesPerDay: profile?.avgWorkMinutesPerDay ?? null,\n      peakProductivityDays: profile?.peakProductivityDays ?? [],\n      completionRate: profile?.avgPlanAccuracy ?? null,\n      frequentlyMissedProjects,\n      workInsights,\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Generate plan via AI\n  // --------------------------------------------------------------------------\n\n  async function generatePlan(interview?: InterviewAnswers) {\n    state.value.status = 'loading'\n    state.value.error = null\n    if (interview) {\n      state.value.interviewAnswers = interview\n    }\n\n    try {\n      const tasks = getEligibleTasks()\n      if (tasks.length === 0) {\n        state.value.status = 'error'\n        state.value.error = 'No eligible tasks found'\n        return\n      }\n\n      // FEATURE-1317: Load work profile + auto-refresh insights for AI context\n      const settingsStore = useSettingsStore()\n      let profile = null\n      if (settingsStore.aiLearningEnabled) {\n        profile = await loadProfile()\n        // Auto-refresh observations so AI always gets current task context\n        try {\n          await computeCapacityMetrics()\n          profile = await reloadProfile()\n        } catch (e) {\n          console.debug('[WeeklyPlan] Insight refresh skipped:', e)\n        }\n      }\n\n      // Compute behavioral context from actual app usage data\n      const behavioral = computeBehavioralContext(profile)\n      console.log('[WeeklyPlan] Behavioral context:', {\n        recentCompleted: behavioral.recentlyCompletedTitles.length,\n        activeProjects: behavioral.activeProjectNames,\n        avgTasks: behavioral.avgTasksCompletedPerDay,\n        completionRate: behavioral.completionRate,\n      })\n\n      const result = await aiGeneratePlan(tasks, state.value.interviewAnswers || undefined, profile, behavioral)\n      state.value.plan = result.plan\n      state.value.reasoning = result.reasoning\n      state.value.taskReasons = result.taskReasons\n      state.value.weekTheme = result.weekTheme\n      state.value.status = 'review'\n      savePlanToStorage(state.value)\n    } catch (err) {\n      state.value.status = 'error'\n      state.value.error = err instanceof Error ? err.message : 'Failed to generate plan'\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Move task between days (drag-drop in review UI)\n  // --------------------------------------------------------------------------\n\n  function moveTask(taskId: string, fromDay: keyof WeeklyPlan, toDay: keyof WeeklyPlan) {\n    if (!state.value.plan) return\n    const fromArr = state.value.plan[fromDay]\n    const idx = fromArr.indexOf(taskId)\n    if (idx !== -1) {\n      fromArr.splice(idx, 1)\n    }\n    state.value.plan[toDay].push(taskId)\n    savePlanToStorage(state.value)\n  }\n\n  // --------------------------------------------------------------------------\n  // Interview mode\n  // --------------------------------------------------------------------------\n\n  function startInterview() {\n    state.value.status = 'interview'\n    state.value.interviewAnswers = null\n  }\n\n  function skipInterview() {\n    generatePlan()\n  }\n\n  function submitInterview(answers: InterviewAnswers) {\n    generatePlan(answers)\n  }\n\n  // --------------------------------------------------------------------------\n  // Quick actions: remove, snooze, priority cycle\n  // --------------------------------------------------------------------------\n\n  function removeTaskFromPlan(taskId: string) {\n    if (!state.value.plan) return\n    const allKeys = [...DAY_KEYS, 'unscheduled'] as const\n    for (const key of allKeys) {\n      const arr = state.value.plan[key]\n      const idx = arr.indexOf(taskId)\n      if (idx !== -1) {\n        arr.splice(idx, 1)\n        break\n      }\n    }\n    // Move to unscheduled\n    state.value.plan.unscheduled.push(taskId)\n    savePlanToStorage(state.value)\n  }\n\n  function snoozeTask(taskId: string) {\n    if (!state.value.plan) return\n    // Remove from all days (including unscheduled)\n    const allKeys = [...DAY_KEYS, 'unscheduled'] as const\n    for (const key of allKeys) {\n      const arr = state.value.plan[key]\n      const idx = arr.indexOf(taskId)\n      if (idx !== -1) {\n        arr.splice(idx, 1)\n        break\n      }\n    }\n    // Task is simply removed from the plan — it stays in the task store\n    // and will appear next week as an eligible task\n    savePlanToStorage(state.value)\n  }\n\n  function changePriority(taskId: string) {\n    const taskStore = useTaskStore()\n    const task = taskStore.tasks.find(t => t.id === taskId)\n    if (!task) return\n\n    const cycle: Array<'low' | 'medium' | 'high' | null> = ['low', 'medium', 'high', null]\n    const currentIdx = cycle.indexOf(task.priority)\n    const nextPriority = cycle[(currentIdx + 1) % cycle.length]\n    taskStore.updateTask(taskId, { priority: nextPriority })\n  }\n\n  // --------------------------------------------------------------------------\n  // Re-suggest a single day via AI\n  // --------------------------------------------------------------------------\n\n  async function regenerateDay(dayKey: typeof DAY_KEYS[number]) {\n    if (!state.value.plan) return\n\n    try {\n      const tasks = getEligibleTasks()\n      const profile = workProfile.value\n      const result = await aiRegenerateDay(dayKey, state.value.plan, tasks, profile)\n\n      // Merge result into existing plan\n      state.value.plan[dayKey] = result.dayTasks\n      state.value.plan.unscheduled = result.unscheduled\n      if (result.reasoning) {\n        state.value.reasoning = result.reasoning\n      }\n      savePlanToStorage(state.value)\n    } catch (err) {\n      console.warn('[WeeklyPlan] Day re-suggest failed', err)\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Apply plan: assign tasks to day groups + set dueDates\n  // --------------------------------------------------------------------------\n\n  async function applyPlan() {\n    if (!state.value.plan) return\n\n    state.value.status = 'applying'\n\n    try {\n      const canvasStore = useCanvasStore()\n      const taskStore = useTaskStore()\n      const plan = state.value.plan\n\n      // Day-of-week index mapping: DAY_OF_WEEK_KEYWORDS uses JS day indices (0=Sun...6=Sat)\n      // But we iterate DAY_KEYS as [Mon=0, Tue=1, ...Sun=6] in our array\n      // JS Date getDay(): 0=Sun, 1=Mon...6=Sat\n      const jsDayIndices = [1, 2, 3, 4, 5, 6, 0] // Mon=1, Tue=2, ...Sun=0\n\n      for (let dayIndex = 0; dayIndex < DAY_KEYS.length; dayIndex++) {\n        const dayKey = DAY_KEYS[dayIndex]\n        const taskIds = plan[dayKey]\n        if (!taskIds || taskIds.length === 0) continue\n\n        // Calculate target date\n        const targetDate = new Date(state.value.weekStart)\n        targetDate.setDate(state.value.weekStart.getDate() + dayIndex)\n        const targetDateISO = formatDateISO(targetDate)\n\n        // Find existing day-of-week group on canvas\n        const jsDayIndex = jsDayIndices[dayIndex]\n        let groupId: string | null = null\n\n        for (const group of canvasStore.groups) {\n          const result = detectPowerKeyword(group.name)\n          if (result && result.category === 'day_of_week' && result.value === String(jsDayIndex)) {\n            groupId = group.id\n            break\n          }\n        }\n\n        // Create group if none exists\n        if (!groupId) {\n          const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n          const dayColors = ['#3b82f6', '#8b5cf6', '#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#ec4899']\n\n          const newGroup = await canvasStore.createGroup({\n            name: dayNames[dayIndex],\n            type: 'timeline',\n            position: { x: 100 + (dayIndex * 450), y: 100, width: 400, height: 500 },\n            color: dayColors[dayIndex],\n            layout: 'vertical',\n            isVisible: true,\n            isCollapsed: false,\n            parentGroupId: null,\n          })\n\n          if (newGroup) {\n            groupId = newGroup.id\n          }\n        }\n\n        // Assign tasks to group + set dueDate\n        // NOTE: Only parentId and dueDate. NEVER set canvasPosition (geometry invariant).\n        for (const taskId of taskIds) {\n          const updates: Record<string, unknown> = { dueDate: targetDateISO }\n          if (groupId) {\n            updates.parentId = groupId\n          }\n          await taskStore.updateTask(taskId, updates)\n        }\n      }\n\n      // FEATURE-1317: Record weekly outcome for feedback loop\n      const settingsStoreForFeedback = useSettingsStore()\n      if (settingsStoreForFeedback.aiLearningEnabled) {\n        // Collect all planned task IDs from this plan\n        const allPlannedIds: string[] = []\n        for (const dayKey of DAY_KEYS) {\n          allPlannedIds.push(...plan[dayKey])\n        }\n        if (allPlannedIds.length > 0) {\n          // Get completed task IDs from the task store\n          const completedIds = taskStore.tasks\n            .filter(t => t.status === 'done' && allPlannedIds.includes(t.id))\n            .map(t => t.id)\n          // Fire-and-forget: record outcome + generate observations\n          recordWeeklyOutcome(allPlannedIds, completedIds)\n            .then(() => {\n              // FEATURE-1317 Phase 2: Generate structured observations from this week's data\n              return generateObservationsFromWeeklyOutcome(allPlannedIds, completedIds, taskStore)\n            })\n            .catch(err => console.warn('[WeeklyPlan] Failed to record weekly outcome:', err))\n        }\n      }\n\n      state.value.status = 'applied'\n      savePlanToStorage(state.value)\n    } catch (err) {\n      state.value.status = 'error'\n      state.value.error = err instanceof Error ? err.message : 'Failed to apply plan'\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Computed helpers\n  // --------------------------------------------------------------------------\n\n  const eligibleTasks = computed(() => getEligibleTasks())\n  const eligibleTaskCount = computed(() => getEligibleTasks().length)\n\n  const appliedStats = computed(() => {\n    if (state.value.status !== 'applied' || !state.value.plan) return null\n    let totalScheduled = 0\n    let daysUsed = 0\n    for (const dayKey of DAY_KEYS) {\n      const count = state.value.plan[dayKey].length\n      totalScheduled += count\n      if (count > 0) daysUsed++\n    }\n    return { totalScheduled, daysUsed }\n  })\n\n  // --------------------------------------------------------------------------\n  // Reset\n  // --------------------------------------------------------------------------\n\n  function reset() {\n    state.value = {\n      status: 'idle',\n      plan: null,\n      reasoning: null,\n      taskReasons: {},\n      weekTheme: null,\n      error: null,\n      weekStart: getWeekStart(settings.weekStartsOn),\n      weekEnd: getWeekEnd(settings.weekStartsOn),\n      interviewAnswers: null,\n    }\n    _stateCreatedAt = Date.now()\n    clearPlanStorage()\n  }\n\n  return {\n    state,\n    eligibleTasks,\n    eligibleTaskCount,\n    taskMap,\n    generatePlan,\n    moveTask,\n    removeTaskFromPlan,\n    snoozeTask,\n    changePriority,\n    regenerateDay,\n    startInterview,\n    skipInterview,\n    submitInterview,\n    applyPlan,\n    reset,\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useWeeklyPlanAI.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":327,"column":49,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":327,"endColumn":51,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[14670,14671],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":327,"column":63,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":327,"endColumn":65,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[14684,14685],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":327,"column":83,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":327,"endColumn":85,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[14704,14705],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":327,"column":115,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":327,"endColumn":117,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[14736,14737],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref } from 'vue'\nimport type { Ref } from 'vue'\nimport { createAIRouter } from '@/services/ai/router'\nimport type { ChatMessage } from '@/services/ai/types'\nimport type { WorkProfile } from '@/utils/supabaseMappers'\nimport { useSettingsStore } from '@/stores/settings'\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface WeeklyPlan {\n  monday: string[]\n  tuesday: string[]\n  wednesday: string[]\n  thursday: string[]\n  friday: string[]\n  saturday: string[]\n  sunday: string[]\n  unscheduled: string[]\n}\n\nexport type WeeklyPlanStatus = 'idle' | 'interview' | 'loading' | 'review' | 'applying' | 'applied' | 'error'\n\nexport interface WeeklyPlanState {\n  status: WeeklyPlanStatus\n  plan: WeeklyPlan | null\n  reasoning: string | null\n  taskReasons: Record<string, string>\n  weekTheme: string | null\n  error: string | null\n  weekStart: Date\n  weekEnd: Date\n  interviewAnswers: InterviewAnswers | null\n}\n\nexport interface TaskSummary {\n  id: string\n  title: string\n  priority: 'low' | 'medium' | 'high' | null\n  dueDate: string\n  estimatedDuration?: number\n  status: string\n  projectId: string\n  projectName?: string\n  description?: string\n  subtaskCount?: number\n  completedSubtaskCount?: number\n}\n\nexport interface InterviewAnswers {\n  topPriority?: string\n  daysOff?: string[]\n  heavyMeetingDays?: string[]\n  maxTasksPerDay?: number\n  preferredWorkStyle?: 'frontload' | 'balanced' | 'backload'\n}\n\nexport interface BehavioralContext {\n  recentlyCompletedTitles: string[]        // Titles of tasks completed in last 2 weeks\n  activeProjectNames: string[]             // Projects with recent activity\n  avgTasksCompletedPerDay: number | null   // From work profile\n  avgWorkMinutesPerDay: number | null      // From work profile\n  peakProductivityDays: string[]           // Days when user is most productive\n  completionRate: number | null            // % of planned tasks actually completed\n  frequentlyMissedProjects: string[]       // Projects where tasks often get skipped\n  workInsights: string[]                   // Observations from memoryGraph (task analysis, patterns)\n}\n\n// ============================================================================\n// Day keys and helpers\n// ============================================================================\n\nconst DAY_KEYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const\ntype DayKey = typeof DAY_KEYS[number]\n\nconst WEEKDAY_KEYS: DayKey[] = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday']\n\n// TASK-1321: Parameterized to support Sunday or Monday week start\nfunction getWeekBounds(weekStartsOn: 0 | 1 = 0): { weekStart: Date; weekEnd: Date } {\n  const now = new Date()\n  const day = now.getDay() // 0=Sun, 1=Mon...6=Sat\n\n  let diff: number\n  if (weekStartsOn === 1) {\n    // Monday start: go back to this week's Monday\n    diff = day === 0 ? -6 : 1 - day\n  } else {\n    // Sunday start: go back to this week's Sunday\n    diff = -day\n  }\n\n  const weekStart = new Date(now)\n  weekStart.setDate(now.getDate() + diff)\n  weekStart.setHours(0, 0, 0, 0)\n\n  const weekEnd = new Date(weekStart)\n  weekEnd.setDate(weekStart.getDate() + 6)\n  weekEnd.setHours(23, 59, 59, 999)\n\n  return { weekStart, weekEnd }\n}\n\n// BUG-1321: Use local date (not UTC) to avoid timezone-related overdue false positives\nfunction formatDate(d: Date): string {\n  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`\n}\n\n// ============================================================================\n// Prompt builders (distribution — the ONLY LLM job)\n// Research consensus: deterministic rules for filtering, LLM for distribution.\n// ============================================================================\n\nfunction buildSystemPrompt(interview?: InterviewAnswers, profile?: WorkProfile | null): string {\n  let base = `You are a productivity assistant that distributes tasks across a user's work week.\n\nALL tasks given to you have already been pre-filtered for relevance. Your ONLY job is to distribute them across Monday through Sunday.\n\nLANGUAGE RULE (CRITICAL — NEVER IGNORE):\nYou MUST write taskReasons and weekTheme in the SAME language as the task titles. If a task title is in Hebrew, its taskReasons MUST be written in Hebrew. If a task title is in English, its taskReasons MUST be in English. NEVER write English reasons for Hebrew tasks. This is non-negotiable.\n\nRules:\n- Return ONLY valid JSON (no markdown, no explanation outside the JSON).\n- The JSON must have these keys: monday, tuesday, wednesday, thursday, friday, saturday, sunday, unscheduled, reasoning, weekTheme.\n- Each day key is an array of task ID strings.\n- \"unscheduled\" contains task IDs that don't fit the available capacity.\n- \"reasoning\" is a brief string explaining your distribution logic.\n- \"weekTheme\" is a short motivating theme for the week (5-10 words) based on what dominates the task list. Examples: \"Infrastructure & Stability Sprint\", \"Client Delivery Push\", \"שבוע של סגירת פיצ'רים\". Match the user's dominant language.\n- \"taskReasons\" is an object mapping each task ID to 2-3 bullet points (separated by \"\\n\") explaining WHY this task matters and why it's placed on that day. Each task MUST have UNIQUE reasons derived from its SPECIFIC title, project, description, and due date. NEVER repeat the same reasons across tasks.\n  Rules for taskReasons:\n  1. Reference the task's ACTUAL content — mention its title, project, or description specifics.\n  2. Explain the scheduling decision — why THIS day, not just \"it's important\".\n  3. Connect to workflow — what does completing this unblock? What momentum does it build?\n  4. Match language — write in the same language as the task title (Hebrew tasks get Hebrew reasons, English tasks get English reasons).\n  BAD: \"Overdue task\" or \"High priority\" or generic phrases that could apply to any task.\n  GOOD: \"Blocking the auth refactor\\nClear before Wednesday's API work\\n3 subtasks left — close it out\"\n  GOOD: \"Wraps up the payment integration — 2 subtasks remain\\nFrees the team for Thursday's release\\nIn-progress since last week, momentum is hot\"\n\nSCHEDULING PRIORITY:\n1. Overdue tasks (due date in the past) — MUST go on Monday or Tuesday.\n2. In-progress tasks — already started, schedule early in the week.\n3. Tasks due this week — place on or before their due date.\n4. High-priority tasks — schedule on weekdays.\n5. Lower priority / no-date tasks — fill remaining capacity, or put in unscheduled if the week is full.\n\nDISTRIBUTION:\n- Keep daily load to 3-6 tasks maximum per day.\n- Prefer weekdays (Mon-Fri) for work tasks; use Sat/Sun only for overflow or light tasks.\n- Each task ID must appear in exactly ONE day or in unscheduled — no duplicates.\n- Consider task COMPLEXITY: tasks with many subtasks need their own day. Don't stack complex tasks.\n- Distribute EVENLY across the working week unless the user prefers otherwise.\n- It's OK to put tasks in unscheduled if the week is already full.\n\nPROJECT BATCHING (important for reducing context switches):\n- Group tasks from the SAME project on the same day when possible.\n- If a project has 3+ tasks, spread across 2 days max — not 1 per day scattered.\n- Avoid mixing more than 2-3 different projects on the same day.\n- If tasks are related (same project or similar descriptions), place them consecutively on the same day.`\n\n  if (interview) {\n    const extras: string[] = []\n    if (interview.topPriority) {\n      extras.push(`- The user's TOP PRIORITY this week: \"${interview.topPriority}\". Schedule related tasks earliest.`)\n    }\n    if (interview.daysOff && interview.daysOff.length > 0) {\n      extras.push(`- Days OFF (schedule ZERO tasks): ${interview.daysOff.join(', ')}.`)\n    }\n    if (interview.heavyMeetingDays && interview.heavyMeetingDays.length > 0) {\n      extras.push(`- Heavy MEETING days (schedule fewer/lighter tasks): ${interview.heavyMeetingDays.join(', ')}.`)\n    }\n    if (interview.maxTasksPerDay) {\n      extras.push(`- Maximum tasks per day: ${interview.maxTasksPerDay}.`)\n    }\n    if (interview.preferredWorkStyle === 'frontload') {\n      extras.push('- User prefers front-loading: schedule more tasks Mon-Tue, lighter Thu-Fri.')\n    } else if (interview.preferredWorkStyle === 'backload') {\n      extras.push('- User prefers ramping up: lighter Mon-Tue, heavier Thu-Fri.')\n    }\n    if (extras.length > 0) {\n      base += `\\n\\nUser preferences for this week:\\n${extras.join('\\n')}`\n    }\n  }\n\n  if (profile) {\n    const insights: string[] = []\n\n    if (profile.avgTasksCompletedPerDay) {\n      insights.push(`- Historical capacity: user completes ~${profile.avgTasksCompletedPerDay} tasks/day on average`)\n    }\n    if (profile.avgWorkMinutesPerDay) {\n      insights.push(`- Average focused work time: ~${Math.round(profile.avgWorkMinutesPerDay)} minutes/day`)\n    }\n    if (profile.peakProductivityDays?.length) {\n      insights.push(`- Most productive days: ${profile.peakProductivityDays.join(', ')}. Schedule demanding tasks here.`)\n    }\n    if (profile.avgPlanAccuracy) {\n      if (profile.avgPlanAccuracy < 60) {\n        insights.push(`- Past plans were only ${profile.avgPlanAccuracy}% accurate. Schedule FEWER tasks than requested.`)\n      } else if (profile.avgPlanAccuracy > 90) {\n        insights.push(`- Past plans were ${profile.avgPlanAccuracy}% accurate. User executes well — schedule confidently.`)\n      }\n    }\n    if (profile.preferredWorkStyle === 'frontload') {\n      insights.push('- User prefers front-loading: schedule more tasks Mon-Tue, lighter Thu-Fri.')\n    } else if (profile.preferredWorkStyle === 'backload') {\n      insights.push('- User prefers ramping up: lighter Mon-Tue, heavier Thu-Fri.')\n    }\n\n    if (insights.length > 0) {\n      base += `\\n\\nLearned work patterns:\\n${insights.join('\\n')}`\n    }\n  }\n\n  return base\n}\n\nfunction buildUserPrompt(tasks: TaskSummary[], weekStart: Date, weekEnd: Date, behavioral?: BehavioralContext): string {\n  const today = formatDate(new Date())\n  const weekEndStr = formatDate(weekEnd)\n  const overdueTasks = tasks.filter(t => t.dueDate && t.dueDate < today)\n  const dueThisWeek = tasks.filter(t => t.dueDate && t.dueDate >= today && t.dueDate <= weekEndStr)\n  const inProgress = tasks.filter(t => t.status === 'in_progress')\n\n  const taskList = tasks.map(t => {\n    // Compute urgency category for the AI\n    let urgency = 'normal'\n    if (t.dueDate && t.dueDate < today) urgency = 'OVERDUE'\n    else if (t.status === 'in_progress') urgency = 'IN_PROGRESS'\n    else if (t.dueDate && t.dueDate <= weekEndStr) urgency = 'DUE_THIS_WEEK'\n\n    // Truncate description to save tokens but give AI meaningful context\n    const desc = t.description ? t.description.slice(0, 150).trim() : null\n\n    return {\n      id: t.id,\n      title: t.title,\n      project: t.projectName || null,\n      description: desc,\n      priority: t.priority,\n      dueDate: t.dueDate || null,\n      estimatedDuration: t.estimatedDuration,\n      status: t.status,\n      urgency,\n      subtasks: t.subtaskCount || 0,\n      completedSubtasks: t.completedSubtaskCount || 0,\n    }\n  })\n\n  // Build behavioral section\n  let behavioralSection = ''\n  if (behavioral) {\n    const lines: string[] = []\n    if (behavioral.recentlyCompletedTitles.length > 0) {\n      lines.push(`Recently completed (user momentum): ${behavioral.recentlyCompletedTitles.slice(0, 8).join(', ')}`)\n    }\n    if (behavioral.activeProjectNames.length > 0) {\n      lines.push(`Active projects: ${behavioral.activeProjectNames.join(', ')}`)\n    }\n    if (behavioral.peakProductivityDays.length > 0) {\n      lines.push(`Most productive days: ${behavioral.peakProductivityDays.join(', ')} — schedule demanding tasks here`)\n    }\n    if (behavioral.avgTasksCompletedPerDay) {\n      lines.push(`User capacity: ~${behavioral.avgTasksCompletedPerDay} tasks/day`)\n    }\n    if (behavioral.frequentlyMissedProjects.length > 0) {\n      lines.push(`Often skipped projects: ${behavioral.frequentlyMissedProjects.join(', ')} — put these in unscheduled unless high priority`)\n    }\n    if (behavioral.workInsights?.length > 0) {\n      lines.push('')\n      lines.push('Learned work patterns (use these to make better scheduling decisions):')\n      for (const insight of behavioral.workInsights) {\n        lines.push(`  - ${insight}`)\n      }\n    }\n    if (lines.length > 0) {\n      behavioralSection = `\\nUser behavior data:\\n${lines.join('\\n')}\\n`\n    }\n  }\n\n  // Detect dominant language from task titles\n  const hebrewPattern = /[\\u0590-\\u05FF]/\n  const hebrewCount = tasks.filter(t => hebrewPattern.test(t.title)).length\n  const dominantLang = hebrewCount > tasks.length / 2 ? 'Hebrew' : 'English'\n  const langInstruction = dominantLang === 'Hebrew'\n    ? `\\nIMPORTANT: Most tasks are in Hebrew. You MUST write taskReasons in Hebrew for Hebrew tasks and weekTheme in Hebrew. Do NOT write in English.`\n    : ''\n\n  return `Today: ${today}\nWeek: ${formatDate(weekStart)} to ${weekEndStr}\nTasks: ${tasks.length} (${overdueTasks.length} overdue, ${dueThisWeek.length} due this week, ${inProgress.length} in-progress)\n${behavioralSection}\nAll tasks below are pre-filtered for this week's relevance. Distribute them across Mon-Sun.\nUrgency guide: OVERDUE → must be Mon/Tue. IN_PROGRESS → early in week. DUE_THIS_WEEK → on/before due date.\n\nTasks:\n${JSON.stringify(taskList, null, 2)}\n\nReturn ONLY the JSON object with monday...sunday, unscheduled, reasoning, weekTheme, and taskReasons keys.\nFor taskReasons: 2-3 bullet lines per task separated by \\\\n. Each task's reasons must be UNIQUE and reference that task's specific title, project, or description.${langInstruction}`\n}\n\nfunction buildDayResuggestPrompt(\n  dayKey: DayKey,\n  currentPlan: WeeklyPlan,\n  allTasks: TaskSummary[]\n): string {\n  const taskMap = new Map(allTasks.map(t => [t.id, t]))\n\n  const otherDays = DAY_KEYS.filter(k => k !== dayKey)\n  const otherScheduled: Record<string, string[]> = {}\n  for (const d of otherDays) {\n    if (currentPlan[d].length > 0) {\n      otherScheduled[d] = currentPlan[d]\n    }\n  }\n\n  const currentDayTasks = currentPlan[dayKey].map(id => taskMap.get(id)).filter(Boolean)\n  const unscheduledTasks = currentPlan.unscheduled.map(id => taskMap.get(id)).filter(Boolean)\n  const availableTasks = [...currentDayTasks, ...unscheduledTasks]\n\n  return `Re-suggest tasks for ${dayKey}.\n\nCurrently scheduled on other days (DO NOT move these):\n${JSON.stringify(otherScheduled, null, 2)}\n\nAvailable tasks for ${dayKey} (pick from these):\n${JSON.stringify(availableTasks.map(t => ({ id: t!.id, title: t!.title, priority: t!.priority, estimatedDuration: t!.estimatedDuration })), null, 2)}\n\nReturn ONLY a JSON object with two keys:\n- \"${dayKey}\": array of task ID strings for this day\n- \"unscheduled\": array of remaining task IDs not placed on ${dayKey}\n- \"reasoning\": brief explanation`\n}\n\n// ============================================================================\n// Response parsing\n// ============================================================================\n\nfunction parseWeeklyPlanResponse(\n  response: string,\n  validTaskIds: Set<string>\n): { plan: WeeklyPlan; reasoning: string | null; taskReasons: Record<string, string>; weekTheme: string | null } {\n  // Strip markdown code fences if present\n  let json = response.trim()\n  const codeBlockMatch = json.match(/```(?:json)?\\s*([\\s\\S]*?)```/)\n  if (codeBlockMatch) {\n    json = codeBlockMatch[1].trim()\n  }\n\n  let parsed: Record<string, unknown>\n  try {\n    parsed = JSON.parse(json)\n  } catch {\n    throw new Error('AI response is not valid JSON')\n  }\n\n  // Validate day keys exist\n  for (const key of DAY_KEYS) {\n    if (!Array.isArray(parsed[key])) {\n      parsed[key] = []\n    }\n  }\n  if (!Array.isArray(parsed.unscheduled)) {\n    parsed.unscheduled = []\n  }\n\n  const reasoning = typeof parsed.reasoning === 'string' ? parsed.reasoning : null\n  const weekTheme = typeof parsed.weekTheme === 'string' ? parsed.weekTheme : null\n\n  // Extract per-task AI reasons\n  const taskReasons: Record<string, string> = {}\n  if (parsed.taskReasons && typeof parsed.taskReasons === 'object') {\n    for (const [id, reason] of Object.entries(parsed.taskReasons as Record<string, unknown>)) {\n      if (typeof reason === 'string' && validTaskIds.has(id)) {\n        taskReasons[id] = reason\n      }\n    }\n  }\n\n  // Filter invalid IDs and deduplicate across days\n  const seen = new Set<string>()\n  const plan: WeeklyPlan = {\n    monday: [],\n    tuesday: [],\n    wednesday: [],\n    thursday: [],\n    friday: [],\n    saturday: [],\n    sunday: [],\n    unscheduled: [],\n  }\n\n  for (const key of [...DAY_KEYS, 'unscheduled'] as const) {\n    const ids = parsed[key] as unknown[]\n    for (const id of ids) {\n      if (typeof id === 'string' && validTaskIds.has(id) && !seen.has(id)) {\n        seen.add(id)\n        plan[key].push(id)\n      }\n    }\n  }\n\n  // Check result isn't completely empty\n  const totalAssigned = Object.values(plan).reduce((sum, arr) => sum + arr.length, 0)\n  if (totalAssigned === 0) {\n    throw new Error('Parsed plan contains no valid task assignments')\n  }\n\n  return { plan, reasoning, taskReasons, weekTheme }\n}\n\n// ============================================================================\n// Fallback plan\n// ============================================================================\n\nfunction generateFallbackPlan(tasks: TaskSummary[], _weekStart: Date): WeeklyPlan {\n  const priorityOrder: Record<string, number> = { high: 0, medium: 1, low: 2 }\n\n  const sorted = [...tasks].sort((a, b) => {\n    const pa = a.priority ? priorityOrder[a.priority] ?? 3 : 3\n    const pb = b.priority ? priorityOrder[b.priority] ?? 3 : 3\n    if (pa !== pb) return pa - pb\n    // Then by due date (earlier first, nulls last)\n    if (a.dueDate && b.dueDate) return a.dueDate.localeCompare(b.dueDate)\n    if (a.dueDate) return -1\n    if (b.dueDate) return 1\n    return 0\n  })\n\n  const plan: WeeklyPlan = {\n    monday: [],\n    tuesday: [],\n    wednesday: [],\n    thursday: [],\n    friday: [],\n    saturday: [],\n    sunday: [],\n    unscheduled: [],\n  }\n\n  const MAX_PER_DAY = 8\n  let dayIndex = 0\n\n  for (const task of sorted) {\n    if (dayIndex < WEEKDAY_KEYS.length) {\n      const dayKey = WEEKDAY_KEYS[dayIndex]\n      plan[dayKey].push(task.id)\n      if (plan[dayKey].length >= MAX_PER_DAY) {\n        dayIndex++\n      }\n    } else {\n      plan.unscheduled.push(task.id)\n    }\n  }\n\n  return plan\n}\n\n// ============================================================================\n// Composable\n// ============================================================================\n\nexport function useWeeklyPlanAI() {\n  const isGenerating = ref(false) as Ref<boolean>\n\n  async function generatePlan(\n    tasks: TaskSummary[],\n    interview?: InterviewAnswers,\n    profile?: WorkProfile | null,\n    behavioral?: BehavioralContext\n  ): Promise<{ plan: WeeklyPlan; reasoning: string | null; taskReasons: Record<string, string>; weekTheme: string | null }> {\n    if (tasks.length === 0) {\n      return {\n        plan: {\n          monday: [], tuesday: [], wednesday: [], thursday: [],\n          friday: [], saturday: [], sunday: [], unscheduled: [],\n        },\n        reasoning: 'No tasks to schedule.',\n        taskReasons: {},\n        weekTheme: null,\n      }\n    }\n\n    const { weekStart, weekEnd } = getWeekBounds(useSettingsStore().weekStartsOn)\n\n    isGenerating.value = true\n\n    try {\n      const router = createAIRouter()\n      await router.initialize()\n\n      // Architecture: Deterministic filtering (done by caller) → LLM distribution.\n      // Research consensus: LLMs are unreliable at scoring/filtering tasks.\n      // The caller (useWeeklyPlan) already hard-filtered to only relevant tasks.\n      // The LLM's only job is to distribute them across Mon-Sun.\n      console.log(`[WeeklyPlanAI] Distributing ${tasks.length} pre-filtered tasks across week ${formatDate(weekStart)}-${formatDate(weekEnd)}`)\n\n      const validTaskIds = new Set(tasks.map(t => t.id))\n      const messages: ChatMessage[] = [\n        { role: 'system', content: buildSystemPrompt(interview, profile) },\n        { role: 'user', content: buildUserPrompt(tasks, weekStart, weekEnd, behavioral) },\n      ]\n\n      // First attempt (30s timeout to prevent hanging during tool execution)\n      try {\n        const response = await router.chat(messages, {\n          taskType: 'planning',\n          temperature: 0.3,\n          timeout: 30000,\n        })\n        return parseWeeklyPlanResponse(response.content, validTaskIds)\n      } catch (firstError) {\n        console.warn('[WeeklyPlanAI] Distribution attempt failed, retrying...', firstError)\n      }\n\n      // Retry once\n      try {\n        const response = await router.chat(messages, {\n          taskType: 'planning',\n          temperature: 0.3,\n          timeout: 30000,\n        })\n        return parseWeeklyPlanResponse(response.content, validTaskIds)\n      } catch (retryError) {\n        console.warn('[WeeklyPlanAI] Retry failed, using fallback plan', retryError)\n      }\n\n      // Fallback: deterministic round-robin\n      return {\n        plan: generateFallbackPlan(tasks, weekStart),\n        reasoning: 'AI was unavailable. Tasks distributed by priority using a round-robin schedule.',\n        taskReasons: {},\n        weekTheme: null,\n      }\n    } finally {\n      isGenerating.value = false\n    }\n  }\n\n  async function regenerateDay(\n    dayKey: DayKey,\n    currentPlan: WeeklyPlan,\n    allTasks: TaskSummary[],\n    profile?: WorkProfile | null\n  ): Promise<{ dayTasks: string[]; unscheduled: string[]; reasoning: string | null }> {\n    const validTaskIds = new Set(allTasks.map(t => t.id))\n\n    isGenerating.value = true\n\n    try {\n      const router = createAIRouter()\n      await router.initialize()\n\n      const messages: ChatMessage[] = [\n        { role: 'system', content: buildSystemPrompt(undefined, profile) },\n        { role: 'user', content: buildDayResuggestPrompt(dayKey, currentPlan, allTasks) },\n      ]\n\n      try {\n        const response = await router.chat(messages, {\n          taskType: 'planning',\n          temperature: 0.5,\n        })\n\n        let json = response.content.trim()\n        const codeBlockMatch = json.match(/```(?:json)?\\s*([\\s\\S]*?)```/)\n        if (codeBlockMatch) json = codeBlockMatch[1].trim()\n\n        const parsed = JSON.parse(json) as Record<string, unknown>\n        const dayTasks = (Array.isArray(parsed[dayKey]) ? parsed[dayKey] : [])\n          .filter((id: unknown): id is string => typeof id === 'string' && validTaskIds.has(id as string))\n        const unscheduled = (Array.isArray(parsed.unscheduled) ? parsed.unscheduled : [])\n          .filter((id: unknown): id is string => typeof id === 'string' && validTaskIds.has(id as string))\n        const reasoning = typeof parsed.reasoning === 'string' ? parsed.reasoning : null\n\n        return { dayTasks, unscheduled, reasoning }\n      } catch (err) {\n        console.warn('[WeeklyPlanAI] Day re-suggest failed, shuffling by priority', err)\n\n        // Fallback: shuffle current day + unscheduled by priority\n        const priorityOrder: Record<string, number> = { high: 0, medium: 1, low: 2 }\n        const taskMap = new Map(allTasks.map(t => [t.id, t]))\n        const available = [...currentPlan[dayKey], ...currentPlan.unscheduled]\n        available.sort((a, b) => {\n          const ta = taskMap.get(a)\n          const tb = taskMap.get(b)\n          const pa = ta?.priority ? priorityOrder[ta.priority] ?? 3 : 3\n          const pb = tb?.priority ? priorityOrder[tb.priority] ?? 3 : 3\n          return pa - pb\n        })\n        const dayTasks = available.slice(0, 6)\n        const unscheduled = available.slice(6)\n        return { dayTasks, unscheduled, reasoning: 'Shuffled by priority (AI unavailable).' }\n      }\n    } finally {\n      isGenerating.value = false\n    }\n  }\n\n  return {\n    generatePlan,\n    regenerateDay,\n    isGenerating,\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useWhisperSpeech.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useWorkProfile.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":97,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":97,"endColumn":45},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":104,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":104,"endColumn":36,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[3376,3377],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":120,"column":92,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":120,"endColumn":109},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":129,"column":7,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":129,"endColumn":36,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[4421,4422],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":404,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":404,"endColumn":57},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":461,"column":42,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":461,"endColumn":63},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":518,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":518,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useProjectStore } from '@/stores/projects'\nimport type { WorkProfile, MemoryObservation } from '@/utils/supabaseMappers'\n\nconst cachedProfile = ref<WorkProfile | null>(null)\nconst isLoading = ref(false)\n\nexport function useWorkProfile() {\n  const db = useSupabaseDatabase()\n\n  const hasCompletedInterview = computed(() => cachedProfile.value?.interviewCompleted ?? false)\n  const profile = computed(() => cachedProfile.value)\n\n  async function loadProfile(): Promise<WorkProfile | null> {\n    if (cachedProfile.value) return cachedProfile.value\n    if (isLoading.value) return null\n\n    isLoading.value = true\n    try {\n      const result = await db.fetchWorkProfile()\n      cachedProfile.value = result\n      return result\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  /** Force-reload profile from DB (bypasses cache) */\n  async function reloadProfile(): Promise<WorkProfile | null> {\n    cachedProfile.value = null\n    isLoading.value = true\n    try {\n      const result = await db.fetchWorkProfile()\n      cachedProfile.value = result\n      return result\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  async function savePreferences(prefs: Partial<WorkProfile>): Promise<void> {\n    await db.saveWorkProfile({\n      ...prefs,\n      interviewCompleted: true\n    })\n    // Update cache\n    if (cachedProfile.value) {\n      Object.assign(cachedProfile.value, prefs, { interviewCompleted: true })\n    } else {\n      cachedProfile.value = {\n        id: '',\n        userId: '',\n        workDays: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],\n        daysOff: [],\n        heavyMeetingDays: [],\n        maxTasksPerDay: 6,\n        preferredWorkStyle: 'balanced',\n        topPriorityNote: null,\n        avgWorkMinutesPerDay: null,\n        avgTasksCompletedPerDay: null,\n        peakProductivityDays: null,\n        avgPlanAccuracy: null,\n        weeklyHistory: [],\n        profileVersion: 1,\n        interviewCompleted: true,\n        ...prefs\n      } as WorkProfile\n    }\n  }\n\n  async function computeCapacityMetrics(): Promise<{\n    avgMinutesPerDay: number | null\n    avgTasksPerDay: number | null\n    peakDays: string[]\n    dataSources: string[]\n  }> {\n    const taskStore = useTaskStore()\n    const now = new Date()\n    const sinceDate = new Date()\n    sinceDate.setDate(now.getDate() - 28)\n\n    // --- Source 1: Pomodoro history (focused time tracking) ---\n    const history = await db.fetchPomodoroHistory(28)\n    const pomodoroMap = new Map<string, { minutes: number; tasks: Set<string> }>()\n    const pomoDayOfWeek = new Map<string, number[]>()\n\n    for (const entry of history) {\n      if (entry.isBreak) continue\n      const date = entry.completedAt.split('T')[0]\n      const dayOfWeek = new Date(entry.completedAt).toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase()\n\n      if (!pomodoroMap.has(date)) {\n        pomodoroMap.set(date, { minutes: 0, tasks: new Set() })\n      }\n      const dayData = pomodoroMap.get(date)!\n      dayData.minutes += Math.round(entry.duration / 60)\n      if (entry.taskId) dayData.tasks.add(entry.taskId)\n\n      if (!pomoDayOfWeek.has(dayOfWeek)) {\n        pomoDayOfWeek.set(dayOfWeek, [])\n      }\n      pomoDayOfWeek.get(dayOfWeek)!.push(Math.round(entry.duration / 60))\n    }\n\n    // --- Source 2: Completed tasks (from task store) ---\n    const completedTasks = taskStore.tasks.filter(t => {\n      if (t.status !== 'done') return false\n      const cat = t.completedAt\n      if (!cat) return false\n      const completedDate = cat instanceof Date ? cat : new Date(cat)\n      return completedDate >= sinceDate && completedDate <= now\n    })\n\n    const taskCompletionMap = new Map<string, number>()\n    const taskDayOfWeek = new Map<string, number[]>()\n\n    for (const task of completedTasks) {\n      const completedDate = task.completedAt instanceof Date ? task.completedAt : new Date(task.completedAt!)\n      const dateStr = completedDate.toISOString().split('T')[0]\n      const dayOfWeek = completedDate.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase()\n\n      taskCompletionMap.set(dateStr, (taskCompletionMap.get(dateStr) || 0) + 1)\n\n      if (!taskDayOfWeek.has(dayOfWeek)) {\n        taskDayOfWeek.set(dayOfWeek, [])\n      }\n      taskDayOfWeek.get(dayOfWeek)!.push(1)\n    }\n\n    const hasPomodoroData = pomodoroMap.size > 0\n    const hasTaskData = taskCompletionMap.size > 0\n    const dataSources: string[] = []\n\n    if (!hasPomodoroData && !hasTaskData) {\n      return { avgMinutesPerDay: null, avgTasksPerDay: null, peakDays: [], dataSources: [] }\n    }\n\n    // --- Compute avgMinutesPerDay from pomodoro (only source for time) ---\n    let avgMinutesPerDay: number | null = null\n    if (hasPomodoroData) {\n      const pomoDays = Array.from(pomodoroMap.values())\n      avgMinutesPerDay = Math.round(pomoDays.reduce((sum, d) => sum + d.minutes, 0) / pomoDays.length * 10) / 10\n      dataSources.push('pomodoro')\n    }\n\n    // --- Compute avgTasksPerDay from task completions (more accurate than pomodoro alone) ---\n    let avgTasksPerDay: number | null = null\n    if (hasTaskData) {\n      const taskDays = Array.from(taskCompletionMap.values())\n      avgTasksPerDay = Math.round(taskDays.reduce((sum, count) => sum + count, 0) / taskDays.length * 10) / 10\n      dataSources.push('tasks')\n    } else if (hasPomodoroData) {\n      // Fallback: count unique tasks from pomodoro sessions\n      const pomoDays = Array.from(pomodoroMap.values())\n      avgTasksPerDay = Math.round(pomoDays.reduce((sum, d) => sum + d.tasks.size, 0) / pomoDays.length * 10) / 10\n    }\n\n    // --- Compute peakDays from whichever source has data ---\n    let peakDays: string[] = []\n    if (hasTaskData) {\n      // Prefer task completions for peak days (captures all work, not just timed)\n      const dayTotals = new Map<string, number>()\n      for (const [day, counts] of taskDayOfWeek) {\n        dayTotals.set(day, counts.length)\n      }\n      peakDays = Array.from(dayTotals.entries())\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 2)\n        .map(([day]) => day)\n    } else if (hasPomodoroData) {\n      const dayAvgs = Array.from(pomoDayOfWeek.entries())\n        .map(([day, mins]) => ({ day, avg: mins.reduce((a, b) => a + b, 0) / mins.length }))\n        .sort((a, b) => b.avg - a.avg)\n      peakDays = dayAvgs.slice(0, 2).map(d => d.day)\n    }\n\n    // Save computed metrics to profile\n    await db.saveWorkProfile({\n      avgWorkMinutesPerDay: avgMinutesPerDay,\n      avgTasksCompletedPerDay: avgTasksPerDay,\n      peakProductivityDays: peakDays\n    })\n\n    if (cachedProfile.value) {\n      cachedProfile.value.avgWorkMinutesPerDay = avgMinutesPerDay\n      cachedProfile.value.avgTasksCompletedPerDay = avgTasksPerDay\n      cachedProfile.value.peakProductivityDays = peakDays\n    }\n\n    // FEATURE-1317 Phase 2: Generate structured observations from stats + task context\n    await generateObservationsFromStats()\n    await generateObservationsFromTasks()\n\n    return { avgMinutesPerDay, avgTasksPerDay, peakDays, dataSources }\n  }\n\n  async function recordWeeklyOutcome(\n    plannedTaskIds: string[],\n    completedTaskIds: string[]\n  ): Promise<void> {\n    const planned = plannedTaskIds.length\n    if (planned === 0) return\n\n    const completed = completedTaskIds.filter(id => plannedTaskIds.includes(id)).length\n    const accuracy = Math.round((completed / planned) * 100 * 100) / 100\n\n    const weekStart = new Date()\n    weekStart.setDate(weekStart.getDate() - 7)\n    const entry = {\n      weekStart: weekStart.toISOString().split('T')[0],\n      plannedCount: planned,\n      completedCount: completed,\n      accuracy\n    }\n\n    const currentHistory = cachedProfile.value?.weeklyHistory || []\n    const newHistory = [...currentHistory, entry].slice(-8) // Keep last 8 weeks\n\n    const avgAccuracy = newHistory.length > 0\n      ? Math.round(newHistory.reduce((sum, w) => sum + w.accuracy, 0) / newHistory.length * 100) / 100\n      : null\n\n    await db.saveWorkProfile({\n      weeklyHistory: newHistory,\n      avgPlanAccuracy: avgAccuracy\n    })\n\n    if (cachedProfile.value) {\n      cachedProfile.value.weeklyHistory = newHistory\n      cachedProfile.value.avgPlanAccuracy = avgAccuracy\n    }\n  }\n\n  async function addMemoryObservation(obs: Omit<MemoryObservation, 'createdAt'>): Promise<void> {\n    const current = cachedProfile.value?.memoryGraph || []\n\n    // Dedup: if same entity+relation exists, update it\n    const existingIdx = current.findIndex(o => o.entity === obs.entity && o.relation === obs.relation)\n    const newObs: MemoryObservation = { ...obs, createdAt: new Date().toISOString() }\n\n    let updated: MemoryObservation[]\n    if (existingIdx !== -1) {\n      updated = [...current]\n      updated[existingIdx] = newObs\n    } else {\n      updated = [...current, newObs]\n    }\n\n    // Cap at 50 observations (FIFO)\n    if (updated.length > 50) {\n      updated = updated.slice(updated.length - 50)\n    }\n\n    await db.saveWorkProfile({ memoryGraph: updated })\n    if (cachedProfile.value) {\n      cachedProfile.value.memoryGraph = updated\n    }\n  }\n\n  async function generateObservationsFromStats(): Promise<void> {\n    const p = cachedProfile.value\n    if (!p) return\n\n    const observations: Omit<MemoryObservation, 'createdAt'>[] = []\n\n    // Peak productivity days\n    if (p.peakProductivityDays?.length) {\n      for (const day of p.peakProductivityDays) {\n        observations.push({\n          entity: `day:${day}`,\n          relation: 'peak_productivity',\n          value: 'consistently highest output',\n          confidence: 0.85,\n          source: 'pomodoro_data'\n        })\n      }\n    }\n\n    // Capacity gap: completes fewer tasks than planned\n    if (p.avgTasksCompletedPerDay && p.maxTasksPerDay && p.avgTasksCompletedPerDay < p.maxTasksPerDay * 0.7) {\n      observations.push({\n        entity: 'user',\n        relation: 'capacity_gap',\n        value: `completes ${p.avgTasksCompletedPerDay.toFixed(1)} but plans for ${p.maxTasksPerDay}`,\n        confidence: 0.7,\n        source: 'pomodoro_data'\n      })\n    }\n\n    // Plan accuracy observations\n    if (p.avgPlanAccuracy !== null && p.avgPlanAccuracy !== undefined) {\n      if (p.avgPlanAccuracy < 60) {\n        observations.push({\n          entity: 'user',\n          relation: 'overplans',\n          value: `only ${p.avgPlanAccuracy.toFixed(0)}% of planned tasks completed`,\n          confidence: 0.75,\n          source: 'weekly_history'\n        })\n      } else if (p.avgPlanAccuracy > 90) {\n        observations.push({\n          entity: 'user',\n          relation: 'reliable_planner',\n          value: `${p.avgPlanAccuracy.toFixed(0)}% accuracy`,\n          confidence: 0.8,\n          source: 'weekly_history'\n        })\n      }\n    }\n\n    for (const obs of observations) {\n      await addMemoryObservation(obs)\n    }\n  }\n\n  async function generateObservationsFromTasks(): Promise<void> {\n    const taskStore = useTaskStore()\n    const projectStore = useProjectStore()\n    const now = new Date()\n    const sinceDate = new Date()\n    sinceDate.setDate(now.getDate() - 28)\n    const todayStr = now.toISOString().split('T')[0]\n\n    const allTasks = taskStore.tasks\n    if (allTasks.length === 0) return\n\n    const observations: Omit<MemoryObservation, 'createdAt'>[] = []\n\n    // --- 1. Status distribution snapshot ---\n    const statusCounts = { planned: 0, in_progress: 0, done: 0, backlog: 0, on_hold: 0 }\n    for (const t of allTasks) {\n      if (t.status in statusCounts) statusCounts[t.status as keyof typeof statusCounts]++\n    }\n    const total = allTasks.length\n    const backlogRatio = total > 0 ? statusCounts.backlog / total : 0\n    if (backlogRatio > 0.4 && statusCounts.backlog >= 5) {\n      observations.push({\n        entity: 'user',\n        relation: 'backlog_heavy',\n        value: `${statusCounts.backlog} of ${total} tasks (${Math.round(backlogRatio * 100)}%) in backlog`,\n        confidence: 0.8,\n        source: 'task_analysis'\n      })\n    }\n\n    // --- 2. Priority completion rate ---\n    const recentDone = allTasks.filter(t => {\n      if (t.status !== 'done') return false\n      const cat = t.completedAt\n      if (!cat) return false\n      const d = cat instanceof Date ? cat : new Date(cat)\n      return d >= sinceDate\n    })\n    const priorityDone = { high: 0, medium: 0, low: 0 }\n    const priorityTotal = { high: 0, medium: 0, low: 0 }\n    for (const t of allTasks) {\n      if (t.priority && t.priority in priorityTotal) {\n        priorityTotal[t.priority as keyof typeof priorityTotal]++\n      }\n    }\n    for (const t of recentDone) {\n      if (t.priority && t.priority in priorityDone) {\n        priorityDone[t.priority as keyof typeof priorityDone]++\n      }\n    }\n    if (priorityTotal.high >= 3) {\n      const rate = Math.round((priorityDone.high / priorityTotal.high) * 100)\n      observations.push({\n        entity: 'priority:high',\n        relation: 'completion_rate',\n        value: `${rate}% of high-priority tasks completed (${priorityDone.high}/${priorityTotal.high})`,\n        confidence: Math.min(0.9, 0.5 + priorityTotal.high * 0.04),\n        source: 'task_analysis'\n      })\n    }\n\n    // --- 3. Overdue pattern ---\n    const overdueTasks = allTasks.filter(t => {\n      if (t.status === 'done') return false\n      if (!t.dueDate) return false\n      return t.dueDate < todayStr\n    })\n    if (overdueTasks.length >= 3) {\n      observations.push({\n        entity: 'user',\n        relation: 'overdue_pattern',\n        value: `${overdueTasks.length} tasks past their due date`,\n        confidence: 0.85,\n        source: 'task_analysis'\n      })\n    }\n\n    // --- 4. Project activity (top active + stale projects) ---\n    const SKIP_PROJECT_IDS = new Set(['uncategorized', '1', ''])\n    const projectTaskCounts = new Map<string, { total: number; done: number; name: string }>()\n    for (const t of allTasks) {\n      if (!t.projectId || SKIP_PROJECT_IDS.has(t.projectId)) continue\n      if (!projectTaskCounts.has(t.projectId)) {\n        const proj = projectStore.projects.find(p => p.id === t.projectId)\n        projectTaskCounts.set(t.projectId, { total: 0, done: 0, name: proj?.name || t.projectId })\n      }\n      const counts = projectTaskCounts.get(t.projectId)!\n      counts.total++\n      if (t.status === 'done') counts.done++\n    }\n    // Most active project\n    const sortedProjects = Array.from(projectTaskCounts.entries())\n      .filter(([, c]) => c.total >= 3)\n      .sort((a, b) => b[1].total - a[1].total)\n    if (sortedProjects.length > 0) {\n      const [, top] = sortedProjects[0]\n      observations.push({\n        entity: `project:${top.name}`,\n        relation: 'most_active',\n        value: `${top.total} tasks (${top.done} done, ${top.total - top.done} remaining)`,\n        confidence: 0.75,\n        source: 'task_analysis'\n      })\n    }\n    // Stale projects (0 completions but 3+ open tasks)\n    for (const [, counts] of sortedProjects) {\n      if (counts.done === 0 && counts.total >= 3) {\n        observations.push({\n          entity: `project:${counts.name}`,\n          relation: 'stale',\n          value: `${counts.total} tasks, none completed`,\n          confidence: 0.7,\n          source: 'task_analysis'\n        })\n      }\n    }\n\n    // --- 5. Task completion speed (created → done) ---\n    const completionDays: number[] = []\n    for (const t of recentDone) {\n      if (!t.completedAt || !t.createdAt) continue\n      const created = t.createdAt instanceof Date ? t.createdAt : new Date(t.createdAt)\n      const completed = t.completedAt instanceof Date ? t.completedAt : new Date(t.completedAt)\n      const daysDiff = Math.round((completed.getTime() - created.getTime()) / (1000 * 60 * 60 * 24))\n      if (daysDiff >= 0) completionDays.push(daysDiff)\n    }\n    if (completionDays.length >= 3) {\n      const avgDays = Math.round(completionDays.reduce((a, b) => a + b, 0) / completionDays.length * 10) / 10\n      const sameDayRate = Math.round((completionDays.filter(d => d === 0).length / completionDays.length) * 100)\n      observations.push({\n        entity: 'user',\n        relation: 'avg_completion_speed',\n        value: `${avgDays} days avg from creation to done (${sameDayRate}% same-day)`,\n        confidence: Math.min(0.9, 0.5 + completionDays.length * 0.03),\n        source: 'task_analysis'\n      })\n    }\n\n    // --- 6. Estimation accuracy (estimatedPomodoros vs completedPomodoros) ---\n    const estimatedTasks = recentDone.filter(t => t.estimatedPomodoros && t.estimatedPomodoros > 0 && t.completedPomodoros > 0)\n    if (estimatedTasks.length >= 3) {\n      // Per-task ratios (median is more robust than sum ratio for outliers)\n      const perTaskRatios = estimatedTasks\n        .map(t => t.completedPomodoros / t.estimatedPomodoros!)\n        .sort((a, b) => a - b)\n      const medianRatio = perTaskRatios[Math.floor(perTaskRatios.length / 2)]\n\n      if (medianRatio > 1.3) {\n        observations.push({\n          entity: 'user',\n          relation: 'underestimates',\n          value: `median task takes ${medianRatio.toFixed(1)}x more pomodoros than estimated (${estimatedTasks.length} tasks measured)`,\n          confidence: Math.min(0.9, 0.5 + estimatedTasks.length * 0.05),\n          source: 'task_analysis'\n        })\n      } else if (medianRatio < 0.7) {\n        observations.push({\n          entity: 'user',\n          relation: 'overestimates',\n          value: `median task takes ${medianRatio.toFixed(1)}x fewer pomodoros than estimated (${estimatedTasks.length} tasks measured)`,\n          confidence: Math.min(0.9, 0.5 + estimatedTasks.length * 0.05),\n          source: 'task_analysis'\n        })\n      }\n    }\n\n    // --- 7. In-progress WIP limit check ---\n    if (statusCounts.in_progress >= 5) {\n      observations.push({\n        entity: 'user',\n        relation: 'high_wip',\n        value: `${statusCounts.in_progress} tasks in progress simultaneously`,\n        confidence: 0.8,\n        source: 'task_analysis'\n      })\n    }\n\n    for (const obs of observations) {\n      await addMemoryObservation(obs)\n    }\n  }\n\n  async function generateObservationsFromWeeklyOutcome(\n    plannedTaskIds: string[],\n    completedTaskIds: string[],\n    taskStore: { tasks: Array<{ id: string; projectId?: string; status: string }> }\n  ): Promise<void> {\n    if (plannedTaskIds.length === 0) return\n\n    const completedSet = new Set(completedTaskIds)\n    const observations: Omit<MemoryObservation, 'createdAt'>[] = []\n\n    // Group missed tasks by project\n    const projectMissCount = new Map<string, { missed: number; total: number }>()\n    for (const taskId of plannedTaskIds) {\n      const task = taskStore.tasks.find(t => t.id === taskId)\n      const projectId = task?.projectId || 'uncategorized'\n      if (!projectMissCount.has(projectId)) {\n        projectMissCount.set(projectId, { missed: 0, total: 0 })\n      }\n      const counts = projectMissCount.get(projectId)!\n      counts.total++\n      if (!completedSet.has(taskId)) {\n        counts.missed++\n      }\n    }\n\n    for (const [projectId, counts] of projectMissCount) {\n      if (counts.total >= 2 && counts.missed / counts.total > 0.5) {\n        observations.push({\n          entity: `project:${projectId}`,\n          relation: 'frequently_missed',\n          value: `${counts.missed} of ${counts.total} tasks missed`,\n          confidence: Math.min(0.9, 0.5 + (counts.total * 0.05)),\n          source: 'weekly_history'\n        })\n      }\n    }\n\n    // Check day distribution of completed tasks\n    const dayCompletions = new Map<string, number>()\n    const daysOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']\n    for (const taskId of completedTaskIds) {\n      const task = taskStore.tasks.find(t => t.id === taskId)\n      if (task) {\n        // Use current day as approximation (tasks may have been completed on different days)\n        const today = daysOfWeek[new Date().getDay()]\n        dayCompletions.set(today, (dayCompletions.get(today) || 0) + 1)\n      }\n    }\n\n    for (const obs of observations) {\n      await addMemoryObservation(obs)\n    }\n  }\n\n  function getProfileContext(): string | null {\n    const p = cachedProfile.value\n    if (!p) return null\n\n    const insights: string[] = []\n\n    if (p.avgTasksCompletedPerDay) {\n      insights.push(`- Historical capacity: user completes ~${p.avgTasksCompletedPerDay} tasks/day on average`)\n    }\n    if (p.avgWorkMinutesPerDay) {\n      insights.push(`- Average focused work time: ~${Math.round(p.avgWorkMinutesPerDay)} minutes/day`)\n    }\n    if (p.peakProductivityDays?.length) {\n      insights.push(`- Most productive days: ${p.peakProductivityDays.join(', ')}. Schedule demanding tasks here.`)\n    }\n    if (p.avgPlanAccuracy) {\n      if (p.avgPlanAccuracy < 60) {\n        insights.push(`- Past plans were only ${p.avgPlanAccuracy}% accurate. Schedule FEWER tasks than requested.`)\n      } else if (p.avgPlanAccuracy > 90) {\n        insights.push(`- Past plans were ${p.avgPlanAccuracy}% accurate. User executes well — schedule confidently.`)\n      }\n    }\n    if (p.preferredWorkStyle === 'frontload') {\n      insights.push('- User prefers front-loading: schedule more tasks Mon-Tue, lighter Thu-Fri.')\n    } else if (p.preferredWorkStyle === 'backload') {\n      insights.push('- User prefers ramping up: lighter Mon-Tue, heavier Thu-Fri.')\n    }\n\n    // FEATURE-1317 Phase 2: Include memory observations\n    const memoryObs = (p.memoryGraph || [])\n      .filter(o => o.confidence >= 0.5)\n      .sort((a, b) => b.confidence - a.confidence)\n      .slice(0, 10)\n\n    if (memoryObs.length > 0) {\n      insights.push('')  // blank line separator\n      insights.push('Observations from past weeks:')\n      for (const obs of memoryObs) {\n        insights.push(`- ${obs.entity} ${obs.relation}: ${obs.value} (confidence: ${obs.confidence.toFixed(2)})`)\n      }\n    }\n\n    return insights.length > 0 ? `Learned work patterns:\\n${insights.join('\\n')}` : null\n  }\n\n  async function resetLearnedData(): Promise<void> {\n    await db.saveWorkProfile({\n      avgWorkMinutesPerDay: null,\n      avgTasksCompletedPerDay: null,\n      peakProductivityDays: null,\n      avgPlanAccuracy: null,\n      weeklyHistory: [],\n      memoryGraph: []\n    })\n    if (cachedProfile.value) {\n      cachedProfile.value.avgWorkMinutesPerDay = null\n      cachedProfile.value.avgTasksCompletedPerDay = null\n      cachedProfile.value.peakProductivityDays = null\n      cachedProfile.value.avgPlanAccuracy = null\n      cachedProfile.value.weeklyHistory = []\n      cachedProfile.value.memoryGraph = []\n    }\n  }\n\n  return {\n    profile,\n    hasCompletedInterview,\n    isLoading: computed(() => isLoading.value),\n    loadProfile,\n    reloadProfile,\n    savePreferences,\n    computeCapacityMetrics,\n    recordWeeklyOutcome,\n    addMemoryObservation,\n    generateObservationsFromStats,\n    generateObservationsFromWeeklyOutcome,\n    getProfileContext,\n    resetLearnedData\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/composables/useXpAnimations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/config/environments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/config/timing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/config/urls.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/constants/canvas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/i18n/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/i18n/useDirection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/layouts/AppHeader.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ref' is defined but never used. Allowed unused vars must match /^_/u.","line":194,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":194,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ref"},"fix":{"range":[6956,6961],"text":""},"desc":"Remove unused variable \"ref\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'settingsStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":212,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":212,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'authStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":213,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":213,"endColumn":16}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <header class=\"app-header\">\n    <div class=\"header-section\">\n      <!-- USER PROFILE (Left side) - Firebase Auth disabled -->\n      <div class=\"user-profile-container\">\n        <!-- UserProfile v-if=\"authStore.isAuthenticated\" /-->\n      </div>\n\n      <div class=\"page-title\">\n        <h1 class=\"title-main\">\n          {{ pageTitleInfo.main }}\n        </h1>\n        <span v-if=\"pageTitleInfo.filter\" class=\"title-filter\">\n          <template v-if=\"typeof pageTitleInfo.filter === 'object' && pageTitleInfo.filter.type === 'project'\">\n            <!-- Emoji Indicator -->\n            <ProjectEmojiIcon\n              v-if=\"pageTitleInfo.filter.project?.colorType === 'emoji'\"\n              :emoji=\"pageTitleInfo.filter.project.emoji || ''\"\n              size=\"sm\"\n              :title=\"`Project: ${pageTitleInfo.filter.project.name}`\"\n              class=\"project-emoji-header\"\n            />\n            <!-- Color Indicator -->\n            <span\n              v-else\n              class=\"project-color-header\"\n              :style=\"{ backgroundColor: Array.isArray(pageTitleInfo.filter.project?.color) ? pageTitleInfo.filter.project.color[0] : pageTitleInfo.filter.project?.color }\"\n            />\n            {{ pageTitleInfo.filter.project?.name }}\n          </template>\n          <template v-else-if=\"typeof pageTitleInfo.filter === 'object' && pageTitleInfo.filter.type === 'smart-view'\">\n            <!-- Smart View Emoji Indicator -->\n            <ProjectEmojiIcon\n              v-if=\"pageTitleInfo.filter.emoji\"\n              :emoji=\"pageTitleInfo.filter.emoji\"\n              size=\"sm\"\n              :title=\"`Smart View: ${pageTitleInfo.filter.name}`\"\n              class=\"project-emoji-header\"\n            />\n            {{ pageTitleInfo.filter.name }}\n          </template>\n          <template v-else>\n            {{ pageTitleInfo.filter }}\n          </template>\n        </span>\n      </div>\n\n      <!-- INTEGRATED CONTROL PANEL: Gamification + Sync + AI + Clock + Timer -->\n      <div class=\"control-panel\">\n        <!-- TASK-1177: Sync Status Indicator -->\n        <SyncStatusIndicator />\n\n        <div class=\"control-divider\" />\n\n        <!-- TASK-1319: Keyboard Shortcuts Help -->\n        <button\n          class=\"help-btn\"\n          title=\"Keyboard Shortcuts (?)\"\n          @click=\"uiStore.toggleShortcutsPanel()\"\n        >\n          <Keyboard :size=\"18\" />\n        </button>\n\n        <div class=\"control-divider\" />\n\n        <!-- AI Assistant Toggle (TASK-1120) -->\n        <button\n          class=\"ai-toggle-btn\"\n          :class=\"{ 'ai-active': aiChatStore.isPanelOpen }\"\n          title=\"AI Assistant (Ctrl+/)\"\n          @click=\"aiChatStore.togglePanel\"\n        >\n          <Sparkles :size=\"18\" />\n          <span v-if=\"aiChatStore.pendingSuggestionCount > 0\" class=\"ai-badge\">\n            {{ aiChatStore.pendingSuggestionCount }}\n          </span>\n        </button>\n\n        <div class=\"control-divider\" />\n\n        <div class=\"time-display-container\">\n          <TimeDisplay />\n        </div>\n\n        <!-- FEATURE-1248: Quick Task Shortcuts -->\n        <QuickTaskDropdown />\n\n        <!-- POMODORO TIMER DISPLAY -->\n        <div class=\"timer-container\">\n          <div class=\"timer-display\" :class=\"{ 'timer-active': timerStore.isTimerActive, 'timer-break': timerStore.currentSession?.isBreak }\">\n            <div class=\"timer-icon\">\n              <span v-if=\"timerStore.isTimerActive && !timerStore.currentSession?.isBreak\" class=\"timer-emoticon active\">🍅</span>\n              <span v-else-if=\"timerStore.isTimerActive && timerStore.currentSession?.isBreak\" class=\"timer-emoticon active\">🧎</span>\n              <Timer\n                v-else\n                :size=\"20\"\n                :stroke-width=\"1.5\"\n                class=\"timer-stroke\"\n              />\n            </div>\n            <div class=\"timer-info\">\n              <div class=\"timer-time\">\n                {{ timerStore.displayTime }}\n              </div>\n              <div class=\"timer-task\" dir=\"auto\">\n                {{ timerStore.currentTaskName || '&nbsp;' }}\n              </div>\n            </div>\n            <div class=\"timer-controls\">\n              <div v-if=\"!timerStore.currentSession\" class=\"timer-start-options\">\n                <button\n                  class=\"timer-btn timer-start\"\n                  title=\"Start 25-min work timer\"\n                  @click=\"startQuickTimer\"\n                >\n                  <Play :size=\"16\" />\n                </button>\n                <button\n                  class=\"timer-btn timer-break\"\n                  title=\"Start 5-min break\"\n                  @click=\"startShortBreak\"\n                >\n                  <Coffee :size=\"16\" :stroke-width=\"1.5\" class=\"coffee-stroke\" />\n                </button>\n                <button\n                  class=\"timer-btn timer-break\"\n                  title=\"Start 15-min long break\"\n                  @click=\"startLongBreak\"\n                >\n                  <User :size=\"16\" :stroke-width=\"1.5\" class=\"meditation-stroke\" />\n                </button>\n              </div>\n\n              <button\n                v-else-if=\"timerStore.isPaused\"\n                class=\"timer-btn timer-resume\"\n                title=\"Resume timer\"\n                @click=\"timerStore.resumeTimer\"\n              >\n                <Play :size=\"16\" />\n              </button>\n\n              <button\n                v-else-if=\"timerStore.isTimerActive\"\n                class=\"timer-btn timer-pause\"\n                title=\"Pause timer\"\n                @click=\"timerStore.pauseTimer\"\n              >\n                <Pause :size=\"16\" />\n              </button>\n\n              <button\n                v-if=\"timerStore.currentSession\"\n                class=\"timer-btn timer-stop\"\n                title=\"Stop timer\"\n                @click=\"timerStore.stopTimer\"\n              >\n                <Square :size=\"16\" />\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- VIEW TABS AND CONTROLS -->\n    <div class=\"content-header\">\n      <div class=\"view-tabs\">\n        <router-link to=\"/\" class=\"view-tab\" active-class=\"active\">\n          Canvas\n        </router-link>\n        <router-link to=\"/calendar\" class=\"view-tab\" active-class=\"active\">\n          Calendar\n        </router-link>\n        <router-link to=\"/board\" class=\"view-tab\" active-class=\"active\">\n          Board\n        </router-link>\n        <router-link to=\"/catalog\" class=\"view-tab\" active-class=\"active\">\n          Catalog\n        </router-link>\n        <router-link to=\"/quick-sort\" class=\"view-tab\" active-class=\"active\">\n          Quick Sort\n          <span v-if=\"uncategorizedCount > 0\" class=\"tab-badge\">{{ uncategorizedCount }}</span>\n        </router-link>\n        <router-link to=\"/ai\" class=\"view-tab\" active-class=\"active\">\n          AI\n        </router-link>\n      </div>\n    </div>\n  </header>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\nimport { useRouter } from 'vue-router'\nimport { useTaskStore, type Project } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useAIChatStore } from '@/stores/aiChat'\nimport { useSettingsStore } from '@/stores/settings'\nimport { useUIStore } from '@/stores/ui'\nimport { Timer, Play, Pause, Coffee, Square, User, Sparkles, Keyboard } from 'lucide-vue-next'\nimport TimeDisplay from '@/components/common/TimeDisplay.vue'\nimport ProjectEmojiIcon from '@/components/base/ProjectEmojiIcon.vue'\nimport SyncStatusIndicator from '@/components/sync/SyncStatusIndicator.vue'\nimport { useAuthStore } from '@/stores/auth'\nimport QuickTaskDropdown from '@/components/timer/QuickTaskDropdown.vue'\n\nconst router = useRouter()\nconst taskStore = useTaskStore()\nconst timerStore = useTimerStore()\nconst aiChatStore = useAIChatStore()\nconst settingsStore = useSettingsStore()\nconst authStore = useAuthStore()\nconst uiStore = useUIStore()\n\n// Route name to display title mapping\nconst routeNameToTitle = {\n  'canvas': 'Canvas',\n  'calendar': 'Calendar',\n  'board': 'Board',\n  'catalog': 'Task Catalog',\n  'all-tasks': 'All Tasks',\n  'quick-sort': 'Quick Sort',\n  'focus': 'Focus',\n  'today': 'Today',\n  'calendar-test': 'Calendar Test',\n  'keyboard-test': 'Keyboard Test',\n  'yjs-test': 'YJS Test',\n  'design-system': 'Design System',\n  'ai': 'AI Hub',\n}\n\n// Define proper types for page title info\ninterface FilterContext {\n  type?: string\n  name: string\n  emoji?: string\n  smartView?: string\n  project?: Project\n}\n\ninterface PageTitleInfo {\n  main: string\n  filter: string | FilterContext\n}\n\n// Dynamic page title with hierarchical display and smart defaults\nconst pageTitleInfo = computed<PageTitleInfo>(() => {\n  // Get current route name for main title\n  const currentRouteName = router.currentRoute.value.name as string\n  const mainTitle = routeNameToTitle[currentRouteName as keyof typeof routeNameToTitle] || 'Canvas'\n\n  // Determine filter context with priority order:\n  // 1. Explicit smart views (highest priority)\n  // 2. Selected projects\n  // 3. Route-based defaults (fallback to ensure context is always shown)\n  let filterContext: string | FilterContext = ''\n\n  // Priority 1: Check for active smart views\n  if (taskStore.activeSmartView === 'today') {\n    filterContext = {\n      type: 'smart-view',\n      name: 'Today',\n      emoji: '📅',\n      smartView: 'today'\n    }\n  } else if (taskStore.activeSmartView === 'week') {\n    filterContext = {\n      type: 'smart-view',\n      name: 'This Week',\n      emoji: '📆',\n      smartView: 'week'\n    }\n  } else if (taskStore.activeSmartView === 'uncategorized') {\n    filterContext = {\n      type: 'smart-view',\n      name: 'Uncategorized Tasks',\n      emoji: '🪣',\n      smartView: 'uncategorized'\n    }\n  } else if (taskStore.activeSmartView === 'all_active') {\n    filterContext = {\n      type: 'smart-view',\n      name: 'All Active Tasks',\n      emoji: '📋',\n      smartView: 'all_active'\n    }\n  }\n  // Priority 2: Check for selected projects\n  else if (taskStore.activeProjectId) {\n    const project = taskStore.projects.find(p => p.id === taskStore.activeProjectId)\n    if (project) {\n      filterContext = {\n        type: 'project',\n        name: project.name,\n        project: project\n      }\n    }\n  }\n  // Priority 3: Route-based smart defaults (ensure context is never empty)\n  else {\n    // Apply smart defaults based on current route\n    switch (currentRouteName) {\n      case 'canvas':\n        filterContext = 'Workflow'\n        break\n      case 'calendar':\n        filterContext = 'Schedule'\n        break\n      case 'board':\n        filterContext = 'Overview'\n        break\n      case 'catalog':\n        filterContext = 'Knowledge Base'\n        break\n      case 'quick-sort':\n        filterContext = 'Triage'\n        break\n      case 'ai':\n        filterContext = 'Assistant'\n        break\n      default:\n        filterContext = ''\n    }\n  }\n\n  return {\n    main: mainTitle,\n    filter: filterContext\n  }\n})\n\n// Uncategorized task count for Quick Sort badge\nconst uncategorizedCount = computed(() => {\n  return taskStore.getUncategorizedTaskCount()\n})\n\n// Timer methods\nconst startQuickTimer = async () => {\n  // BUG-1051: AWAIT for timer sync\n  await timerStore.startTimer('quick-timer', timerStore.settings.workDuration, false)\n}\n\nconst startShortBreak = async () => {\n  // BUG-1051: AWAIT for timer sync\n  await timerStore.startTimer('short-break', timerStore.settings.shortBreakDuration, true)\n}\n\nconst startLongBreak = async () => {\n  // BUG-1051: AWAIT for timer sync\n  await timerStore.startTimer('long-break', timerStore.settings.longBreakDuration, true)\n}\n</script>\n\n<style scoped>\n/* App Header Container */\n.app-header {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n}\n\n/* HEADER SECTION */\n.header-section {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  gap: var(--space-4);\n  margin-bottom: var(--space-6);\n  pointer-events: none;\n  position: relative;\n  z-index: 5;\n}\n\n/* Raise above .content-header when gamification panel is open\n   so the fixed backdrop blocks clicks on nav tabs */\n.header-section--panel-open {\n  z-index: 10;\n}\n\n/* USER PROFILE CONTAINER */\n.user-profile-container {\n  pointer-events: auto;\n}\n\n/* Hierarchical page title display */\n.page-title {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  pointer-events: auto;\n}\n\n.title-main {\n  font-size: var(--text-2xl);\n  font-weight: 800;\n  letter-spacing: -0.02em;\n  background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  margin: 0;\n  line-height: 1.1;\n}\n\n.title-filter {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  font-size: var(--text-xs);\n  font-weight: 600;\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n  margin-top: var(--space-1);\n}\n\n.project-color-header {\n  width: 8px;\n  height: 8px;\n  border-radius: var(--radius-full);\n}\n\n.project-emoji-header {\n  font-size: var(--text-sm);\n}\n\n/* INTEGRATED CONTROL PANEL */\n.control-panel {\n  display: flex;\n  align-items: center;\n  gap: var(--space-4);\n  padding: var(--space-3) var(--space-4);\n  margin-left: auto;\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  backdrop-filter: blur(var(--blur-md));\n  -webkit-backdrop-filter: blur(var(--blur-md));\n  box-shadow: var(--shadow-xl);\n  pointer-events: auto;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.control-panel:hover {\n  background: var(--glass-bg-soft);\n  border-color: var(--state-hover-border);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15),\n              0 2px 6px rgba(0, 0, 0, 0.1);\n}\n\n.time-display-container {\n  display: flex;\n  align-items: center;\n}\n\n.timer-container {\n  display: flex;\n  align-items: center;\n}\n\n.timer-display {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-xl);\n  border: 1.5px solid transparent;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n/* Work Timer - Stroke + Glow (NO fill) */\n.timer-display.timer-active {\n  background: transparent !important;\n  border: 1.5px solid var(--timer-work-stroke);\n  box-shadow: var(--timer-work-stroke-glow);\n}\n\n.timer-display.timer-active:hover {\n  box-shadow: var(--timer-work-stroke-glow-intense);\n}\n\n/* Break Timer - Stroke + Glow (NO fill) */\n.timer-display.timer-break {\n  background: transparent !important;\n  border: 1.5px solid var(--timer-break-stroke);\n  box-shadow: var(--timer-break-stroke-glow);\n}\n\n.timer-display.timer-break:hover {\n  box-shadow: var(--timer-break-stroke-glow-intense);\n}\n\n.timer-icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.timer-emoticon {\n  font-size: var(--text-2xl);\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.timer-emoticon.active {\n  animation: emoticonBounce 1.5s ease-in-out infinite;\n}\n\n@keyframes emoticonBounce {\n  0%, 100% { transform: translateY(0) scale(1); }\n  25% { transform: translateY(-6px) scale(1.1); }\n  50% { transform: translateY(0) scale(1); }\n  75% { transform: translateY(-3px) scale(1.05); }\n}\n\n.timer-stroke {\n  color: var(--color-work);\n  animation: pulse 2s infinite;\n}\n\n.coffee-stroke {\n  color: var(--color-break);\n}\n\n.meditation-stroke {\n  color: var(--color-focus);\n}\n\n.timer-info {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.timer-time {\n  font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n  font-size: var(--text-lg);\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n  min-width: 4rem;\n  letter-spacing: 0.025em;\n}\n\n.timer-task {\n  font-size: var(--text-sm);\n  color: var(--text-muted);\n  font-weight: var(--font-medium);\n  max-width: 150px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  /* RTL support: auto-detect text direction for Hebrew/Arabic */\n  unicode-bidi: plaintext;\n  text-align: start;\n}\n\n.timer-controls {\n  display: flex;\n  gap: var(--space-1);\n}\n\n.timer-start-options {\n  display: flex;\n  gap: var(--space-1);\n}\n\n.timer-btn {\n  background: transparent;\n  border: none;\n  color: var(--text-muted);\n  width: 1.75rem;\n  height: 1.75rem;\n  border-radius: var(--radius-6);\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all var(--duration-fast) var(--ease-out);\n}\n\n.timer-btn:hover {\n  background: var(--surface-hover);\n  color: var(--text-secondary);\n}\n\n.timer-start, .timer-resume {\n  color: var(--color-work);\n}\n\n.timer-start:hover, .timer-resume:hover {\n  background: var(--state-hover-bg);\n  color: var(--color-work);\n}\n\n.timer-pause {\n  color: var(--color-break);\n}\n\n.timer-pause:hover {\n  background: var(--glass-bg-tint);\n  color: var(--color-break);\n}\n\n.timer-stop {\n  color: var(--color-danger);\n}\n\n.timer-stop:hover {\n  background: var(--danger-bg-subtle);\n  color: var(--color-danger);\n}\n\n@keyframes pulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.7; }\n}\n\n.sync-status-container {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n/* CONTENT HEADER */\n.content-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: var(--nav-tabs-spacing-below);\n  /* border-bottom removed — shared layout-header-border in MainLayout handles this */\n  padding-bottom: var(--nav-tabs-padding-bottom);\n  margin-left: calc(var(--space-12) * -1);\n  margin-right: calc(var(--space-12) * -1);\n  padding-left: var(--space-12);\n  padding-right: var(--space-12);\n  pointer-events: none;\n  position: relative;\n  z-index: 5;\n}\n\n.view-tabs {\n  display: flex;\n  gap: 0.125rem;\n  pointer-events: auto;\n}\n\n.view-tab {\n  background: transparent;\n  border: 1px solid transparent;\n  color: var(--text-muted);\n  padding: var(--space-3) var(--space-4);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n  text-decoration: none;\n}\n\n.view-tab:hover {\n  color: var(--text-secondary);\n  background: var(--state-hover-bg);\n  border-color: var(--state-hover-border);\n  backdrop-filter: var(--state-active-glass);\n  box-shadow: var(--shadow-md);\n}\n\n.view-tab.active {\n  color: var(--state-active-text);\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  backdrop-filter: var(--state-active-glass);\n  font-weight: var(--font-semibold);\n  box-shadow: var(--shadow-md), var(--state-hover-glow);\n}\n\n.tab-badge {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  min-width: 20px;\n  height: 20px;\n  padding: 0 var(--space-1_5);\n  margin-left: var(--space-1_5);\n  background: linear-gradient(135deg, var(--color-blue), #8b5cf6);\n  border-radius: var(--radius-md);\n  font-size: var(--text-xs);\n  font-weight: 700;\n  color: #ffffff;\n  line-height: 1;\n}\n\n.view-tab.active .tab-badge {\n  background: linear-gradient(135deg, #60a5fa, #a78bfa);\n  box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);\n}\n\n/* AI TOGGLE BUTTON (TASK-1120) */\n.ai-toggle-btn {\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 36px;\n  height: 36px;\n  border: none;\n  background: transparent;\n  color: var(--text-muted);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.ai-toggle-btn:hover {\n  color: var(--accent-primary, #8b5cf6);\n  background: var(--state-hover-bg);\n}\n\n.ai-toggle-btn.ai-active {\n  color: var(--accent-primary, #8b5cf6);\n  background: var(--accent-bg, rgba(139, 92, 246, 0.15));\n}\n\n.ai-badge {\n  position: absolute;\n  top: 2px;\n  right: 2px;\n  min-width: 16px;\n  height: 16px;\n  padding: 0 4px;\n  font-size: var(--text-xs);\n  font-weight: 700;\n  color: white;\n  background: linear-gradient(135deg, #8b5cf6, #06b6d4);\n  border-radius: var(--radius-full);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation: badgePulse 2s ease-in-out infinite;\n}\n\n@keyframes badgePulse {\n  0%, 100% { transform: scale(1); }\n  50% { transform: scale(1.1); }\n}\n\n.control-divider {\n  width: 1px;\n  height: 24px;\n  background: var(--border-subtle, rgba(255, 255, 255, 0.1));\n  margin: 0 var(--space-2);\n}\n\n/* HELP BUTTON (TASK-1319) */\n.help-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 36px;\n  height: 36px;\n  border: none;\n  background: transparent;\n  color: var(--text-muted);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.help-btn:hover {\n  color: var(--brand-primary);\n  background: var(--state-hover-bg);\n}\n\n/* GAMIFICATION WIDGETS (FEATURE-1118) */\n.gamification-widgets {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  position: relative;\n}\n\n.gamification-dropdown {\n  position: absolute;\n  top: calc(100% + var(--space-2));\n  right: 0;\n  z-index: 100;\n  min-width: 320px;\n  max-height: calc(100vh - 120px);\n  overflow-y: auto;\n  animation: slideDown 0.2s ease-out;\n}\n\n@keyframes slideDown {\n  from {\n    opacity: 0;\n    transform: translateY(-8px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.gamification-backdrop {\n  position: fixed;\n  inset: 0;\n  z-index: 99;\n}\n\n/* Cyberflow intensity: intense glow on Cyberflow nav tab */\n.cyberflow-tab--glow {\n  box-shadow: 0 0 8px var(--neon-magenta, rgba(255, 0, 255, 0.4)),\n              0 0 16px var(--neon-magenta, rgba(255, 0, 255, 0.2));\n  animation: cyberflowPulse 2s ease-in-out infinite;\n}\n\n@keyframes cyberflowPulse {\n  0%, 100% { filter: brightness(1); }\n  50% { filter: brightness(1.15); }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/layouts/AppSidebar.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isWhisperSupported' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":778,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":778,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'hasWhisperApiKey' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":779,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":779,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":854,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":854,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29632,29635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29632,29635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":858,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":858,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29741,29744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29741,29744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <!-- LEFT SIDEBAR NAVIGATION - Extracted from App.vue -->\n  <Transition name=\"sidebar-slide\">\n    <aside\n      v-if=\"uiStore\"\n      v-show=\"uiStore.mainSidebarVisible\"\n      class=\"sidebar\"\n      aria-label=\"Main navigation\"\n      :aria-hidden=\"!uiStore.mainSidebarVisible\"\n    >\n      <!-- App Header -->\n      <div class=\"sidebar-header\">\n        <div class=\"app-brand\">\n          <span class=\"brand-icon\">🍅</span>\n          <span class=\"brand-text\">FlowState</span>\n        </div>\n        <BaseButton variant=\"secondary\" size=\"md\" @click=\"sidebar.openCreateProject\">\n          <Plus :size=\"14\" />\n          Create project\n        </BaseButton>\n\n        <div class=\"icon-button-group\">\n          <button\n            class=\"icon-btn\"\n            title=\"Hide Sidebar\"\n            aria-label=\"Hide sidebar\"\n            @click=\"uiStore.toggleMainSidebar\"\n          >\n            <PanelLeftClose :size=\"18\" />\n          </button>\n\n          <button\n            class=\"icon-btn\"\n            title=\"Settings\"\n            aria-label=\"Open settings\"\n            @click=\"uiStore.openSettingsModal()\"\n          >\n            <Settings :size=\"18\" />\n          </button>\n        </div>\n      </div>\n\n      <!-- Quick Task Creation - REBUILT with TASK-1324 enhancements -->\n      <div class=\"quick-task-section\">\n        <div class=\"quick-task-row\">\n          <!-- Single-line input (shown when not expanded) -->\n          <input\n            v-if=\"!isQuickAddExpanded\"\n            ref=\"quickTaskRef\"\n            v-model=\"quickTaskText\"\n            :dir=\"quickTaskDirection\"\n            type=\"text\"\n            class=\"quick-task-input\"\n            :class=\"{ 'voice-active': isListening }\"\n            :placeholder=\"isListening ? 'Listening...' : 'Quick add task (Enter)...'\"\n            aria-label=\"Quick add task\"\n            @keydown.enter.prevent=\"createQuickTask\"\n            @keydown.escape=\"collapseQuickAdd\"\n            @focus=\"quickTaskFocused = true\"\n            @blur=\"quickTaskFocused = false\"\n          >\n          <!-- Multi-line textarea (shown when expanded) -->\n          <textarea\n            v-else\n            ref=\"quickTaskExpandedRef\"\n            v-model=\"quickTaskText\"\n            :dir=\"quickTaskDirection\"\n            class=\"quick-task-textarea\"\n            :class=\"{ 'voice-active': isListening }\"\n            :placeholder=\"isListening ? 'Listening...' : 'Quick add task (Enter)...'\"\n            aria-label=\"Quick add task\"\n            rows=\"3\"\n            @keydown.enter.exact.prevent=\"createQuickTask\"\n            @keydown.escape=\"collapseQuickAdd\"\n            @focus=\"quickTaskFocused = true\"\n            @blur=\"quickTaskFocused = false\"\n          />\n          <!-- Mic button (TASK-1024) - ALWAYS SHOW FOR DEBUG -->\n          <button\n            class=\"mic-btn\"\n            :class=\"[{ recording: isListening }]\"\n            :title=\"isListening ? 'Stop recording' : 'Voice input'\"\n            @click=\"toggleVoiceInput\"\n          >\n            <Mic v-if=\"!isListening\" :size=\"16\" />\n            <MicOff v-else :size=\"16\" />\n          </button>\n        </div>\n\n        <!-- Metadata row (date + priority pickers) - TASK-1324 Feature 2 & 3 -->\n        <Transition name=\"fade-slide\">\n          <div v-if=\"showMetadataRow\" class=\"metadata-row\">\n            <!-- Date picker -->\n            <div class=\"metadata-picker\">\n              <button\n                class=\"metadata-btn\"\n                :class=\"{ 'has-value': quickTaskDueDate }\"\n                :style=\"quickTaskDueDate ? { color: 'var(--brand-primary)' } : {}\"\n                @click=\"toggleDatePicker\"\n              >\n                <CalendarDays :size=\"14\" />\n                <span v-if=\"quickTaskDueDate\" class=\"metadata-label\">{{ formatDateLabel(quickTaskDueDate) }}</span>\n                <span v-else class=\"metadata-label\">No date</span>\n              </button>\n\n              <!-- Date dropdown -->\n              <Transition name=\"fade\">\n                <div v-if=\"showDatePicker\" class=\"metadata-dropdown date-dropdown\">\n                  <button class=\"dropdown-option\" @click=\"selectDate('today')\">\n                    Today\n                  </button>\n                  <button class=\"dropdown-option\" @click=\"selectDate('tomorrow')\">\n                    Tomorrow\n                  </button>\n                  <button class=\"dropdown-option\" @click=\"selectDate('weekend')\">\n                    This Weekend\n                  </button>\n                  <button class=\"dropdown-option\" @click=\"selectDate(null)\">\n                    No Date\n                  </button>\n                </div>\n              </Transition>\n            </div>\n\n            <span class=\"metadata-divider\">·</span>\n\n            <!-- Priority picker -->\n            <div class=\"metadata-picker\">\n              <button\n                class=\"metadata-btn\"\n                :class=\"{ 'has-value': quickTaskPriority }\"\n                :style=\"getPriorityColor(quickTaskPriority)\"\n                @click=\"togglePriorityPicker\"\n              >\n                <Flag :size=\"14\" />\n                <span class=\"metadata-label\">{{ formatPriorityLabel(quickTaskPriority) }}</span>\n              </button>\n\n              <!-- Priority dropdown -->\n              <Transition name=\"fade\">\n                <div v-if=\"showPriorityPicker\" class=\"metadata-dropdown priority-dropdown\">\n                  <button class=\"dropdown-option\" @click=\"selectPriority(null)\">\n                    <Flag :size=\"12\" />\n                    <span>None</span>\n                  </button>\n                  <button class=\"dropdown-option priority-low\" @click=\"selectPriority('low')\">\n                    <Flag :size=\"12\" />\n                    <span>Low</span>\n                  </button>\n                  <button class=\"dropdown-option priority-medium\" @click=\"selectPriority('medium')\">\n                    <Flag :size=\"12\" />\n                    <span>Medium</span>\n                  </button>\n                  <button class=\"dropdown-option priority-high\" @click=\"selectPriority('high')\">\n                    <Flag :size=\"12\" />\n                    <span>High</span>\n                  </button>\n                </div>\n              </Transition>\n            </div>\n          </div>\n        </Transition>\n\n        <!-- Voice feedback (when recording) -->\n        <div v-if=\"isListening || isProcessingVoice\" class=\"voice-feedback\">\n          <div class=\"voice-waveform\">\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n          </div>\n          <span class=\"voice-status\">{{ displayTranscript || 'Speak now...' }}</span>\n          <button class=\"voice-cancel\" @click=\"cancelVoice\">\n            <X :size=\"12\" />\n          </button>\n        </div>\n        <!-- Voice error message -->\n        <div v-if=\"voiceError && !isListening\" class=\"voice-error\">\n          {{ voiceError }}\n        </div>\n      </div>\n\n      <!-- Project & Task Management -->\n      <div class=\"task-management-section\">\n        <!-- Smart Views - Using DateDropZone for drag and drop functionality -->\n        <div class=\"smart-views-grid\">\n          <!-- Today -->\n          <SidebarSmartItem\n            :active=\"taskStore.activeSmartView === 'today'\"\n            :count=\"todayTaskCount\"\n            drop-type=\"date\"\n            drop-value=\"today\"\n            color=\"azure\"\n            compact\n            @click=\"selectSmartView('today')\"\n          >\n            <template #icon>\n              <Calendar :size=\"14\" />\n            </template>\n            Today\n          </SidebarSmartItem>\n\n          <!-- This Week -->\n          <SidebarSmartItem\n            :active=\"taskStore.activeSmartView === 'week'\"\n            :count=\"weekTaskCount\"\n            drop-type=\"date\"\n            drop-value=\"weekend\"\n            color=\"azure-dark\"\n            compact\n            @click=\"selectSmartView('week')\"\n          >\n            <template #icon>\n              <Calendar :size=\"14\" />\n            </template>\n            This Week\n          </SidebarSmartItem>\n        </div>\n\n        <div class=\"sidebar-sub-divider\" />\n\n        <div class=\"smart-views-grid secondary\">\n          <!-- All Active -->\n          <SidebarSmartItem\n            :active=\"taskStore.activeSmartView === 'all_active'\"\n            :count=\"allActiveCount\"\n            drop-type=\"date\"\n            drop-value=\"nodate\"\n            color=\"blue\"\n            compact\n            @click=\"selectSmartView('all_active')\"\n          >\n            <template #icon>\n              <List :size=\"14\" />\n            </template>\n            All Active\n          </SidebarSmartItem>\n\n          <!-- Uncategorized (Inbox) -->\n          <SidebarSmartItem\n            :active=\"taskStore.activeSmartView === 'uncategorized'\"\n            :count=\"uncategorizedCount\"\n            drop-type=\"date\"\n            drop-value=\"nodate\"\n            color=\"orange\"\n            compact\n            @click=\"selectSmartView('uncategorized')\"\n          >\n            <template #icon>\n              <Inbox :size=\"14\" />\n            </template>\n            Inbox\n          </SidebarSmartItem>\n        </div>\n\n        <!-- Quick Sort Button (shows when uncategorized filter is active) -->\n        <Transition name=\"fade\">\n          <button\n            v-if=\"taskStore.activeSmartView === 'uncategorized' && uncategorizedCount > 0\"\n            class=\"quick-sort-button-full\"\n            title=\"Start Quick Sort to categorize these tasks\"\n            @click=\"handleStartQuickSort\"\n          >\n            <Zap :size=\"16\" />\n            <span>Categorize Inbox ({{ uncategorizedCount }})</span>\n          </button>\n        </Transition>\n\n        <!-- Duration Groups - Collapsible Section -->\n        <div class=\"duration-section\">\n          <button \n            class=\"section-toggle\" \n            :aria-expanded=\"sidebar.isDurationSectionExpanded.value\"\n            @click=\"sidebar.toggleDurationSection\"\n          >\n            <Clock :size=\"14\" />\n            <span>By Duration</span>\n            <ChevronRight \n              :size=\"14\" \n              class=\"toggle-chevron\" \n              :class=\"{ rotated: sidebar.isDurationSectionExpanded.value }\" \n            />\n          </button>\n          \n          <div v-show=\"sidebar.isDurationSectionExpanded.value\" class=\"duration-grid\">\n            <!-- Quick (<15m) -->\n            <SidebarSmartItem\n              :active=\"taskStore.activeDurationFilter === 'quick'\"\n              :count=\"sidebar.quickCount.value\"\n              drop-type=\"duration\"\n              :drop-value=\"15\"\n              color=\"green\"\n              compact\n              @click=\"sidebar.selectSmartView('quick')\"\n            >\n              <template #icon>\n                <Zap :size=\"14\" />\n              </template>\n              Quick\n            </SidebarSmartItem>\n\n            <!-- Short (15-30m) -->\n            <SidebarSmartItem\n              :active=\"taskStore.activeDurationFilter === 'short'\"\n              :count=\"sidebar.shortCount.value\"\n              drop-type=\"duration\"\n              :drop-value=\"30\"\n              color=\"teal\"\n              compact\n              @click=\"sidebar.selectSmartView('short')\"\n            >\n              <template #icon>\n                <Coffee :size=\"14\" />\n              </template>\n              Short\n            </SidebarSmartItem>\n\n            <!-- Medium (30-60m) -->\n            <SidebarSmartItem\n              :active=\"taskStore.activeDurationFilter === 'medium'\"\n              :count=\"sidebar.mediumCount.value\"\n              drop-type=\"duration\"\n              :drop-value=\"60\"\n              color=\"teal\"\n              compact\n              @click=\"sidebar.selectSmartView('medium')\"\n            >\n              <template #icon>\n                <Hourglass :size=\"14\" />\n              </template>\n              Medium\n            </SidebarSmartItem>\n\n            <!-- Long (>60m) -->\n            <SidebarSmartItem\n              :active=\"taskStore.activeDurationFilter === 'long'\"\n              :count=\"sidebar.longCount.value\"\n              drop-type=\"duration\"\n              :drop-value=\"120\"\n              color=\"purple\"\n              compact\n              @click=\"sidebar.selectSmartView('long')\"\n            >\n              <template #icon>\n                <Mountain :size=\"14\" />\n              </template>\n              Long\n            </SidebarSmartItem>\n\n            <!-- Unestimated -->\n            <SidebarSmartItem\n              :active=\"taskStore.activeDurationFilter === 'unestimated'\"\n              :count=\"sidebar.unestimatedCount.value\"\n              drop-type=\"duration\"\n              :drop-value=\"-1\"\n              color=\"gray\"\n              compact\n              @click=\"sidebar.selectSmartView('unestimated')\"\n            >\n              <template #icon>\n                <HelpCircle :size=\"14\" />\n              </template>\n              No Estimate\n            </SidebarSmartItem>\n          </div>\n        </div>\n\n        <!-- Projects Section Header -->\n        <div class=\"projects-divider\" />\n        <div class=\"section-header\">\n          <h3 class=\"section-title\">\n            <FolderOpen :size=\"16\" class=\"section-icon\" />\n            Projects\n          </h3>\n          <button class=\"add-project-btn\" title=\"Add Project\" @click=\"sidebar.openCreateProject\">\n            <Plus :size=\"14\" />\n          </button>\n        </div>\n\n        <!-- Project Selection Bar (shown when projects are selected) -->\n        <Transition name=\"fade\">\n          <div v-if=\"multiSelectMode\" class=\"project-selection-bar\">\n            <span class=\"selection-count\">{{ selectedProjectIds.size }} selected</span>\n            <button\n              class=\"selection-action delete-action\"\n              title=\"Delete selected projects\"\n              @click=\"confirmDeleteSelectedProjects\"\n            >\n              <Trash2 :size=\"14\" />\n              Delete\n            </button>\n            <button\n              class=\"selection-action clear-action\"\n              title=\"Clear selection (Esc)\"\n              @click=\"clearProjectSelection\"\n            >\n              <X :size=\"14\" />\n            </button>\n          </div>\n        </Transition>\n\n        <!-- Delete Confirmation Modal -->\n        <Transition name=\"fade\">\n          <div v-if=\"showDeleteConfirm\" class=\"delete-confirm-overlay\" @click.self=\"cancelDeleteProjects\">\n            <div class=\"delete-confirm-modal\">\n              <h4>Delete {{ projectsToDeleteCount }} project{{ projectsToDeleteCount > 1 ? 's' : '' }}?</h4>\n              <p>Tasks in {{ projectsToDeleteCount > 1 ? 'these projects' : 'this project' }} will be moved to Inbox. This cannot be undone.</p>\n              <div class=\"confirm-actions\">\n                <button class=\"cancel-btn\" @click=\"cancelDeleteProjects\">\n                  Cancel\n                </button>\n                <button class=\"delete-btn\" @click=\"executeDeleteProjects\">\n                  Delete\n                </button>\n              </div>\n            </div>\n          </div>\n        </Transition>\n\n        <!-- Project List - Recursive tree rendering with accessibility -->\n        <nav\n          class=\"projects-list\"\n          role=\"tree\"\n          aria-label=\"Projects\"\n          :aria-activedescendant=\"taskStore.activeProjectId ? `project-${taskStore.activeProjectId}` : undefined\"\n          @keydown=\"handleProjectTreeKeydown\"\n        >\n          <!-- All Projects Option -->\n          <div class=\"project-tree-item\">\n            <BaseNavItem\n              :active=\"!taskStore.activeProjectId && selectedProjectIds.size === 0\"\n              @click=\"handleAllProjectsClick\"\n            >\n              <template #icon>\n                <Layers :size=\"16\" />\n              </template>\n              All Projects\n            </BaseNavItem>\n          </div>\n\n          <ProjectTreeItem\n            v-for=\"project in taskStore.projects.filter(p => !p.parentId)\"\n            :key=\"project.id\"\n            :project=\"project\"\n            :expanded-projects=\"sidebar.expandedProjects.value || []\"\n            :selected-project-ids=\"selectedProjectIds\"\n            :level=\"1\"\n            @click=\"handleProjectClick\"\n            @toggle-expand=\"sidebar.toggleProjectExpansion\"\n            @contextmenu=\"handleProjectContextMenu\"\n            @project-drop=\"() => {}\"\n          />\n        </nav>\n      </div>\n\n\n      <!-- User Profile Footer -->\n      <div class=\"sidebar-footer\">\n        <button v-if=\"!authStore.user\" class=\"sidebar-login-btn\" @click=\"uiStore.openAuthModal('login')\">\n          <span style=\"font-weight: 600;\">Sign In</span>\n        </button>\n        <div v-else class=\"user-profile-row\">\n          <div class=\"user-avatar-circle\">\n            {{ (authStore.user?.email ? authStore.user.email[0].toUpperCase() : 'U') }}\n          </div>\n          <div class=\"user-info-col\">\n            <span class=\"user-email\" :title=\"authStore.user?.email || ''\">{{ authStore.user?.email || 'Authenticated' }}</span>\n            <span class=\"user-status\">Online</span>\n          </div>\n          <button class=\"settings-mini-btn\" title=\"Settings\" @click=\"uiStore.openSettingsModal()\">\n            <Settings :size=\"16\" />\n          </button>\n        </div>\n      </div>\n    </aside>\n  </Transition>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, onMounted, onBeforeUnmount, nextTick } from 'vue'\nimport { useRouter } from 'vue-router'\nimport { useUIStore } from '@/stores/ui'\nimport { useTaskStore, type Project } from '@/stores/tasks'\nimport { useAuthStore } from '@/stores/auth'\nimport { useSidebarManagement } from '@/composables/app/useSidebarManagement'\nimport {\n  Plus, PanelLeftClose, Settings, FolderOpen,\n  Calendar, List, Inbox, Zap, Clock, HelpCircle,\n  ChevronRight, Coffee, Hourglass, Mountain, Trash2, X,\n  Layers, Mic, MicOff, CalendarDays, Flag\n} from 'lucide-vue-next'\nimport { useWhisperSpeech } from '@/composables/useWhisperSpeech'\n\nimport BaseButton from '@/components/base/BaseButton.vue'\nimport BaseNavItem from '@/components/base/BaseNavItem.vue'\nimport SidebarSmartItem from '@/components/layout/SidebarSmartItem.vue'\nimport ProjectTreeItem from '@/components/projects/ProjectTreeItem.vue'\n\nconst router = useRouter()\nconst uiStore = useUIStore()\nconst taskStore = useTaskStore()\nconst authStore = useAuthStore()\nconst sidebar = useSidebarManagement()\n\n// BUG-1086: REMOVED fire-and-forget authStore.initialize() call\n// Auth is already initialized by router guard (src/router/index.ts:130)\n// and useAppInitialization.ts - this duplicate call caused race conditions\n\n// Project Multi-Select State (Now Global)\nconst selectedProjectIds = computed(() => uiStore.selectedProjectIds)\nconst lastSelectedProjectId = computed(() => uiStore.lastSelectedProjectId)\nconst multiSelectMode = computed(() => uiStore.selectedProjectIds.size > 0)\nconst showDeleteConfirm = ref(false)\n\n// Handle \"All Projects\" click\nconst handleAllProjectsClick = () => {\n  taskStore.setActiveProject(null)\n  uiStore.clearProjectSelection()\n}\n\n// Project Selection Handlers\nconst handleProjectClick = (event: MouseEvent, project: Project) => {\n  // Handle Shift+Click (Range Selection)\n  if (event.shiftKey) {\n    if (!lastSelectedProjectId.value) {\n      uiStore.setProjectSelection([project.id])\n      return\n    }\n\n    // Has anchor - perform range selection\n    const allProjects = getFlattenedProjectList()\n    const lastIndex = allProjects.findIndex(p => p.id === lastSelectedProjectId.value)\n    const currentIndex = allProjects.findIndex(p => p.id === project.id)\n\n    if (lastIndex === -1) {\n      uiStore.setProjectSelection([project.id])\n      return\n    }\n\n    if (currentIndex !== -1) {\n      const start = Math.min(lastIndex, currentIndex)\n      const end = Math.max(lastIndex, currentIndex)\n      const rangeProjects = allProjects.slice(start, end + 1)\n      \n      const ids = rangeProjects.map(p => p.id)\n      // Merge with existing selection if Ctrl also held? No, standard range replace.\n      // But typically Shift appends range to selection if Ctrl held? simpler for now: replace.\n      uiStore.setProjectSelection(ids)\n    }\n    return\n  }\n\n  // Handle Ctrl/Cmd+Click (Toggle Selection)\n  if (event.ctrlKey || event.metaKey) {\n    uiStore.toggleProjectSelection(project.id)\n    return\n  }\n\n  // Single click - clear selection and select project normally\n  // This is the \"All Projects\" feature: accessing a single project clears multi-select\n  clearProjectSelection()\n  sidebar.selectProject(project)\n}\n\nconst clearProjectSelection = () => {\n  uiStore.clearProjectSelection()\n  showDeleteConfirm.value = false\n}\n\nconst deleteSelectedProjects = async () => {\n  // Get IDs to delete - either from multi-selection or from active project\n  let idsToDelete: string[] = []\n\n  if (selectedProjectIds.value.size > 0) {\n    idsToDelete = Array.from(selectedProjectIds.value)\n  } else if (taskStore.activeProjectId && taskStore.activeProjectId !== 'uncategorized') {\n    // Single active project (not in multi-select mode)\n    idsToDelete = [taskStore.activeProjectId]\n  }\n\n  if (idsToDelete.length === 0) return\n\n  try {\n    await taskStore.deleteProjects(idsToDelete)\n  } catch (error) {\n    console.error('❌ Error deleting projects:', error)\n  }\n  clearProjectSelection()\n}\n\nconst confirmDeleteSelectedProjects = () => {\n  showDeleteConfirm.value = true\n}\n\nconst cancelDeleteProjects = () => {\n  showDeleteConfirm.value = false\n}\n\nconst executeDeleteProjects = async () => {\n  await deleteSelectedProjects()\n  showDeleteConfirm.value = false\n}\n\n// Check if there are projects that can be deleted (selected or active)\nconst hasDeletableProjects = computed(() => {\n  if (selectedProjectIds.value.size > 0) return true\n  if (taskStore.activeProjectId && taskStore.activeProjectId !== 'uncategorized') return true\n  return false\n})\n\n// Get count of projects to delete (for modal)\nconst projectsToDeleteCount = computed(() => {\n  if (selectedProjectIds.value.size > 0) return selectedProjectIds.value.size\n  if (taskStore.activeProjectId && taskStore.activeProjectId !== 'uncategorized') return 1\n  return 0\n})\n\n// Keyboard handler for project selection actions\nconst handleProjectKeydown = (event: KeyboardEvent) => {\n  // Don't handle if typing in an input field\n  const target = event.target as HTMLElement\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return\n  }\n\n  // Escape: Clear selection\n  if (event.key === 'Escape' && selectedProjectIds.value.size > 0) {\n    clearProjectSelection()\n    return\n  }\n\n  // Delete or Backspace: Show confirmation to delete projects (selected or active)\n  if ((event.key === 'Delete' || event.key === 'Backspace') && hasDeletableProjects.value) {\n    event.preventDefault()\n    event.stopPropagation()\n    confirmDeleteSelectedProjects()\n    return\n  }\n}\n\n// Lifecycle - add/remove keyboard listener and outside click handler\nonMounted(() => {\n  window.addEventListener('keydown', handleProjectKeydown)\n  window.addEventListener('click', handleOutsideClick)\n})\n\nonBeforeUnmount(() => {\n  window.removeEventListener('keydown', handleProjectKeydown)\n  window.removeEventListener('click', handleOutsideClick)\n})\n\n// Quick Task Logic\nconst quickTaskRef = ref<HTMLInputElement | null>(null)\nconst quickTaskExpandedRef = ref<HTMLTextAreaElement | null>(null)\nconst quickTaskText = ref('')\nconst quickTaskFocused = ref(false)\n\n// TASK-1324: Quick task metadata (date + priority)\nconst quickTaskDueDate = ref<string | null>(null)\nconst quickTaskPriority = ref<'low' | 'medium' | 'high' | null>(null)\nconst showDatePicker = ref(false)\nconst showPriorityPicker = ref(false)\n\n// RTL detection for Hebrew input\nconst quickTaskDirection = computed(() => {\n  const text = quickTaskText.value.trim()\n  if (!text) return 'ltr'\n  const rtlRegex = /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/\n  return rtlRegex.test(text[0]) ? 'rtl' : 'ltr'\n})\n\n// TASK-1324 Feature 1: Auto-expand when text gets long\nconst isQuickAddExpanded = computed(() => {\n  const text = quickTaskText.value.trim()\n  if (!text) return false\n  const wordCount = text.split(/\\s+/).length\n  return wordCount >= 6 || text.length > 40\n})\n\n// Show metadata row when input is focused OR has values set\nconst showMetadataRow = computed(() => {\n  return quickTaskFocused.value || quickTaskDueDate.value !== null || quickTaskPriority.value !== null\n})\n\n// Auto-focus the textarea when expanding\nwatch(isQuickAddExpanded, (expanded) => {\n  if (expanded) {\n    nextTick(() => quickTaskExpandedRef.value?.focus())\n  }\n})\n\n// Collapse quick add (clear text)\nconst collapseQuickAdd = () => {\n  quickTaskText.value = ''\n}\n\n// TASK-1324 Feature 2: Date picker\nconst toggleDatePicker = () => {\n  showDatePicker.value = !showDatePicker.value\n  showPriorityPicker.value = false\n}\n\nconst selectDate = (option: 'today' | 'tomorrow' | 'weekend' | null) => {\n  if (option === null) {\n    quickTaskDueDate.value = null\n  } else if (option === 'today') {\n    const today = new Date()\n    quickTaskDueDate.value = today.toISOString().split('T')[0]\n  } else if (option === 'tomorrow') {\n    const tomorrow = new Date()\n    tomorrow.setDate(tomorrow.getDate() + 1)\n    quickTaskDueDate.value = tomorrow.toISOString().split('T')[0]\n  } else if (option === 'weekend') {\n    const today = new Date()\n    const dayOfWeek = today.getDay()\n    const daysUntilSaturday = (6 - dayOfWeek + 7) % 7\n    const saturday = new Date()\n    saturday.setDate(today.getDate() + daysUntilSaturday)\n    quickTaskDueDate.value = saturday.toISOString().split('T')[0]\n  }\n  showDatePicker.value = false\n}\n\nconst formatDateLabel = (date: string | null): string => {\n  if (!date) return 'No date'\n  const d = new Date(date + 'T00:00:00')\n  const today = new Date()\n  const tomorrow = new Date()\n  tomorrow.setDate(today.getDate() + 1)\n\n  const dateStr = d.toISOString().split('T')[0]\n  const todayStr = today.toISOString().split('T')[0]\n  const tomorrowStr = tomorrow.toISOString().split('T')[0]\n\n  if (dateStr === todayStr) return 'Today'\n  if (dateStr === tomorrowStr) return 'Tomorrow'\n  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })\n}\n\n// TASK-1324 Feature 3: Priority picker\nconst togglePriorityPicker = () => {\n  showPriorityPicker.value = !showPriorityPicker.value\n  showDatePicker.value = false\n}\n\nconst selectPriority = (priority: 'low' | 'medium' | 'high' | null) => {\n  quickTaskPriority.value = priority\n  showPriorityPicker.value = false\n}\n\nconst formatPriorityLabel = (priority: 'low' | 'medium' | 'high' | null): string => {\n  if (!priority) return 'None'\n  return priority.charAt(0).toUpperCase() + priority.slice(1)\n}\n\nconst getPriorityColor = (priority: 'low' | 'medium' | 'high' | null) => {\n  if (!priority) return {}\n  const colors: Record<string, string> = {\n    low: 'var(--color-priority-low)',\n    medium: 'var(--color-priority-medium)',\n    high: 'var(--color-priority-high)'\n  }\n  return { color: colors[priority] }\n}\n\n// Close dropdowns when clicking outside\nconst handleOutsideClick = (event: MouseEvent) => {\n  const target = event.target as HTMLElement\n  if (!target.closest('.metadata-picker')) {\n    showDatePicker.value = false\n    showPriorityPicker.value = false\n  }\n}\n\n// TASK-1322: Whisper-only voice input (browser speech recognition removed)\nconst {\n  isRecording: isWhisperRecording,\n  isProcessing: isWhisperProcessing,\n  isSupported: isWhisperSupported,\n  hasApiKey: hasWhisperApiKey,\n  transcript: whisperTranscript,\n  error: whisperError,\n  start: startWhisper,\n  stop: stopWhisper,\n  cancel: cancelWhisper\n} = useWhisperSpeech({\n  onResult: (result) => {\n    console.log('[Whisper Sidebar] Result:', result)\n    if (result.transcript.trim()) {\n      quickTaskText.value = result.transcript.trim()\n      // Don't auto-submit — let user review and press Enter\n    }\n  },\n  onError: (err) => {\n    console.warn('[Whisper Sidebar] Error:', err)\n  }\n})\n\n// Voice state\nconst isListening = computed(() => isWhisperRecording.value)\nconst isProcessingVoice = computed(() => isWhisperProcessing.value)\nconst displayTranscript = computed(() => whisperTranscript.value)\nconst voiceError = computed(() => whisperError.value)\n\n// Toggle voice recording\nconst toggleVoiceInput = async () => {\n  if (isListening.value) {\n    stopWhisper()\n  } else {\n    quickTaskText.value = ''\n    await startWhisper()\n  }\n}\n\n// Cancel voice recording\nconst cancelVoice = () => {\n  cancelWhisper()\n}\n\nconst createQuickTask = async () => {\n  if (!quickTaskText.value.trim()) return\n\n  const title = quickTaskText.value.trim()\n  try {\n    await taskStore.createTaskWithUndo({\n      title,\n      description: '',\n      status: 'planned',\n      projectId: undefined,\n      ...(quickTaskDueDate.value && { dueDate: quickTaskDueDate.value }),\n      ...(quickTaskPriority.value && { priority: quickTaskPriority.value })\n    })\n    quickTaskText.value = ''\n    quickTaskDueDate.value = null\n    quickTaskPriority.value = null\n  } catch (error) {\n    console.error('Error creating quick task:', error)\n  }\n}\n\n// Smart View Counts\nconst todayTaskCount = computed(() => taskStore.smartViewTaskCounts.today)\nconst weekTaskCount = computed(() => taskStore.smartViewTaskCounts.week)\nconst allActiveCount = computed(() => taskStore.smartViewTaskCounts.allActive)\nconst uncategorizedCount = computed(() => taskStore.getUncategorizedTaskCount())\n// Reactive counts using the store getters\n\n\n// Methods\nconst selectSmartView = (view: string) => {\n  taskStore.setActiveProject(null)\n  \n  // Check if view is a duration filter\n  if (['quick', 'short', 'medium', 'long', 'unestimated'].includes(view)) {\n    taskStore.setActiveDurationFilter(view as any)\n    taskStore.setSmartView(null)\n  } else {\n    // It's a smart view\n    taskStore.setSmartView(view as any)\n    taskStore.setActiveDurationFilter(null)\n  }\n  \n  // TASK-1330: Verify navigation to tasks view when selecting a smart view\n  router.push('/tasks')\n}\n\nconst handleStartQuickSort = () => {\n  router.push('/quick-sort')\n}\n\n// Project Tree Navigation\nconst handleProjectTreeKeydown = (event: KeyboardEvent) => {\n  const { key } = event\n\n  switch (key) {\n    case 'ArrowDown':\n      event.preventDefault()\n      navigateToNextProject()\n      break\n    case 'ArrowUp':\n      event.preventDefault()\n      navigateToPreviousProject()\n      break\n    case 'ArrowRight':\n      event.preventDefault()\n      expandCurrentProject()\n      break\n    case 'ArrowLeft':\n      event.preventDefault()\n      collapseCurrentProjectOrNavigateToParent()\n      break\n    case 'Enter':\n    case ' ':\n      event.preventDefault()\n      activateCurrentProject()\n      break\n    case 'Home':\n      event.preventDefault()\n      navigateToFirstProject()\n      break\n    case 'End':\n      event.preventDefault()\n      navigateToLastProject()\n      break\n  }\n}\n\nconst navigateToNextProject = () => {\n  const currentProjectId = taskStore.activeProjectId\n  const allProjects = getFlattenedProjectList()\n  const currentIndex = allProjects.findIndex(p => p.id === currentProjectId)\n\n  if (currentIndex < allProjects.length - 1) {\n    taskStore.setActiveProject(allProjects[currentIndex + 1].id)\n  }\n}\n\nconst navigateToPreviousProject = () => {\n  const currentProjectId = taskStore.activeProjectId\n  const allProjects = getFlattenedProjectList()\n  const currentIndex = allProjects.findIndex(p => p.id === currentProjectId)\n\n  if (currentIndex > 0) {\n    taskStore.setActiveProject(allProjects[currentIndex - 1].id)\n  }\n}\n\nconst expandCurrentProject = () => {\n  const currentProjectId = taskStore.activeProjectId\n  if (currentProjectId && hasProjectChildren(currentProjectId)) {\n    if (!sidebar.expandedProjects.value.includes(currentProjectId)) {\n      sidebar.expandedProjects.value.push(currentProjectId)\n    }\n  }\n}\n\nconst collapseCurrentProjectOrNavigateToParent = () => {\n  const currentProjectId = taskStore.activeProjectId\n  if (!currentProjectId) return\n\n  if (hasProjectChildren(currentProjectId) && sidebar.expandedProjects.value.includes(currentProjectId)) {\n    const index = sidebar.expandedProjects.value.indexOf(currentProjectId)\n    sidebar.expandedProjects.value.splice(index, 1)\n  } else {\n    const project = taskStore.getProjectById(currentProjectId)\n    if (project?.parentId) {\n      taskStore.setActiveProject(project.parentId)\n    }\n  }\n}\n\nconst activateCurrentProject = () => {\n  const currentProjectId = taskStore.activeProjectId\n  if (currentProjectId) {\n    const project = taskStore.getProjectById(currentProjectId)\n    if (project) {\n      sidebar.selectProject(project)\n    }\n  }\n}\n\nconst navigateToFirstProject = () => {\n  const allProjects = getFlattenedProjectList()\n  if (allProjects.length > 0) {\n    taskStore.setActiveProject(allProjects[0].id)\n  }\n}\n\nconst navigateToLastProject = () => {\n  const allProjects = getFlattenedProjectList()\n  if (allProjects.length > 0) {\n    taskStore.setActiveProject(allProjects[allProjects.length - 1].id)\n  }\n}\n\nconst getFlattenedProjectList = () => {\n  const flatten = (projects: Project[]): Project[] => {\n    const result: Project[] = []\n    for (const project of projects) {\n      result.push(project)\n      if (sidebar.expandedProjects.value.includes(project.id)) {\n        const children = taskStore.projects.filter(p => p.parentId === project.id)\n        result.push(...flatten(children))\n      }\n    }\n    return result\n  }\n  return flatten(taskStore.projects.filter(p => !p.parentId))\n}\n\nconst hasProjectChildren = (projectId: string) => {\n  return taskStore.projects.some(p => p.parentId === projectId)\n}\n\nconst handleProjectContextMenu = (event: MouseEvent, project: Project) => {\n  event.preventDefault()\n  window.dispatchEvent(new CustomEvent('project-context-menu', {\n    detail: { event, project }\n  }))\n}\n\n// Expose focus method\ndefineExpose({\n  focusQuickTask: () => {\n    quickTaskRef.value?.focus()\n  }\n})\n</script>\n\n<style scoped>\n/* LEFT SIDEBAR - Glass effect */\n.sidebar {\n  /* Remove fixed width - let CSS Grid control the width */\n  min-width: 240px; /* Minimum width for usability */\n  max-width: 340px; /* Maximum width to prevent overly wide sidebar */\n  width: 100%; /* Fill the grid column */\n  background: linear-gradient(\n    135deg,\n    rgba(255, 255, 255, 0.03) 0%,\n    rgba(255, 255, 255, 0.01) 100%\n  );\n  backdrop-filter: blur(40px) saturate(200%);\n  -webkit-backdrop-filter: blur(40px) saturate(200%);\n  border-right: 1px solid var(--glass-border);\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  position: relative;\n  z-index: 100;\n  box-shadow:\n    var(--shadow-2xl),\n    inset -1px 0 0 var(--glass-bg-heavy);\n  contain: layout style; /* Performance optimization */\n  overflow: hidden; /* Prevent sidebar content from causing horizontal scroll */\n}\n\n.sidebar-footer {\n  margin-top: auto;\n  padding: var(--space-4);\n  border-top: 1px solid var(--glass-border);\n  background: var(--glass-bg-soft);\n}\n\n.sidebar-login-btn {\n  width: 100%;\n  padding: var(--space-2_5);\n  background: var(--glass-bg-soft);\n  color: var(--brand-primary);\n  border: 1px solid var(--brand-primary-alpha-40);\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--ease-out);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.sidebar-login-btn:hover {\n  background: var(--brand-primary-alpha-10);\n  border-color: var(--brand-primary);\n  box-shadow: 0 0 15px var(--brand-primary-alpha-20);\n}\n\n.user-profile-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2_5);\n  padding: var(--space-1);\n}\n\n.user-avatar-circle {\n  width: 32px;\n  height: 32px;\n  background: var(--brand-primary);\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-weight: bold;\n  font-size: var(--text-sm);\n  flex-shrink: 0;\n}\n\n.user-info-col {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.user-email {\n  font-size: var(--text-sm);\n  font-weight: 500;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  color: var(--text-primary);\n}\n\n.user-status {\n  font-size: var(--text-xs);\n  color: var(--success);\n}\n\n.settings-mini-btn {\n  background: transparent;\n  border: none;\n  color: var(--text-muted);\n  cursor: pointer;\n  padding: var(--space-1);\n  border-radius: var(--radius-sm);\n}\n\n.settings-mini-btn:hover {\n  background: var(--glass-border);\n  color: var(--text-primary);\n}\n\n/* Sidebar toggle transitions */\n.sidebar-slide-enter-active,\n.sidebar-slide-leave-active {\n  transition: transform var(--duration-slow) cubic-bezier(0.4, 0, 0.2, 1),\n              opacity 300ms cubic-bezier(0.4, 0, 0.2, 1);\n  will-change: transform, opacity;\n}\n\n.sidebar-slide-enter-from,\n.sidebar-slide-leave-to {\n  transform: translateX(-100%);\n  opacity: 0;\n}\n\n.sidebar-slide-enter-to,\n.sidebar-slide-leave-from {\n  transform: translateX(0);\n  opacity: 1;\n}\n\n.sidebar-header {\n  padding: var(--space-10) var(--space-6) var(--space-6) var(--space-6);\n  /* border-bottom removed — shared layout-header-border in MainLayout handles this */\n  background: var(--glass-bg-medium);\n}\n\n.app-brand {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  margin-bottom: var(--space-6);\n}\n\n.brand-icon {\n  font-size: var(--text-xl);\n}\n\n.brand-text {\n  font-size: var(--text-lg);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n}\n\n/* Sidebar header buttons */\n.sidebar-header button {\n  width: 100%;\n}\n\n/* Icon button group */\n.icon-button-group {\n  display: flex;\n  gap: var(--space-2);\n  margin-top: var(--space-2);\n}\n\n.icon-btn {\n  background: transparent;\n  border: 1px solid var(--border-medium);\n  color: var(--text-secondary);\n  width: 40px;\n  height: 40px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: var(--radius-md);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.icon-btn:hover {\n  background: var(--state-hover-bg);\n  border-color: var(--state-hover-border);\n  color: var(--text-primary);\n  box-shadow: var(--state-hover-shadow);\n}\n\n.icon-btn:active {\n  transform: scale(0.95);\n}\n\n/* Quick Task Section */\n.quick-task-section {\n  padding: var(--space-2);\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  margin: var(--space-4) var(--space-6);\n}\n\n.quick-task-row {\n  display: flex;\n  gap: var(--space-2);\n  align-items: center;\n}\n\n.quick-task-input {\n  flex: 1;\n  padding: var(--space-2_5);\n  background: var(--glass-bg-tint);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  transition: all var(--duration-normal);\n}\n\n.quick-task-input:focus {\n  outline: none;\n  border-color: var(--brand-primary);\n  background: var(--glass-bg-light);\n}\n\n.quick-task-input.voice-active {\n  border-color: var(--danger-text, #ef4444);\n  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);\n}\n\n/* Mic Button (TASK-1024) */\n.mic-btn {\n  width: 32px;\n  height: 32px;\n  border-radius: 50%;\n  border: none;\n  background: var(--glass-bg-soft);\n  color: var(--text-secondary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n  transition: all 0.2s ease;\n}\n\n.mic-btn:hover {\n  background: var(--glass-bg);\n  color: var(--text-primary);\n}\n\n.mic-btn:active {\n  transform: scale(0.95);\n}\n\n.mic-btn.recording {\n  background: var(--danger-text, #ef4444);\n  color: white;\n  animation: pulse-recording 1.5s ease-in-out infinite;\n}\n\n@keyframes pulse-recording {\n  0%, 100% {\n    box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);\n  }\n  50% {\n    box-shadow: 0 0 0 6px rgba(239, 68, 68, 0);\n  }\n}\n\n/* Voice feedback panel */\n.voice-feedback {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2);\n  margin-top: var(--space-2);\n  background: var(--glass-bg-soft);\n  border-radius: var(--radius-sm);\n  border: 1px solid var(--glass-border);\n}\n\n.voice-waveform {\n  display: flex;\n  align-items: center;\n  gap: 2px;\n  height: 16px;\n}\n\n.wave-bar {\n  width: 2px;\n  height: 4px;\n  background: var(--danger-text, #ef4444);\n  border-radius: 1px;\n  animation: wave 0.8s ease-in-out infinite;\n}\n\n.wave-bar:nth-child(1) { animation-delay: 0s; }\n.wave-bar:nth-child(2) { animation-delay: 0.1s; }\n.wave-bar:nth-child(3) { animation-delay: 0.2s; }\n\n@keyframes wave {\n  0%, 100% { height: 4px; }\n  50% { height: 12px; }\n}\n\n.voice-status {\n  flex: 1;\n  font-size: var(--text-xs);\n  color: var(--text-secondary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.voice-cancel {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  border: none;\n  background: transparent;\n  color: var(--text-tertiary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.voice-cancel:hover {\n  background: var(--glass-bg);\n  color: var(--danger-text, #ef4444);\n}\n\n/* Voice error message */\n.voice-error {\n  margin-top: var(--space-2);\n  padding: var(--space-1) var(--space-2);\n  background: rgba(239, 68, 68, 0.1);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: var(--danger-text, #ef4444);\n}\n\n.task-management-section {\n  flex: 1;\n  overflow-y: auto;\n  padding: var(--space-4) var(--space-6);\n}\n\n.section-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: var(--space-4);\n}\n\n.section-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  margin: 0;\n  letter-spacing: 0.05em;\n}\n\n.section-icon {\n  color: var(--text-muted);\n}\n\n.add-project-btn {\n  background: transparent;\n  border: 1px solid var(--border-medium);\n  color: var(--text-muted);\n  padding: var(--space-1);\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  transition: all var(--duration-fast) var(--ease-out);\n}\n\n.add-project-btn:hover {\n  background: var(--surface-hover);\n  border-color: var(--border-strong);\n  color: var(--text-secondary);\n}\n\n/* Smart Views Section */\n.smart-views {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  margin-bottom: var(--space-4);\n}\n\n/* Uncategorized Filter Styles */\n.smart-view-uncategorized {\n  margin-top: var(--space-2);\n  border-top: 1px solid var(--glass-bg-heavy);\n  padding-top: var(--space-2);\n}\n\n.uncategorized-filter {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  width: 100%;\n  padding: var(--space-3) var(--space-4);\n  background: transparent;\n  border: 1px solid transparent;\n  border-radius: var(--radius-lg);\n  color: var(--text-muted);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n\n/* Quick Sort Button */\n\n.projects-divider {\n  height: 1px;\n  background: linear-gradient(\n    90deg,\n    rgba(255, 255, 255, 0) 0%,\n    var(--glass-bg-heavy) 50%,\n    rgba(255, 255, 255, 0) 100%\n  );\n  margin: var(--space-4) 0;\n}\n\n.projects-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n  overflow-y: auto;\n  max-height: calc(100vh - 500px); /* Leave space for header and controls */\n  padding-right: var(--space-2); /* Prevent scroll from interfering with content */\n}\n\n/* RTL Support */\n[dir=\"rtl\"] .sidebar {\n  border-right: none;\n  border-left: 1px solid var(--glass-border-hover);\n  box-shadow:\n    var(--shadow-2xl),\n    inset 1px 0 0 var(--glass-bg-heavy);\n}\n\n[dir=\"rtl\"] .sidebar-slide-enter-from,\n[dir=\"rtl\"] .sidebar-slide-leave-to {\n  transform: translateX(100%);\n}\n/* Duration Section */\n.duration-section {\n  margin-bottom: var(--space-4);\n}\n\n.section-toggle {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  width: 100%;\n  padding: var(--space-2) var(--space-1);\n  background: transparent;\n  border: none;\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  letter-spacing: 0.05em;\n  cursor: pointer;\n  text-transform: uppercase;\n  margin-bottom: var(--space-2);\n}\n\n.section-toggle:hover {\n  color: var(--text-secondary);\n}\n\n.toggle-chevron {\n  margin-left: auto;\n  transition: transform var(--duration-fast);\n  opacity: 0.5;\n}\n\n.toggle-chevron.rotated {\n  transform: rotate(90deg);\n}\n\n.smart-views-grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-2);\n  padding: var(--space-4) var(--space-4) var(--space-2) var(--space-4);\n}\n\n.smart-views-grid.secondary {\n  padding-top: var(--space-2);\n  padding-bottom: var(--space-4);\n}\n\n.sidebar-sub-divider {\n  height: 1px;\n  background: var(--glass-border);\n  margin: var(--space-1) var(--space-4);\n  opacity: 0.3;\n}\n\n.quick-sort-button-full {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  width: calc(100% - 32px);\n  margin: 0 16px var(--space-4) 16px;\n  padding: var(--space-2);\n  background: var(--brand-primary);\n  color: #0a0a0a;\n  border: none;\n  border-radius: var(--radius-md);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n  box-shadow: var(--shadow-sm);\n}\n\n.quick-sort-button-full:hover {\n  transform: translateY(-1px);\n  box-shadow: var(--shadow-md);\n  filter: brightness(1.1);\n}\n\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity var(--duration-slow) var(--ease-out);\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n\n.duration-grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: var(--space-2);\n  padding: 0 var(--space-4) var(--space-4) var(--space-4);\n}\n\n/* Project Selection Bar */\n.project-selection-bar {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-4);\n  background: var(--glass-bg-heavy);\n  border: 1px solid var(--brand-primary-alpha-30);\n  border-radius: var(--radius-md);\n  margin: 0 var(--space-4) var(--space-2) var(--space-4);\n}\n\n.selection-count {\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  color: var(--brand-primary);\n  flex: 1;\n}\n\n.selection-action {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: transparent;\n  border: 1px solid var(--border-medium);\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.selection-action:hover {\n  background: var(--state-hover-bg);\n  border-color: var(--state-hover-border);\n}\n\n.selection-action.delete-action:hover {\n  background: rgba(239, 68, 68, 0.15);\n  border-color: rgba(239, 68, 68, 0.4);\n  color: var(--color-danger);\n}\n\n.selection-action.clear-action {\n  padding: var(--space-1);\n}\n\n/* Delete Confirmation Modal */\n.delete-confirm-overlay {\n  position: fixed;\n  inset: 0;\n  background: rgba(0, 0, 0, 0.75);\n  backdrop-filter: blur(12px);\n  -webkit-backdrop-filter: blur(12px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: var(--z-tooltip);\n}\n\n.delete-confirm-modal {\n  background: rgba(28, 25, 45, 0.95);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  padding: var(--space-6);\n  max-width: 400px;\n  width: 90%;\n  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);\n}\n\n.delete-confirm-modal h4 {\n  margin: 0 0 var(--space-3) 0;\n  font-size: var(--text-lg);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n}\n\n.delete-confirm-modal p {\n  margin: 0 0 var(--space-4) 0;\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  line-height: 1.5;\n}\n\n.confirm-actions {\n  display: flex;\n  gap: var(--space-2);\n  justify-content: flex-end;\n}\n\n.confirm-actions button {\n  padding: var(--space-2) var(--space-4);\n  border-radius: var(--radius-md);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.cancel-btn {\n  background: transparent;\n  border: 1px solid var(--border-medium);\n  color: var(--text-secondary);\n}\n\n.cancel-btn:hover {\n  background: var(--state-hover-bg);\n  border-color: var(--state-hover-border);\n}\n\n.delete-btn {\n  background: var(--color-danger);\n  border: none;\n  color: white;\n}\n\n.delete-btn:hover {\n  background: #dc2626;\n}\n\n/* TASK-1324: Textarea for expanded quick add (Feature 1) */\n.quick-task-textarea {\n  flex: 1;\n  padding: var(--space-2_5);\n  background: var(--glass-bg-tint);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  font-family: inherit;\n  resize: none;\n  transition: all var(--duration-normal);\n  line-height: 1.4;\n}\n\n.quick-task-textarea:focus {\n  outline: none;\n  border-color: var(--brand-primary);\n  background: var(--glass-bg-light);\n}\n\n.quick-task-textarea.voice-active {\n  border-color: var(--danger-text, #ef4444);\n  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);\n}\n\n/* TASK-1324: Metadata row for date + priority pickers (Features 2 & 3) */\n.metadata-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  margin-top: var(--space-2);\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-soft);\n}\n\n.metadata-divider {\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  user-select: none;\n}\n\n.metadata-picker {\n  position: relative;\n  display: flex;\n  align-items: center;\n}\n\n.metadata-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: transparent;\n  border: 1px solid var(--border-medium);\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.metadata-btn:hover {\n  background: var(--glass-bg);\n  border-color: var(--border-strong);\n  color: var(--text-primary);\n}\n\n.metadata-btn.has-value {\n  border-color: var(--brand-primary);\n}\n\n.metadata-label {\n  font-size: var(--text-xs);\n  white-space: nowrap;\n}\n\n/* Metadata dropdowns */\n.metadata-dropdown {\n  position: absolute;\n  top: calc(100% + var(--space-1));\n  left: 0;\n  z-index: var(--z-tooltip);\n  min-width: 140px;\n  background: var(--glass-bg-heavy);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  padding: var(--space-1);\n  box-shadow: var(--shadow-lg);\n  backdrop-filter: blur(12px);\n  -webkit-backdrop-filter: blur(12px);\n}\n\n.dropdown-option {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  width: 100%;\n  padding: var(--space-2);\n  background: transparent;\n  border: none;\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  text-align: left;\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.dropdown-option:hover {\n  background: var(--glass-bg-soft);\n  color: var(--text-primary);\n}\n\n/* Priority color variants */\n.dropdown-option.priority-low {\n  color: var(--color-priority-low);\n}\n\n.dropdown-option.priority-low:hover {\n  background: rgba(59, 130, 246, 0.1);\n}\n\n.dropdown-option.priority-medium {\n  color: var(--color-priority-medium);\n}\n\n.dropdown-option.priority-medium:hover {\n  background: rgba(245, 158, 11, 0.1);\n}\n\n.dropdown-option.priority-high {\n  color: var(--color-priority-high);\n}\n\n.dropdown-option.priority-high:hover {\n  background: rgba(239, 68, 68, 0.1);\n}\n\n/* Fade-slide transition for metadata row */\n.fade-slide-enter-active,\n.fade-slide-leave-active {\n  transition: all var(--duration-normal) var(--ease-out);\n}\n\n.fade-slide-enter-from,\n.fade-slide-leave-to {\n  opacity: 0;\n  transform: translateY(-4px);\n}\n\n.fade-slide-enter-to,\n.fade-slide-leave-from {\n  opacity: 1;\n  transform: translateY(0);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/layouts/MainLayout.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/layouts/ModalManager.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useTimerStore' is defined but never used. Allowed unused vars must match /^_/u.","line":106,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":106,"endColumn":23,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"useTimerStore"},"fix":{"range":[2978,3024],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":249,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7727,7730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7727,7730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":282,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8670,8673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8670,8673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13930,13933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13930,13933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14649,14652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14649,14652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <!-- MODAL MANAGER - Extracted from App.vue to reduce complexity -->\n  <div class=\"modal-manager\">\n    <!-- SETTINGS MODAL -->\n    <SettingsModal\n      :is-open=\"uiStore.settingsModalOpen\"\n      @close=\"uiStore.closeSettingsModal()\"\n    />\n    \n    <!-- AUTH MODAL -->\n    <AuthModal\n      :is-open=\"uiStore.authModalOpen\"\n      :initial-view=\"uiStore.authModalView\"\n      @close=\"uiStore.closeAuthModal()\"\n    />\n\n    <!-- PROJECT MODAL -->\n    <ProjectModal\n      :is-open=\"sidebar.showProjectModal.value\"\n      :project=\"sidebar.editingProject.value\"\n      @close=\"sidebar.showProjectModal.value = false\"\n    />\n\n    <!-- TASK EDIT MODAL -->\n    <TaskEditModal\n      :is-open=\"showTaskEditModal\"\n      :task=\"editingTask\"\n      @close=\"showTaskEditModal = false\"\n    />\n\n    <!-- TASK CONTEXT MENU -->\n    <TaskContextMenu\n      :is-visible=\"showTaskContextMenu\"\n      :x=\"contextMenuX\"\n      :y=\"contextMenuY\"\n      :task=\"contextMenuTask\"\n      :compact-mode=\"settingsStore.boardDensity === 'ultrathin'\"\n      @close=\"closeTaskContextMenu\"\n      @edit=\"(taskId: string) => {\n        const task = taskStore.tasks.find(t => t.id === taskId)\n        if (task) openEditTask(task)\n      }\"\n      @confirm-delete=\"handleContextMenuDelete\"\n      @move-to-section=\"handleMoveToSection\"\n    />\n\n    <!-- PROJECT CONTEXT MENU -->\n    <ContextMenu\n      :is-visible=\"showProjectContextMenu\"\n      :x=\"projectContextMenuX\"\n      :y=\"projectContextMenuY\"\n      :items=\"projectContextMenuItems\"\n      @close=\"showProjectContextMenu = false\"\n    />\n\n    <!-- CONFIRMATION MODAL -->\n    <ConfirmationModal\n      :is-open=\"showConfirmModal\"\n      title=\"Confirm Action\"\n      :message=\"confirmMessage\"\n      :details=\"confirmDetails\"\n      confirm-text=\"Delete\"\n      @confirm=\"executeConfirmAction\"\n      @cancel=\"cancelConfirmAction\"\n    />\n\n    <!-- SEARCH MODAL -->\n    <SearchModal\n      :is-open=\"showSearchModal\"\n      @close=\"showSearchModal = false\"\n      @select-task=\"handleSearchSelectTask\"\n      @select-project=\"handleSearchSelectProject\"\n    />\n\n    <!-- QUICK TASK CREATE MODAL -->\n    <QuickTaskCreateModal\n      :is-open=\"showQuickTaskCreate\"\n      :loading=\"false\"\n      @cancel=\"closeQuickTaskCreate\"\n      @create=\"handleQuickTaskCreate\"\n    />\n\n    <!-- COMMAND PALETTE -->\n    <CommandPalette ref=\"commandPaletteRef\" />\n\n    <!-- SECTION SELECTION MODAL -->\n    <SectionSelectionModal\n      :is-open=\"showSectionSelectionModal\"\n      :task=\"selectedTaskForSection\"\n      @cancel=\"showSectionSelectionModal = false\"\n      @confirm=\"confirmMoveToSection\"\n    />\n\n    <!-- KEYBOARD SHORTCUTS PANEL (TASK-1319) -->\n    <KeyboardShortcutsPanel\n      :is-open=\"uiStore.shortcutsPanelOpen\"\n      @close=\"uiStore.closeShortcutsPanel()\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onUnmounted } from 'vue'\nimport { useUIStore } from '@/stores/ui'\nimport { useTaskStore, type Task, type Project } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useSidebarManagement } from '@/composables/app/useSidebarManagement'\nimport { createLazyModal } from '@/composables/useLazyComponent'\nimport { getViewportCoordinates } from '@/utils/contextMenuCoordinates'\nimport { Edit, Palette, Copy, Trash2 } from 'lucide-vue-next'\n\n// Components\nimport AuthModal from '@/components/auth/AuthModal.vue'\nimport SettingsModal from '@/components/layout/SettingsModal.vue'\nimport ProjectModal from '@/components/projects/ProjectModal.vue'\nimport TaskEditModal from '@/components/tasks/TaskEditModal.vue'\nimport TaskContextMenu from '@/components/tasks/TaskContextMenu.vue'\nimport ConfirmationModal from '@/components/common/ConfirmationModal.vue'\nimport ContextMenu, { type ContextMenuItem } from '@/components/ContextMenu.vue'\nimport SearchModal from '@/components/layout/SearchModal.vue'\nimport QuickTaskCreateModal from '@/components/tasks/QuickTaskCreateModal.vue'\nimport SectionSelectionModal from '@/components/canvas/SectionSelectionModal.vue'\nimport KeyboardShortcutsPanel from '@/components/layout/KeyboardShortcutsPanel.vue'\nconst CommandPalette = createLazyModal(() => import('@/components/layout/CommandPalette.vue'))\n\nimport { useSettingsStore } from '@/stores/settings'\n\n// Stores\nconst uiStore = useUIStore()\nconst settingsStore = useSettingsStore()\nconst taskStore = useTaskStore()\nconst canvasStore = useCanvasStore()\nconst sidebar = useSidebarManagement()\n\n// State\nconst showTaskEditModal = ref(false)\nconst editingTask = ref<Task | null>(null)\n\nconst showTaskContextMenu = ref(false)\nconst contextMenuX = ref(0)\nconst contextMenuY = ref(0)\nconst contextMenuTask = ref<Task | null>(null)\n\nconst showProjectContextMenu = ref(false)\nconst projectContextMenuX = ref(0)\nconst projectContextMenuY = ref(0)\nconst contextMenuProject = ref<Project | null>(null)\n\nconst showConfirmModal = ref(false)\nconst confirmAction = ref<() => void | Promise<void>>(() => {})\nconst confirmMessage = ref('')\nconst confirmDetails = ref<string[]>([])\n\nconst showSearchModal = ref(false)\nconst showQuickTaskCreate = ref(false)\nconst showSectionSelectionModal = ref(false)\nconst selectedTaskForSection = ref<Task | null>(null)\nconst commandPaletteRef = ref<{ open: () => void; close: () => void } | null>(null)\n\n// Methods\nconst openEditTask = (task: Task) => {\n  editingTask.value = task\n  showTaskEditModal.value = true\n}\n\nconst closeTaskContextMenu = () => {\n  showTaskContextMenu.value = false\n  contextMenuTask.value = null\n}\n\nconst confirmDeleteTask = async (task: Task) => {\n  confirmMessage.value = `Delete task \"${task.title}\"?`\n  confirmAction.value = async () => {\n    const { useUnifiedUndoRedo } = await import('@/composables/useUnifiedUndoRedo')\n    const undoRedoActions = useUnifiedUndoRedo()\n    await undoRedoActions.deleteTaskWithUndo(task.id)\n  }\n  showConfirmModal.value = true\n}\n\nconst handleContextMenuDelete = (taskId: string, instanceId?: string, isCalendarEvent?: boolean) => {\n  const task = taskStore.tasks.find(t => t.id === taskId)\n\n  if (!task) {\n    return\n  }\n\n  if (isCalendarEvent && instanceId) {\n    confirmMessage.value = `Remove \"${task.title}\" from calendar?`\n    confirmAction.value = () => {\n      taskStore.deleteTaskInstance(taskId, instanceId)\n      showTaskContextMenu.value = false\n    }\n    confirmDetails.value = ['This will remove the scheduled instance and return the task to the sidebar.']\n    showConfirmModal.value = true\n  } else {\n    confirmDeleteTask(task)\n  }\n}\n\nconst executeConfirmAction = async () => {\n  // Close modal first (optimistic) to ensure it closes even if action fails\n  const action = confirmAction.value\n  showConfirmModal.value = false\n  confirmAction.value = () => {}\n  confirmMessage.value = ''\n  confirmDetails.value = []\n\n  // Execute action after modal is closed\n  try {\n    await action()\n  } catch (error) {\n    console.error('[ModalManager] Confirm action failed:', error)\n  }\n}\n\nconst cancelConfirmAction = () => {\n  showConfirmModal.value = false\n  confirmAction.value = () => {}\n  confirmMessage.value = ''\n  confirmDetails.value = []\n}\n\nconst handleSearchSelectTask = (task: Task) => {\n  openEditTask(task)\n}\n\nconst handleSearchSelectProject = (_project: Project) => {\n  // TODO: Navigate to project view or filter by project\n}\n\nconst closeQuickTaskCreate = () => {\n  showQuickTaskCreate.value = false\n}\n\nconst handleQuickTaskCreate = async (data: {\n  title: string\n  description: string\n  status: string\n  priority: 'low' | 'medium' | 'high'\n  dueDate?: string\n  projectId?: string\n}) => {\n  try {\n    await taskStore.createTaskWithUndo({\n      title: data.title,\n      description: data.description,\n      status: data.status as any,\n      priority: data.priority,\n      dueDate: data.dueDate,\n      projectId: data.projectId || undefined\n    })\n    closeQuickTaskCreate()\n  } catch (error) {\n    console.error('Failed to create task:', error)\n  }\n}\n\nconst handleMoveToSection = (taskId: string) => {\n  const task = taskStore.tasks.find(t => t.id === taskId)\n  if (task) {\n    selectedTaskForSection.value = task\n    showSectionSelectionModal.value = true\n    showTaskContextMenu.value = false\n  }\n}\n\nconst confirmMoveToSection = async (sectionId: string) => {\n  if (!selectedTaskForSection.value) return\n\n  const task = selectedTaskForSection.value\n  const section = canvasStore.sections.find(s => s.id === sectionId)\n  \n  if (section) {\n    // Calculate new position (center of section)\n    const newPosition = {\n      x: section.position.x + (section.position.width / 2) - 100,\n      y: section.position.y + (section.position.height / 2) - 40\n    }\n\n    const updates: any = {\n      canvasPosition: newPosition,\n      isInInbox: false\n    }\n\n    // Apply \"Assign on Drop\" settings\n    if (section.assignOnDrop) {\n      if (section.assignOnDrop.priority) updates.priority = section.assignOnDrop.priority\n      if (section.assignOnDrop.status) updates.status = section.assignOnDrop.status\n      if (section.assignOnDrop.projectId) updates.projectId = section.assignOnDrop.projectId\n      \n      if (section.assignOnDrop.dueDate) {\n        const { resolveDueDate } = await import('@/composables/useGroupSettings')\n        const dateStr = await resolveDueDate(section.assignOnDrop.dueDate)\n        if (dateStr) updates.dueDate = dateStr\n      }\n    }\n\n    await taskStore.updateTaskWithUndo(task.id, updates)\n    canvasStore.requestSync('user:context-menu')\n  }\n\n  showSectionSelectionModal.value = false\n  selectedTaskForSection.value = null\n}\n\nconst projectContextMenuItems = computed<ContextMenuItem[]>(() => {\n  if (!contextMenuProject.value) return []\n  const project = contextMenuProject.value\n  const isDefaultProject = project.id === '1'\n\n  return [\n    { id: 'edit', label: 'Edit Project', icon: Edit, action: () => sidebar.openEditProject(project) },\n    { id: 'change-icon', label: 'Change Icon', icon: Palette, action: () => sidebar.openEditProject(project) },\n    { id: 'duplicate', label: 'Duplicate Project', icon: Copy, action: () => duplicateProject(project) },\n    {\n      id: 'delete',\n      label: 'Delete Project',\n      icon: Trash2,\n      action: () => confirmDeleteProject(project),\n      danger: true,\n      disabled: isDefaultProject\n    }\n  ]\n})\n\nconst duplicateProject = async (project: Project) => {\n  if (!project || !project.id) return\n  taskStore.createProject({\n    name: `${project.name} (Copy)`,\n    color: project.color,\n    colorType: project.colorType,\n    emoji: project.emoji,\n    viewType: project.viewType,\n    parentId: project.parentId\n  })\n  showProjectContextMenu.value = false\n}\n\nconst confirmDeleteProject = (project: Project) => {\n  if (!project || !project.id) return\n  const taskCount = taskStore.tasks.filter(t => t.projectId === project.id).length\n  const childCount = taskStore.projects.filter(p => p.parentId === project.id).length\n  const details: string[] = []\n  if (taskCount > 0) details.push(`${taskCount} task${taskCount > 1 ? 's' : ''} will become uncategorized`)\n  if (childCount > 0) details.push(`${childCount} child project${childCount > 1 ? 's' : ''} will be un-nested`)\n\n  confirmMessage.value = `Delete project \"${project.name}\"?`\n  confirmAction.value = () => {\n    taskStore.deleteProject(project.id)\n    showProjectContextMenu.value = false\n  }\n  confirmDetails.value = details\n  showConfirmModal.value = true\n}\n\nconst handleConfirmDeleteSelected = () => {\n  const selectedTaskIds = [...taskStore.selectedTaskIds]\n  if (selectedTaskIds.length === 0) return\n\n  const selectedTasks = taskStore.tasks.filter(task => selectedTaskIds.includes(task.id))\n  let message = ''\n  let details: string[] = []\n\n  if (selectedTasks.length === 1) {\n    const task = selectedTasks[0]\n    message = `Delete task \"${task.title}\"?`\n    details = ['This will permanently remove the task from all views.']\n  } else {\n    message = `Delete ${selectedTasks.length} selected tasks?`\n    const taskTitles = selectedTasks.map(task => `• ${task.title}`)\n    details = [\n      'This will permanently remove the following tasks from all views:',\n      ...taskTitles\n    ]\n  }\n\n  confirmAction.value = async () => {\n    const { useUnifiedUndoRedo } = await import('@/composables/useUnifiedUndoRedo')\n    const undoRedoActions = useUnifiedUndoRedo()\n    for (const taskId of selectedTaskIds) {\n      await undoRedoActions.deleteTaskWithUndo(taskId)\n    }\n    taskStore.clearSelection()\n  }\n  confirmMessage.value = message\n  confirmDetails.value = details\n  showConfirmModal.value = true\n}\n\n// Global Event Handlers\nconst handleOpenTaskEdit = (event: Event) => {\n  const customEvent = event as CustomEvent\n  const task = taskStore.tasks.find(t => t.id === customEvent.detail.taskId)\n  if (task) openEditTask(task)\n}\n\nconst handleTaskContextMenu = (event: Event) => {\n  const customEvent = event as CustomEvent\n  const { event: mouseEvent, task, instanceId, isCalendarEvent } = customEvent.detail\n\n  if (isCalendarEvent && instanceId) {\n    contextMenuTask.value = {\n      ...task,\n      instanceId,\n      isCalendarEvent\n    } as Task & { instanceId: string; isCalendarEvent: boolean }\n  } else {\n    contextMenuTask.value = task\n  }\n\n  // BUG-1096: Use normalized coordinates for Tauri compatibility\n  const { x, y } = getViewportCoordinates(mouseEvent)\n  contextMenuX.value = x\n  contextMenuY.value = y\n  showTaskContextMenu.value = true\n}\n\nconst handleProjectContextMenu = (event: Event) => {\n  const customEvent = event as CustomEvent\n  const { event: mouseEvent, project } = customEvent.detail\n\n  // BUG-1096: Use normalized coordinates for Tauri compatibility\n  const { x, y } = getViewportCoordinates(mouseEvent)\n  projectContextMenuX.value = x\n  projectContextMenuY.value = y\n  contextMenuProject.value = project\n  showProjectContextMenu.value = true\n}\n\nonMounted(() => {\n  window.addEventListener('open-task-edit', handleOpenTaskEdit)\n  window.addEventListener('task-context-menu' as any, handleTaskContextMenu as unknown as EventListener)\n  window.addEventListener('project-context-menu', handleProjectContextMenu)\n  window.addEventListener('open-command-palette', () => { commandPaletteRef.value?.open() })\n  window.addEventListener('open-search', () => { showSearchModal.value = true })\n  window.addEventListener('open-quick-task-create', () => { showQuickTaskCreate.value = true })\n  window.addEventListener('confirm-delete-selected', handleConfirmDeleteSelected)\n  window.addEventListener('open-shortcuts-panel', () => { uiStore.toggleShortcutsPanel() })\n})\n\nonUnmounted(() => {\n  window.removeEventListener('open-task-edit', handleOpenTaskEdit)\n  window.removeEventListener('task-context-menu' as any, handleTaskContextMenu as unknown as EventListener)\n  window.removeEventListener('project-context-menu', handleProjectContextMenu)\n  window.removeEventListener('open-command-palette', () => { commandPaletteRef.value?.open() })\n  window.removeEventListener('open-search', () => { showSearchModal.value = true })\n  window.removeEventListener('open-quick-task-create', () => { showQuickTaskCreate.value = true })\n  window.removeEventListener('confirm-delete-selected', handleConfirmDeleteSelected)\n  window.removeEventListener('open-shortcuts-panel', () => { uiStore.toggleShortcutsPanel() })\n})\n\n// Expose methods for App.vue or parent triggers\ndefineExpose({\n  openEditTask,\n  openSearch: () => { showSearchModal.value = true },\n  openQuickTask: () => { showQuickTaskCreate.value = true },\n  openCommandPalette: () => { commandPaletteRef.value?.open() },\n  openConfirmationModal: (title: string, message: string, action: () => void, details: string[] = []) => {\n    confirmMessage.value = message\n    confirmAction.value = action\n    confirmDetails.value = details\n    showConfirmModal.value = true\n  },\n  openTaskContextMenu: (event: MouseEvent, task: Task) => {\n    // BUG-1096: Use normalized coordinates for Tauri compatibility\n    const { x, y } = getViewportCoordinates(event)\n    contextMenuX.value = x\n    contextMenuY.value = y\n    contextMenuTask.value = task\n    showTaskContextMenu.value = true\n  },\n  openProjectContextMenu: (event: MouseEvent, project: Project) => {\n    // BUG-1096: Use normalized coordinates for Tauri compatibility\n    const { x, y } = getViewportCoordinates(event)\n    projectContextMenuX.value = x\n    projectContextMenuY.value = y\n    contextMenuProject.value = project\n    showProjectContextMenu.value = true\n  },\n  closeTaskContextMenu\n})\n</script>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/main.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[855,858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[855,858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1054,1057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1054,1057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3313,3316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3313,3316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2893,2896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2893,2896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// 🚨 CACHE BREAKER - FORCES RELOAD - TIMESTAMP: 2026-01-27T11:00:00Z - V24 - BUG-1090 FIX2\n// BUG-1090: Capture task data BEFORE emit('close') to prevent null reference\n\n// Cache bust version - increment to force new asset hashes\nconst __BUILD_VERSION__ = 'v24-bug1090-fix2-20260127'\nconsole.log(`[FlowState] Build: ${__BUILD_VERSION__}`)\n\n// Console filter - reduces log noise in development (toggle via localStorage)\nimport './utils/consoleFilter'\n\nimport { createApp } from 'vue'\nimport { createPinia } from 'pinia'\nimport { PiniaSharedState } from 'pinia-shared-state'\nimport router from './router'\nimport App from './App.vue'\nimport i18n from './i18n'\n\n  // Early Tauri & PWA detection - must run BEFORE CSS import for proper fallback application\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ; (() => {\n    const w = window as any\n    const isTauri = ('isTauri' in w && w.isTauri) || ('__TAURI__' in w) || ('__TAURI_INTERNALS__' in w)\n    const isPWA = window.matchMedia('(display-mode: standalone)').matches || (navigator as any).standalone\n\n    if (isTauri) {\n      document.documentElement.classList.add('tauri-app')\n    }\n    if (isPWA) {\n      document.documentElement.classList.add('pwa-app')\n    }\n  })()\n\n// Design system - Tailwind CSS must be imported here for Vite to process @tailwind directives\nimport './assets/styles.css'\n\n// Initialize static resource cache for CSS and other assets\nimport { staticResourceCache } from './composables/useStaticResourceCache'\n\n// Preload critical CSS files with static resource cache\nconst preloadCriticalResources = async () => {\n  try {\n    await staticResourceCache.preloadResources([\n      { url: '/src/assets/styles.css', priority: 'high' }\n    ])\n  } catch {\n    // Silent fail - CSS will load normally\n  }\n}\n\npreloadCriticalResources()\n\n// TASK-1215: Preload UI state from Tauri native store before Vue mounts\nimport { preloadTauriUiState } from './composables/usePersistentRef'\n\n// Initialize global error handler\nimport './utils/errorHandler'\n\n// Initialize security systems\nimport { useSecurityHeaderManager as _useSecurityHeaderManager } from './utils/securityHeaderManager'\nimport { useCSPManager as _useCSPManager } from './utils/cspManager'\nimport { useSecurityMonitor as _useSecurityMonitor } from './utils/securityMonitor'\n\n// SECURITY: App is now 100% Supabase standard\n\n// Run pre-check and initialize app\nasync function initializeApp() {\n  // NOTE: PouchDB migration cleanup removed Jan 2026 - migration complete\n  console.log('🚀 [MAIN] Starting app initialization...')\n\n  // Detect Tauri environment and apply class for CSS optimizations\n  // WebKitGTK on Linux has limited backdrop-filter support, so we need fallbacks\n  // Tauri v2 uses window.isTauri, older versions use __TAURI__ or __TAURI_INTERNALS__\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const win = window as any\n  const isTauriEnv = ('isTauri' in win && win.isTauri) ||\n    ('__TAURI__' in win) ||\n    ('__TAURI_INTERNALS__' in win)\n\n  if (isTauriEnv) {\n    document.documentElement.classList.add('tauri-app')\n    document.body?.classList.add('tauri-app')\n    console.log('🖥️ [MAIN] Tauri environment detected - applying CSS optimizations')\n  } else if (window.matchMedia('(display-mode: standalone)').matches || (navigator as any).standalone) {\n    document.documentElement.classList.add('pwa-app')\n    document.body?.classList.add('pwa-app')\n    console.log('📱 [MAIN] PWA standalone environment detected - applying CSS optimizations')\n  } else {\n    console.log('🌐 [MAIN] Browser environment detected')\n  }\n\n  try {\n    // Analytics/Monitoring can go here\n    console.log('📊 [MAIN] Monitoring systems active')\n  } catch (error) {\n    console.warn('⚠️ [MAIN] Initialization monitor warning:', error)\n  }\n\n  // TASK-1215: Load UI preferences from Tauri native store into localStorage\n  // BEFORE Vue mounts, so useStorage/usePersistentRef picks up correct values\n  await preloadTauriUiState()\n\n  const app = createApp(App)\n\n  // Create Pinia with cross-tab state synchronization\n  // ROLLBACK: Remove PiniaSharedState plugin and revert to: app.use(createPinia())\n  const pinia = createPinia()\n  // BUG-1207 Fix 5.2: Disable PiniaSharedState globally.\n  // Stores that handle their own sync (tasks, canvas, projects, timer, gamification)\n  // must NOT use BroadcastChannel cross-tab sync - it fights with Supabase Realtime\n  // and causes state overwrites. Individual UI-only stores can opt in via\n  // share: { enable: true } in their store options if needed.\n  pinia.use(\n    PiniaSharedState({\n      enable: false,      // BUG-1207: Disabled globally - stores opt in individually\n      initialize: false,  // FIXED: Disable auto-hydration to prevent \"ghost data\" flash (BUG-037)\n      type: 'native',     // Use BroadcastChannel API (fastest, best support)\n    })\n  )\n\n  app.use(pinia)\n  app.use(router)\n  app.use(i18n)\n\n  // Global error handler for extension compatibility\n  app.config.errorHandler = (err, _vm, info) => {\n    const errorStr = String(err);\n\n    // Extension or harmless browser errors: log silently, don't crash\n    if (errorStr.match(/chrome is not defined|browser is not defined|ResizeObserver loop completed/i)) {\n      console.warn('ℹ️ [SILENCED] Harmless browser/extension error:', errorStr);\n      return; // Don't propagate - app continues\n    }\n\n    // Real application errors: log normally\n    console.error('App error:', err, info);\n  };\n\n  // Unhandled promise rejections are captured by GlobalErrorHandler (errorHandler.ts)\n  // with throttled notifications. Only add a lightweight handler here for known-harmless errors.\n  window.addEventListener('unhandledrejection', (event) => {\n    const reasonStr = String(event.reason)\n    // Prevent default for harmless browser/extension errors\n    if (reasonStr.match(/chrome is not defined|ResizeObserver loop/i)) {\n      event.preventDefault()\n    }\n  });\n\n  app.mount('#app')\n}\n\n// Start the app\ninitializeApp()\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/components/MobileNav.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/components/SwipeableTaskItem.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/components/TaskCreateBottomSheet.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CalendarPlus' is defined but never used. Allowed unused vars must match /^_/u.","line":169,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":169,"endColumn":31,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"CalendarPlus"},"fix":{"range":[5773,5787],"text":""},"desc":"Remove unused variable \"CalendarPlus\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CalendarDays' is defined but never used. Allowed unused vars must match /^_/u.","line":169,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":169,"endColumn":45,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"CalendarDays"},"fix":{"range":[5787,5801],"text":""},"desc":"Remove unused variable \"CalendarDays\"."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <Teleport to=\"body\">\n    <Transition name=\"sheet\">\n      <div\n        v-if=\"isOpen\"\n        class=\"sheet-overlay\"\n        @click=\"handleCancel\"\n        @touchmove.prevent\n      >\n        <div\n          class=\"task-create-sheet\"\n          :class=\"{ 'sheet-active': isOpen }\"\n          @click.stop\n          @touchmove.stop\n        >\n          <!-- Header: Cancel | New Task | Add/Stop -->\n          <div class=\"sheet-header\">\n            <button class=\"header-btn cancel-btn\" @click=\"handleCancel\">\n              Cancel\n            </button>\n            <h3 class=\"sheet-title\">\n              {{ isListening ? 'Recording...' : isProcessing ? 'Processing...' : 'New Task' }}\n            </h3>\n            <!-- Show Stop when recording, spinner when processing, Add when idle -->\n            <button\n              v-if=\"isListening\"\n              class=\"header-btn stop-btn\"\n              @click=\"emit('stopRecording')\"\n            >\n              Stop\n            </button>\n            <button\n              v-else-if=\"isProcessing\"\n              class=\"header-btn processing-btn\"\n              disabled\n            >\n              <div class=\"btn-spinner\" />\n            </button>\n            <button\n              v-else\n              class=\"header-btn add-btn\"\n              :disabled=\"!taskTitle.trim()\"\n              @click=\"handleCreate\"\n            >\n              Add\n            </button>\n          </div>\n\n          <!-- Create Form -->\n          <div class=\"create-form\">\n            <!-- Single text block for task content -->\n            <textarea\n              ref=\"titleInputRef\"\n              v-model=\"taskTitle\"\n              :dir=\"titleDirection\"\n              class=\"task-text-block\"\n              placeholder=\"What needs to be done?&#10;&#10;Add notes here...\"\n              @input=\"autoResize\"\n            />\n\n            <!-- Compact options -->\n            <div class=\"compact-options\">\n              <!-- Due Date chips -->\n              <div class=\"option-group\">\n                <Calendar :size=\"14\" class=\"option-icon\" />\n                <button\n                  class=\"chip\"\n                  :class=\"{ active: isDueToday }\"\n                  @click=\"setDueDate('today')\"\n                >\n                  Today\n                </button>\n                <button\n                  class=\"chip\"\n                  :class=\"{ active: isDueTomorrow }\"\n                  @click=\"setDueDate('tomorrow')\"\n                >\n                  Tomorrow\n                </button>\n                <button\n                  class=\"chip\"\n                  :class=\"{ active: isDueNextWeek }\"\n                  @click=\"setDueDate('nextWeek')\"\n                >\n                  +1wk\n                </button>\n                <button\n                  class=\"chip\"\n                  :class=\"{ active: hasCustomDate }\"\n                  @click=\"showDatePicker = true\"\n                >\n                  {{ hasCustomDate ? formatDate(taskDueDate!) : 'Pick' }}\n                </button>\n                <button\n                  v-if=\"taskDueDate\"\n                  class=\"chip clear\"\n                  @click=\"clearDueDate\"\n                >\n                  <X :size=\"12\" />\n                </button>\n              </div>\n              <input\n                v-show=\"showDatePicker\"\n                ref=\"datePickerRef\"\n                v-model=\"taskDueDateInput\"\n                type=\"date\"\n                class=\"native-date-picker\"\n                @change=\"handleDatePickerChange\"\n                @blur=\"showDatePicker = false\"\n              >\n\n              <!-- Priority chips -->\n              <div class=\"option-group\">\n                <Flag :size=\"14\" class=\"option-icon\" />\n                <button\n                  v-for=\"option in priorityOptions\"\n                  :key=\"option.value\"\n                  class=\"chip\"\n                  :class=\"[`priority-${option.value}`, { active: taskPriority === option.value }]\"\n                  @click=\"taskPriority = option.value\"\n                >\n                  {{ option.label }}\n                </button>\n                <button\n                  class=\"chip\"\n                  :class=\"{ active: taskPriority === null }\"\n                  @click=\"taskPriority = null\"\n                >\n                  None\n                </button>\n              </div>\n            </div>\n\n            <!-- Voice Feedback (Recording or Processing) -->\n            <div v-if=\"isListening || isProcessing\" class=\"voice-feedback\" :class=\"{ processing: isProcessing }\">\n              <div class=\"voice-indicator\">\n                <div v-if=\"isProcessing\" class=\"processing-spinner\" />\n                <div v-else class=\"voice-pulse\" />\n                <span>{{ isProcessing ? 'Transcribing audio...' : 'Listening...' }}</span>\n              </div>\n              <p v-if=\"voiceTranscript\" class=\"voice-transcript\">\n                {{ voiceTranscript }}\n              </p>\n              <button v-if=\"isListening\" class=\"stop-recording-btn\" @click=\"emit('stopRecording')\">\n                <Square :size=\"16\" />\n                <span>Stop Recording</span>\n              </button>\n            </div>\n\n            <!-- Re-record button (TASK-1110) - Shows when voice is supported and not actively recording -->\n            <button\n              v-if=\"canReRecord && !isListening && !isProcessing\"\n              class=\"rerecord-btn\"\n              @click=\"emit('startRecording')\"\n            >\n              <Mic :size=\"16\" />\n              <span>{{ taskTitle.trim() ? 'Re-record' : 'Record' }}</span>\n            </button>\n          </div>\n        </div>\n      </div>\n    </Transition>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, nextTick } from 'vue'\nimport {\n  Flag, Calendar, CalendarPlus, CalendarDays, X, Square, Mic\n} from 'lucide-vue-next'\nimport { useVoiceNLPParser } from '@/composables/useVoiceNLPParser'\n\ninterface Props {\n  isOpen: boolean\n  isListening?: boolean\n  isProcessing?: boolean\n  voiceTranscript?: string\n  canReRecord?: boolean  // TASK-1110: Allow re-recording\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  isListening: false,\n  isProcessing: false,\n  voiceTranscript: '',\n  canReRecord: false\n})\n\nconst emit = defineEmits<{\n  (e: 'close'): void\n  (e: 'created', data: TaskCreationData): void\n  (e: 'stopRecording'): void\n  (e: 'startRecording'): void  // TASK-1110: Request re-recording\n}>()\n\ninterface TaskCreationData {\n  title: string\n  description: string\n  priority: 'high' | 'medium' | 'low' | null\n  dueDate: Date | null\n}\n\n// Form state\nconst taskTitle = ref('')\nconst taskDescription = ref('')\nconst taskPriority = ref<'low' | 'medium' | 'high' | null>(null)\nconst taskDueDate = ref<Date | null>(null)\nconst taskDueDateInput = ref('')\nconst showDatePicker = ref(false)\n\n// Refs\nconst titleInputRef = ref<HTMLTextAreaElement | null>(null)\nconst datePickerRef = ref<HTMLInputElement | null>(null)\n\n// Options\nconst priorityOptions = [\n  { value: 'high' as const, label: 'High' },\n  { value: 'medium' as const, label: 'Medium' },\n  { value: 'low' as const, label: 'Low' }\n]\n\n// Computed\nconst isDueToday = computed(() => {\n  if (!taskDueDate.value) return false\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  const dueDate = new Date(taskDueDate.value)\n  dueDate.setHours(0, 0, 0, 0)\n  return dueDate.getTime() === today.getTime()\n})\n\nconst isDueTomorrow = computed(() => {\n  if (!taskDueDate.value) return false\n  const tomorrow = new Date()\n  tomorrow.setDate(tomorrow.getDate() + 1)\n  tomorrow.setHours(0, 0, 0, 0)\n  const dueDate = new Date(taskDueDate.value)\n  dueDate.setHours(0, 0, 0, 0)\n  return dueDate.getTime() === tomorrow.getTime()\n})\n\nconst isDueNextWeek = computed(() => {\n  if (!taskDueDate.value) return false\n  const nextWeek = new Date()\n  nextWeek.setDate(nextWeek.getDate() + 7)\n  nextWeek.setHours(0, 0, 0, 0)\n  const dueDate = new Date(taskDueDate.value)\n  dueDate.setHours(0, 0, 0, 0)\n  return dueDate.getTime() === nextWeek.getTime()\n})\n\n// BUG-1108: RTL detection for title text (Hebrew, Arabic, Persian, Urdu)\nconst titleDirection = computed(() => {\n  if (!taskTitle.value.trim()) return 'auto'\n  const firstChar = taskTitle.value.trim()[0]\n  const rtlRegex = /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/\n  return rtlRegex.test(firstChar) ? 'rtl' : 'ltr'\n})\n\nconst hasCustomDate = computed(() => {\n  return taskDueDate.value !== null && !isDueToday.value && !isDueTomorrow.value && !isDueNextWeek.value\n})\n\n// NLP Parser for voice transcripts\nconst { parseTranscription } = useVoiceNLPParser()\n\n// Watch for voice transcript and parse it with NLP\nwatch(() => props.voiceTranscript, (transcript) => {\n  if (transcript && transcript.trim()) {\n    // Parse the transcript to extract title, date, priority\n    const parsed = parseTranscription(transcript.trim())\n\n    // Set the cleaned title (with date/priority keywords removed)\n    taskTitle.value = parsed.title\n\n    // Set priority if detected\n    if (parsed.priority) {\n      taskPriority.value = parsed.priority\n    }\n\n    // Set due date if detected\n    if (parsed.dueDate) {\n      const date = new Date(parsed.dueDate + 'T00:00:00')\n      if (!isNaN(date.getTime())) {\n        taskDueDate.value = date\n        taskDueDateInput.value = parsed.dueDate\n      }\n    }\n\n    if (import.meta.env.DEV) {\n      console.log('[VoiceNLP] Parsed:', parsed)\n    }\n  }\n})\n\n// Focus title input when opened\nwatch(() => props.isOpen, async (isOpen) => {\n  if (isOpen) {\n    await nextTick()\n    titleInputRef.value?.focus()\n  } else {\n    // Reset form when closed\n    resetForm()\n  }\n})\n\n// Watch for date picker visibility\nwatch(showDatePicker, async (show) => {\n  if (show) {\n    await nextTick()\n    datePickerRef.value?.focus()\n    datePickerRef.value?.showPicker?.()\n  }\n})\n\n// Actions\nfunction setDueDate(preset: 'today' | 'tomorrow' | 'nextWeek') {\n  const date = new Date()\n  date.setHours(0, 0, 0, 0)\n\n  if (preset === 'tomorrow') {\n    date.setDate(date.getDate() + 1)\n  } else if (preset === 'nextWeek') {\n    date.setDate(date.getDate() + 7)\n  }\n\n  taskDueDate.value = date\n  taskDueDateInput.value = date.toISOString().split('T')[0]\n  triggerHaptic(10)\n}\n\nfunction clearDueDate() {\n  taskDueDate.value = null\n  taskDueDateInput.value = ''\n  triggerHaptic(10)\n}\n\nfunction handleDatePickerChange() {\n  if (taskDueDateInput.value) {\n    const date = new Date(taskDueDateInput.value + 'T00:00:00')\n    taskDueDate.value = date\n  }\n  showDatePicker.value = false\n}\n\nfunction formatDate(date: Date): string {\n  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })\n}\n\nfunction handleCancel() {\n  triggerHaptic(10)\n  emit('close')\n}\n\nfunction handleCreate() {\n  if (!taskTitle.value.trim()) return\n\n  triggerHaptic(30)\n\n  const data: TaskCreationData = {\n    title: taskTitle.value.trim(),\n    description: taskDescription.value.trim(),\n    priority: taskPriority.value,\n    dueDate: taskDueDate.value\n  }\n\n  emit('created', data)\n  emit('close')\n}\n\nfunction resetForm() {\n  taskTitle.value = ''\n  taskDescription.value = ''\n  taskPriority.value = null\n  taskDueDate.value = null\n  taskDueDateInput.value = ''\n  showDatePicker.value = false\n}\n\nfunction triggerHaptic(duration: number = 10) {\n  if (typeof navigator !== 'undefined' && 'vibrate' in navigator) {\n    try {\n      navigator.vibrate(duration)\n    } catch {\n      // Vibration API not supported\n    }\n  }\n}\n\n// Auto-resize title textarea as user types\nfunction autoResize(event: Event) {\n  const textarea = event.target as HTMLTextAreaElement\n  textarea.style.height = 'auto'\n  textarea.style.height = textarea.scrollHeight + 'px'\n}\n</script>\n\n<style scoped>\n/* ================================\n   TASK CREATE BOTTOM SHEET\n   Full-screen with clean layout\n   ================================ */\n\n.sheet-overlay {\n  position: fixed;\n  inset: 0;\n  background: var(--overlay-bg);\n  backdrop-filter: blur(var(--blur-xs));\n  -webkit-backdrop-filter: blur(var(--blur-xs));\n  display: flex;\n  align-items: flex-start; /* Start from TOP */\n  z-index: var(--z-modal);\n}\n\n.task-create-sheet {\n  width: 100%;\n  height: 100dvh;\n  max-height: none;\n  background: var(--surface-primary);\n  /* No border-radius - full screen */\n  border-radius: 0;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n/* Header: Cancel | Title | Add */\n.sheet-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: var(--space-4) var(--space-4) var(--space-3);\n  border-bottom: 1px solid var(--glass-border-light);\n  flex-shrink: 0;\n}\n\n.sheet-title {\n  font-size: var(--text-lg);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  margin: 0;\n  flex: 1;\n  text-align: center;\n}\n\n.header-btn {\n  min-width: var(--space-16);\n  padding: var(--space-2) var(--space-4);\n  border: none;\n  border-radius: var(--radius-md);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.cancel-btn {\n  background: transparent;\n  color: var(--text-secondary);\n}\n\n.cancel-btn:active {\n  background: var(--glass-bg-weak);\n}\n\n.add-btn {\n  background: transparent;\n  color: var(--brand-primary);\n}\n\n.add-btn:disabled {\n  opacity: 0.4;\n  cursor: not-allowed;\n}\n\n.add-btn:not(:disabled):active {\n  transform: scale(0.96);\n}\n\n.stop-btn {\n  background: var(--color-priority-high);\n  color: var(--text-primary);\n}\n\n.stop-btn:active {\n  transform: scale(0.96);\n  background: var(--color-priority-high);\n}\n\n.processing-btn {\n  background: var(--brand-primary);\n  color: var(--text-primary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.btn-spinner {\n  width: var(--icon-xl);\n  height: var(--icon-xl);\n  border: 2px solid var(--overlay-component-bg-lighter);\n  border-top-color: var(--surface-secondary);\n  border-radius: var(--radius-full);\n  animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n/* Create Form */\n.create-form {\n  flex: 1;\n  overflow-y: auto;\n  padding: var(--space-4);\n  padding-bottom: calc(var(--space-4) + env(safe-area-inset-bottom, 0px));\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-4);\n}\n\n/* Single text block - main writing area */\n.task-text-block {\n  flex: 1;\n  min-height: 12.5rem;\n  padding: var(--space-4);\n  background: transparent;\n  border: none;\n  color: var(--text-primary);\n  font-size: var(--text-lg);\n  line-height: var(--leading-normal);\n  font-family: inherit;\n  resize: none;\n  outline: none;\n}\n\n.task-text-block::placeholder {\n  color: var(--text-muted);\n}\n\n/* RTL support for Hebrew/Arabic text */\n.task-text-block[dir=\"rtl\"] {\n  text-align: right;\n}\n\n.task-text-block[dir=\"rtl\"]::placeholder {\n  text-align: right;\n}\n\n/* Compact options at bottom */\n.compact-options {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2_5);\n  padding-top: var(--space-3);\n  border-top: 1px solid var(--glass-border-light);\n}\n\n.option-group {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  flex-wrap: wrap;\n}\n\n.option-icon {\n  color: var(--text-muted);\n  flex-shrink: 0;\n}\n\n/* Compact chips */\n.chip {\n  padding: var(--space-1_5) var(--space-2_5);\n  background: var(--glass-bg-weak);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  font-size: var(--text-meta);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast) ease;\n}\n\n.chip:active {\n  transform: scale(0.95);\n}\n\n.chip.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-hover-border);\n  color: var(--brand-primary, #4ECDC4);\n}\n\n.chip.clear {\n  padding: var(--space-1_5) var(--space-2);\n  color: var(--text-muted);\n}\n\n/* Priority colors */\n.chip.priority-high.active {\n  background: var(--danger-bg-subtle);\n  border-color: var(--danger-border-strong);\n  color: var(--color-priority-high);\n}\n\n.chip.priority-medium.active {\n  background: var(--orange-bg-light);\n  border-color: var(--color-priority-medium-border-medium);\n  color: var(--color-priority-medium);\n}\n\n.chip.priority-low.active {\n  background: var(--blue-bg-subtle);\n  border-color: var(--blue-border-medium);\n  color: var(--color-priority-low);\n}\n\n.native-date-picker {\n  margin-top: var(--space-1_5);\n  padding: var(--space-2);\n  background: var(--glass-bg-weak);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  color-scheme: dark;\n}\n\n/* Voice Feedback */\n.voice-feedback {\n  padding: var(--space-4);\n  background: var(--state-hover-bg);\n  border: 1px solid var(--brand-border-subtle);\n  border-radius: var(--radius-lg);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n}\n\n.voice-indicator {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  color: var(--brand-primary);\n  font-weight: var(--font-semibold);\n}\n\n.voice-pulse {\n  width: var(--space-3);\n  height: var(--space-3);\n  background: var(--brand-primary);\n  border-radius: var(--radius-full);\n  animation: pulse 1.5s ease-in-out infinite;\n}\n\n.processing-spinner {\n  width: var(--icon-md);\n  height: var(--icon-md);\n  border: 2px solid var(--brand-border-subtle);\n  border-top-color: var(--brand-primary);\n  border-radius: var(--radius-full);\n  animation: spin 0.8s linear infinite;\n}\n\n.voice-feedback.processing {\n  background: var(--orange-bg-light);\n  border-color: var(--color-priority-medium-border-medium);\n}\n\n.voice-feedback.processing .voice-indicator {\n  color: var(--color-priority-medium);\n}\n\n.voice-feedback.processing .processing-spinner {\n  border-color: var(--color-priority-medium-border-medium);\n  border-top-color: var(--color-priority-medium);\n}\n\n@keyframes pulse {\n  0%, 100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n  50% {\n    opacity: 0.5;\n    transform: scale(1.2);\n  }\n}\n\n.voice-transcript {\n  margin: 0;\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  line-height: var(--leading-normal);\n}\n\n.stop-recording-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  margin-top: var(--space-3);\n  padding: var(--space-3) var(--space-6);\n  background: var(--danger-bg-subtle);\n  border: 1px solid var(--danger-border-strong);\n  border-radius: var(--radius-2xl);\n  color: var(--color-priority-high);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.stop-recording-btn:active {\n  transform: scale(0.96);\n  background: var(--danger-bg-medium);\n}\n\n/* Re-record button (TASK-1110) */\n.rerecord-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  margin-top: var(--space-3);\n  padding: var(--space-2_5) var(--space-5);\n  background: var(--state-hover-bg);\n  border: 1px solid var(--brand-border-subtle);\n  border-radius: var(--radius-xl);\n  color: var(--brand-primary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n}\n\n.rerecord-btn:hover {\n  background: var(--brand-bg-subtle);\n  border-color: var(--state-hover-border);\n}\n\n.rerecord-btn:active {\n  transform: scale(0.96);\n  background: var(--state-active-bg);\n}\n\n/* ================================\n   SHEET TRANSITIONS\n   ================================ */\n\n.sheet-enter-active,\n.sheet-leave-active {\n  transition: all var(--duration-slow) cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.sheet-enter-from,\n.sheet-leave-to {\n  opacity: 0;\n}\n\n.sheet-enter-from .task-create-sheet,\n.sheet-leave-to .task-create-sheet {\n  transform: translateY(-20px);\n  opacity: 0;\n}\n\n/* ================================\n   ACCESSIBILITY - REDUCED MOTION\n   ================================ */\n\n@media (prefers-reduced-motion: reduce) {\n  .sheet-enter-active,\n  .sheet-leave-active {\n    transition: opacity var(--duration-fast) ease;\n  }\n\n  .sheet-enter-from .task-create-sheet,\n  .sheet-leave-to .task-create-sheet {\n    transform: none;\n  }\n\n  .voice-pulse {\n    animation: none;\n  }\n}\n\n/* RTL Support */\n[dir=\"rtl\"] .sheet-header {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .form-field {\n  text-align: right;\n}\n\n[dir=\"rtl\"] .field-input,\n[dir=\"rtl\"] .field-textarea {\n  text-align: right;\n  direction: rtl;\n}\n\n[dir=\"rtl\"] .priority-options,\n[dir=\"rtl\"] .date-options {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .priority-pill,\n[dir=\"rtl\"] .date-pill {\n  flex-direction: row-reverse;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/components/TaskEditBottomSheet.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/components/VoiceTaskConfirmation.vue","messages":[{"ruleId":"vue/prefer-true-attribute-shorthand","severity":2,"message":"Boolean prop with 'true' value should be written in shorthand form.","line":9,"column":7,"nodeType":"VAttribute","messageId":"expectShort","endLine":9,"endColumn":37,"suggestions":[{"messageId":"rewriteIntoShort","fix":{"range":[164,194],"text":"close-on-overlay-click"},"desc":"Rewrite this prop into shorthand form."}]},{"ruleId":"vue/prefer-true-attribute-shorthand","severity":2,"message":"Boolean prop with 'true' value should be written in shorthand form.","line":10,"column":7,"nodeType":"VAttribute","messageId":"expectShort","endLine":10,"endColumn":30,"suggestions":[{"messageId":"rewriteIntoShort","fix":{"range":[201,224],"text":"close-on-escape"},"desc":"Rewrite this prop into shorthand form."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <Teleport to=\"body\">\n    <BaseModal\n      :is-open=\"isOpen\"\n      title=\"\"\n      size=\"md\"\n      :show-header=\"false\"\n      :show-footer=\"false\"\n      :close-on-overlay-click=\"true\"\n      :close-on-escape=\"true\"\n      @close=\"handleCancel\"\n    >\n      <div class=\"voice-confirmation-content\">\n        <!-- Header -->\n        <div class=\"confirmation-header\">\n          <div class=\"header-info\">\n            <CheckCircle2 :size=\"18\" class=\"header-icon\" />\n            <span class=\"header-title\">{{ $t?.('voice.confirmTask') || 'Confirm Task' }}</span>\n          </div>\n          <button class=\"close-btn\" @click=\"handleCancel\">\n            <X :size=\"18\" />\n          </button>\n        </div>\n\n        <!-- Editable Fields -->\n        <div class=\"confirmation-body\">\n          <!-- Title Textarea (RTL-aware) with Re-record button (TASK-1110) -->\n          <div class=\"field-section\">\n            <div class=\"field-label-row\">\n              <label class=\"field-label\">{{ $t?.('task.title') || 'Title' }}</label>\n              <!-- Re-record button (TASK-1110) -->\n              <button\n                v-if=\"canReRecord\"\n                class=\"rerecord-btn\"\n                :class=\"{ recording: isRecording, processing: isProcessing }\"\n                :disabled=\"isProcessing\"\n                :title=\"isRecording ? 'Stop recording' : (isProcessing ? 'Processing...' : 'Re-record')\"\n                @click=\"handleReRecord\"\n              >\n                <Loader2 v-if=\"isProcessing\" :size=\"14\" class=\"spin\" />\n                <MicOff v-else-if=\"isRecording\" :size=\"14\" />\n                <Mic v-else :size=\"14\" />\n                <span class=\"rerecord-label\">\n                  {{ isRecording ? 'Stop' : (isProcessing ? 'Processing' : 'Re-record') }}\n                </span>\n              </button>\n            </div>\n            <textarea\n              ref=\"titleInputRef\"\n              v-model=\"editedTitle\"\n              :dir=\"titleDirection\"\n              :class=\"{ 'recording-active': isRecording }\"\n              class=\"title-textarea\"\n              :placeholder=\"isRecording ? 'Listening...' : ($t?.('task.titlePlaceholder') || 'Task title...')\"\n              :disabled=\"isRecording\"\n              rows=\"3\"\n              @keydown.enter.exact.prevent=\"handleConfirm\"\n            />\n          </div>\n\n          <!-- Priority Pills -->\n          <div class=\"field-section\">\n            <label class=\"field-label\">\n              <Flag :size=\"12\" />\n              {{ $t?.('task.priority') || 'Priority' }}\n            </label>\n            <div class=\"pill-options\">\n              <button\n                class=\"pill priority-high\"\n                :class=\"[{ active: editedPriority === 'high' }]\"\n                @click=\"setPriority('high')\"\n              >\n                {{ $t?.('priority.high') || 'High' }}\n              </button>\n              <button\n                class=\"pill priority-medium\"\n                :class=\"[{ active: editedPriority === 'medium' }]\"\n                @click=\"setPriority('medium')\"\n              >\n                {{ $t?.('priority.medium') || 'Medium' }}\n              </button>\n              <button\n                class=\"pill priority-low\"\n                :class=\"[{ active: editedPriority === 'low' }]\"\n                @click=\"setPriority('low')\"\n              >\n                {{ $t?.('priority.low') || 'Low' }}\n              </button>\n              <button\n                class=\"pill priority-none\"\n                :class=\"[{ active: editedPriority === null }]\"\n                @click=\"setPriority(null)\"\n              >\n                {{ $t?.('priority.none') || 'None' }}\n              </button>\n            </div>\n          </div>\n\n          <!-- Due Date Chips -->\n          <div class=\"field-section\">\n            <label class=\"field-label\">\n              <Calendar :size=\"12\" />\n              {{ $t?.('task.dueDate') || 'Due Date' }}\n            </label>\n            <div class=\"pill-options\">\n              <button\n                class=\"pill date-pill\"\n                :class=\"[{ active: isToday }]\"\n                @click=\"setDueDate('today')\"\n              >\n                {{ $t?.('date.today') || 'Today' }}\n              </button>\n              <button\n                class=\"pill date-pill\"\n                :class=\"[{ active: isTomorrow }]\"\n                @click=\"setDueDate('tomorrow')\"\n              >\n                {{ $t?.('date.tomorrow') || 'Tomorrow' }}\n              </button>\n              <button\n                class=\"pill date-pill\"\n                :class=\"[{ active: isNextWeek }]\"\n                @click=\"setDueDate('week')\"\n              >\n                {{ $t?.('date.nextWeek') || 'Next Week' }}\n              </button>\n              <button\n                v-if=\"editedDueDate\"\n                class=\"pill clear-pill\"\n                @click=\"clearDueDate\"\n              >\n                <X :size=\"14\" />\n              </button>\n            </div>\n            <!-- Show detected date label if different from presets -->\n            <div v-if=\"parsedTask?.dueDateLabel && editedDueDate && !isPresetDate\" class=\"detected-label\">\n              {{ $t?.('voice.detected') || 'Detected' }}: {{ parsedTask.dueDateLabel }}\n            </div>\n          </div>\n        </div>\n\n        <!-- Action Buttons -->\n        <div class=\"confirmation-actions\">\n          <button class=\"action-btn cancel-btn\" @click=\"handleCancel\">\n            {{ $t?.('common.cancel') || 'Cancel' }}\n          </button>\n          <button\n            class=\"action-btn confirm-btn\"\n            :disabled=\"!editedTitle.trim()\"\n            @click=\"handleConfirm\"\n          >\n            <Plus :size=\"18\" />\n            {{ $t?.('task.create') || 'Create Task' }}\n          </button>\n        </div>\n      </div>\n    </BaseModal>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, nextTick } from 'vue'\nimport { CheckCircle2, X, Flag, Calendar, Plus, Mic, MicOff, Loader2 } from 'lucide-vue-next'\nimport BaseModal from '@/components/base/BaseModal.vue'\nimport type { ParsedVoiceTask } from '@/composables/useVoiceTaskParser'\n\ninterface Props {\n  isOpen: boolean\n  parsedTask: ParsedVoiceTask | null\n  // Re-record props (TASK-1110)\n  isRecording?: boolean\n  isProcessing?: boolean\n  canReRecord?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  isRecording: false,\n  isProcessing: false,\n  canReRecord: false\n})\n\nconst emit = defineEmits<{\n  confirm: [task: { title: string; priority: 'high' | 'medium' | 'low' | null; dueDate: Date | null }]\n  cancel: []\n  reRecord: []  // TASK-1110: Request re-recording\n}>()\n\n// Refs\nconst titleInputRef = ref<HTMLTextAreaElement | null>(null)\n\n// Editable state\nconst editedTitle = ref('')\nconst editedPriority = ref<'high' | 'medium' | 'low' | null>(null)\nconst editedDueDate = ref<Date | null>(null)\n\n// RTL detection for title text\nconst titleDirection = computed(() => {\n  if (!editedTitle.value.trim()) return 'auto'\n  const firstChar = editedTitle.value.trim()[0]\n  // Hebrew, Arabic, Persian, Urdu character ranges\n  const rtlRegex = /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/\n  return rtlRegex.test(firstChar) ? 'rtl' : 'ltr'\n})\n\n// Initialize from parsed task\nwatch(() => props.parsedTask, (task) => {\n  if (task) {\n    editedTitle.value = task.title\n    editedPriority.value = task.priority\n    editedDueDate.value = task.dueDate\n  }\n}, { immediate: true })\n\n// Focus title when opened\nwatch(() => props.isOpen, async (isOpen) => {\n  if (isOpen) {\n    await nextTick()\n    // Small delay to ensure modal animation completes\n    setTimeout(() => {\n      titleInputRef.value?.focus()\n      titleInputRef.value?.select()\n    }, 100)\n  }\n})\n\n// Date computations\nconst today = computed(() => {\n  const d = new Date()\n  d.setHours(0, 0, 0, 0)\n  return d.getTime()\n})\n\nconst tomorrow = computed(() => {\n  const d = new Date()\n  d.setDate(d.getDate() + 1)\n  d.setHours(0, 0, 0, 0)\n  return d.getTime()\n})\n\nconst nextWeek = computed(() => {\n  const d = new Date()\n  d.setDate(d.getDate() + 7)\n  d.setHours(0, 0, 0, 0)\n  return d.getTime()\n})\n\nconst isToday = computed(() => {\n  if (!editedDueDate.value) return false\n  const d = new Date(editedDueDate.value)\n  d.setHours(0, 0, 0, 0)\n  return d.getTime() === today.value\n})\n\nconst isTomorrow = computed(() => {\n  if (!editedDueDate.value) return false\n  const d = new Date(editedDueDate.value)\n  d.setHours(0, 0, 0, 0)\n  return d.getTime() === tomorrow.value\n})\n\nconst isNextWeek = computed(() => {\n  if (!editedDueDate.value) return false\n  const d = new Date(editedDueDate.value)\n  d.setHours(0, 0, 0, 0)\n  return d.getTime() === nextWeek.value\n})\n\nconst isPresetDate = computed(() => isToday.value || isTomorrow.value || isNextWeek.value)\n\n// Actions\nfunction setPriority(value: 'high' | 'medium' | 'low' | null) {\n  editedPriority.value = value\n  triggerHaptic(10)\n}\n\nfunction setDueDate(preset: 'today' | 'tomorrow' | 'week') {\n  const d = new Date()\n  d.setHours(23, 59, 59, 999)\n\n  switch (preset) {\n    case 'today':\n      // Keep today\n      break\n    case 'tomorrow':\n      d.setDate(d.getDate() + 1)\n      break\n    case 'week':\n      d.setDate(d.getDate() + 7)\n      break\n  }\n\n  editedDueDate.value = d\n  triggerHaptic(10)\n}\n\nfunction clearDueDate() {\n  editedDueDate.value = null\n  triggerHaptic(10)\n}\n\nfunction handleConfirm() {\n  if (!editedTitle.value.trim()) return\n\n  triggerHaptic(30)\n  emit('confirm', {\n    title: editedTitle.value.trim(),\n    priority: editedPriority.value,\n    dueDate: editedDueDate.value\n  })\n}\n\nfunction handleCancel() {\n  triggerHaptic(10)\n  emit('cancel')\n}\n\n// TASK-1110: Handle re-record button click\nfunction handleReRecord() {\n  triggerHaptic(20)\n  emit('reRecord')\n}\n\nfunction triggerHaptic(duration: number = 10) {\n  if (typeof navigator !== 'undefined' && 'vibrate' in navigator) {\n    try {\n      navigator.vibrate(duration)\n    } catch {\n      // Vibration API not supported\n    }\n  }\n}\n</script>\n\n<style scoped>\n/* ================================\n   VOICE TASK CONFIRMATION MODAL\n   Popup window with RTL support\n   ================================ */\n\n.voice-confirmation-content {\n  display: flex;\n  flex-direction: column;\n  gap: 0;\n}\n\n/* Header */\n.confirmation-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: var(--space-4) var(--space-5);\n  border-bottom: 1px solid var(--glass-border);\n  background: var(--brand-bg-subtle);\n}\n\n.header-info {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.header-icon {\n  color: var(--brand-primary);\n}\n\n.header-title {\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n}\n\n.close-btn {\n  width: var(--space-8);\n  height: var(--space-8);\n  border: none;\n  border-radius: var(--radius-full);\n  background: var(--glass-bg-soft);\n  color: var(--text-secondary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.close-btn:hover {\n  background: var(--glass-bg);\n  color: var(--text-primary);\n}\n\n.close-btn:active {\n  transform: scale(0.9);\n}\n\n/* Body */\n.confirmation-body {\n  padding: var(--space-5);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-5);\n}\n\n.field-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.field-label-row {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--space-2);\n}\n\n.field-label {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n}\n\n/* Re-record button (TASK-1110) */\n.rerecord-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1) var(--space-2);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-full);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.rerecord-btn:hover:not(:disabled) {\n  background: var(--glass-bg);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.rerecord-btn:active:not(:disabled) {\n  transform: scale(0.95);\n}\n\n.rerecord-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.rerecord-btn.recording {\n  background: var(--danger-bg-subtle);\n  border-color: var(--danger-border-strong);\n  color: var(--color-priority-high);\n  animation: pulse-rerecord 1.5s ease-in-out infinite;\n}\n\n.rerecord-btn.processing {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--brand-primary);\n}\n\n.rerecord-label {\n  white-space: nowrap;\n}\n\n.spin {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n@keyframes pulse-rerecord {\n  0%, 100% {\n    box-shadow: 0 0 0 0 var(--danger-bg-medium);\n  }\n  50% {\n    box-shadow: 0 0 0 var(--space-1) transparent;\n  }\n}\n\n/* Title Textarea - RTL-aware */\n.title-textarea {\n  width: 100%;\n  min-height: var(--space-20);\n  padding: var(--space-3) var(--space-4);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text-primary);\n  font-size: var(--text-base);\n  font-family: inherit;\n  line-height: var(--leading-relaxed);\n  outline: none;\n  resize: vertical;\n  transition: all var(--duration-fast);\n}\n\n.title-textarea:focus {\n  border-color: var(--brand-primary);\n  box-shadow: 0 0 0 var(--space-0_5) var(--state-active-bg);\n}\n\n.title-textarea::placeholder {\n  color: var(--text-muted);\n}\n\n/* RTL text alignment is handled by dir attribute */\n.title-textarea[dir=\"rtl\"] {\n  text-align: right;\n}\n\n.title-textarea[dir=\"ltr\"] {\n  text-align: left;\n}\n\n/* Recording active state (TASK-1110) */\n.title-textarea.recording-active {\n  border-color: var(--danger-border-hover);\n  background: var(--danger-bg-subtle);\n  animation: pulse-textarea 1.5s ease-in-out infinite;\n}\n\n.title-textarea:disabled {\n  opacity: 0.7;\n  cursor: not-allowed;\n}\n\n@keyframes pulse-textarea {\n  0%, 100% {\n    box-shadow: 0 0 0 0 var(--danger-bg-medium);\n  }\n  50% {\n    box-shadow: 0 0 0 var(--space-0_5) transparent;\n  }\n}\n\n/* Pill Options */\n.pill-options {\n  display: flex;\n  gap: var(--space-2);\n  flex-wrap: wrap;\n}\n\n.pill {\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-full);\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.pill:hover {\n  background: var(--glass-bg);\n  border-color: var(--glass-border-hover);\n}\n\n.pill:active {\n  transform: scale(0.95);\n}\n\n/* Priority pills */\n.pill.priority-high.active {\n  background: var(--priority-high-bg);\n  border-color: var(--priority-high-border);\n  color: var(--color-priority-high);\n}\n\n.pill.priority-medium.active {\n  background: var(--priority-medium-bg);\n  border-color: var(--priority-medium-border);\n  color: var(--color-priority-medium);\n}\n\n.pill.priority-low.active {\n  background: var(--priority-low-bg);\n  border-color: var(--priority-low-border);\n  color: var(--color-priority-low);\n}\n\n.pill.priority-none.active {\n  background: var(--glass-bg);\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n/* Date pills */\n.pill.date-pill.active {\n  background: var(--state-active-bg);\n  border-color: var(--state-active-border);\n  color: var(--brand-primary);\n}\n\n.pill.clear-pill {\n  padding: var(--space-2);\n  background: var(--danger-bg-subtle);\n  border-color: var(--danger-border-medium);\n  color: var(--color-priority-high);\n}\n\n.pill.clear-pill:hover {\n  background: var(--danger-bg-medium);\n}\n\n.detected-label {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  font-style: italic;\n  margin-top: var(--space-1);\n}\n\n/* Actions */\n.confirmation-actions {\n  display: flex;\n  gap: var(--space-3);\n  padding: var(--space-4) var(--space-5);\n  border-top: 1px solid var(--glass-border);\n}\n\n.action-btn {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-3) var(--space-4);\n  border: none;\n  border-radius: var(--radius-lg);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.action-btn:active {\n  transform: scale(0.97);\n}\n\n.cancel-btn {\n  background: var(--glass-bg-soft);\n  color: var(--text-secondary);\n  border: 1px solid var(--glass-border);\n}\n\n.cancel-btn:hover {\n  background: var(--glass-bg);\n  color: var(--text-primary);\n}\n\n.confirm-btn {\n  background: var(--brand-primary);\n  color: var(--surface-primary);\n}\n\n.confirm-btn:hover:not(:disabled) {\n  filter: brightness(1.1);\n}\n\n.confirm-btn:disabled {\n  opacity: 0.4;\n  cursor: not-allowed;\n}\n\n/* ================================\n   RESPONSIVE\n   ================================ */\n\n@media (max-width: 480px) {\n  .confirmation-header {\n    padding: var(--space-3) var(--space-4);\n  }\n\n  .confirmation-body {\n    padding: var(--space-4);\n    gap: var(--space-4);\n  }\n\n  .confirmation-actions {\n    padding: var(--space-3) var(--space-4);\n    flex-direction: column;\n  }\n\n  .action-btn {\n    width: 100%;\n  }\n}\n\n/* ================================\n   ACCESSIBILITY - REDUCED MOTION\n   ================================ */\n\n@media (prefers-reduced-motion: reduce) {\n  .pill,\n  .close-btn,\n  .action-btn,\n  .title-textarea {\n    transition: none;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/layouts/MobileLayout.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/views/MobileInboxView.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Circle' is defined but never used. Allowed unused vars must match /^_/u.","line":310,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":310,"endColumn":9,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Circle"},"fix":{"range":[11879,11889],"text":""},"desc":"Remove unused variable \"Circle\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Clock' is defined but never used. Allowed unused vars must match /^_/u.","line":310,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":310,"endColumn":16,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Clock"},"fix":{"range":[11889,11896],"text":""},"desc":"Remove unused variable \"Clock\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectedProject' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":327,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":327,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectedPriority' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":328,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":328,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'hasActiveFilters' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":331,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":331,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'clearFilters' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":333,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":333,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'toggleHideDoneTasks' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":335,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":335,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dateOptions' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":505,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":505,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'priorityOptions' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":513,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":513,"endColumn":22},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":653,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":653,"endColumn":81},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'expandQuickAdd' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":839,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":839,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'collapseQuickAdd' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":844,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":844,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectDueDate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":853,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":853,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectQuickAddPriority' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":857,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":857,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'submitTask' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":886,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":886,"endColumn":17}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"mobile-inbox\">\n    <!-- Debug Banner (tap to toggle) — dev user only -->\n    <template v-if=\"isDevUser\">\n      <div v-if=\"showDebug\" class=\"debug-banner\" @click=\"showDebug = false\">\n        <div><strong>Sync Debug</strong> (tap to hide)</div>\n        <div>Auth: {{ authStatus }}</div>\n        <div>User: {{ userId || 'none' }}</div>\n        <div>Tasks loaded: {{ taskStore.tasks.length }}</div>\n        <div>Filtered: {{ filteredTasks.length }}</div>\n        <div v-if=\"syncError\" class=\"error\">\n          Error: {{ syncError }}\n        </div>\n      </div>\n      <button v-else class=\"debug-toggle\" @click=\"showDebug = true\">\n        ?\n      </button>\n    </template>\n\n    <!-- Header -->\n    <div class=\"mobile-inbox-header\">\n      <h2>Inbox</h2>\n      <div class=\"header-actions\">\n        <span class=\"task-count\">{{ filteredTasks.length }}</span>\n      </div>\n    </div>\n\n    <!-- TASK-1104: Enhanced Filter Section -->\n    <div class=\"filter-section\">\n      <!-- Time-based Filters Row -->\n      <div class=\"filter-chips\">\n        <button\n          v-for=\"filter in timeFilters\"\n          :key=\"filter.value\"\n          class=\"filter-chip\"\n          :class=\"[{ active: activeTimeFilter === filter.value }]\"\n          @click=\"setTimeFilter(filter.value)\"\n        >\n          <component :is=\"filter.icon\" :size=\"14\" />\n          {{ filter.label }}\n          <span v-if=\"filter.count > 0\" class=\"filter-count\">{{ filter.count }}</span>\n        </button>\n      </div>\n\n      <!-- Group By + Sort Row -->\n      <div class=\"controls-row\">\n        <!-- Group By Dropdown -->\n        <div class=\"group-by-control\">\n          <button class=\"control-btn\" @click=\"toggleGroupByDropdown\">\n            <Layers :size=\"14\" />\n            <span>{{ groupByLabel }}</span>\n            <ChevronDown :size=\"12\" :class=\"{ rotated: showGroupByDropdown }\" />\n          </button>\n          <div v-if=\"showGroupByDropdown\" class=\"dropdown-menu\">\n            <button\n              v-for=\"option in groupByOptions\"\n              :key=\"option.value\"\n              class=\"dropdown-item\"\n              :class=\"{ active: groupBy === option.value }\"\n              @click=\"selectGroupBy(option.value)\"\n            >\n              <component :is=\"option.icon\" :size=\"14\" />\n              {{ option.label }}\n            </button>\n          </div>\n        </div>\n\n        <!-- Sort toggle -->\n        <button class=\"sort-btn\" @click=\"toggleSort\">\n          <ArrowUpDown :size=\"16\" />\n          {{ sortLabel }}\n        </button>\n\n        <!-- Hide Done Toggle -->\n        <button\n          class=\"control-btn hide-done-btn\"\n          :class=\"{ active: hideDoneTasks }\"\n          :title=\"hideDoneTasks ? 'Showing active tasks' : 'Show completed tasks'\"\n          @click=\"hideDoneTasks = !hideDoneTasks\"\n        >\n          <CheckCircle2 :size=\"14\" />\n        </button>\n      </div>\n    </div>\n\n    <!-- Swipe hint (shows once) -->\n    <div v-if=\"showSwipeHint\" class=\"swipe-hint\">\n      <span class=\"hint-text\">← Delete</span>\n      <span class=\"hint-divider\">|</span>\n      <span class=\"hint-text\">Edit →</span>\n      <button class=\"hint-dismiss\" @click=\"dismissSwipeHint\">\n        Got it\n      </button>\n    </div>\n\n    <!-- Task List -->\n    <div class=\"mobile-task-list\">\n      <div v-if=\"filteredTasks.length === 0\" class=\"empty-state\">\n        <Inbox :size=\"48\" />\n        <p v-if=\"activeTimeFilter === 'all'\">\n          No tasks yet\n        </p>\n        <p v-else>\n          No {{ timeFilterLabel }} tasks\n        </p>\n      </div>\n\n      <!-- TASK-1104: Grouped Task Display -->\n      <template v-if=\"groupBy !== 'none' && filteredTasks.length > 0\">\n        <div v-for=\"group in groupedTasks\" :key=\"group.key\" class=\"task-group\">\n          <div class=\"group-header\">\n            <span v-if=\"group.color\" class=\"group-color-dot\" :style=\"{ backgroundColor: group.color }\" />\n            <span class=\"group-title\">{{ group.title }}</span>\n            <span class=\"group-count\">{{ group.tasks.length }}</span>\n          </div>\n          <SwipeableTaskItem\n            v-for=\"task in group.tasks\"\n            :key=\"task.id\"\n            :task-id=\"task.id\"\n            @edit=\"handleEditTask(task)\"\n            @delete=\"handleDeleteTask(task)\"\n          >\n            <div\n              class=\"mobile-task-item\"\n              :class=\"[{ 'timer-active': isTimerActive(task.id) }]\"\n              @click=\"handleTaskClick(task)\"\n            >\n              <div class=\"task-checkbox\" @click.stop=\"toggleTask(task)\">\n                <div class=\"checkbox-circle\" :class=\"[{ checked: task.status === 'done' }]\">\n                  <Check v-if=\"task.status === 'done'\" :size=\"14\" />\n                </div>\n              </div>\n\n              <div class=\"task-content\">\n                <div class=\"task-title-row\">\n                  <span class=\"task-title\" dir=\"auto\" :class=\"[{ done: task.status === 'done' }]\">{{ task.title }}</span>\n                  <span v-if=\"task.priority && groupBy !== 'priority'\" class=\"priority-badge-inline\" :class=\"[task.priority]\">\n                    {{ priorityLabel(task.priority || 'none') }}\n                  </span>\n                </div>\n                <div class=\"task-meta\">\n                  <span v-if=\"task.dueDate && groupBy !== 'date'\" class=\"due-date\" :class=\"[{ overdue: isOverdue(task.dueDate) }]\">\n                    <Calendar :size=\"12\" />\n                    {{ formatDueDate(task.dueDate) }}\n                  </span>\n                  <span v-if=\"getProjectName(task.projectId) && groupBy !== 'project'\" class=\"project-badge\">\n                    {{ getProjectName(task.projectId) }}\n                  </span>\n                </div>\n              </div>\n\n              <button class=\"timer-btn\" @click.stop=\"startTimer(task)\">\n                <Play :size=\"16\" />\n              </button>\n            </div>\n          </SwipeableTaskItem>\n        </div>\n      </template>\n\n      <!-- Flat List (no grouping) -->\n      <template v-else>\n        <SwipeableTaskItem\n          v-for=\"task in filteredTasks\"\n          :key=\"task.id\"\n          :task-id=\"task.id\"\n          @edit=\"handleEditTask(task)\"\n          @delete=\"handleDeleteTask(task)\"\n        >\n          <div\n            class=\"mobile-task-item\"\n            :class=\"[{ 'timer-active': isTimerActive(task.id) }]\"\n            @click=\"handleTaskClick(task)\"\n          >\n            <div class=\"task-checkbox\" @click.stop=\"toggleTask(task)\">\n              <div class=\"checkbox-circle\" :class=\"[{ checked: task.status === 'done' }]\">\n                <Check v-if=\"task.status === 'done'\" :size=\"14\" />\n              </div>\n            </div>\n\n            <div class=\"task-content\">\n              <div class=\"task-title-row\">\n                <span class=\"task-title\" dir=\"auto\" :class=\"[{ done: task.status === 'done' }]\">{{ task.title }}</span>\n                <span v-if=\"task.priority\" class=\"priority-badge-inline\" :class=\"[task.priority]\">\n                  {{ priorityLabel(task.priority || 'none') }}\n                </span>\n              </div>\n              <div class=\"task-meta\">\n                <span v-if=\"task.dueDate\" class=\"due-date\" :class=\"[{ overdue: isOverdue(task.dueDate) }]\">\n                  <Calendar :size=\"12\" />\n                  {{ formatDueDate(task.dueDate) }}\n                </span>\n                <span v-if=\"getProjectName(task.projectId)\" class=\"project-badge\">\n                  {{ getProjectName(task.projectId) }}\n                </span>\n              </div>\n            </div>\n\n            <button class=\"timer-btn\" @click.stop=\"startTimer(task)\">\n              <Play :size=\"16\" />\n            </button>\n          </div>\n        </SwipeableTaskItem>\n      </template>\n    </div>\n\n    <!-- Quick Add Bar (trigger only) — Teleported to <body> to escape scroll container's\n         overflow clipping, which breaks position:fixed on mobile WebKit/Blink (BUG-1312) -->\n    <Teleport to=\"body\">\n      <div class=\"quick-add-bar\">\n        <div class=\"quick-add-row\">\n          <input\n            type=\"text\"\n            placeholder=\"Add a task...\"\n            class=\"quick-add-input\"\n            readonly\n            @click=\"openTaskCreateSheet\"\n          >\n\n          <!-- Mic button with offline queue badge (TASK-1131) -->\n          <button\n            v-if=\"isVoiceSupported\"\n            class=\"mic-btn\"\n            :class=\"[{ recording: isListening, offline: !isVoiceOnline }]\"\n            @click=\"toggleVoiceInput\"\n          >\n            <Mic v-if=\"!isListening\" :size=\"20\" />\n            <MicOff v-else :size=\"20\" />\n            <span v-if=\"hasVoicePending\" class=\"voice-pending-badge\">{{ voicePendingCount }}</span>\n          </button>\n\n          <button\n            class=\"add-btn\"\n            @click=\"openTaskCreateSheet\"\n          >\n            <Plus :size=\"20\" />\n          </button>\n        </div>\n\n        <!-- Voice feedback (when recording) - Whisper only (TASK-1119) -->\n        <div v-if=\"isListening || isProcessingVoice || isVoiceQueued\" class=\"voice-feedback\">\n          <span class=\"voice-mode-badge whisper\">🤖 AI</span>\n          <div class=\"voice-waveform\" :class=\"{ paused: isVoiceQueued }\">\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n            <span class=\"wave-bar\" />\n          </div>\n          <span class=\"voice-status\">\n            <template v-if=\"isVoiceQueued\">📥 Saved offline - will transcribe when online</template>\n            <template v-else-if=\"isProcessingVoice\">Processing...</template>\n            <template v-else>{{ recordingDuration }}s - Speak freely...</template>\n          </span>\n          <button v-if=\"!isVoiceQueued\" class=\"voice-cancel\" @click=\"cancelVoice\">\n            <X :size=\"16\" />\n          </button>\n        </div>\n\n        <!-- Voice mode indicator when not recording -->\n        <div v-if=\"isVoiceSupported && !isListening && !isProcessingVoice && !isVoiceQueued\" class=\"voice-lang-hint\">\n          <span v-if=\"!isVoiceOnline\" class=\"voice-offline-badge\">📴 Offline</span>\n          <span class=\"voice-mode-badge whisper\">🤖 AI (auto-detect)</span>\n          <span v-if=\"hasVoicePending\" class=\"voice-queue-status\">{{ voicePendingCount }} queued</span>\n        </div>\n\n        <!-- Voice error message -->\n        <div v-if=\"voiceError && !isListening\" class=\"voice-error\">\n          {{ voiceError }}\n        </div>\n\n      <!-- Voice Task Confirmation removed - using TaskCreateBottomSheet instead (TASK-1077) -->\n      </div>\n    </Teleport>\n\n    <!-- Task Edit Bottom Sheet -->\n    <TaskEditBottomSheet\n      :is-open=\"isEditSheetOpen\"\n      :task=\"editingTask\"\n      @close=\"closeEditSheet\"\n      @save=\"handleSaveTask\"\n    />\n\n    <!-- Full-screen Task Creation Sheet -->\n    <TaskCreateBottomSheet\n      :is-open=\"isTaskCreateOpen\"\n      :is-listening=\"isListening\"\n      :is-processing=\"isProcessingVoice\"\n      :voice-transcript=\"finalVoiceTranscript || whisperTranscript\"\n      :can-re-record=\"isVoiceSupported\"\n      @close=\"handleTaskCreateClose\"\n      @created=\"handleTaskSheetCreated\"\n      @stop-recording=\"stopVoice\"\n      @start-recording=\"handleStartReRecord\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, ref, onMounted, onBeforeUnmount } from 'vue'\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useAuthStore } from '@/stores/auth'\nimport { useTimerStore } from '@/stores/timer'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { useMobileFilters, type GroupByType } from '@/composables/mobile/useMobileFilters'\nimport TaskEditBottomSheet from '@/mobile/components/TaskEditBottomSheet.vue'\nimport TaskCreateBottomSheet from '@/mobile/components/TaskCreateBottomSheet.vue'\nimport SwipeableTaskItem from '@/mobile/components/SwipeableTaskItem.vue'\nimport {\n  Plus, Check, Play, Calendar, Inbox,\n  Circle, Clock, CheckCircle2, ArrowUpDown,\n  Flag, ChevronDown, Mic, MicOff, X,\n  Layers, CalendarClock, AlertCircle, FolderOpen, ListFilter\n} from 'lucide-vue-next'\n// Web Speech API removed (TASK-1119) - Whisper-only for better Hebrew support\nimport { useWhisperSpeech } from '@/composables/useWhisperSpeech'\nimport { useOfflineVoiceQueue } from '@/composables/useOfflineVoiceQueue'\nimport { useHaptics } from '@/composables/useHaptics'\n\nconst taskStore = useTaskStore()\nconst authStore = useAuthStore()\nconst timerStore = useTimerStore()\nconst { lastSyncError } = useSupabaseDatabase()\nconst { triggerHaptic } = useHaptics()\n\n// Shared mobile filter state (persists across view navigation)\nconst {\n  selectedProject,\n  selectedPriority,\n  groupBy,\n  hideDoneTasks,\n  hasActiveFilters,\n  priorityLabel,\n  clearFilters,\n  setGroupBy,\n  toggleHideDoneTasks\n} = useMobileFilters()\n\n// State\nconst newTaskTitle = ref('')\nconst taskInput = ref<HTMLInputElement | null>(null)\nconst showDebug = ref(false)\nconst isDevUser = computed(() => authStore.user?.email === 'endlessblink@gmail.com')\nconst sortBy = ref<'newest' | 'priority' | 'dueDate'>('newest')\n\n// TASK-1104: Enhanced filtering state (view-specific)\ntype TimeFilterType = 'all' | 'today' | 'week' | 'overdue'\n\nconst activeTimeFilter = ref<TimeFilterType>('all')\nconst showGroupByDropdown = ref(false)\n\n// Quick-add expanded state\nconst isQuickAddExpanded = ref(false)\nconst selectedDueDate = ref<string | null>(null)\nconst quickAddPriority = ref<string | null>(null) // Local state for quick-add form only\n\n// Task create sheet state\nconst isTaskCreateOpen = ref(false)\nconst finalVoiceTranscript = ref('')\n\n// Swipe hint - show once for first-time users\nconst SWIPE_HINT_KEY = 'flowstate-inbox-swipe-hint-dismissed'\nconst showSwipeHint = ref(false)\n\nonMounted(() => {\n  const dismissed = localStorage.getItem(SWIPE_HINT_KEY)\n  if (!dismissed) {\n    showSwipeHint.value = true\n  }\n})\n\nconst dismissSwipeHint = () => {\n  showSwipeHint.value = false\n  localStorage.setItem(SWIPE_HINT_KEY, 'true')\n}\n\n// TASK-1131: Offline voice queue - transcribe audio function for queue processing\nconst getWhisperEndpoint = () => {\n  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || ''\n  if (supabaseUrl.startsWith('/')) {\n    return `${window.location.origin}${supabaseUrl}/functions/v1/whisper-transcribe`\n  }\n  return `${supabaseUrl}/functions/v1/whisper-transcribe`\n}\n\nconst transcribeAudioForQueue = async (blob: Blob, mimeType: string): Promise<{ text: string; language: string }> => {\n  const formData = new FormData()\n  const extension = mimeType.includes('webm') ? 'webm'\n    : mimeType.includes('mp4') ? 'mp4'\n    : mimeType.includes('wav') ? 'wav'\n    : 'webm'\n\n  formData.append('file', blob, `audio.${extension}`)\n  formData.append('model', 'whisper-large-v3-turbo')\n\n  const response = await fetch(getWhisperEndpoint(), {\n    method: 'POST',\n    body: formData\n  })\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}))\n    throw new Error(errorData.error?.message || `API error: ${response.status}`)\n  }\n\n  const data = await response.json()\n  return { text: data.text || '', language: data.language || 'unknown' }\n}\n\n// TASK-1131: Offline voice queue\nconst {\n  pendingCount: voicePendingCount,\n  hasPending: hasVoicePending,\n  isProcessing: isQueueProcessing,\n  enqueue: enqueueVoice\n} = useOfflineVoiceQueue({\n  transcribeAudio: transcribeAudioForQueue,\n  onProcessed: (result) => {\n    console.log('[OfflineVoice] Processed queued audio:', result.transcript)\n    // Open TaskCreateBottomSheet and set transcript\n    finalVoiceTranscript.value = result.transcript.trim()\n    isTaskCreateOpen.value = true\n  },\n  onError: (error, item) => {\n    console.error('[OfflineVoice] Failed to process queued audio:', error, item.id)\n  }\n})\n\n// Voice input - Whisper only (TASK-1119: removed Web Speech API for better Hebrew support)\nconst {\n  isRecording: isWhisperRecording,\n  isProcessing: isWhisperProcessing,\n  isQueued: isWhisperQueued,\n  isSupported: isWhisperSupported,\n  hasApiKey: hasWhisperApiKey,\n  transcript: whisperTranscript,\n  error: whisperError,\n  recordingDuration,\n  isOnline: isVoiceOnline,\n  start: startWhisper,\n  stop: stopWhisper,\n  cancel: cancelWhisper\n} = useWhisperSpeech({\n  onResult: (result) => {\n    console.log('[Whisper] Result:', result)\n    if (result.transcript.trim()) {\n      // Keep TaskCreateBottomSheet open - transcript flows via voiceTranscript prop\n      // The sheet's watcher will populate the text field\n      finalVoiceTranscript.value = result.transcript.trim()\n    }\n  },\n  onError: (err) => {\n    console.warn('[Whisper] Error:', err)\n  },\n  // TASK-1131: Handle offline recording\n  onOfflineRecord: async (audioBlob, mimeType) => {\n    console.log('[Whisper] Offline - queuing audio')\n    await enqueueVoice(audioBlob, mimeType)\n    // Show feedback that audio was queued\n    triggerHaptic('medium')\n  }\n})\n\n// Voice state - Whisper only (TASK-1119) + offline queue (TASK-1131)\nconst isListening = computed(() => isWhisperRecording.value)\nconst isProcessingVoice = computed(() => isWhisperProcessing.value || isQueueProcessing.value)\nconst isVoiceQueued = computed(() => isWhisperQueued.value)\nconst isVoiceSupported = computed(() => isWhisperSupported.value && hasWhisperApiKey.value)\nconst voiceError = computed(() => whisperError.value)\n\n// Voice control functions - Whisper only\nconst startVoice = async () => {\n  await startWhisper()\n}\n\nconst stopVoice = () => {\n  stopWhisper()\n}\n\n// TASK-1110: Handle re-record request from TaskCreateBottomSheet\nconst handleStartReRecord = async () => {\n  // Clear previous transcript\n  finalVoiceTranscript.value = ''\n  // Start new recording\n  await startVoice()\n}\n\nconst cancelVoice = () => {\n  cancelWhisper()\n}\n\n// Toggle voice recording\nconst toggleVoiceInput = async () => {\n  if (isListening.value) {\n    stopVoice()\n  } else {\n    // Reset state when starting new voice input\n    finalVoiceTranscript.value = ''\n    // Open TaskCreateBottomSheet to show voice feedback during recording\n    isTaskCreateOpen.value = true\n    await startVoice()\n  }\n}\n\n// Date quick options\nconst dateOptions = [\n  { label: 'Today', value: 'today' },\n  { label: 'Tomorrow', value: 'tomorrow' },\n  { label: 'Next Week', value: 'nextweek' },\n  { label: 'None', value: null }\n]\n\n// Priority options (matches Task type: 'low' | 'medium' | 'high' | null)\nconst priorityOptions = [\n  { label: 'High', value: 'high' },\n  { label: 'Medium', value: 'medium' },\n  { label: 'Low', value: 'low' }\n]\n\n// Edit sheet state\nconst isEditSheetOpen = ref(false)\nconst editingTask = ref<Task | null>(null)\n\n// Debug info\nconst authStatus = computed(() => authStore.isAuthenticated ? 'Signed in' : 'Not signed in')\nconst userId = computed(() => authStore.user?.id?.substring(0, 8) + '...' || null)\nconst syncError = computed(() => lastSyncError.value)\n\n// Open edit bottom sheet for task\nconst handleEditTask = (task: Task) => {\n  editingTask.value = task\n  isEditSheetOpen.value = true\n}\n\n// Close edit bottom sheet\nconst closeEditSheet = () => {\n  isEditSheetOpen.value = false\n  // Delay clearing the task to allow close animation\n  setTimeout(() => {\n    editingTask.value = null\n  }, 300)\n}\n\n// Save task changes from edit sheet\nconst handleSaveTask = async (taskId: string, updates: Partial<Task>) => {\n  // BUG-1051: AWAIT to ensure persistence\n  await taskStore.updateTask(taskId, updates)\n}\n\n// Delete task (triggered by swipe left + confirm)\nconst handleDeleteTask = (task: Task) => {\n  taskStore.deleteTask(task.id)\n}\n\n// TASK-1104: Date helpers\nconst getToday = () => {\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  return today\n}\n\nconst getWeekEnd = () => {\n  const today = getToday()\n  const dayOfWeek = today.getDay()\n  const daysUntilSunday = dayOfWeek === 0 ? 7 : (7 - dayOfWeek)\n  const weekEnd = new Date(today)\n  weekEnd.setDate(today.getDate() + daysUntilSunday)\n  return weekEnd\n}\n\nconst isDueToday = (dueDate: string | undefined): boolean => {\n  if (!dueDate) return false\n  const date = new Date(dueDate)\n  date.setHours(0, 0, 0, 0)\n  return date.getTime() === getToday().getTime()\n}\n\nconst isDueThisWeek = (dueDate: string | undefined): boolean => {\n  if (!dueDate) return false\n  const date = new Date(dueDate)\n  date.setHours(0, 0, 0, 0)\n  const today = getToday()\n  const weekEnd = getWeekEnd()\n  return date >= today && date < weekEnd\n}\n\nconst isTaskOverdue = (dueDate: string | undefined): boolean => {\n  if (!dueDate) return false\n  const date = new Date(dueDate)\n  date.setHours(0, 0, 0, 0)\n  return date < getToday()\n}\n\n// TASK-1104: Time filter configuration with counts\nconst timeFilters = computed(() => {\n  const allTasks = taskStore.tasks.filter(t => !hideDoneTasks.value || t.status !== 'done')\n  return [\n    { value: 'all' as const, label: 'All', icon: Inbox, count: allTasks.length },\n    { value: 'today' as const, label: 'Today', icon: Calendar, count: allTasks.filter(t => isDueToday(t.dueDate)).length },\n    { value: 'week' as const, label: 'This Week', icon: CalendarClock, count: allTasks.filter(t => isDueThisWeek(t.dueDate)).length },\n    { value: 'overdue' as const, label: 'Overdue', icon: AlertCircle, count: allTasks.filter(t => isTaskOverdue(t.dueDate) && t.status !== 'done').length },\n  ]\n})\n\nconst timeFilterLabel = computed(() => {\n  const labels: Record<TimeFilterType, string> = {\n    all: 'all',\n    today: 'due today',\n    week: 'due this week',\n    overdue: 'overdue'\n  }\n  return labels[activeTimeFilter.value]\n})\n\n// TASK-1104: Group by options\nconst groupByOptions = [\n  { value: 'none' as const, label: 'No Grouping', icon: ListFilter },\n  { value: 'date' as const, label: 'By Date', icon: Calendar },\n  { value: 'project' as const, label: 'By Project', icon: FolderOpen },\n  { value: 'priority' as const, label: 'By Priority', icon: Flag },\n]\n\nconst groupByLabel = computed(() => {\n  const option = groupByOptions.find(o => o.value === groupBy.value)\n  return option?.label || 'Group'\n})\n\n// Computed: Filtered tasks\nconst filteredTasks = computed(() => {\n  let tasks = [...taskStore.tasks]\n\n  // Hide done tasks filter\n  if (hideDoneTasks.value) {\n    tasks = tasks.filter(t => t.status !== 'done')\n  }\n\n  // Time-based filter\n  switch (activeTimeFilter.value) {\n    case 'today':\n      tasks = tasks.filter(t => isDueToday(t.dueDate))\n      break\n    case 'week':\n      tasks = tasks.filter(t => isDueThisWeek(t.dueDate))\n      break\n    case 'overdue':\n      tasks = tasks.filter(t => isTaskOverdue(t.dueDate) && t.status !== 'done')\n      break\n    // 'all' shows everything\n  }\n\n  // Sort\n  switch (sortBy.value) {\n    case 'priority':\n      const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3, none: 4 }\n      tasks.sort((a, b) =>\n        (priorityOrder[a.priority || 'none'] || 4) - (priorityOrder[b.priority || 'none'] || 4)\n      )\n      break\n    case 'dueDate':\n      tasks.sort((a, b) => {\n        if (!a.dueDate) return 1\n        if (!b.dueDate) return -1\n        return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()\n      })\n      break\n    case 'newest':\n    default:\n      tasks.sort((a, b) => {\n        const aTime = a.createdAt ? new Date(a.createdAt).getTime() : 0\n        const bTime = b.createdAt ? new Date(b.createdAt).getTime() : 0\n        return bTime - aTime\n      })\n  }\n\n  return tasks\n})\n\n// TASK-1104: Grouped tasks computed\ninterface TaskGroup {\n  key: string\n  title: string\n  color?: string\n  tasks: Task[]\n}\n\nconst groupedTasks = computed((): TaskGroup[] => {\n  if (groupBy.value === 'none') return []\n\n  const tasks = filteredTasks.value\n  const groups: Map<string, TaskGroup> = new Map()\n\n  tasks.forEach(task => {\n    let key: string\n    let title: string\n    let color: string | undefined\n\n    switch (groupBy.value) {\n      case 'date': {\n        if (!task.dueDate) {\n          key = 'no-date'\n          title = 'No Due Date'\n        } else if (isTaskOverdue(task.dueDate)) {\n          key = 'overdue'\n          title = 'Overdue'\n          color = '#ef4444'\n        } else if (isDueToday(task.dueDate)) {\n          key = 'today'\n          title = 'Today'\n          color = '#22c55e'\n        } else if (isDueThisWeek(task.dueDate)) {\n          key = 'this-week'\n          title = 'This Week'\n          color = '#3b82f6'\n        } else {\n          key = 'later'\n          title = 'Later'\n          color = '#6b7280'\n        }\n        break\n      }\n      case 'project': {\n        if (!task.projectId) {\n          key = 'no-project'\n          title = 'No Project'\n        } else {\n          const project = taskStore.projects.find(p => p.id === task.projectId)\n          key = task.projectId\n          title = project?.name || 'Unknown Project'\n          // Handle color being string or string[]\n          const projectColor = project?.color\n          color = Array.isArray(projectColor) ? projectColor[0] : projectColor\n        }\n        break\n      }\n      case 'priority': {\n        const priorityColors: Record<string, string> = {\n          critical: '#dc2626',\n          high: '#f97316',\n          medium: '#eab308',\n          low: '#22c55e',\n          none: '#6b7280'\n        }\n        const priorityLabels: Record<string, string> = {\n          critical: 'Critical (P0)',\n          high: 'High (P1)',\n          medium: 'Medium (P2)',\n          low: 'Low (P3)',\n          none: 'No Priority'\n        }\n        const priority = task.priority || 'none'\n        key = priority\n        title = priorityLabels[priority] || 'No Priority'\n        color = priorityColors[priority]\n        break\n      }\n      default:\n        key = 'default'\n        title = 'Tasks'\n    }\n\n    if (!groups.has(key)) {\n      groups.set(key, { key, title, color, tasks: [] })\n    }\n    groups.get(key)!.tasks.push(task)\n  })\n\n  // Sort groups based on groupBy type\n  const sortedGroups = Array.from(groups.values())\n\n  if (groupBy.value === 'date') {\n    const dateOrder = ['overdue', 'today', 'this-week', 'later', 'no-date']\n    sortedGroups.sort((a, b) => dateOrder.indexOf(a.key) - dateOrder.indexOf(b.key))\n  } else if (groupBy.value === 'priority') {\n    const priorityOrder = ['critical', 'high', 'medium', 'low', 'none']\n    sortedGroups.sort((a, b) => priorityOrder.indexOf(a.key) - priorityOrder.indexOf(b.key))\n  } else if (groupBy.value === 'project') {\n    // Sort by project name, with \"No Project\" at the end\n    sortedGroups.sort((a, b) => {\n      if (a.key === 'no-project') return 1\n      if (b.key === 'no-project') return -1\n      return a.title.localeCompare(b.title)\n    })\n  }\n\n  return sortedGroups\n})\n\n// Helper to get project name\nconst getProjectName = (projectId: string | undefined | null): string | null => {\n  if (!projectId) return null\n  const project = taskStore.projects.find(p => p.id === projectId)\n  return project?.name || null\n}\n\nconst sortLabel = computed(() => {\n  switch (sortBy.value) {\n    case 'priority': return 'Priority'\n    case 'dueDate': return 'Due'\n    default: return 'Newest'\n  }\n})\n\n// TASK-1104: Filter Actions\nconst setTimeFilter = (filter: TimeFilterType) => {\n  activeTimeFilter.value = filter\n}\n\nconst toggleGroupByDropdown = () => {\n  showGroupByDropdown.value = !showGroupByDropdown.value\n}\n\nconst selectGroupBy = (value: GroupByType) => {\n  setGroupBy(value)\n  showGroupByDropdown.value = false\n}\n\nconst toggleSort = () => {\n  const sortOptions: Array<'newest' | 'priority' | 'dueDate'> = ['newest', 'priority', 'dueDate']\n  const currentIndex = sortOptions.indexOf(sortBy.value)\n  sortBy.value = sortOptions[(currentIndex + 1) % sortOptions.length]\n}\n\n// Close dropdown when clicking outside\nconst handleClickOutside = (event: MouseEvent) => {\n  const target = event.target as HTMLElement\n  if (!target.closest('.group-by-control')) {\n    showGroupByDropdown.value = false\n  }\n}\n\nonMounted(() => {\n  document.addEventListener('click', handleClickOutside)\n})\n\nonBeforeUnmount(() => {\n  document.removeEventListener('click', handleClickOutside)\n})\n\n// Quick-add expansion handlers\nconst expandQuickAdd = () => {\n  console.log('[TASK-1005] expandQuickAdd called, setting isQuickAddExpanded to true')\n  isQuickAddExpanded.value = true\n}\n\nconst collapseQuickAdd = () => {\n  isQuickAddExpanded.value = false\n}\n\n// Open task create sheet\nconst openTaskCreateSheet = () => {\n  isTaskCreateOpen.value = true\n}\n\nconst selectDueDate = (value: string | null) => {\n  selectedDueDate.value = value\n}\n\nconst selectQuickAddPriority = (value: string | null) => {\n  quickAddPriority.value = quickAddPriority.value === value ? null : value\n}\n\n// Calculate actual due date from option\nconst calculateDueDate = (option: string | null): Date | null => {\n  if (!option) return null\n\n  const today = new Date()\n  today.setHours(23, 59, 59, 999)\n\n  switch (option) {\n    case 'today':\n      return today\n    case 'tomorrow': {\n      const tomorrow = new Date(today)\n      tomorrow.setDate(tomorrow.getDate() + 1)\n      return tomorrow\n    }\n    case 'nextweek': {\n      const nextWeek = new Date(today)\n      nextWeek.setDate(nextWeek.getDate() + 7)\n      return nextWeek\n    }\n    default:\n      return null\n  }\n}\n\nconst submitTask = () => {\n  if (!newTaskTitle.value.trim()) return\n\n  const dueDate = calculateDueDate(selectedDueDate.value)\n\n  taskStore.createTask({\n    title: newTaskTitle.value,\n    status: 'planned',\n    ...(dueDate && { dueDate: dueDate.toISOString() }),\n    ...(quickAddPriority.value && { priority: quickAddPriority.value as 'high' | 'medium' | 'low' })\n  })\n\n  // Reset state\n  newTaskTitle.value = ''\n  selectedDueDate.value = null\n  quickAddPriority.value = null\n  isQuickAddExpanded.value = false\n  taskInput.value?.blur()\n}\n\n// Task create sheet handler\nconst handleTaskCreateClose = () => {\n  isTaskCreateOpen.value = false\n  finalVoiceTranscript.value = ''\n}\n\nconst handleTaskSheetCreated = (data: { title: string; description: string; priority: 'high' | 'medium' | 'low' | null; dueDate: Date | null }) => {\n  taskStore.createTask({\n    title: data.title,\n    status: 'planned',\n    ...(data.description && { description: data.description }),\n    ...(data.dueDate && { dueDate: data.dueDate.toISOString() }),\n    ...(data.priority && { priority: data.priority })\n  })\n  handleTaskCreateClose()\n}\n\nconst toggleTask = async (task: Task) => {\n  const newStatus = task.status === 'done' ? 'planned' : 'done'\n  // BUG-1051: AWAIT to ensure persistence\n  await taskStore.updateTask(task.id, { status: newStatus })\n}\n\nconst handleTaskClick = (_task: Task) => {\n  // Normal tap - no action needed\n  // Swipe gestures handle edit/delete\n}\n\nconst startTimer = async (task: Task) => {\n  // BUG-1051: AWAIT for timer sync\n  await timerStore.startTimer(task.id)\n}\n\nconst isTimerActive = (taskId: string) => {\n  return timerStore.isTimerActive && timerStore.currentTaskId === taskId\n}\n\n// Helpers are now provided by useMobileFilters composable (priorityLabel)\n\nconst formatDueDate = (dueDate: string | Date): string => {\n  const date = new Date(dueDate)\n  const today = new Date()\n  const tomorrow = new Date(today)\n  tomorrow.setDate(tomorrow.getDate() + 1)\n\n  if (date.toDateString() === today.toDateString()) {\n    return 'Today'\n  } else if (date.toDateString() === tomorrow.toDateString()) {\n    return 'Tomorrow'\n  } else {\n    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })\n  }\n}\n\nconst isOverdue = (dueDate: string | Date): boolean => {\n  return new Date(dueDate) < new Date()\n}\n</script>\n\n<style scoped>\n.mobile-inbox {\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  padding-bottom: 140px; /* Space for quick-add + nav */\n}\n\n.mobile-inbox-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--space-4);\n  position: sticky;\n  top: 0;\n  background: var(--app-background-gradient);\n  z-index: 10;\n}\n\n.mobile-inbox-header h2 {\n  font-size: var(--text-2xl);\n  font-weight: var(--font-bold);\n  margin: 0;\n}\n\n.task-count {\n  background: var(--surface-secondary);\n  padding: var(--space-1) var(--space-3);\n  border-radius: var(--radius-xl);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n}\n\n/* Filter Section */\n.filter-section {\n  padding: 0 var(--space-4) var(--space-3);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3);\n}\n\n.filter-chips {\n  display: flex;\n  gap: var(--space-2);\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n  scrollbar-width: none;\n}\n\n.filter-chips::-webkit-scrollbar {\n  display: none;\n}\n\n.filter-chip {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-2) var(--space-3_5);\n  border-radius: var(--radius-xl);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-secondary);\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  white-space: nowrap;\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.filter-chip.active {\n  background: transparent;\n  border-color: var(--primary-brand);\n  color: var(--primary-brand);\n}\n\n.sort-section {\n  display: flex;\n  justify-content: flex-end;\n}\n\n/* TASK-1104: Filter count badge */\n.filter-count {\n  background: var(--border-hover);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  margin-left: var(--space-0_5);\n}\n\n.filter-chip.active .filter-count {\n  background: var(--primary-brand);\n  color: white;\n}\n\n/* TASK-1104: Controls row (Group By + Sort) */\n.controls-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.control-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-secondary);\n  color: var(--text-secondary);\n  font-size: var(--text-meta);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.control-btn:active {\n  transform: scale(0.98);\n}\n\n.control-btn .rotated {\n  transform: rotate(180deg);\n}\n\n/* Group By Dropdown */\n.group-by-control {\n  position: relative;\n}\n\n.dropdown-menu {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  margin-top: var(--space-1);\n  min-width: 150px;\n  background: var(--surface-primary);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-lg);\n  box-shadow: var(--shadow-lg);\n  z-index: 100;\n  overflow: hidden;\n}\n\n.dropdown-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2_5);\n  width: 100%;\n  padding: var(--space-3) var(--space-4);\n  border: none;\n  background: transparent;\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  text-align: left;\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.dropdown-item:hover {\n  background: var(--surface-secondary);\n}\n\n.dropdown-item.active {\n  background: var(--primary-brand-bg-subtle);\n  color: var(--primary-brand);\n}\n\n/* Hide Done Toggle */\n.hide-done-btn {\n  padding: var(--space-2);\n  min-width: 36px;\n  justify-content: center;\n}\n\n.hide-done-btn.active {\n  background: var(--primary-brand-bg-subtle);\n  border-color: var(--primary-brand);\n  color: var(--primary-brand);\n}\n\n.sort-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-secondary);\n  color: var(--text-secondary);\n  font-size: var(--text-meta);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.sort-btn:active {\n  transform: scale(0.98);\n}\n\n/* Swipe hint banner */\n.swipe-hint {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-3);\n  padding: var(--space-2_5) var(--space-4);\n  margin: 0 var(--space-4) var(--space-3);\n  background: var(--surface-secondary);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-subtle);\n}\n\n.hint-text {\n  font-size: var(--text-meta);\n  color: var(--text-secondary);\n  font-weight: var(--font-medium);\n}\n\n.hint-divider {\n  color: var(--border-subtle);\n}\n\n.hint-dismiss {\n  margin-left: var(--space-2);\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--primary-brand);\n  background: var(--primary-brand-bg-subtle);\n  border: none;\n  border-radius: var(--radius-md);\n  cursor: pointer;\n}\n\n.hint-dismiss:active {\n  transform: scale(0.95);\n}\n\n/* Task List */\n.mobile-task-list {\n  flex: 1;\n  padding: 0 var(--space-4);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2_5);\n}\n\n/* TASK-1104: Task Groups */\n.task-group {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.task-group:not(:first-child) {\n  margin-top: var(--space-4);\n}\n\n.group-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-1);\n  border-bottom: 1px solid var(--border-subtle);\n}\n\n.group-color-dot {\n  width: var(--space-2);\n  height: var(--space-2);\n  border-radius: var(--radius-full);\n  flex-shrink: 0;\n}\n\n.group-title {\n  font-size: var(--text-meta);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  flex: 1;\n}\n\n.group-count {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  background: var(--surface-secondary);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-sm);\n}\n\n/* Project badge in task meta */\n.project-badge {\n  font-size: var(--text-xs);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-xs);\n  background: var(--surface-tertiary);\n  color: var(--text-tertiary);\n  max-width: 80px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.mobile-task-item {\n  display: flex;\n  align-items: center;\n  background: var(--surface-primary);\n  padding: var(--space-3_5);\n  border-radius: var(--radius-lg);\n  gap: var(--space-3);\n  box-shadow: var(--shadow-xs);\n  cursor: pointer;\n  /* Prevent text selection during swipe */\n  -webkit-user-select: none;\n  user-select: none;\n  -webkit-touch-callout: none;\n}\n\n.mobile-task-item:active {\n  background: var(--surface-tertiary);\n}\n\n.mobile-task-item.timer-active {\n  border: var(--space-0_5) solid var(--timer-active-border, var(--primary-brand));\n  box-shadow: var(--timer-active-glow-strong);\n}\n\n.task-checkbox {\n  padding: var(--space-1);\n  flex-shrink: 0;\n}\n\n.checkbox-circle {\n  width: 22px;\n  height: 22px;\n  border: var(--space-0_5) solid var(--border-subtle);\n  border-radius: var(--radius-full);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all var(--duration-normal);\n}\n\n.checkbox-circle.checked {\n  background: var(--primary-brand);\n  border-color: var(--primary-brand);\n  color: white;\n}\n\n.task-content {\n  flex: 1;\n  min-width: 0;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-1);\n}\n\n.task-title {\n  font-size: var(--text-base);\n  color: var(--text-primary);\n  /* Multi-line truncation for RTL/long text */\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: normal;\n  line-height: 1.4;\n  word-break: break-word;\n  /* RTL support - text aligns based on content direction */\n  text-align: start;\n  unicode-bidi: plaintext;\n}\n\n.task-title.done {\n  text-decoration: line-through;\n  color: var(--text-muted);\n}\n\n/* Title row with inline priority badge */\n.task-title-row {\n  display: flex;\n  align-items: flex-start;\n  gap: var(--space-2);\n}\n\n.task-title-row .task-title {\n  flex: 1;\n  min-width: 0;\n}\n\n/* Inline priority badge (right side of title) */\n.priority-badge-inline {\n  flex-shrink: 0;\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-xs);\n  margin-top: var(--space-0_5);\n  background: var(--surface-tertiary);\n  color: var(--text-secondary);\n}\n\n.priority-badge-inline.critical { background: var(--danger-bg-subtle); color: var(--danger-text); }\n.priority-badge-inline.high { background: var(--warning-bg-subtle); color: var(--warning-text); }\n.priority-badge-inline.medium { background: var(--primary-brand-bg-subtle); color: var(--primary-brand); }\n.priority-badge-inline.low { background: var(--surface-tertiary); color: var(--text-muted); }\n\n.task-meta {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.priority-badge {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-xs);\n  background: var(--surface-tertiary);\n  color: var(--text-secondary);\n}\n\n.priority-badge.critical { background: var(--danger-bg-subtle); color: var(--danger-text); }\n.priority-badge.high { background: var(--warning-bg-subtle); color: var(--warning-text); }\n.priority-badge.medium { background: var(--primary-brand-bg-subtle); color: var(--primary-brand); }\n.priority-badge.low { background: var(--surface-tertiary); color: var(--text-muted); }\n\n.due-date {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n}\n\n.due-date.overdue {\n  color: var(--danger-text);\n}\n\n.timer-btn {\n  width: 36px;\n  height: 36px;\n  border-radius: var(--radius-full);\n  border: none;\n  background: var(--primary-brand-bg-subtle);\n  color: var(--primary-brand);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.timer-btn:active {\n  transform: scale(0.95);\n}\n\n.empty-state {\n  text-align: center;\n  color: var(--text-muted);\n  padding: 60px var(--space-5);\n}\n\n.empty-state p {\n  margin-top: var(--space-3);\n}\n\n/* Quick Add Bar — Teleported to <body> so position:fixed is relative to viewport (BUG-1312) */\n.quick-add-bar {\n  position: fixed;\n  bottom: 64px; /* Above nav */\n  left: 0;\n  right: 0;\n  padding: var(--space-3) var(--space-4);\n  padding-bottom: calc(var(--space-3) + env(safe-area-inset-bottom, 0px));\n  box-sizing: border-box;\n  background: var(--surface-primary);\n  border-top: 1px solid var(--border-subtle);\n  z-index: 50;\n  box-shadow: var(--shadow-md);\n  transition: all var(--duration-slow) var(--spring-smooth);\n}\n\n.quick-add-bar.expanded {\n  padding-top: var(--space-4);\n  padding-bottom: calc(var(--space-4) + env(safe-area-inset-bottom, 0px));\n  box-shadow: var(--shadow-lg);\n  border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;\n}\n\n.quick-add-row {\n  display: flex;\n  gap: var(--space-3);\n  align-items: center;\n  min-width: 0;\n}\n\n.quick-add-input {\n  flex: 1;\n  min-width: 0; /* Allow flex shrinking past intrinsic input width (BUG-1312) */\n  padding: var(--space-3) var(--space-4);\n  border-radius: var(--radius-2xl);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-secondary);\n  color: var(--text-primary);\n  font-size: var(--text-base);\n  outline: none;\n}\n\n.quick-add-input:focus {\n  border-color: var(--primary-brand);\n  box-shadow: var(--brand-primary-glow);\n}\n\n.add-btn {\n  width: 48px;\n  height: 48px;\n  border-radius: var(--radius-full);\n  border: none;\n  background: var(--primary-brand);\n  color: white;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n  box-shadow: var(--brand-primary-glow);\n}\n\n.add-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.add-btn:active:not(:disabled) {\n  transform: scale(0.95);\n}\n\n/* Quick Add Options (expanded state) */\n.quick-add-options {\n  margin-top: var(--space-4);\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-3_5);\n  animation: slideUp var(--duration-normal) ease-out;\n}\n\n@keyframes slideUp {\n  from {\n    opacity: 0;\n    transform: translateY(10px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.option-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.option-label {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-tertiary);\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.option-chips {\n  display: flex;\n  gap: var(--space-2);\n  flex-wrap: wrap;\n}\n\n.option-chip {\n  padding: var(--space-2) var(--space-3_5);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-secondary);\n  color: var(--text-secondary);\n  font-size: var(--text-meta);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-fast) ease;\n}\n\n.option-chip:active {\n  transform: scale(0.96);\n}\n\n.option-chip.active {\n  background: transparent;\n  border-color: var(--primary-brand);\n  color: var(--primary-brand);\n}\n\n/* Priority-specific colors when active */\n.option-chip.priority-chip.high.active {\n  background: transparent;\n  border-color: var(--danger-text);\n  color: var(--danger-text);\n}\n\n.option-chip.priority-chip.medium.active {\n  background: transparent;\n  border-color: var(--warning-text);\n  color: var(--warning-text);\n}\n\n.option-chip.priority-chip.low.active {\n  background: transparent;\n  border-color: var(--text-tertiary);\n  color: var(--text-tertiary);\n}\n\n.collapse-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-1);\n  padding: var(--space-2);\n  margin-top: var(--space-1);\n  border: none;\n  background: transparent;\n  color: var(--text-tertiary);\n  font-size: var(--text-meta);\n  cursor: pointer;\n}\n\n.collapse-btn:active {\n  opacity: 0.7;\n}\n\n/* Mic Button (TASK-1025) */\n.mic-btn {\n  width: 48px;\n  height: 48px;\n  border-radius: var(--radius-full);\n  border: none;\n  background: var(--surface-tertiary);\n  color: var(--text-secondary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n  transition: all var(--duration-normal) ease;\n}\n\n.mic-btn:active {\n  transform: scale(0.95);\n}\n\n.mic-btn.recording {\n  background: var(--danger-text);\n  color: white;\n  animation: pulse-recording 1.5s ease-in-out infinite;\n}\n\n@keyframes pulse-recording {\n  0%, 100% {\n    box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);\n  }\n  50% {\n    box-shadow: 0 0 0 12px rgba(239, 68, 68, 0);\n  }\n}\n\n/* Voice input active state on input */\n.quick-add-input.voice-active {\n  border-color: var(--danger-text);\n  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);\n}\n\n/* Voice feedback panel */\n.voice-feedback {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3) var(--space-4);\n  margin-top: var(--space-3);\n  background: var(--surface-secondary);\n  border-radius: var(--radius-lg);\n  animation: slideUp var(--duration-normal) ease-out;\n}\n\n.voice-waveform {\n  display: flex;\n  align-items: center;\n  gap: 3px;\n  height: var(--space-6);\n}\n\n.wave-bar {\n  width: 3px;\n  height: var(--space-2);\n  background: var(--danger-text);\n  border-radius: var(--radius-xs);\n  animation: wave 0.8s ease-in-out infinite;\n}\n\n.wave-bar:nth-child(1) { animation-delay: 0s; }\n.wave-bar:nth-child(2) { animation-delay: 0.1s; }\n.wave-bar:nth-child(3) { animation-delay: 0.2s; }\n.wave-bar:nth-child(4) { animation-delay: 0.3s; }\n.wave-bar:nth-child(5) { animation-delay: 0.4s; }\n\n@keyframes wave {\n  0%, 100% { height: var(--space-2); }\n  50% { height: var(--space-5); }\n}\n\n.voice-status {\n  flex: 1;\n  font-size: var(--text-sm);\n  color: var(--text-secondary);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.voice-cancel {\n  width: 32px;\n  height: 32px;\n  border-radius: var(--radius-full);\n  border: none;\n  background: var(--surface-tertiary);\n  color: var(--text-tertiary);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.voice-cancel:active {\n  transform: scale(0.95);\n  background: var(--danger-bg-subtle);\n  color: var(--danger-text);\n}\n\n/* Voice language toggle button (inside feedback) */\n.voice-lang-toggle {\n  min-width: 36px;\n  height: 28px;\n  padding: 0 var(--space-2);\n  border-radius: var(--radius-sm);\n  border: 1px solid var(--border-hover);\n  background: var(--glass-bg-light);\n  color: var(--text-primary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-bold);\n  cursor: pointer;\n  flex-shrink: 0;\n  transition: all var(--duration-fast) ease;\n}\n\n.voice-lang-toggle:active {\n  transform: scale(0.95);\n  background: var(--border-hover);\n}\n\n/* Voice language hint (when not recording) */\n.voice-lang-hint {\n  display: flex;\n  justify-content: center;\n  gap: var(--space-2);\n  margin-top: var(--space-2);\n}\n\n.voice-lang-btn {\n  padding: var(--space-1_5) var(--space-3);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-tertiary);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  cursor: pointer;\n  transition: all var(--duration-fast) ease;\n}\n\n.voice-lang-btn:active {\n  transform: scale(0.97);\n  background: var(--surface-secondary);\n}\n\n/* Voice mode badge (inside recording feedback) */\n.voice-mode-badge {\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  flex-shrink: 0;\n}\n\n.voice-mode-badge.whisper {\n  background: var(--state-active-bg);\n  color: var(--brand-primary);\n}\n\n/* Voice error message */\n.voice-error {\n  margin-top: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: var(--danger-bg-subtle);\n  border-radius: var(--radius-md);\n  font-size: var(--text-meta);\n  color: var(--danger-text);\n}\n\n/* TASK-1131: Offline voice queue styles */\n.mic-btn {\n  position: relative;\n}\n\n.mic-btn.offline {\n  opacity: 0.7;\n}\n\n.mic-btn.offline::after {\n  content: '';\n  position: absolute;\n  bottom: var(--space-0_5);\n  right: var(--space-0_5);\n  width: var(--space-2);\n  height: var(--space-2);\n  background: var(--warning-text);\n  border-radius: var(--radius-full);\n  border: var(--space-0_5) solid var(--surface-primary);\n}\n\n.voice-pending-badge {\n  position: absolute;\n  top: -4px;\n  right: -4px;\n  min-width: 18px;\n  height: 18px;\n  padding: 0 5px;\n  font-size: var(--text-xs);\n  font-weight: var(--font-bold);\n  color: white;\n  background: var(--primary-brand);\n  border-radius: 9px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation: pulse-badge 2s ease-in-out infinite;\n}\n\n@keyframes pulse-badge {\n  0%, 100% { transform: scale(1); }\n  50% { transform: scale(1.1); }\n}\n\n.voice-waveform.paused .wave-bar {\n  animation: none;\n  opacity: 0.5;\n}\n\n.voice-offline-badge {\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  background: var(--orange-bg-light);\n  color: var(--warning-text);\n}\n\n.voice-queue-status {\n  padding: var(--space-1) var(--space-2);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  background: var(--primary-brand-bg-subtle);\n  color: var(--primary-brand);\n}\n\n/* Debug Banner */\n.debug-banner {\n  background: var(--overlay-component-bg-lighter);\n  color: #0f0;\n  font-family: monospace;\n  font-size: var(--text-xs);\n  padding: var(--space-2) var(--space-3);\n  margin: var(--space-2) var(--space-4);\n  border-radius: var(--radius-md);\n  line-height: 1.6;\n}\n\n.debug-banner .error {\n  color: #f66;\n}\n\n.debug-toggle {\n  position: fixed;\n  top: 60px;\n  right: var(--space-2);\n  width: 28px;\n  height: 28px;\n  border-radius: var(--radius-full);\n  background: var(--overlay-component-bg-lighter);\n  border: none;\n  color: var(--text-muted);\n  font-size: var(--text-sm);\n  z-index: var(--z-dropdown);\n}\n\n/* RTL Layout Support */\n[dir=\"rtl\"] .mobile-inbox-header {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .mobile-task-item {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .task-content {\n  text-align: right;\n}\n\n[dir=\"rtl\"] .task-title-row {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .task-meta {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .filter-chips {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .controls-row {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .group-header {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .quick-add-row {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .due-date {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .dropdown-menu {\n  left: auto;\n  right: 0;\n}\n\n[dir=\"rtl\"] .debug-toggle {\n  right: auto;\n  left: 8px;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/views/MobileQuickSortView.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'onUnmounted' is defined but never used. Allowed unused vars must match /^_/u.","line":587,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":587,"endColumn":54,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"onUnmounted"},"fix":{"range":[20438,20451],"text":""},"desc":"Remove unused variable \"onUnmounted\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Edit3' is defined but never used. Allowed unused vars must match /^_/u.","line":593,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":593,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Edit3"},"fix":{"range":[20717,20724],"text":""},"desc":"Remove unused variable \"Edit3\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentTaskId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":609,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":609,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'undoLastCategorization' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":621,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":621,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'swipeProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":705,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":705,"endColumn":26}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"mobile-quick-sort\">\n    <!-- Grain Texture Overlay -->\n    <div class=\"grain-overlay\" aria-hidden=\"true\" />\n\n    <!-- Header -->\n    <header class=\"qs-header\">\n      <button class=\"back-btn\" aria-label=\"Exit Quick Sort\" @click=\"handleExit\">\n        <X :size=\"24\" />\n      </button>\n      <div class=\"header-content\">\n        <h1 class=\"qs-title\">\n          <Zap :size=\"20\" class=\"zap-icon\" />\n          <span>Quick Sort</span>\n        </h1>\n        <p class=\"qs-subtitle\">\n          {{ activePhase === 'capture' ? 'Capture' : 'Swipe to sort' }}\n        </p>\n      </div>\n      <div class=\"header-stats\">\n        <span class=\"stat-badge\">{{ progress.current }}/{{ progress.total }}</span>\n      </div>\n    </header>\n\n    <!-- Progress Bar -->\n    <div v-if=\"!isComplete && activePhase === 'sort'\" class=\"progress-track\">\n      <div\n        class=\"progress-fill\"\n        :style=\"{ width: `${progress.percentage}%` }\"\n      />\n      <div class=\"progress-glow\" :style=\"{ left: `${progress.percentage}%` }\" />\n    </div>\n\n    <!-- Phase Toggle -->\n    <div class=\"phase-toggle\">\n      <button\n        class=\"phase-btn\"\n        :class=\"{ active: activePhase === 'sort' }\"\n        @click=\"activePhase = 'sort'\"\n      >\n        <Zap :size=\"16\" />\n        Sort\n        <span v-if=\"uncategorizedCount > 0\" class=\"count-badge\">{{ uncategorizedCount }}</span>\n      </button>\n      <button\n        class=\"phase-btn\"\n        :class=\"{ active: activePhase === 'capture' }\"\n        @click=\"activePhase = 'capture'\"\n      >\n        <Plus :size=\"16\" />\n        Capture\n      </button>\n    </div>\n\n    <!-- Task Context Bar (visible only in sort phase, reactive to task changes) -->\n    <div v-if=\"activePhase === 'sort' && !isComplete && currentTask\" class=\"task-context-bar\">\n      <!-- Due Date -->\n      <div class=\"context-item\">\n        <CalendarDays :size=\"14\" />\n        <span v-if=\"taskDueDate\" :class=\"{ 'overdue-text': isTaskOverdue }\">{{ taskDueDate }}</span>\n        <span v-else class=\"context-empty\">No date</span>\n      </div>\n\n      <!-- Priority -->\n      <div class=\"context-divider\" />\n      <div class=\"context-item\">\n        <span\n          class=\"priority-indicator\"\n          :class=\"`priority-${currentTask.priority || 'none'}`\"\n        />\n        <span class=\"capitalize\">{{ currentTask.priority || 'None' }}</span>\n      </div>\n\n      <!-- Project -->\n      <div class=\"context-divider\" />\n      <div class=\"context-item\">\n        <FolderOpen :size=\"14\" />\n        <span v-if=\"currentTaskProject\" class=\"project-text\">\n          <span v-if=\"currentTaskProject.emoji\" class=\"project-emoji\">{{ currentTaskProject.emoji }}</span>\n          {{ currentTaskProject.name }}\n        </span>\n        <span v-else class=\"context-empty\">No project</span>\n      </div>\n    </div>\n\n    <!-- Main Content -->\n    <main class=\"qs-main\">\n      <!-- CAPTURE PHASE -->\n      <div v-if=\"activePhase === 'capture'\" class=\"capture-phase\">\n        <div class=\"capture-input-area\">\n          <div class=\"capture-card\">\n            <input\n              ref=\"captureInputRef\"\n              v-model=\"newTaskTitle\"\n              type=\"text\"\n              class=\"capture-input\"\n              placeholder=\"What needs to be done?\"\n              autofocus\n              @keydown.enter=\"handleQuickAdd\"\n            >\n\n            <!-- Quick Actions -->\n            <div class=\"quick-actions\">\n              <button\n                class=\"quick-action-btn\"\n                :class=\"{ active: newTaskPriority === 'high' }\"\n                @click=\"newTaskPriority = newTaskPriority === 'high' ? undefined : 'high'\"\n              >\n                <Flag :size=\"16\" class=\"priority-high\" />\n                High\n              </button>\n              <button\n                class=\"quick-action-btn\"\n                :class=\"{ active: newTaskDue === 'today' }\"\n                @click=\"newTaskDue = newTaskDue === 'today' ? undefined : 'today'\"\n              >\n                <Calendar :size=\"16\" />\n                Today\n              </button>\n              <button\n                class=\"quick-action-btn\"\n                :class=\"{ active: newTaskDue === 'tomorrow' }\"\n                @click=\"newTaskDue = newTaskDue === 'tomorrow' ? undefined : 'tomorrow'\"\n              >\n                <CalendarPlus :size=\"16\" />\n                Tomorrow\n              </button>\n            </div>\n\n            <button\n              class=\"add-task-btn\"\n              :disabled=\"!newTaskTitle.trim()\"\n              @click=\"handleQuickAdd\"\n            >\n              <Plus :size=\"20\" />\n              Add Task\n            </button>\n          </div>\n        </div>\n\n        <!-- Recently Added -->\n        <div v-if=\"recentlyAdded.length > 0\" class=\"recently-added\">\n          <h3 class=\"section-title\">\n            Just Added\n          </h3>\n          <TransitionGroup name=\"task-list\" tag=\"ul\" class=\"recent-list\">\n            <li\n              v-for=\"task in recentlyAdded\"\n              :key=\"task.id\"\n              class=\"recent-item\"\n            >\n              <CheckCircle :size=\"16\" class=\"check-icon\" />\n              <span class=\"recent-title\">{{ task.title }}</span>\n            </li>\n          </TransitionGroup>\n        </div>\n      </div>\n\n      <!-- SORT PHASE -->\n      <div v-else-if=\"!isComplete\" class=\"sort-phase\">\n        <!-- Process Flow Indicator - Shows clear hierarchy -->\n        <div class=\"process-flow-indicator\">\n          <div class=\"flow-step active\">\n            <span class=\"flow-icon\">👀</span>\n            <span class=\"flow-label\">Review</span>\n          </div>\n          <div class=\"flow-arrow\">\n            →\n          </div>\n          <div class=\"flow-step\">\n            <span class=\"flow-icon\">✏️</span>\n            <span class=\"flow-label\">Edit</span>\n          </div>\n          <div class=\"flow-arrow\">\n            →\n          </div>\n          <div class=\"flow-step\">\n            <span class=\"flow-icon\">💾</span>\n            <span class=\"flow-label\">Save</span>\n          </div>\n        </div>\n\n        <!-- Swipe Instructions - Clear hierarchy explanation -->\n        <div v-if=\"!hasSwipedOnce\" class=\"swipe-hints\">\n          <div class=\"hint hint-left\">\n            <ChevronLeft :size=\"24\" />\n            <span>Skip</span>\n          </div>\n          <div class=\"hint hint-right\">\n            <span>Exit</span>\n            <ChevronRight :size=\"24\" />\n          </div>\n        </div>\n\n        <!-- Card Stack -->\n        <div class=\"card-stack\">\n          <!-- Background cards (depth effect) -->\n          <div\n            v-for=\"(task, idx) in stackPreview\"\n            :key=\"task.id\"\n            class=\"stack-card\"\n            :style=\"{\n              transform: `scale(${1 - idx * 0.05}) translateY(${idx * 8}px)`,\n              opacity: 1 - idx * 0.3,\n              zIndex: 10 - idx\n            }\"\n          />\n\n          <!-- Active Card -->\n          <div\n            ref=\"cardRef\"\n            class=\"task-card\"\n            :class=\"{\n              'swiping': swipeState.isSwiping,\n              'swipe-left': swipeDirection === 'left',\n              'swipe-right': swipeDirection === 'right'\n            }\"\n            :style=\"cardStyle\"\n          >\n            <!-- Swipe Indicators - Clear action feedback -->\n            <div\n              class=\"swipe-indicator left\"\n              :style=\"{ opacity: leftOverlayOpacity }\"\n            >\n              <div class=\"swipe-content\">\n                <SkipForward :size=\"32\" />\n                <span>Skip</span>\n              </div>\n            </div>\n            <div\n              class=\"swipe-indicator right\"\n              :style=\"{ opacity: rightOverlayOpacity }\"\n            >\n              <div class=\"swipe-content\">\n                <X :size=\"32\" />\n                <span>Exit</span>\n              </div>\n            </div>\n\n            <!-- Card Content with blur when swiping -->\n            <div v-if=\"currentTask\" class=\"card-content\" :style=\"contentBlurStyle\">\n              <!-- Priority Indicator -->\n              <div\n                class=\"priority-strip\"\n                :class=\"`priority-${currentTask.priority || 'none'}`\"\n              />\n\n              <h2 class=\"task-title\" dir=\"auto\">\n                {{ currentTask.title }}\n              </h2>\n\n              <p v-if=\"currentTask.description\" class=\"task-description\">\n                {{ truncateDescription(currentTask.description) }}\n              </p>\n\n              <!-- Metadata -->\n              <div class=\"task-meta\">\n                <div v-if=\"currentTask.dueDate\" class=\"meta-item\">\n                  <Calendar :size=\"14\" />\n                  <span>{{ formatDueDate(currentTask.dueDate) }}</span>\n                </div>\n                <div v-if=\"currentTask.priority\" class=\"meta-item\" :class=\"`priority-${currentTask.priority}`\">\n                  <Flag :size=\"14\" />\n                  <span class=\"capitalize\">{{ currentTask.priority }}</span>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <!-- Quick Edit Actions (Thumb Zone) -->\n        <div class=\"thumb-zone\">\n          <!-- Priority Quick Edit -->\n          <div class=\"quick-edit-row\">\n            <span class=\"edit-label\">Priority</span>\n            <div class=\"priority-pills\">\n              <button\n                class=\"pill\"\n                :class=\"{ active: currentTask?.priority === 'low' }\"\n                @click=\"setPriority('low')\"\n              >\n                Low\n              </button>\n              <button\n                class=\"pill\"\n                :class=\"{ active: currentTask?.priority === 'medium' }\"\n                @click=\"setPriority('medium')\"\n              >\n                Med\n              </button>\n              <button\n                class=\"pill\"\n                :class=\"{ active: currentTask?.priority === 'high' }\"\n                @click=\"setPriority('high')\"\n              >\n                High\n              </button>\n            </div>\n          </div>\n\n          <!-- Date Quick Edit - Scrollable -->\n          <div class=\"quick-edit-row date-row\">\n            <span class=\"edit-label\">Due</span>\n            <div class=\"date-pills-scroll\">\n              <button\n                class=\"pill\"\n                :class=\"{ active: isToday }\"\n                @click=\"setDueDate('today')\"\n              >\n                ☀️ Today\n              </button>\n              <button\n                class=\"pill\"\n                :class=\"{ active: isTomorrow }\"\n                @click=\"setDueDate('tomorrow')\"\n              >\n                🌅 Tmrw\n              </button>\n              <button\n                class=\"pill\"\n                @click=\"setDueDate('in3days')\"\n              >\n                📅 +3d\n              </button>\n              <button\n                class=\"pill\"\n                :class=\"{ active: isWeekend }\"\n                @click=\"setDueDate('weekend')\"\n              >\n                🏖️ Wknd\n              </button>\n              <button\n                class=\"pill\"\n                @click=\"setDueDate('nextweek')\"\n              >\n                📆 +1wk\n              </button>\n              <button\n                class=\"pill\"\n                @click=\"setDueDate('1month')\"\n              >\n                🗓️ +1mo\n              </button>\n              <button\n                class=\"pill clear\"\n                @click=\"setDueDate('clear')\"\n              >\n                <X :size=\"14\" />\n              </button>\n            </div>\n          </div>\n\n          <!-- Action Buttons - Four options: Done, Save, Assign, Delete -->\n          <div class=\"action-row\">\n            <button class=\"action-btn done\" @click=\"handleMarkDone\">\n              <CheckCircle :size=\"20\" />\n              <span>Done</span>\n            </button>\n            <button class=\"action-btn save\" @click=\"handleSave\">\n              <Save :size=\"20\" />\n              <span>Save</span>\n              <span v-if=\"isTaskDirty\" class=\"dirty-dot\" />\n            </button>\n            <button class=\"action-btn assign\" @click=\"showProjectSheet = true\">\n              <FolderOpen :size=\"20\" />\n              <span>Assign</span>\n            </button>\n            <button class=\"action-btn delete\" @click=\"showDeleteConfirm = true\">\n              <Trash2 :size=\"20\" />\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <!-- COMPLETION CELEBRATION -->\n      <div v-else class=\"completion-phase\">\n        <div class=\"celebration-container\">\n          <div ref=\"confettiRef\" class=\"confetti-burst\" />\n\n          <div class=\"celebration-icon\">\n            <PartyPopper :size=\"80\" />\n          </div>\n\n          <h2 class=\"celebration-title\">\n            All Sorted!\n          </h2>\n          <p class=\"celebration-subtitle\">\n            You've processed all your tasks\n          </p>\n\n          <div v-if=\"sessionSummary\" class=\"session-summary\">\n            <div class=\"summary-stat\">\n              <span class=\"stat-number\">{{ sessionSummary.tasksProcessed }}</span>\n              <span class=\"stat-label\">Tasks</span>\n            </div>\n            <div class=\"summary-stat\">\n              <span class=\"stat-number\">{{ formatDuration(sessionSummary.timeSpent) }}</span>\n              <span class=\"stat-label\">Time</span>\n            </div>\n            <div v-if=\"sessionSummary.efficiency > 0\" class=\"summary-stat\">\n              <span class=\"stat-number\">{{ sessionSummary.efficiency.toFixed(1) }}</span>\n              <span class=\"stat-label\">Tasks/min</span>\n            </div>\n          </div>\n\n          <button class=\"return-btn\" @click=\"handleExit\">\n            <ArrowLeft :size=\"20\" />\n            Return to Tasks\n          </button>\n        </div>\n      </div>\n    </main>\n\n    <!-- Project Selector Bottom Sheet -->\n    <Teleport to=\"body\">\n      <Transition name=\"sheet\">\n        <div v-if=\"showProjectSheet\" class=\"sheet-overlay\" @click=\"showProjectSheet = false; projectSearch = ''\">\n          <div class=\"project-sheet\" @click.stop>\n            <div class=\"sheet-handle\" />\n            <h3 class=\"sheet-title\">\n              Where does this belong?\n            </h3>\n\n            <!-- Search Input (sticky) -->\n            <div class=\"project-search-wrapper\">\n              <Search :size=\"16\" class=\"search-icon\" />\n              <input\n                v-model=\"projectSearch\"\n                type=\"text\"\n                class=\"project-search\"\n                placeholder=\"Search projects...\"\n              >\n            </div>\n\n            <div class=\"project-list\">\n              <!-- Keep in Inbox option - allows sorting without project assignment -->\n              <button\n                v-if=\"!projectSearch\"\n                class=\"project-option inbox-option\"\n                @click=\"handleSortWithoutProject\"\n              >\n                <span class=\"project-indicator inbox-indicator\">\n                  📥\n                </span>\n                <span class=\"project-name\">Keep in Inbox</span>\n                <span class=\"option-hint\">Sort without assigning</span>\n              </button>\n\n              <!-- Recent Projects (if no search and has recents) -->\n              <div v-if=\"!projectSearch && recentProjects.length > 0\" class=\"recent-projects-section\">\n                <span class=\"section-label\">Recent</span>\n                <div class=\"recent-projects-grid\">\n                  <button\n                    v-for=\"project in recentProjects\"\n                    :key=\"project.id\"\n                    class=\"recent-project-chip\"\n                    @click=\"handleAssignProject(project.id)\"\n                  >\n                    <span class=\"chip-emoji\">{{ project.emoji || project.name.charAt(0) }}</span>\n                    <span class=\"chip-name\">{{ project.name }}</span>\n                  </button>\n                </div>\n              </div>\n\n              <div v-if=\"!projectSearch\" class=\"project-divider\">\n                <span>{{ recentProjects.length > 0 ? 'All projects' : 'Or assign to project' }}</span>\n              </div>\n\n              <!-- Filtered/All Projects List -->\n              <button\n                v-for=\"{ project, depth } in filteredProjects\"\n                :key=\"project.id\"\n                class=\"project-option\"\n                :style=\"{ paddingLeft: `${16 + Math.min(depth, 2) * 24}px` }\"\n                @click=\"handleAssignProject(project.id)\"\n              >\n                <span v-if=\"depth > 0\" class=\"hierarchy-line\" :style=\"{ width: `${Math.min(depth, 2) * 24}px` }\">\n                  <span class=\"hierarchy-connector\" />\n                </span>\n                <span\n                  class=\"project-indicator\"\n                  :style=\"{ backgroundColor: Array.isArray(project.color) ? project.color[0] : project.color }\"\n                >\n                  {{ project.emoji || project.name.charAt(0) }}\n                </span>\n                <span class=\"project-name\">{{ project.name }}</span>\n                <span v-if=\"depth > 2\" class=\"depth-indicator\">+{{ depth - 2 }}</span>\n              </button>\n\n              <!-- No results message -->\n              <div v-if=\"projectSearch && filteredProjects.length === 0\" class=\"no-results\">\n                No projects match \"{{ projectSearch }}\"\n              </div>\n            </div>\n          </div>\n        </div>\n      </Transition>\n    </Teleport>\n\n    <!-- Delete Confirmation Modal -->\n    <Teleport to=\"body\">\n      <Transition name=\"modal\">\n        <div v-if=\"showDeleteConfirm\" class=\"confirm-overlay\">\n          <div class=\"confirm-modal\">\n            <Trash2 :size=\"32\" class=\"confirm-icon\" />\n            <h3>Delete this task?</h3>\n            <p>This action cannot be undone</p>\n            <div class=\"confirm-actions\">\n              <button class=\"cancel-btn\" @click=\"cancelDelete\">\n                Cancel\n              </button>\n              <button class=\"delete-btn\" @click=\"confirmDelete\">\n                Delete\n              </button>\n            </div>\n          </div>\n        </div>\n      </Transition>\n    </Teleport>\n\n    <!-- Quick Edit Panel -->\n    <Teleport to=\"body\">\n      <Transition name=\"sheet\">\n        <div v-if=\"showQuickEditPanel\" class=\"sheet-overlay\" @click=\"showQuickEditPanel = false\">\n          <div class=\"quick-edit-sheet\" @click.stop>\n            <div class=\"sheet-handle\" />\n            <h3 class=\"sheet-title\">\n              Quick Edit\n            </h3>\n\n            <!-- Priority Section -->\n            <div class=\"edit-section\">\n              <span class=\"edit-label\">Priority</span>\n              <div class=\"priority-pills\">\n                <button class=\"pill\" :class=\"{ active: currentTask?.priority === 'low' }\" @click=\"setPriorityAndClose('low')\">\n                  Low\n                </button>\n                <button class=\"pill\" :class=\"{ active: currentTask?.priority === 'medium' }\" @click=\"setPriorityAndClose('medium')\">\n                  Med\n                </button>\n                <button class=\"pill\" :class=\"{ active: currentTask?.priority === 'high' }\" @click=\"setPriorityAndClose('high')\">\n                  High\n                </button>\n              </div>\n            </div>\n\n            <!-- Date Section -->\n            <div class=\"edit-section\">\n              <span class=\"edit-label\">Due Date</span>\n              <div class=\"date-pills\">\n                <button class=\"pill\" @click=\"setDueDateAndClose('today')\">\n                  Today\n                </button>\n                <button class=\"pill\" @click=\"setDueDateAndClose('tomorrow')\">\n                  Tmrw\n                </button>\n                <button class=\"pill\" @click=\"setDueDateAndClose('in3days')\">\n                  +3d\n                </button>\n                <button class=\"pill\" @click=\"setDueDateAndClose('weekend')\">\n                  Wknd\n                </button>\n              </div>\n            </div>\n\n            <!-- Assign to Project button -->\n            <button class=\"assign-project-btn\" @click=\"openProjectSheet\">\n              <FolderOpen :size=\"20\" />\n              Assign to Project\n            </button>\n          </div>\n        </div>\n      </Transition>\n    </Teleport>\n\n    <!-- Celebration Overlay -->\n    <Transition name=\"celebration\">\n      <div v-if=\"showCelebration\" class=\"mini-celebration\">\n        <CheckCircle :size=\"32\" />\n        <span>Sorted!</span>\n      </div>\n    </Transition>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, onMounted, onUnmounted, nextTick } from 'vue'\nimport { useRouter } from 'vue-router'\nimport { useLocalStorage } from '@vueuse/core'\nimport {\n  Zap, X, Plus, CheckCircle, Calendar, CalendarPlus, CalendarDays, Flag,\n  ChevronLeft, ChevronRight, SkipForward, PartyPopper,\n  ArrowLeft, Trash2, Edit3, FolderOpen, Search, Save\n} from 'lucide-vue-next'\nimport { useQuickSort } from '@/composables/useQuickSort'\nimport { useSwipeGestures } from '@/composables/useSwipeGestures'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useProjectStore } from '@/stores/projects'\nimport type { Task } from '@/types/tasks'\nimport type { SessionSummary } from '@/stores/quickSort'\n\nconst router = useRouter()\nconst taskStore = useTaskStore()\nconst projectStore = useProjectStore()\n\n// Quick Sort composable\nconst {\n  currentTask,\n  currentTaskId,\n  uncategorizedTasks,\n  progress,\n  isComplete,\n  isTaskDirty,\n  startSession,\n  endSession,\n  categorizeTask,\n  saveTask,\n  markTaskDone,\n  markDoneAndDeleteTask,\n  skipTask,\n  undoLastCategorization\n} = useQuickSort()\n\n// UI State\nconst activePhase = ref<'sort' | 'capture'>('sort')\nconst showProjectSheet = ref(false)\nconst showCelebration = ref(false)\nconst hasSwipedOnce = ref(false)\nconst sessionSummary = ref<SessionSummary | null>(null)\nconst showDeleteConfirm = ref(false)\nconst showQuickEditPanel = ref(false)\n\n// Capture phase state\nconst newTaskTitle = ref('')\nconst newTaskPriority = ref<'low' | 'medium' | 'high' | undefined>()\nconst newTaskDue = ref<'today' | 'tomorrow' | undefined>()\nconst recentlyAdded = ref<Task[]>([])\nconst captureInputRef = ref<HTMLInputElement | null>(null)\n\n// Project picker state\nconst projectSearch = ref('')\nconst recentProjectIds = useLocalStorage<string[]>('quicksort-recent-projects', [])\n\n// Card and swipe refs\nconst cardRef = ref<HTMLElement | null>(null)\nconst confettiRef = ref<HTMLElement | null>(null)\n\n// Projects - hierarchical structure for nested display\nconst rootProjects = computed(() => projectStore.rootProjects)\n\n// Build flat list with hierarchy info for display\ninterface ProjectWithDepth {\n  project: typeof projectStore.projects[number]\n  depth: number\n}\n\nconst projectsWithDepth = computed(() => {\n  const result: ProjectWithDepth[] = []\n\n  const addProjectWithChildren = (project: typeof projectStore.projects[number], depth: number) => {\n    result.push({ project, depth })\n    const children = projectStore.getChildProjects(project.id)\n    for (const child of children) {\n      addProjectWithChildren(child, depth + 1)\n    }\n  }\n\n  // Start from root projects\n  for (const rootProject of rootProjects.value) {\n    addProjectWithChildren(rootProject, 0)\n  }\n\n  return result\n})\n\n// Recent projects (last 4 used)\nconst recentProjects = computed(() =>\n  recentProjectIds.value\n    .slice(0, 4)\n    .map(id => projectStore.projects.find(p => p.id === id))\n    .filter((p): p is typeof projectStore.projects[number] => Boolean(p))\n)\n\n// Filtered projects for search\nconst filteredProjects = computed(() => {\n  if (!projectSearch.value.trim()) return projectsWithDepth.value\n  const search = projectSearch.value.toLowerCase()\n  return projectsWithDepth.value.filter(({ project }) =>\n    project.name.toLowerCase().includes(search)\n  )\n})\n\n// Uncategorized count\nconst uncategorizedCount = computed(() => uncategorizedTasks.value.length)\n\n// Stack preview (next 2 tasks)\nconst stackPreview = computed(() => {\n  return uncategorizedTasks.value.slice(1, 3)\n})\n\n// Swipe gesture handling\nconst {\n  swipeState,\n  deltaX,\n  progress: swipeProgress,\n  direction: swipeDirection,\n  triggerHaptic\n} = useSwipeGestures(cardRef, {\n  threshold: 120,\n  velocityThreshold: 0.4,\n  haptics: true,\n  onSwipeRight: () => {\n    hasSwipedOnce.value = true\n    // Swipe right = Exit Quick Sort\n    handleExit()\n  },\n  onSwipeLeft: () => {\n    hasSwipedOnce.value = true\n    // Swipe left = Skip to next task\n    handleSkip()\n  },\n  onSwipeEnd: () => {\n    // Reset card position handled by transition\n  }\n})\n\n// Card transform style\nconst cardStyle = computed(() => {\n  if (!swipeState.value.isSwiping) {\n    return {\n      transform: 'translateX(0) rotate(0deg)',\n      transition: 'transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)'\n    }\n  }\n\n  const rotate = deltaX.value * 0.05\n  const maxRotate = 15\n  const clampedRotate = Math.max(-maxRotate, Math.min(maxRotate, rotate))\n\n  return {\n    transform: `translateX(${deltaX.value}px) rotate(${clampedRotate}deg)`,\n    transition: 'none'\n  }\n})\n\n// Overlay opacities\nconst leftOverlayOpacity = computed(() => {\n  if (deltaX.value >= 0) return 0\n  return Math.min(Math.abs(deltaX.value) / 120, 1) * 0.9\n})\n\nconst rightOverlayOpacity = computed(() => {\n  if (deltaX.value <= 0) return 0\n  return Math.min(deltaX.value / 120, 1) * 0.9\n})\n\n// Content blur effect when swiping\nconst contentBlurStyle = computed(() => {\n  const progress = Math.min(Math.abs(deltaX.value) / 100, 1)\n  if (progress < 0.1) {\n    return { filter: 'none', opacity: 1 }\n  }\n  const blurAmount = progress * 6 // Max 6px blur\n  const dimAmount = 1 - (progress * 0.4) // Dim to 60%\n  return {\n    filter: `blur(${blurAmount}px)`,\n    opacity: dimAmount,\n    transition: swipeState.value.isSwiping ? 'none' : 'filter 0.2s ease, opacity 0.2s ease'\n  }\n})\n\n// Date detection\nconst isToday = computed(() => {\n  if (!currentTask.value?.dueDate) return false\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  const taskDate = new Date(currentTask.value.dueDate)\n  taskDate.setHours(0, 0, 0, 0)\n  return taskDate.getTime() === today.getTime()\n})\n\nconst isTomorrow = computed(() => {\n  if (!currentTask.value?.dueDate) return false\n  const tomorrow = new Date()\n  tomorrow.setDate(tomorrow.getDate() + 1)\n  tomorrow.setHours(0, 0, 0, 0)\n  const taskDate = new Date(currentTask.value.dueDate)\n  taskDate.setHours(0, 0, 0, 0)\n  return taskDate.getTime() === tomorrow.getTime()\n})\n\nconst isWeekend = computed(() => {\n  if (!currentTask.value?.dueDate) return false\n  // Don't highlight Weekend if Today or Tomorrow is already active\n  if (isToday.value || isTomorrow.value) return false\n  const taskDate = new Date(currentTask.value.dueDate)\n  const dayOfWeek = taskDate.getDay()\n  return dayOfWeek === 0 || dayOfWeek === 6\n})\n\n// Actions\nasync function handleQuickAdd() {\n  if (!newTaskTitle.value.trim()) return\n\n  let dueDate: string | undefined\n  if (newTaskDue.value === 'today') {\n    dueDate = new Date().toISOString()\n  } else if (newTaskDue.value === 'tomorrow') {\n    const tomorrow = new Date()\n    tomorrow.setDate(tomorrow.getDate() + 1)\n    dueDate = tomorrow.toISOString()\n  }\n\n  const newTask = await taskStore.createTask({\n    title: newTaskTitle.value.trim(),\n    priority: newTaskPriority.value,\n    dueDate\n  })\n\n  // Add to recently added\n  recentlyAdded.value.unshift(newTask)\n  if (recentlyAdded.value.length > 5) {\n    recentlyAdded.value.pop()\n  }\n\n  // Reset form\n  newTaskTitle.value = ''\n  newTaskPriority.value = undefined\n  newTaskDue.value = undefined\n\n  // Haptic feedback\n  triggerHaptic('medium')\n\n  // Refocus input\n  nextTick(() => {\n    captureInputRef.value?.focus()\n  })\n}\n\nfunction handleAssignProject(projectId: string) {\n  if (!currentTask.value) return\n\n  // Track as recent project (dedupe, limit 10)\n  recentProjectIds.value = [\n    projectId,\n    ...recentProjectIds.value.filter(id => id !== projectId)\n  ].slice(0, 10)\n\n  categorizeTask(currentTask.value.id, projectId)\n  showProjectSheet.value = false\n  projectSearch.value = '' // Reset search\n\n  // NO celebration, NO auto-advance - task stays for further edits\n  triggerHaptic('medium')\n}\n\n// Sort task without assigning to a project (keep in inbox)\nfunction handleSortWithoutProject() {\n  if (!currentTask.value) return\n  categorizeTask(currentTask.value.id, '')\n  showProjectSheet.value = false\n  projectSearch.value = '' // Reset search\n  // NO celebration, NO auto-advance - task stays for further edits\n  triggerHaptic('medium')\n}\n\nfunction handleSkip() {\n  skipTask()\n  triggerHaptic('light')\n}\n\nfunction handleSave() {\n  if (!currentTask.value) return\n  saveTask()\n\n  showCelebration.value = true\n  setTimeout(() => {\n    showCelebration.value = false\n  }, 600)\n\n  triggerHaptic('heavy')\n}\n\nfunction handleMarkDone() {\n  if (!currentTask.value) return\n  markTaskDone(currentTask.value.id)\n\n  showCelebration.value = true\n  setTimeout(() => {\n    showCelebration.value = false\n  }, 600)\n\n  triggerHaptic('heavy')\n}\n\nasync function setPriority(priority: 'low' | 'medium' | 'high') {\n  if (!currentTask.value) return\n  // AWAIT to ensure persistence before UI updates (BUG-1051)\n  await taskStore.updateTask(currentTask.value.id, { priority })\n  triggerHaptic('light')\n}\n\nasync function setDueDate(preset: 'today' | 'tomorrow' | 'in3days' | 'weekend' | 'nextweek' | '1month' | 'clear') {\n  if (!currentTask.value) return\n\n  let dueDate: string | undefined\n  const now = new Date()\n\n  if (preset === 'today') {\n    const today = new Date(now)\n    today.setHours(0, 0, 0, 0)\n    dueDate = today.toISOString()\n  } else if (preset === 'tomorrow') {\n    const tomorrow = new Date(now)\n    tomorrow.setDate(tomorrow.getDate() + 1)\n    tomorrow.setHours(0, 0, 0, 0)\n    dueDate = tomorrow.toISOString()\n  } else if (preset === 'in3days') {\n    const date = new Date(now)\n    date.setDate(date.getDate() + 3)\n    date.setHours(0, 0, 0, 0)\n    dueDate = date.toISOString()\n  } else if (preset === 'weekend') {\n    const dayOfWeek = now.getDay()\n    const daysUntilSaturday = dayOfWeek === 6 ? 7 : (6 - dayOfWeek + 7) % 7\n    const saturday = new Date(now)\n    saturday.setDate(now.getDate() + (daysUntilSaturday || 7))\n    saturday.setHours(0, 0, 0, 0)\n    dueDate = saturday.toISOString()\n  } else if (preset === 'nextweek') {\n    const date = new Date(now)\n    date.setDate(date.getDate() + 7)\n    date.setHours(0, 0, 0, 0)\n    dueDate = date.toISOString()\n  } else if (preset === '1month') {\n    const date = new Date(now)\n    date.setMonth(date.getMonth() + 1)\n    date.setHours(0, 0, 0, 0)\n    dueDate = date.toISOString()\n  } else {\n    dueDate = undefined\n  }\n\n  // AWAIT to ensure persistence before UI updates (BUG-1051)\n  await taskStore.updateTask(currentTask.value.id, { dueDate: dueDate || '' })\n  triggerHaptic('light')\n}\n\nfunction handleExit() {\n  router.push('/tasks')\n}\n\nfunction cancelDelete() {\n  showDeleteConfirm.value = false\n}\n\nasync function confirmDelete() {\n  if (!currentTask.value) return\n  // Use QuickSort's delete function which properly handles the flow (advances to next task, records action)\n  // Must await so the task is removed before closing the dialog\n  await markDoneAndDeleteTask(currentTask.value.id)\n  showDeleteConfirm.value = false\n  triggerHaptic('heavy')\n}\n\nfunction setPriorityAndClose(priority: 'low' | 'medium' | 'high') {\n  setPriority(priority)\n  showQuickEditPanel.value = false\n}\n\nfunction setDueDateAndClose(preset: 'today' | 'tomorrow' | 'in3days' | 'weekend' | 'nextweek' | '1month' | 'clear') {\n  setDueDate(preset)\n  showQuickEditPanel.value = false\n}\n\nfunction openProjectSheet() {\n  showQuickEditPanel.value = false\n  showProjectSheet.value = true\n}\n\nfunction truncateDescription(desc: string): string {\n  if (desc.length <= 120) return desc\n  return desc.slice(0, 120) + '...'\n}\n\nfunction formatDueDate(date: string): string {\n  const d = new Date(date)\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  const tomorrow = new Date(today)\n  tomorrow.setDate(tomorrow.getDate() + 1)\n\n  d.setHours(0, 0, 0, 0)\n\n  if (d.getTime() === today.getTime()) return 'Today'\n  if (d.getTime() === tomorrow.getTime()) return 'Tomorrow'\n\n  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })\n}\n\nfunction formatDuration(ms: number): string {\n  const seconds = Math.floor(ms / 1000)\n  const minutes = Math.floor(seconds / 60)\n  const remainingSeconds = seconds % 60\n\n  if (minutes === 0) return `${remainingSeconds}s`\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`\n}\n\n// Task context computed properties (reactive to task changes)\nconst taskDueDate = computed(() => {\n  if (!currentTask.value?.dueDate) return null\n  const d = new Date(currentTask.value.dueDate)\n  if (isNaN(d.getTime())) return null\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  const taskDate = new Date(d)\n  taskDate.setHours(0, 0, 0, 0)\n  const diffDays = Math.round((taskDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24))\n  if (diffDays === 0) return 'Today'\n  if (diffDays === 1) return 'Tomorrow'\n  if (diffDays === -1) return 'Yesterday'\n  if (diffDays > 1 && diffDays <= 7) return `In ${diffDays} days`\n  if (diffDays < -1) return `${Math.abs(diffDays)} days ago`\n  return d.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' })\n})\n\nconst isTaskOverdue = computed(() => {\n  if (!currentTask.value?.dueDate) return false\n  const d = new Date(currentTask.value.dueDate)\n  if (isNaN(d.getTime())) return false\n  const today = new Date()\n  today.setHours(0, 0, 0, 0)\n  d.setHours(0, 0, 0, 0)\n  return d.getTime() < today.getTime()\n})\n\nconst currentTaskProject = computed(() => {\n  if (!currentTask.value?.projectId) return null\n  return projectStore.projects.find(p => p.id === currentTask.value!.projectId)\n})\n\n// Watch for completion\nwatch(isComplete, (completed) => {\n  if (completed) {\n    const summary = endSession()\n    sessionSummary.value = summary || null\n  }\n})\n\n// Lifecycle\nonMounted(() => {\n  startSession()\n})\n</script>\n\n<style scoped>\n/* ================================\n   MOBILE QUICK SORT - \"DECISIVE FLOW\"\n   Neo-brutalist meets fluid glass\n   ================================ */\n\n.mobile-quick-sort {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 100vh;\n  height: 100dvh; /* Dynamic viewport height - accounts for iOS browser chrome */\n  display: flex;\n  flex-direction: column;\n  background: var(--app-background-gradient);\n  color: var(--text-primary);\n  overflow: hidden;\n  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;\n}\n\n/* Grain texture overlay */\n.grain-overlay {\n  position: absolute;\n  inset: 0;\n  background-image: url(\"data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E\");\n  opacity: 0.03;\n  pointer-events: none;\n  z-index: var(--z-base);\n}\n\n/* ================================\n   HEADER\n   ================================ */\n\n.qs-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-4) var(--space-5);\n  padding-top: calc(var(--space-4) + env(safe-area-inset-top));\n  background: var(--glass-bg);\n  backdrop-filter: blur(var(--blur-lg));\n  -webkit-backdrop-filter: blur(var(--blur-lg));\n  border-bottom: 1px solid var(--glass-border-light);\n  z-index: var(--z-sticky);\n}\n\n.back-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: var(--dropdown-trigger-height);\n  height: var(--dropdown-trigger-height);\n  background: var(--glass-bg-weak);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.back-btn:active {\n  transform: scale(0.95);\n  background: var(--glass-bg-light);\n}\n\n.header-content {\n  flex: 1;\n}\n\n.qs-title {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  font-size: var(--text-xl);\n  font-weight: var(--font-bold);\n  margin: 0;\n  letter-spacing: -0.02em;\n}\n\n.zap-icon {\n  color: var(--brand-primary);\n}\n\n.qs-subtitle {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: var(--space-1) 0 0;\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n}\n\n.header-stats {\n  display: flex;\n  align-items: center;\n}\n\n.stat-badge {\n  padding: var(--space-1_5) var(--space-3);\n  background: var(--glass-bg-light);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-full);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  font-variant-numeric: tabular-nums;\n}\n\n/* ================================\n   PROGRESS BAR\n   ================================ */\n\n.progress-track {\n  position: relative;\n  height: 3px;\n  background: var(--glass-bg-weak);\n  z-index: var(--z-sticky);\n}\n\n.progress-fill {\n  height: 100%;\n  background: linear-gradient(90deg, var(--brand-primary), hsl(174, 80%, 60%));\n  transition: width 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);\n}\n\n.progress-glow {\n  position: absolute;\n  top: 50%;\n  width: var(--space-5);\n  height: var(--space-5);\n  background: var(--brand-primary);\n  border-radius: var(--radius-full);\n  filter: blur(var(--blur-sm));\n  transform: translate(-50%, -50%);\n  transition: left 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);\n}\n\n/* ================================\n   PHASE TOGGLE\n   ================================ */\n\n.phase-toggle {\n  display: flex;\n  gap: var(--space-2);\n  padding: var(--space-3) var(--space-5);\n  z-index: var(--z-sticky);\n}\n\n.phase-btn {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-2_5) var(--space-4);\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-lg);\n  color: var(--text-muted);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.phase-btn.active {\n  background: transparent;\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.phase-btn:active {\n  transform: scale(0.98);\n}\n\n.count-badge {\n  padding: var(--space-0_5) var(--space-2);\n  background: var(--glass-border-hover);\n  color: var(--text-primary);\n  border-radius: var(--radius-full);\n  font-size: var(--text-xs);\n  font-weight: var(--font-bold);\n  min-width: 1.5rem;\n  text-align: center;\n}\n\n/* When Sort tab is active, make badge more prominent */\n.phase-btn.active .count-badge {\n  background: var(--overlay-component-bg-lighter);\n  color: var(--brand-primary);\n  border: 1px solid var(--brand-primary);\n}\n\n/* ================================\n   TASK CONTEXT BAR (REACTIVE)\n   ================================ */\n\n.task-context-bar {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--space-1_5);\n  padding: var(--space-2_5) var(--space-4);\n  margin: 0 var(--space-5);\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-lg);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  z-index: var(--z-sticky);\n  backdrop-filter: blur(8px);\n  -webkit-backdrop-filter: blur(8px);\n}\n\n.context-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  color: var(--text-secondary);\n  flex: 1;\n  min-width: 0;\n  justify-content: center;\n}\n\n.context-item:first-child {\n  justify-content: flex-start;\n}\n\n.context-item:last-child {\n  justify-content: flex-end;\n}\n\n.context-divider {\n  width: 1px;\n  height: var(--space-3);\n  background: var(--border-subtle);\n  opacity: 0.5;\n}\n\n.context-empty {\n  color: var(--text-muted);\n  opacity: 0.6;\n}\n\n.overdue-text {\n  color: var(--color-priority-high);\n  font-weight: var(--font-semibold);\n}\n\n.priority-indicator {\n  width: var(--space-2);\n  height: var(--space-2);\n  border-radius: var(--radius-full);\n  flex-shrink: 0;\n}\n\n.priority-indicator.priority-high {\n  background: var(--color-priority-high);\n}\n\n.priority-indicator.priority-medium {\n  background: var(--color-priority-medium);\n}\n\n.priority-indicator.priority-low {\n  background: var(--color-priority-low);\n}\n\n.priority-indicator.priority-none {\n  background: var(--text-muted);\n  opacity: 0.3;\n}\n\n.project-text {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.project-emoji {\n  font-size: var(--text-sm);\n  line-height: 1;\n}\n\n/* ================================\n   MAIN CONTENT\n   ================================ */\n\n.qs-main {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  z-index: var(--z-base);\n}\n\n/* ================================\n   CAPTURE PHASE\n   ================================ */\n\n.capture-phase {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding: var(--space-5);\n  overflow-y: auto;\n}\n\n.capture-input-area {\n  margin-bottom: var(--space-6);\n}\n\n.capture-card {\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-2xl);\n  padding: var(--space-5);\n}\n\n.capture-input {\n  width: 100%;\n  padding: var(--space-4);\n  background: var(--overlay-component-bg-lighter);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text-primary);\n  font-size: var(--text-lg);\n  font-weight: var(--font-medium);\n  outline: none;\n  transition: all var(--duration-normal) ease;\n}\n\n.capture-input::placeholder {\n  color: var(--text-muted);\n}\n\n.capture-input:focus {\n  border-color: var(--state-hover-border);\n  box-shadow: 0 0 0 3px var(--state-hover-bg);\n}\n\n.quick-actions {\n  display: flex;\n  gap: var(--space-2);\n  margin-top: var(--space-4);\n  flex-wrap: wrap;\n}\n\n.quick-action-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-full);\n  color: var(--text-secondary);\n  font-size: var(--text-meta);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.quick-action-btn.active {\n  background: transparent;\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.quick-action-btn:active {\n  transform: scale(0.95);\n}\n\n.priority-high {\n  color: var(--color-priority-high);\n}\n\n.add-task-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  width: 100%;\n  margin-top: var(--space-4);\n  padding: var(--space-4);\n  background: transparent;\n  border: 1px solid var(--brand-primary);\n  border-radius: var(--radius-lg);\n  color: var(--brand-primary);\n  font-size: var(--text-base);\n  font-weight: 700;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n\n.add-task-btn:disabled {\n  opacity: 0.4;\n  cursor: not-allowed;\n}\n\n.add-task-btn:not(:disabled):active {\n  transform: scale(0.98);\n}\n\n/* Recently Added */\n.recently-added {\n  flex: 1;\n}\n\n.section-title {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n  margin-bottom: var(--space-3);\n}\n\n.recent-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.recent-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3) var(--space-4);\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--glass-bg-weak);\n  border-radius: var(--radius-lg);\n  margin-bottom: var(--space-2);\n}\n\n.check-icon {\n  color: var(--color-success);\n}\n\n.recent-title {\n  flex: 1;\n  font-size: var(--text-base);\n  color: var(--text-secondary);\n}\n\n/* Task list transitions */\n.task-list-enter-active {\n  transition: all var(--duration-slow) ease;\n}\n\n.task-list-leave-active {\n  transition: all var(--duration-normal) ease;\n}\n\n.task-list-enter-from {\n  opacity: 0;\n  transform: translateY(calc(-1 * var(--space-2_5)));\n}\n\n.task-list-leave-to {\n  opacity: 0;\n  transform: translateX(calc(-1 * var(--space-5)));\n}\n\n/* ================================\n   SORT PHASE\n   ================================ */\n\n.sort-phase {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding: var(--space-3) var(--space-4);\n  padding-bottom: 0;\n  overflow: hidden;\n  min-height: 0; /* Allow flex shrinking */\n}\n\n/* Process Flow Indicator - Shows sorting hierarchy */\n.process-flow-indicator {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-4);\n  margin-bottom: var(--space-3);\n  background: var(--glass-bg-subtle);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--glass-border-light);\n}\n\n.flow-step {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-0_5);\n  opacity: 0.5;\n  transition: all var(--duration-normal) ease;\n}\n\n.flow-step.active {\n  opacity: 1;\n}\n\n.flow-step.active .flow-label {\n  color: var(--brand-primary);\n  font-weight: var(--font-semibold);\n}\n\n.flow-icon {\n  font-size: var(--text-base);\n}\n\n.flow-label {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n}\n\n.flow-arrow {\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  opacity: 0.3;\n}\n\n/* Swipe hints */\n.swipe-hints {\n  display: flex;\n  justify-content: space-between;\n  padding: 0 var(--space-4);\n  margin-bottom: var(--space-4);\n  animation: fadeInOut 3s ease-in-out infinite;\n}\n\n@keyframes fadeInOut {\n  0%, 100% { opacity: 0.3; }\n  50% { opacity: 0.6; }\n}\n\n.hint {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n}\n\n/* Card Stack */\n.card-stack {\n  position: relative;\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  perspective: 1000px;\n  min-height: var(--kanban-column-min-height);\n  max-height: 320px;\n}\n\n.stack-card {\n  position: absolute;\n  width: 92%;\n  max-width: 360px;\n  height: 240px;\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--glass-border-light);\n  border-radius: var(--radius-2xl);\n}\n\n/* Main Task Card */\n.task-card {\n  position: relative;\n  width: 92%;\n  max-width: 360px;\n  min-height: 180px;\n  max-height: 260px;\n  background: linear-gradient(\n    145deg,\n    var(--canvas-task-bg),\n    var(--surface-secondary)\n  );\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-2xl);\n  box-shadow:\n    var(--shadow-2xl),\n    var(--shadow-dark-lg),\n    inset 0 1px 0 var(--glass-bg-weak);\n  z-index: var(--z-sticky);\n  touch-action: pan-y;\n  user-select: none;\n  overflow: hidden;\n}\n\n.task-card.swiping {\n  cursor: grabbing;\n}\n\n/* Swipe Indicators */\n.swipe-indicator {\n  position: absolute;\n  inset: 0;\n  border-radius: var(--radius-2xl);\n  pointer-events: none;\n  transition: opacity var(--duration-instant) ease;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: var(--z-sticky); /* Above blurred content */\n}\n\n/* Left swipe = Skip (muted) */\n.swipe-indicator.left {\n  border: 3px solid var(--glass-border-hover);\n  background: var(--glass-bg-medium);\n}\n\n/* Right swipe = Exit (muted) */\n.swipe-indicator.right {\n  border: 3px solid var(--glass-border-hover);\n  background: var(--glass-bg-medium);\n}\n\n.swipe-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-2);\n  color: inherit;\n}\n\n/* Left swipe content = Skip (muted) */\n.swipe-indicator.left .swipe-content {\n  color: var(--text-secondary);\n}\n\n/* Right swipe content = Exit (muted) */\n.swipe-indicator.right .swipe-content {\n  color: var(--text-secondary);\n}\n\n.swipe-content span {\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n}\n\n/* Card Content */\n.card-content {\n  position: relative;\n  padding: var(--space-6);\n  padding-bottom: var(--space-8);\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  z-index: 1; /* Below swipe indicators */\n  will-change: filter, opacity;\n}\n\n.priority-strip {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: var(--space-1);\n  border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;\n}\n\n.priority-strip.priority-high {\n  background: linear-gradient(90deg, var(--color-priority-high), hsl(0, 90%, 65%));\n}\n\n.priority-strip.priority-medium {\n  background: linear-gradient(90deg, var(--color-priority-medium), hsl(38, 95%, 55%));\n}\n\n.priority-strip.priority-low {\n  background: linear-gradient(90deg, var(--color-priority-low), hsl(217, 95%, 65%));\n}\n\n.priority-strip.priority-none {\n  background: transparent;\n}\n\n.task-title {\n  font-size: 1.375rem; /* no-token */\n  font-weight: var(--font-bold);\n  line-height: var(--leading-tight);\n  margin: 0 0 var(--space-3);\n  color: var(--text-primary);\n  letter-spacing: -0.01em;\n  overflow-wrap: anywhere; /* Break long URLs/strings that have no spaces */\n  word-break: break-word;\n  /* Hard height cap — reliable fallback for all browsers */\n  max-height: 5.2em; /* ~3 lines at line-height 1.25 + small buffer */\n  overflow: hidden;\n  /* Progressive enhancement: show ellipsis where supported */\n  display: -webkit-box;\n  -webkit-line-clamp: 3;\n  -webkit-box-orient: vertical;\n  /* RTL support */\n  text-align: start;\n  unicode-bidi: plaintext;\n}\n\n.task-description {\n  flex: 1;\n  font-size: var(--text-base);\n  line-height: var(--leading-normal);\n  color: var(--text-secondary);\n  margin: 0;\n  overflow: hidden;\n  overflow-wrap: anywhere;\n  word-break: break-word;\n}\n\n.task-meta {\n  display: flex;\n  gap: var(--space-3);\n  margin-top: auto;\n  padding-top: var(--space-3);\n}\n\n.meta-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-1_5) var(--space-2_5);\n  background: var(--glass-bg-weak);\n  border-radius: var(--radius-md);\n  font-size: var(--text-meta);\n  color: var(--text-muted);\n}\n\n.meta-item.priority-high {\n  color: var(--color-priority-high);\n  background: var(--priority-high-bg);\n}\n\n.meta-item.priority-medium {\n  color: var(--color-priority-medium);\n  background: var(--priority-medium-bg);\n}\n\n.meta-item.priority-low {\n  color: var(--color-priority-low);\n  background: var(--priority-low-bg);\n}\n\n.capitalize {\n  text-transform: capitalize;\n}\n\n/* ================================\n   THUMB ZONE (Bottom Controls)\n   ================================ */\n\n.thumb-zone {\n  padding: var(--space-4) var(--space-5);\n  padding-bottom: calc(var(--space-6) + env(safe-area-inset-bottom, var(--space-6)));\n  background: linear-gradient(to top, var(--overlay-bg), var(--overlay-component-bg-lighter), transparent);\n  margin-top: auto;\n  flex-shrink: 0;\n}\n\n.quick-edit-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-2) 0;\n  margin-bottom: var(--space-2);\n}\n\n.edit-label {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.08em;\n  min-width: 52px;\n}\n\n.priority-pills,\n.date-pills {\n  display: flex;\n  gap: var(--space-1_5);\n  flex: 1;\n}\n\n.date-pills-scroll {\n  display: flex;\n  gap: var(--space-2_5);\n  flex: 1;\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n  scrollbar-width: none;\n  -ms-overflow-style: none;\n  padding-bottom: 2px; /* Prevent cut-off on scroll */\n  padding-inline-end: var(--space-4);\n  scroll-snap-type: x proximity;\n}\n\n.date-pills-scroll::-webkit-scrollbar {\n  display: none;\n}\n\n.date-row {\n  overflow: visible;\n}\n\n.pill {\n  flex: 0 0 auto;\n  padding: var(--space-2) var(--space-2_5);\n  min-height: var(--dropdown-trigger-height-compact);\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-md);\n  color: var(--text-secondary);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-fast) ease;\n  white-space: nowrap;\n}\n\n.priority-pills .pill {\n  flex: 1;\n}\n\n.pill.active {\n  background: transparent;\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.pill.clear {\n  flex: 0;\n  padding: var(--space-2);\n  color: var(--text-muted);\n}\n\n.pill:active {\n  transform: scale(0.95);\n}\n\n/* Action Row - 4 buttons: Done, Save, Assign, Delete */\n.action-row {\n  display: flex;\n  gap: var(--space-2);\n  padding-top: var(--space-3);\n  margin-top: var(--space-2);\n}\n\n.action-btn {\n  flex: 1;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-1_5);\n  padding: var(--space-2_5) var(--space-2);\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-lg);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  text-transform: uppercase;\n  letter-spacing: 0.02em;\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.action-btn.done {\n  color: var(--color-success);\n  border-color: var(--success-border);\n}\n\n.action-btn.done:active {\n  background: var(--success-bg-subtle);\n}\n\n.action-btn.assign {\n  color: var(--brand-primary);\n  border-color: var(--state-hover-border);\n}\n\n.action-btn.assign:active {\n  background: var(--state-hover-bg);\n}\n\n.action-btn.save {\n  color: var(--brand-primary);\n  border-color: var(--state-hover-border);\n  position: relative;\n}\n\n.action-btn.save:active {\n  background: var(--state-hover-bg);\n}\n\n.dirty-dot {\n  width: 8px;\n  height: 8px;\n  border-radius: var(--radius-full);\n  background: var(--brand-primary);\n  animation: dirty-pulse 2s ease-in-out infinite;\n  flex-shrink: 0;\n}\n\n@keyframes dirty-pulse {\n  0%, 100% { opacity: 1; transform: scale(1); }\n  50% { opacity: 0.6; transform: scale(0.8); }\n}\n\n.action-btn.delete {\n  flex: 0 0 auto;\n  padding: var(--space-2_5);\n  color: var(--color-danger);\n  border-color: var(--danger-border-subtle);\n}\n\n.action-btn.delete:active {\n  background: var(--danger-bg-subtle);\n}\n\n.action-btn:active {\n  transform: scale(0.95);\n}\n\n/* ================================\n   COMPLETION PHASE\n   ================================ */\n\n.completion-phase {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: var(--space-8);\n}\n\n.celebration-container {\n  text-align: center;\n  max-width: 320px;\n}\n\n.confetti-burst {\n  position: absolute;\n  inset: 0;\n  pointer-events: none;\n}\n\n.celebration-icon {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  width: 120px;\n  height: 120px;\n  background: linear-gradient(135deg, var(--state-active-bg), var(--state-hover-bg));\n  border: var(--task-card-selection-border) solid var(--state-hover-border);\n  border-radius: var(--radius-full);\n  color: var(--brand-primary);\n  margin-bottom: var(--space-6);\n  animation: celebratePop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);\n}\n\n@keyframes celebratePop {\n  0% { transform: scale(0); opacity: 0; }\n  50% { transform: scale(1.1); }\n  100% { transform: scale(1); opacity: 1; }\n}\n\n.celebration-title {\n  font-size: var(--text-3xl);\n  font-weight: var(--font-bold);\n  margin: 0 0 var(--space-2);\n  background: linear-gradient(135deg, var(--brand-primary), hsl(174, 80%, 70%));\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  background-clip: text;\n}\n\n.celebration-subtitle {\n  font-size: var(--text-base);\n  color: var(--text-secondary);\n  margin: 0 0 var(--space-8);\n}\n\n.session-summary {\n  display: flex;\n  justify-content: center;\n  gap: var(--space-6);\n  margin-bottom: var(--space-8);\n}\n\n.summary-stat {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.stat-number {\n  font-size: 1.75rem; /* no-token */\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n  font-variant-numeric: tabular-nums;\n}\n\n.stat-label {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n}\n\n.return-btn {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-4) var(--space-6);\n  background: var(--glass-bg-weak);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  color: var(--text-primary);\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.return-btn:active {\n  transform: scale(0.98);\n  background: var(--glass-bg-light);\n}\n\n/* ================================\n   PROJECT SHEET\n   ================================ */\n\n.sheet-overlay {\n  position: fixed;\n  inset: 0;\n  background: var(--overlay-bg);\n  backdrop-filter: blur(var(--blur-xs));\n  -webkit-backdrop-filter: blur(var(--blur-xs));\n  display: flex;\n  align-items: flex-end;\n  z-index: var(--z-dropdown);\n}\n\n.project-sheet {\n  width: 100%;\n  max-height: 70vh;\n  background: var(--surface-primary);\n  border-top-left-radius: var(--radius-2xl);\n  border-top-right-radius: var(--radius-2xl);\n  padding: var(--space-4) var(--space-5);\n  padding-bottom: calc(var(--space-6) + env(safe-area-inset-bottom));\n  overflow-y: auto;\n}\n\n.sheet-handle {\n  width: var(--dropdown-trigger-height-compact);\n  height: var(--space-1);\n  background: var(--glass-border-strong);\n  border-radius: var(--radius-full);\n  margin: 0 auto var(--space-5);\n}\n\n.sheet-title {\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  margin: 0 0 var(--space-4);\n  text-align: center;\n}\n\n/* Project Search */\n.project-search-wrapper {\n  position: sticky;\n  top: 0;\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-3);\n  margin-bottom: var(--space-3);\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  z-index: var(--z-base);\n}\n\n.search-icon {\n  color: var(--text-muted);\n  flex-shrink: 0;\n}\n\n.project-search {\n  flex: 1;\n  background: transparent;\n  border: none;\n  color: var(--text-primary);\n  font-size: var(--text-base);\n  outline: none;\n}\n\n.project-search::placeholder {\n  color: var(--text-muted);\n}\n\n/* Recent Projects Section */\n.recent-projects-section {\n  margin-bottom: var(--space-3);\n}\n\n.section-label {\n  display: block;\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.08em;\n  margin-bottom: var(--space-2);\n}\n\n.recent-projects-grid {\n  display: flex;\n  gap: var(--space-2);\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n  scrollbar-width: none;\n  -ms-overflow-style: none;\n  padding-bottom: var(--space-1);\n}\n\n.recent-projects-grid::-webkit-scrollbar {\n  display: none;\n}\n\n.recent-project-chip {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  flex-shrink: 0;\n  padding: var(--space-2) var(--space-3);\n  background: var(--brand-bg-subtle);\n  border: 1px solid var(--brand-border-subtle);\n  border-radius: var(--radius-full);\n  color: var(--text-primary);\n  font-size: var(--text-meta);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n  white-space: nowrap;\n  box-shadow: var(--shadow-xs);\n}\n\n.recent-project-chip:active {\n  transform: scale(0.95);\n  background: var(--state-active-bg);\n  box-shadow: var(--shadow-sm);\n}\n\n.chip-emoji {\n  font-size: var(--text-base);\n}\n\n.chip-name {\n  max-width: 120px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n/* Depth indicator for deeply nested items */\n.depth-indicator {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  background: var(--glass-bg-weak);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-sm);\n  margin-left: auto;\n}\n\n/* No results message */\n.no-results {\n  padding: var(--space-8) var(--space-4);\n  text-align: center;\n  color: var(--text-muted);\n  font-size: var(--text-sm);\n  background: var(--glass-bg-subtle);\n  border-radius: var(--radius-lg);\n  margin: var(--space-4) 0;\n}\n\n.project-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.project-option {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3) var(--space-4);\n  background: var(--glass-bg-weak);\n  border: 1px solid var(--glass-border-light);\n  border-radius: var(--radius-xl);\n  color: var(--text-primary);\n  font-size: var(--text-base);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  transition: all var(--duration-normal) cubic-bezier(0.34, 1.56, 0.64, 1);\n  position: relative;\n}\n\n.hierarchy-line {\n  position: absolute;\n  left: var(--space-4);\n  top: 50%;\n  transform: translateY(-50%);\n  height: 100%;\n  display: flex;\n  align-items: center;\n}\n\n.hierarchy-connector {\n  width: var(--space-3);\n  height: 1px;\n  background: var(--border-subtle);\n  margin-left: auto;\n  border-radius: 1px;\n}\n\n.project-option:active {\n  background: var(--glass-bg-light);\n  transform: scale(0.98);\n}\n\n.project-indicator {\n  width: var(--project-indicator-size-md);\n  height: var(--project-indicator-size-md);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: var(--radius-lg);\n  font-size: var(--text-xl);\n}\n\n.project-name {\n  flex: 1;\n  text-align: left;\n}\n\n/* Inbox option - special styling */\n.inbox-option {\n  background: var(--brand-bg-subtle);\n  border-color: var(--brand-border-subtle);\n  flex-wrap: wrap;\n}\n\n.inbox-indicator {\n  background: transparent !important;\n}\n\n.option-hint {\n  width: 100%;\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin-top: var(--space-1);\n  padding-left: calc(var(--project-indicator-size-md) + var(--space-3));\n}\n\n/* Project divider */\n.project-divider {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  margin: var(--space-4) 0;\n  color: var(--text-muted);\n  font-size: var(--text-xs);\n  text-transform: uppercase;\n  letter-spacing: 0.1em;\n}\n\n.project-divider::before,\n.project-divider::after {\n  content: '';\n  flex: 1;\n  height: 1px;\n  background: var(--border-subtle);\n}\n\n/* Sheet transition */\n.sheet-enter-active,\n.sheet-leave-active {\n  transition: all var(--duration-slow) cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.sheet-enter-from,\n.sheet-leave-to {\n  opacity: 0;\n}\n\n.sheet-enter-from .project-sheet,\n.sheet-leave-to .project-sheet {\n  transform: translateY(100%);\n}\n\n/* ================================\n   MINI CELEBRATION\n   ================================ */\n\n.mini-celebration {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-6) var(--space-8);\n  background: var(--success-border-active);\n  border-radius: var(--radius-2xl);\n  color: white;\n  font-size: var(--text-xl);\n  font-weight: var(--font-bold);\n  z-index: var(--z-modal);\n  pointer-events: none;\n}\n\n.celebration-enter-active {\n  animation: miniCelebrate 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);\n}\n\n.celebration-leave-active {\n  animation: miniCelebrate var(--duration-slow) ease reverse;\n}\n\n@keyframes miniCelebrate {\n  0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }\n  50% { transform: translate(-50%, -50%) scale(1.1); }\n  100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }\n}\n\n/* ================================\n   DELETE CONFIRMATION MODAL\n   ================================ */\n\n.confirm-overlay {\n  position: fixed;\n  inset: 0;\n  background: var(--overlay-dark);\n  backdrop-filter: blur(var(--blur-xs));\n  -webkit-backdrop-filter: blur(var(--blur-xs));\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: var(--z-modal);\n}\n\n.confirm-modal {\n  background: linear-gradient(145deg, var(--canvas-task-bg), var(--surface-secondary));\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-2xl);\n  padding: var(--space-8);\n  text-align: center;\n  max-width: 320px;\n  margin: var(--space-4);\n}\n\n.confirm-icon {\n  color: var(--color-danger);\n  margin: 0 auto var(--space-4);\n}\n\n.confirm-modal h3 {\n  font-size: var(--text-xl);\n  font-weight: var(--font-bold);\n  margin: 0 0 var(--space-2);\n}\n\n.confirm-modal p {\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  margin: 0 0 var(--space-6);\n}\n\n.confirm-actions {\n  display: flex;\n  gap: var(--space-3);\n}\n\n.confirm-actions button {\n  flex: 1;\n  padding: var(--space-3) var(--space-4);\n  border-radius: var(--radius-lg);\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.cancel-btn {\n  background: var(--glass-bg-weak);\n  border: 1px solid var(--glass-border);\n  color: var(--text-secondary);\n}\n\n.cancel-btn:active {\n  background: var(--glass-bg-light);\n}\n\n.delete-btn {\n  background: var(--color-danger);\n  border: none;\n  color: white;\n}\n\n.delete-btn:active {\n  opacity: 0.9;\n  transform: scale(0.98);\n}\n\n/* Modal transitions */\n.modal-enter-active,\n.modal-leave-active {\n  transition: all var(--duration-normal) ease;\n}\n\n.modal-enter-from,\n.modal-leave-to {\n  opacity: 0;\n}\n\n.modal-enter-from .confirm-modal,\n.modal-leave-to .confirm-modal {\n  transform: scale(0.95);\n}\n\n/* ================================\n   QUICK EDIT PANEL\n   ================================ */\n\n.quick-edit-sheet {\n  width: 100%;\n  max-height: 60vh;\n  background: linear-gradient(\n    180deg,\n    hsl(240, 20%, 12%) 0%,\n    hsl(240, 18%, 10%) 100%\n  );\n  border-top-left-radius: var(--radius-2xl);\n  border-top-right-radius: var(--radius-2xl);\n  padding: var(--space-4) var(--space-5);\n  padding-bottom: calc(var(--space-6) + env(safe-area-inset-bottom));\n}\n\n.edit-section {\n  margin-bottom: var(--space-5);\n}\n\n.edit-section .edit-label {\n  display: block;\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.08em;\n  margin-bottom: var(--space-2);\n}\n\n.edit-section .priority-pills,\n.edit-section .date-pills {\n  display: flex;\n  gap: var(--space-2);\n}\n\n.edit-section .pill {\n  flex: 1;\n  padding: var(--space-3) var(--space-4);\n  background: var(--glass-bg-subtle);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-lg);\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n}\n\n.edit-section .pill.active {\n  background: transparent;\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.edit-section .pill:active {\n  transform: scale(0.98);\n}\n\n.assign-project-btn {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-2);\n  padding: var(--space-4);\n  background: var(--state-hover-bg);\n  border: 1px solid var(--state-hover-border);\n  border-radius: var(--radius-lg);\n  color: var(--brand-primary);\n  font-size: var(--text-base);\n  font-weight: var(--font-semibold);\n  cursor: pointer;\n  transition: all var(--duration-normal) ease;\n  margin-top: var(--space-4);\n}\n\n.assign-project-btn:active {\n  background: var(--state-active-bg);\n  transform: scale(0.98);\n}\n\n/* ================================\n   SMALL SCREEN ADAPTATIONS\n   ================================ */\n\n@media (max-height: 700px) {\n  .card-stack {\n    max-height: 200px;\n    min-height: 160px;\n  }\n\n  .task-card {\n    max-height: 180px;\n    min-height: 140px;\n  }\n\n  .stack-card {\n    height: 160px;\n  }\n\n  .card-content {\n    padding: var(--space-4);\n    padding-bottom: var(--space-5);\n  }\n\n  .task-title {\n    font-size: var(--text-lg);\n    max-height: 3.8em; /* ~3 lines */\n    -webkit-line-clamp: 2;\n  }\n\n  .process-flow-indicator {\n    display: none;\n  }\n}\n\n/* ================================\n   ACCESSIBILITY - REDUCED MOTION\n   ================================ */\n\n@media (prefers-reduced-motion: reduce) {\n  .task-card,\n  .progress-fill,\n  .progress-glow,\n  .celebration-icon,\n  .mini-celebration,\n  .dirty-dot {\n    animation: none !important;\n    transition: none !important;\n  }\n\n  .swipe-hints {\n    animation: none;\n    opacity: 0.5;\n  }\n}\n\n/* ================================\n   RTL LAYOUT SUPPORT\n   ================================ */\n\n[dir=\"rtl\"] .qs-header {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .header-content {\n  text-align: right;\n}\n\n[dir=\"rtl\"] .qs-title {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .card-content {\n  text-align: right;\n}\n\n[dir=\"rtl\"] .task-meta {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .meta-item {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .quick-edit-row {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .priority-pills,\n[dir=\"rtl\"] .date-pills,\n[dir=\"rtl\"] .date-pills-scroll {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .action-row {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .action-btn {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .quick-actions {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .quick-action-btn {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .recent-item {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .capture-input {\n  text-align: right;\n  direction: rtl;\n}\n\n[dir=\"rtl\"] .project-option {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .project-name {\n  text-align: right;\n}\n\n[dir=\"rtl\"] .swipe-hints {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .hint-left {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .hint-right {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .phase-btn {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .add-task-btn {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .return-btn {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .assign-project-btn {\n  flex-direction: row-reverse;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/views/MobileTimerView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/mobile/views/MobileTodayView.vue","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":188,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":188,"endColumn":80,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[6801,6880],"text":"// @ts-expect-error - Avoid strict type check on imported Task type if causing issues"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"mobile-today\">\n    <div class=\"today-header\">\n      <div class=\"date-display\">\n        <h2>{{ dayOfWeek }}</h2>\n        <span class=\"full-date\">{{ formattedDate }}</span>\n      </div>\n      <div class=\"task-count\">\n        {{ filteredTodayTasks.length }} tasks\n      </div>\n    </div>\n\n    <!-- TASK-1104: Filter Controls -->\n    <div class=\"filter-section\">\n      <!-- Project Filter -->\n      <div class=\"filter-row\">\n        <div class=\"filter-dropdown-wrapper\">\n          <button class=\"filter-btn\" @click=\"toggleProjectDropdown\">\n            <FolderOpen :size=\"14\" />\n            <span>{{ selectedProjectLabel }}</span>\n            <ChevronDown :size=\"12\" :class=\"{ rotated: showProjectDropdown }\" />\n          </button>\n          <div v-if=\"showProjectDropdown\" class=\"dropdown-menu\">\n            <button\n              class=\"dropdown-item\"\n              :class=\"{ active: selectedProject === null }\"\n              @click=\"selectProject(null)\"\n            >\n              All Projects\n            </button>\n            <button\n              v-for=\"project in taskStore.projects\"\n              :key=\"project.id\"\n              class=\"dropdown-item\"\n              :class=\"{ active: selectedProject === project.id }\"\n              @click=\"selectProject(project.id)\"\n            >\n              <span v-if=\"project.emoji\" class=\"project-emoji\">{{ project.emoji }}</span>\n              {{ project.name }}\n            </button>\n          </div>\n        </div>\n\n        <!-- Priority Filter -->\n        <div class=\"filter-dropdown-wrapper\">\n          <button class=\"filter-btn\" @click=\"togglePriorityDropdown\">\n            <Flag :size=\"14\" />\n            <span>{{ selectedPriorityLabel }}</span>\n            <ChevronDown :size=\"12\" :class=\"{ rotated: showPriorityDropdown }\" />\n          </button>\n          <div v-if=\"showPriorityDropdown\" class=\"dropdown-menu\">\n            <button\n              class=\"dropdown-item\"\n              :class=\"{ active: selectedPriority === null }\"\n              @click=\"selectPriority(null)\"\n            >\n              All Priorities\n            </button>\n            <button\n              v-for=\"p in priorityOptions\"\n              :key=\"p.value\"\n              class=\"dropdown-item\"\n              :class=\"{ active: selectedPriority === p.value }\"\n              @click=\"selectPriority(p.value)\"\n            >\n              <span class=\"priority-dot\" :class=\"p.value\" />\n              {{ p.label }}\n            </button>\n          </div>\n        </div>\n\n        <!-- Group By Toggle -->\n        <div class=\"filter-dropdown-wrapper\">\n          <button class=\"filter-btn\" @click=\"toggleGroupByDropdown\">\n            <Layers :size=\"14\" />\n            <span>{{ groupByLabel }}</span>\n            <ChevronDown :size=\"12\" :class=\"{ rotated: showGroupByDropdown }\" />\n          </button>\n          <div v-if=\"showGroupByDropdown\" class=\"dropdown-menu\">\n            <button\n              v-for=\"option in groupByOptions\"\n              :key=\"option.value\"\n              class=\"dropdown-item\"\n              :class=\"{ active: groupBy === option.value }\"\n              @click=\"selectGroupBy(option.value)\"\n            >\n              <component :is=\"option.icon\" :size=\"14\" />\n              {{ option.label }}\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <!-- Clear Filters -->\n      <button v-if=\"hasActiveFilters\" class=\"clear-btn\" @click=\"clearFilters\">\n        <X :size=\"14\" />\n        Clear\n      </button>\n    </div>\n\n    <!-- Swipe hint (shows once) -->\n    <div v-if=\"showSwipeHint\" class=\"swipe-hint\">\n      <span class=\"hint-text\">← Delete</span>\n      <span class=\"hint-divider\">|</span>\n      <span class=\"hint-text\">Edit →</span>\n      <button class=\"hint-dismiss\" @click=\"dismissSwipeHint\">\n        Got it\n      </button>\n    </div>\n\n    <!-- Grouped Task Sections -->\n    <div class=\"time-sections\">\n      <!-- Dynamic grouped display -->\n      <template v-for=\"group in groupedTasks\" :key=\"group.key\">\n        <div class=\"time-section\" :class=\"{ overdue: group.key === 'overdue' }\">\n          <div class=\"section-header\">\n            <component :is=\"group.icon\" :size=\"16\" />\n            <span>{{ group.title }}</span>\n            <span class=\"count\">{{ group.tasks.length }}</span>\n          </div>\n          <div class=\"task-list\">\n            <SwipeableTaskItem\n              v-for=\"task in group.tasks\"\n              :key=\"task.id\"\n              :task-id=\"task.id\"\n              @edit=\"handleEditTask(task)\"\n              @delete=\"handleDeleteTask(task)\"\n            >\n              <div class=\"task-item\" @click=\"handleTaskClick(task)\">\n                <div class=\"task-checkbox\" @click.stop=\"toggleTask(task)\">\n                  <div class=\"checkbox-circle\" :class=\"[{ checked: task.status === 'done' }]\">\n                    <Check v-if=\"task.status === 'done'\" :size=\"14\" />\n                  </div>\n                </div>\n                <div class=\"task-content\">\n                  <span class=\"task-title\" dir=\"auto\" :class=\"[{ done: task.status === 'done' }]\">{{ task.title }}</span>\n                  <div class=\"task-meta\">\n                    <span v-if=\"getDueBadge(task) && groupBy !== 'time'\" class=\"task-due\" :class=\"{ overdue: isOverdue(task.dueDate) }\">\n                      {{ getDueBadge(task) }}\n                    </span>\n                    <span v-if=\"task.priority && groupBy !== 'priority'\" class=\"priority-badge\" :class=\"task.priority\">\n                      {{ priorityLabel(task.priority) }}\n                    </span>\n                    <span v-if=\"getProjectName(task.projectId) && groupBy !== 'project'\" class=\"project-badge\">\n                      {{ getProjectName(task.projectId) }}\n                    </span>\n                  </div>\n                </div>\n                <button class=\"timer-btn\" @click.stop=\"startTimer(task)\">\n                  <Play :size=\"16\" />\n                </button>\n              </div>\n            </SwipeableTaskItem>\n          </div>\n        </div>\n      </template>\n\n      <!-- Empty state -->\n      <div v-if=\"filteredTodayTasks.length === 0\" class=\"empty-state\">\n        <CheckCircle :size=\"48\" />\n        <h3 v-if=\"hasActiveFilters\">\n          No matching tasks\n        </h3>\n        <h3 v-else>\n          All clear for today!\n        </h3>\n        <p v-if=\"hasActiveFilters\">\n          Try adjusting your filters.\n        </p>\n        <p v-else>\n          No tasks scheduled. Add one from Inbox.\n        </p>\n      </div>\n    </div>\n\n    <!-- Task Edit Bottom Sheet -->\n    <TaskEditBottomSheet\n      :is-open=\"isEditSheetOpen\"\n      :task=\"editingTask\"\n      @close=\"closeEditSheet\"\n      @save=\"handleSaveTask\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, ref, onMounted, onBeforeUnmount } from 'vue'\n// @ts-ignore - Avoid strict type check on imported Task type if causing issues\nimport { useTaskStore, type Task } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useMobileFilters, type GroupByType } from '@/composables/mobile/useMobileFilters'\nimport TaskEditBottomSheet from '@/mobile/components/TaskEditBottomSheet.vue'\nimport SwipeableTaskItem from '@/mobile/components/SwipeableTaskItem.vue'\nimport {\n  Check, Play, AlertCircle, Sunrise, Sun, Moon, Calendar, CheckCircle,\n  FolderOpen, Flag, ChevronDown, Layers, X, Clock\n} from 'lucide-vue-next'\n\nconst taskStore = useTaskStore()\nconst timerStore = useTimerStore()\n\n// Shared mobile filter state (persists across view navigation)\nconst {\n  selectedProject,\n  selectedPriority,\n  groupBy,\n  hasActiveFilters,\n  priorityLabel,\n  clearFilters,\n  setProjectFilter,\n  setPriorityFilter,\n  setGroupBy\n} = useMobileFilters()\n\n// Edit sheet state\nconst isEditSheetOpen = ref(false)\nconst editingTask = ref<Task | null>(null)\n\n// View-specific dropdown state\nconst showProjectDropdown = ref(false)\nconst showPriorityDropdown = ref(false)\nconst showGroupByDropdown = ref(false)\n\n// Priority options (for dropdown display)\nconst priorityOptions = [\n  { value: 'critical', label: 'Critical (P0)' },\n  { value: 'high', label: 'High (P1)' },\n  { value: 'medium', label: 'Medium (P2)' },\n  { value: 'low', label: 'Low (P3)' }\n]\n\n// Group by options (Today view uses 'time' instead of 'none')\nconst groupByOptions = [\n  { value: 'time' as const, label: 'By Time', icon: Clock },\n  { value: 'project' as const, label: 'By Project', icon: FolderOpen },\n  { value: 'priority' as const, label: 'By Priority', icon: Flag }\n]\n\n// Computed labels\nconst selectedProjectLabel = computed(() => {\n  if (!selectedProject.value) return 'All Projects'\n  const project = taskStore.projects.find(p => p.id === selectedProject.value)\n  return project?.name || 'Project'\n})\n\nconst selectedPriorityLabel = computed(() => {\n  if (!selectedPriority.value) return 'All Priorities'\n  const p = priorityOptions.find(o => o.value === selectedPriority.value)\n  return p?.label.split(' ')[0] || 'Priority'\n})\n\nconst groupByLabel = computed(() => {\n  const option = groupByOptions.find(o => o.value === groupBy.value)\n  return option?.label || 'Group'\n})\n\n// hasActiveFilters is now provided by useMobileFilters composable\n\n// Filter actions\nconst toggleProjectDropdown = () => {\n  showProjectDropdown.value = !showProjectDropdown.value\n  showPriorityDropdown.value = false\n  showGroupByDropdown.value = false\n}\n\nconst togglePriorityDropdown = () => {\n  showPriorityDropdown.value = !showPriorityDropdown.value\n  showProjectDropdown.value = false\n  showGroupByDropdown.value = false\n}\n\nconst toggleGroupByDropdown = () => {\n  showGroupByDropdown.value = !showGroupByDropdown.value\n  showProjectDropdown.value = false\n  showPriorityDropdown.value = false\n}\n\nconst selectProject = (projectId: string | null) => {\n  setProjectFilter(projectId)\n  showProjectDropdown.value = false\n}\n\nconst selectPriority = (priority: string | null) => {\n  setPriorityFilter(priority)\n  showPriorityDropdown.value = false\n}\n\nconst selectGroupBy = (value: GroupByType) => {\n  setGroupBy(value)\n  showGroupByDropdown.value = false\n}\n\n// clearFilters is now provided by useMobileFilters composable\n\n// Close dropdowns when clicking outside\nconst handleClickOutside = (event: MouseEvent) => {\n  const target = event.target as HTMLElement\n  if (!target.closest('.filter-dropdown-wrapper')) {\n    showProjectDropdown.value = false\n    showPriorityDropdown.value = false\n    showGroupByDropdown.value = false\n  }\n}\n\n\n// Swipe hint - show once for first-time users\nconst SWIPE_HINT_KEY = 'flowstate-today-swipe-hint-dismissed'\nconst showSwipeHint = ref(false)\n\nonMounted(() => {\n  const dismissed = localStorage.getItem(SWIPE_HINT_KEY)\n  if (!dismissed) {\n    showSwipeHint.value = true\n  }\n  document.addEventListener('click', handleClickOutside)\n})\n\nonBeforeUnmount(() => {\n  document.removeEventListener('click', handleClickOutside)\n})\n\nconst dismissSwipeHint = () => {\n  showSwipeHint.value = false\n  localStorage.setItem(SWIPE_HINT_KEY, 'true')\n}\n\n// Date formatting\nconst now = new Date()\nconst dayOfWeek = computed(() => {\n  return now.toLocaleDateString('en-US', { weekday: 'long' })\n})\nconst formattedDate = computed(() => {\n  return now.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })\n})\n\n// Get today's date boundaries\nconst todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate())\nconst todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59)\n\n// Filter tasks for today (exclude completed tasks - TASK-1004)\nconst todayTasks = computed(() => {\n  return taskStore.tasks.filter(t => {\n    if (!t.dueDate || t.status === 'done') return false\n    const dueDate = new Date(t.dueDate)\n    return dueDate >= todayStart && dueDate <= todayEnd\n  })\n})\n\n// Overdue tasks (before today)\nconst overdueTasks = computed(() => {\n  return taskStore.tasks.filter(t => {\n    if (!t.dueDate || t.status === 'done') return false\n    const dueDate = new Date(t.dueDate)\n    return dueDate < todayStart\n  })\n})\n\n// TASK-1104: Apply filters to today + overdue tasks\nconst filteredTodayTasks = computed(() => {\n  let tasks = [...todayTasks.value, ...overdueTasks.value]\n\n  // Apply project filter\n  if (selectedProject.value) {\n    tasks = tasks.filter(t => t.projectId === selectedProject.value)\n  }\n\n  // Apply priority filter\n  if (selectedPriority.value) {\n    tasks = tasks.filter(t => t.priority === selectedPriority.value)\n  }\n\n  return tasks\n})\n\n// Time-based categorization — only use explicit dueTime, never extract time from dueDate\n// BUG-1286: dueDate is date-only; parsing it as Date gives UTC midnight → 2am in UTC+2\nconst getTaskHour = (task: Task): number | null => {\n  if (!task.dueTime) return null\n  const [hours] = task.dueTime.split(':').map(Number)\n  return isNaN(hours) ? null : hours\n}\n\nconst isOverdue = (dueDate: string | Date | undefined): boolean => {\n  if (!dueDate) return false\n  return new Date(dueDate) < todayStart\n}\n\n// Helper to get project name\nconst getProjectName = (projectId: string | undefined | null): string | null => {\n  if (!projectId) return null\n  const project = taskStore.projects.find(p => p.id === projectId)\n  return project?.name || null\n}\n\n// priorityLabel is now provided by useMobileFilters composable\n\n// TASK-1104: Grouped tasks based on groupBy mode\ninterface TaskGroup {\n  key: string\n  title: string\n  icon: typeof AlertCircle\n  tasks: Task[]\n}\n\nconst groupedTasks = computed((): TaskGroup[] => {\n  const tasks = filteredTodayTasks.value\n  const groups: TaskGroup[] = []\n\n  // Today view treats 'none' and 'date' the same as 'time' (time-based grouping is the default)\n  if (groupBy.value === 'time' || groupBy.value === 'none' || groupBy.value === 'date') {\n    // Time-based grouping (original behavior)\n    const overdueFiltered = tasks.filter(t => isOverdue(t.dueDate))\n    const morningFiltered = tasks.filter(t => {\n      if (isOverdue(t.dueDate)) return false\n      const hour = getTaskHour(t)\n      return hour !== null && hour >= 6 && hour < 12\n    })\n    const afternoonFiltered = tasks.filter(t => {\n      if (isOverdue(t.dueDate)) return false\n      const hour = getTaskHour(t)\n      return hour !== null && hour >= 12 && hour < 18\n    })\n    const eveningFiltered = tasks.filter(t => {\n      if (isOverdue(t.dueDate)) return false\n      const hour = getTaskHour(t)\n      return hour !== null && (hour >= 18 || hour < 6)\n    })\n    // BUG-1286: Tasks without explicit dueTime are \"untimed\" → \"Anytime Today\"\n    const untimedFiltered = tasks.filter(t => {\n      if (isOverdue(t.dueDate)) return false\n      return getTaskHour(t) === null\n    })\n\n    if (overdueFiltered.length > 0) groups.push({ key: 'overdue', title: 'Overdue', icon: AlertCircle, tasks: overdueFiltered })\n    if (morningFiltered.length > 0) groups.push({ key: 'morning', title: 'Morning', icon: Sunrise, tasks: morningFiltered })\n    if (afternoonFiltered.length > 0) groups.push({ key: 'afternoon', title: 'Afternoon', icon: Sun, tasks: afternoonFiltered })\n    if (eveningFiltered.length > 0) groups.push({ key: 'evening', title: 'Evening', icon: Moon, tasks: eveningFiltered })\n    if (untimedFiltered.length > 0) groups.push({ key: 'anytime', title: 'Anytime Today', icon: Calendar, tasks: untimedFiltered })\n  } else if (groupBy.value === 'project') {\n    // Group by project\n    const projectMap = new Map<string, Task[]>()\n\n    tasks.forEach(task => {\n      const key = task.projectId || 'no-project'\n      if (!projectMap.has(key)) projectMap.set(key, [])\n      projectMap.get(key)!.push(task)\n    })\n\n    // Sort: projects first, then no-project\n    const sortedKeys = Array.from(projectMap.keys()).sort((a, b) => {\n      if (a === 'no-project') return 1\n      if (b === 'no-project') return -1\n      const aName = getProjectName(a) || ''\n      const bName = getProjectName(b) || ''\n      return aName.localeCompare(bName)\n    })\n\n    sortedKeys.forEach(key => {\n      const projectTasks = projectMap.get(key)!\n      const title = key === 'no-project' ? 'No Project' : (getProjectName(key) || 'Unknown')\n      groups.push({ key, title, icon: FolderOpen, tasks: projectTasks })\n    })\n  } else if (groupBy.value === 'priority') {\n    // Group by priority\n    const priorityOrder = ['critical', 'high', 'medium', 'low', 'none']\n    const priorityLabels: Record<string, string> = {\n      critical: 'Critical (P0)',\n      high: 'High (P1)',\n      medium: 'Medium (P2)',\n      low: 'Low (P3)',\n      none: 'No Priority'\n    }\n    const priorityMap = new Map<string, Task[]>()\n\n    tasks.forEach(task => {\n      const key = task.priority || 'none'\n      if (!priorityMap.has(key)) priorityMap.set(key, [])\n      priorityMap.get(key)!.push(task)\n    })\n\n    priorityOrder.forEach(key => {\n      if (priorityMap.has(key) && priorityMap.get(key)!.length > 0) {\n        groups.push({ key, title: priorityLabels[key], icon: Flag, tasks: priorityMap.get(key)! })\n      }\n    })\n  }\n\n  return groups\n})\n\n// BUG-1286: Show meaningful badge — overdue date, explicit time, or nothing\nconst getDueBadge = (task: Task): string => {\n  if (!task.dueDate) return ''\n  // Show relative date if overdue\n  if (isOverdue(task.dueDate)) {\n    // Parse as local date to avoid UTC shift\n    const [y, m, d] = task.dueDate.split('T')[0].split('-').map(Number)\n    const date = new Date(y, m - 1, d)\n    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })\n  }\n  // Show explicit time if user set one\n  if (task.dueTime) {\n    const [hours, minutes] = task.dueTime.split(':').map(Number)\n    const date = new Date()\n    date.setHours(hours, minutes, 0, 0)\n    return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })\n  }\n  return ''\n}\n\nconst toggleTask = async (task: Task) => {\n  const newStatus = task.status === 'done' ? 'planned' : 'done'\n  // BUG-1051: AWAIT to ensure persistence\n  await taskStore.updateTask(task.id, { status: newStatus })\n}\n\nconst handleTaskClick = (_task: Task) => {\n  // Normal tap - currently no action\n  // Swipe gestures handle edit/delete\n}\n\nconst startTimer = async (task: Task) => {\n  // BUG-1051: AWAIT for timer sync\n  await timerStore.startTimer(task.id)\n}\n\n// Open edit bottom sheet for task (triggered by swipe right)\nconst handleEditTask = (task: Task) => {\n  editingTask.value = task\n  isEditSheetOpen.value = true\n}\n\n// Delete task (triggered by swipe left + confirm)\nconst handleDeleteTask = (task: Task) => {\n  taskStore.deleteTask(task.id)\n}\n\n// Close edit bottom sheet\nconst closeEditSheet = () => {\n  isEditSheetOpen.value = false\n  // Delay clearing the task to allow close animation\n  setTimeout(() => {\n    editingTask.value = null\n  }, 300)\n}\n\n// Save task changes from edit sheet\nconst handleSaveTask = async (taskId: string, updates: Partial<Task>) => {\n  // BUG-1051: AWAIT to ensure persistence\n  await taskStore.updateTask(taskId, updates)\n}\n</script>\n\n<style scoped>\n.mobile-today {\n  padding: var(--space-4);\n  padding-bottom: 100px;\n  min-height: 100vh;\n  background: var(--app-background-gradient);\n}\n\n/* Swipe hint banner */\n.swipe-hint {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-3);\n  padding: var(--space-2_5) var(--space-4);\n  margin-bottom: var(--space-4);\n  background: var(--surface-secondary);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-subtle);\n}\n\n.hint-text {\n  font-size: var(--text-meta);\n  color: var(--text-secondary);\n  font-weight: var(--font-medium);\n}\n\n.hint-divider {\n  color: var(--border-subtle);\n}\n\n.hint-dismiss {\n  margin-left: var(--space-2);\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  color: var(--primary-brand);\n  background: var(--primary-brand-bg-subtle);\n  border: none;\n  border-radius: var(--radius-md);\n  cursor: pointer;\n}\n\n.hint-dismiss:active {\n  transform: scale(0.95);\n}\n\n.today-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n  margin-bottom: var(--space-4);\n}\n\n/* TASK-1104: Filter Section */\n.filter-section {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  margin-bottom: var(--space-5);\n}\n\n.filter-row {\n  display: flex;\n  gap: var(--space-2);\n  flex-wrap: wrap;\n}\n\n.filter-dropdown-wrapper {\n  position: relative;\n}\n\n.filter-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  padding: var(--space-2) var(--space-3);\n  border-radius: var(--radius-xl);\n  border: 1px solid var(--border-subtle);\n  background: var(--surface-secondary);\n  color: var(--text-secondary);\n  font-size: var(--text-meta);\n  cursor: pointer;\n  transition: all var(--duration-normal);\n  white-space: nowrap;\n}\n\n.filter-btn:active {\n  transform: scale(0.98);\n}\n\n.filter-btn .rotated {\n  transform: rotate(180deg);\n}\n\n.dropdown-menu {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  margin-top: var(--space-1);\n  min-width: 160px;\n  max-height: 240px;\n  overflow-y: auto;\n  background: var(--surface-primary);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-lg);\n  box-shadow: var(--shadow-lg);\n  z-index: var(--z-dropdown);\n}\n\n.dropdown-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2_5);\n  width: 100%;\n  padding: var(--space-3) var(--space-4);\n  border: none;\n  background: transparent;\n  color: var(--text-secondary);\n  font-size: var(--text-sm);\n  text-align: left;\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.dropdown-item:hover {\n  background: var(--surface-secondary);\n}\n\n.dropdown-item.active {\n  background: var(--primary-brand-bg-subtle);\n  color: var(--primary-brand);\n}\n\n.project-emoji {\n  font-size: var(--text-base);\n}\n\n.priority-dot {\n  width: var(--space-2);\n  height: var(--space-2);\n  border-radius: var(--radius-full);\n}\n\n.priority-dot.critical { background: var(--color-priority-high); }\n.priority-dot.high { background: var(--color-priority-medium); }\n.priority-dot.medium { background: var(--color-warning); }\n.priority-dot.low { background: var(--color-success); }\n\n.clear-btn {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1);\n  padding: var(--space-1_5) var(--space-3);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--danger-border-subtle);\n  background: var(--danger-bg-subtle);\n  color: var(--danger-text);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  cursor: pointer;\n  align-self: flex-start;\n}\n\n.clear-btn:active {\n  transform: scale(0.98);\n}\n\n/* Task meta row */\n.task-meta {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  margin-top: var(--space-0_5);\n}\n\n.priority-badge {\n  font-size: var(--text-xs);\n  font-weight: var(--font-semibold);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-xs);\n}\n\n.priority-badge.critical { background: var(--danger-bg-subtle); color: var(--danger-text); }\n.priority-badge.high { background: var(--orange-bg-subtle); color: var(--color-priority-medium); }\n.priority-badge.medium { background: var(--primary-brand-bg-subtle); color: var(--primary-brand); }\n.priority-badge.low { background: var(--surface-tertiary); color: var(--text-muted); }\n\n.project-badge {\n  font-size: var(--text-xs);\n  padding: var(--space-0_5) var(--space-1_5);\n  border-radius: var(--radius-xs);\n  background: var(--surface-tertiary);\n  color: var(--text-tertiary);\n  max-width: 80px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.date-display h2 {\n  font-size: var(--text-3xl);\n  font-weight: var(--font-bold);\n  margin: 0;\n  color: var(--text-primary);\n}\n\n.full-date {\n  font-size: var(--text-sm);\n  color: var(--text-tertiary);\n}\n\n.task-count {\n  background: var(--surface-secondary);\n  padding: var(--space-1_5) var(--space-3);\n  border-radius: var(--radius-xl);\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  color: var(--text-secondary);\n}\n\n.time-sections {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-5);\n}\n\n.time-section {\n  background: var(--surface-primary);\n  border-radius: var(--radius-lg);\n  padding: var(--space-4);\n  box-shadow: var(--shadow-sm);\n}\n\n.time-section.overdue {\n  border-left: 3px solid var(--danger-text);\n}\n\n.section-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  margin-bottom: var(--space-3);\n  font-weight: var(--font-semibold);\n  color: var(--text-secondary);\n}\n\n.section-header .count {\n  margin-left: auto;\n  background: var(--surface-secondary);\n  padding: var(--space-0_5) var(--space-2);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n}\n\n.task-list {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n}\n\n.task-item {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n  padding: var(--space-3);\n  background: var(--surface-secondary);\n  cursor: pointer;\n  /* Prevent text selection */\n  -webkit-user-select: none;\n  user-select: none;\n  -webkit-touch-callout: none;\n}\n\n.task-item:active {\n  background: var(--surface-tertiary);\n}\n\n.task-checkbox {\n  padding: var(--space-1);\n}\n\n.checkbox-circle {\n  width: 22px;\n  height: 22px;\n  border: 2px solid var(--border-subtle);\n  border-radius: var(--radius-full);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all var(--duration-normal);\n}\n\n.checkbox-circle.checked {\n  background: var(--primary-brand);\n  border-color: var(--primary-brand);\n  color: var(--text-primary);\n}\n\n.task-content {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-0_5);\n  min-width: 0;\n}\n\n.task-title {\n  font-size: var(--text-base);\n  color: var(--text-primary);\n  /* Multi-line truncation for RTL/long text */\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: normal;\n  line-height: 1.4;\n  word-break: break-word;\n  /* RTL support */\n  text-align: start;\n  unicode-bidi: plaintext;\n}\n\n.task-title.done {\n  text-decoration: line-through;\n  color: var(--text-muted);\n}\n\n.task-due {\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n}\n\n.task-due.overdue {\n  color: var(--danger-text);\n}\n\n.timer-btn {\n  width: var(--space-9);\n  height: var(--space-9);\n  border-radius: var(--radius-full);\n  border: none;\n  background: var(--primary-brand-bg-subtle);\n  color: var(--primary-brand);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.timer-btn:active {\n  transform: scale(0.95);\n}\n\n.empty-state {\n  text-align: center;\n  padding: var(--space-16) var(--space-5);\n  color: var(--text-tertiary);\n}\n\n.empty-state h3 {\n  margin: var(--space-4) 0 var(--space-2);\n  font-size: var(--text-xl);\n  color: var(--text-primary);\n}\n\n.empty-state p {\n  margin: 0;\n  font-size: var(--text-sm);\n}\n\n/* RTL Layout Support */\n[dir=\"rtl\"] .today-header {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .filter-row {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .task-item {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .task-content {\n  text-align: right;\n}\n\n[dir=\"rtl\"] .task-meta {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .section-header {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .section-header .count {\n  margin-left: 0;\n  margin-right: auto;\n}\n\n[dir=\"rtl\"] .dropdown-menu {\n  left: auto;\n  right: 0;\n}\n\n[dir=\"rtl\"] .dropdown-item {\n  flex-direction: row-reverse;\n  text-align: right;\n}\n\n[dir=\"rtl\"] .filter-btn {\n  flex-direction: row-reverse;\n}\n\n[dir=\"rtl\"] .time-section.overdue {\n  border-left: none;\n  border-right: 3px solid var(--danger-text);\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/router/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/challengeTemplates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/gamemaster.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AIGenerateChallengesResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":31,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"AIGenerateChallengesResponse"},"fix":{"range":[414,446],"text":""},"desc":"Remove unused variable \"AIGenerateChallengesResponse\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ARIA Game Master Service for Cyberflow RPG\n * FEATURE-1132: AI-driven challenge generation\n *\n * ARIA (Autonomous Runtime Intelligence Agent) is the Game Master AI\n * that generates personalized daily missions and weekly boss fights\n * based on user behavior and stats.\n */\n\nimport type { ChatMessage } from './types'\nimport type {\n  ChallengeGenerationContext,\n  ChallengeDifficulty,\n  AIGeneratedChallenge,\n  AIGenerateChallengesResponse,\n  ChallengeObjective,\n} from '@/types/challenges'\nimport {\n  generateDailyChallengesFromTemplates,\n  generateBossFightFromTemplate,\n  type TemplateGenerationContext,\n} from './challengeTemplates'\n\n// =============================================================================\n// ARIA Persona\n// =============================================================================\n\n/**\n * Build ARIA's system prompt for challenge generation\n */\nfunction buildARIASystemPrompt(): string {\n  return `You are ARIA (Autonomous Runtime Intelligence Agent), the Game Master AI for a cyberpunk productivity RPG called Cyberflow.\n\nYour role is to generate personalized daily missions and weekly boss fights for netrunners (users) based on their productivity patterns.\n\nPERSONALITY:\n- Ship's computer aesthetic (think HAL 9000 meets Cortana)\n- Short, punchy sentences\n- Technical jargon mixed with game terms\n- Use \"netrunner\" for the player, \"Grid\" for their workspace\n- \"Sectors\" for projects, \"hacks\" for tasks, \"data packets\" for work items\n- Be encouraging but not sycophantic\n- Create urgency without stress\n\nVALID OBJECTIVE TYPES (you MUST use ONLY these):\n- complete_tasks: Complete N tasks\n- complete_pomodoros: Complete N pomodoro sessions\n- clear_overdue: Clear N overdue tasks\n- focus_time_minutes: Accumulate N minutes of focus time\n- complete_high_priority: Complete N high-priority tasks\n- complete_project_tasks: Complete N tasks in a specific project (include project_name)\n- complete_before_hour: Complete N tasks before a specific hour (include hour, 1-24)\n- complete_variety: Complete tasks across N different projects\n\nOBJECTIVE CONSTRAINTS:\n- complete_tasks: 1-10\n- complete_pomodoros: 1-6\n- clear_overdue: 1-5\n- focus_time_minutes: 15-120\n- complete_high_priority: 1-3\n- complete_project_tasks: 1-5\n- complete_before_hour: 1-3\n- complete_variety: 2-4\n\nXP REWARDS BY DIFFICULTY:\n- easy: 15-30 XP\n- normal: 25-50 XP\n- hard: 40-75 XP\n- boss: 100-200 XP\n\nRULES:\n1. Generate EXACTLY the number of missions requested\n2. Use DIVERSE objective types (don't repeat the same type)\n3. Scale objective_target based on user's patterns and difficulty\n4. Make titles creative but short (max 50 chars)\n5. Descriptions should be max 150 chars\n6. narrative_flavor should be in ARIA's voice (max 100 chars)\n7. Respond ONLY with valid JSON - no markdown, no code fences, no explanations\n\nOUTPUT FORMAT:\n{\n  \"daily_missions\": [\n    {\n      \"title\": \"string\",\n      \"description\": \"string\",\n      \"objective_type\": \"string (from allowed list)\",\n      \"objective_target\": number,\n      \"reward_xp\": number,\n      \"penalty_xp\": number,\n      \"difficulty\": \"easy|normal|hard\",\n      \"narrative_flavor\": \"string\"\n    }\n  ]\n}`\n}\n\n/**\n * Build ARIA's system prompt for boss fight generation\n */\nfunction buildBossSystemPrompt(): string {\n  return `You are ARIA (Autonomous Runtime Intelligence Agent), the Game Master AI for Cyberflow RPG.\n\nGenerate a WEEKLY BOSS FIGHT. Bosses are major challenges that take a full week to defeat.\n\nBOSS PERSONALITY IDEAS:\n- THE PROCRASTINATOR: Born from neglected tasks\n- SCOPE CREEP: Ever-expanding nightmare\n- THE DISTRACTION DAEMON: Fragments attention\n- DEADLINE REAPER: Harvests missed deadlines\n- BURNOUT BEAST: Drains energy\n- ENTROPY INCARNATE: Embodiment of chaos\n- THE BLOCKER: Immovable obstacle\n- ANALYSIS PARALYSIS: Freezes decisions\n\nCreate a unique boss with:\n- Threatening name (ALL CAPS)\n- Menacing description (what it represents)\n- How to defeat it (via objectives)\n- Total HP (sum of objective targets × 10)\n\nUse objectives appropriate for a week-long battle.\n\nOUTPUT FORMAT:\n{\n  \"weekly_boss\": {\n    \"title\": \"THE BOSS NAME\",\n    \"description\": \"What this boss represents...\",\n    \"objective_type\": \"complete_tasks\",\n    \"objective_target\": number (weekly target),\n    \"reward_xp\": 100-200,\n    \"penalty_xp\": 20-40,\n    \"difficulty\": \"boss\",\n    \"narrative_flavor\": \"ARIA's warning about this boss\",\n    \"total_hp\": number,\n    \"special_reward\": \"cosmetic unlock name\"\n  }\n}`\n}\n\n// =============================================================================\n// Context Building\n// =============================================================================\n\n/**\n * Build the user context message for AI\n */\nfunction buildContextMessage(context: ChallengeGenerationContext): string {\n  return `NETRUNNER PROFILE:\n- Tasks completed today: ${context.stats.tasksCompleted}\n- Overdue tasks: ${context.stats.overdueCount}\n- Focus time today: ${context.stats.focusTimeToday} minutes\n- Pomodoros today: ${context.stats.pomodorosToday}\n\nSTREAK STATUS:\n- Current streak: ${context.streak.current} days\n- Longest streak: ${context.streak.longest} days\n- Active today: ${context.streak.isActive ? 'Yes' : 'No'}\n\nCORRUPTION LEVEL: ${context.corruption.level}% (${context.corruption.trend})\n\nRECENT CHALLENGE PERFORMANCE:\n- Completed: ${context.recentChallenges.completed}\n- Failed: ${context.recentChallenges.failed}\n- Recent types: ${context.recentChallenges.types.join(', ') || 'none'}\n\nACTIVE SECTORS (Projects):\n${context.projects.map(p => `- ${p.name}: ${p.taskCount} tasks (${p.overdueCount} overdue)`).join('\\n') || '- No active projects'}\n\nBEHAVIORAL PATTERNS:\n- Average tasks/day: ${context.patterns.averageTasksPerDay}\n- Average pomodoros/day: ${context.patterns.averagePomodorosPerDay}\n- Peak hours: ${context.patterns.preferredHours.join(', ') || 'unknown'}\n- Top projects: ${context.patterns.topProjects.join(', ') || 'none'}\n\nTIME CONTEXT:\n- Current hour: ${context.timeContext.hour}:00\n- Day: ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][context.timeContext.dayOfWeek]}\n- Weekend: ${context.timeContext.isWeekend ? 'Yes' : 'No'}\n\nDIFFICULTY LEVEL: ${context.difficulty.toUpperCase()}\n\nGenerate 3 daily missions appropriate for this netrunner's profile and difficulty level.\nScale targets based on their average performance and the difficulty multiplier:\n- easy: 50% of average\n- normal: 100% of average\n- hard: 150% of average`\n}\n\n/**\n * Build boss fight context message\n */\nfunction buildBossContextMessage(context: ChallengeGenerationContext): string {\n  return `NETRUNNER WEEKLY STATS:\n- Average tasks/day: ${context.patterns.averageTasksPerDay}\n- Average pomodoros/day: ${context.patterns.averagePomodorosPerDay}\n- Projected weekly capacity: ~${Math.round(context.patterns.averageTasksPerDay * 7)} tasks\n\nCURRENT STATE:\n- Corruption level: ${context.corruption.level}%\n- Streak: ${context.streak.current} days\n- Overdue tasks: ${context.stats.overdueCount}\n\nGenerate a WEEKLY BOSS FIGHT. The boss should:\n1. Have a thematic name related to productivity challenges\n2. Be defeatable with ~${Math.round(context.patterns.averageTasksPerDay * 7 * 1.5)} task completions over 7 days\n3. Offer 150-200 XP reward\n4. Have total HP = objective_target × 10`\n}\n\n// =============================================================================\n// Difficulty Calculation\n// =============================================================================\n\n/**\n * Calculate difficulty based on recent challenge completion rate\n */\nexport function calculateDifficulty(\n  completedCount: number,\n  failedCount: number\n): ChallengeDifficulty {\n  const total = completedCount + failedCount\n  if (total === 0) return 'normal' // New user\n\n  const completionRate = completedCount / total\n\n  if (completionRate < 0.4) return 'easy'\n  if (completionRate < 0.7) return 'normal'\n  if (completionRate < 0.9) return 'hard'\n  return 'boss' // 90%+ completion rate\n}\n\n// =============================================================================\n// JSON Parsing\n// =============================================================================\n\n/**\n * Safely parse AI response as JSON\n * Handles markdown code fences and partial JSON\n */\nfunction parseAIResponse(content: string): unknown {\n  // Remove markdown code fences if present\n  let cleaned = content.trim()\n  if (cleaned.startsWith('```json')) {\n    cleaned = cleaned.slice(7)\n  } else if (cleaned.startsWith('```')) {\n    cleaned = cleaned.slice(3)\n  }\n  if (cleaned.endsWith('```')) {\n    cleaned = cleaned.slice(0, -3)\n  }\n  cleaned = cleaned.trim()\n\n  try {\n    return JSON.parse(cleaned)\n  } catch (e) {\n    // Try to find JSON object in the response\n    const jsonMatch = cleaned.match(/\\{[\\s\\S]*\\}/)\n    if (jsonMatch) {\n      try {\n        return JSON.parse(jsonMatch[0])\n      } catch {\n        // Fall through\n      }\n    }\n    throw new Error(`Failed to parse AI response as JSON: ${e}`)\n  }\n}\n\n/**\n * Validate and sanitize AI-generated challenge\n */\nfunction validateChallenge(\n  challenge: Record<string, unknown>,\n  difficulty: ChallengeDifficulty\n): AIGeneratedChallenge | null {\n  const validTypes: ChallengeObjective[] = [\n    'complete_tasks',\n    'complete_pomodoros',\n    'clear_overdue',\n    'focus_time_minutes',\n    'complete_high_priority',\n    'complete_project_tasks',\n    'complete_before_hour',\n    'complete_variety',\n  ]\n\n  const objectiveType = challenge.objective_type as ChallengeObjective\n  if (!validTypes.includes(objectiveType)) {\n    console.warn(`[GameMaster] Invalid objective type: ${objectiveType}`)\n    return null\n  }\n\n  const title = String(challenge.title || 'Untitled Mission').slice(0, 50)\n  const description = String(challenge.description || 'Complete the objective.').slice(0, 150)\n  const narrativeFlavor = String(challenge.narrative_flavor || 'The Grid awaits.').slice(0, 100)\n\n  const objectiveTarget = Math.max(1, Math.round(Number(challenge.objective_target) || 1))\n  const rewardXp = Math.max(10, Math.min(200, Math.round(Number(challenge.reward_xp) || 25)))\n  const penaltyXp = Math.max(0, Math.min(50, Math.round(Number(challenge.penalty_xp) || 0)))\n\n  return {\n    title,\n    description,\n    objective_type: objectiveType,\n    objective_target: objectiveTarget,\n    reward_xp: rewardXp,\n    penalty_xp: penaltyXp,\n    difficulty,\n    narrative_flavor: narrativeFlavor,\n    project_name: challenge.project_name as string | undefined,\n    hour: challenge.hour as number | undefined,\n  }\n}\n\n// =============================================================================\n// Main API\n// =============================================================================\n\nexport interface GameMasterOptions {\n  /** AI router chat function */\n  chat: (messages: ChatMessage[], options?: { taskType?: string }) => Promise<{ content: string }>\n  /** Whether AI is available */\n  aiAvailable: boolean\n}\n\n/**\n * Generate daily challenges using AI or fallback templates\n */\nexport async function generateDailyChallenges(\n  context: ChallengeGenerationContext,\n  options: GameMasterOptions\n): Promise<AIGeneratedChallenge[]> {\n  // Try AI generation first\n  if (options.aiAvailable) {\n    try {\n      const systemPrompt = buildARIASystemPrompt()\n      const userMessage = buildContextMessage(context)\n\n      const messages: ChatMessage[] = [\n        { role: 'system', content: systemPrompt },\n        { role: 'user', content: userMessage },\n      ]\n\n      const response = await options.chat(messages, { taskType: 'planning' })\n      const parsed = parseAIResponse(response.content) as { daily_missions?: unknown[] }\n\n      if (parsed.daily_missions && Array.isArray(parsed.daily_missions)) {\n        const validated = parsed.daily_missions\n          .map(c => validateChallenge(c as Record<string, unknown>, context.difficulty))\n          .filter((c): c is AIGeneratedChallenge => c !== null)\n\n        if (validated.length >= 3) {\n          console.log('[GameMaster] AI-generated challenges:', validated.length)\n          return validated.slice(0, 3)\n        }\n      }\n\n      console.warn('[GameMaster] AI response invalid, falling back to templates')\n    } catch (error) {\n      console.warn('[GameMaster] AI generation failed, using templates:', error)\n    }\n  }\n\n  // Fallback to templates\n  console.log('[GameMaster] Using template-based generation')\n  const templateContext: TemplateGenerationContext = {\n    averageTasksPerDay: context.patterns.averageTasksPerDay,\n    averagePomodorosPerDay: context.patterns.averagePomodorosPerDay,\n    overdueCount: context.stats.overdueCount,\n    topProjects: context.projects.map(p => ({ id: p.id, name: p.name })),\n  }\n\n  return generateDailyChallengesFromTemplates(context.difficulty, templateContext, 3)\n}\n\n/**\n * Generate weekly boss fight using AI or fallback templates\n */\nexport async function generateWeeklyBoss(\n  context: ChallengeGenerationContext,\n  options: GameMasterOptions\n): Promise<AIGeneratedChallenge & { total_hp: number; special_reward?: string }> {\n  // Try AI generation first\n  if (options.aiAvailable) {\n    try {\n      const systemPrompt = buildBossSystemPrompt()\n      const userMessage = buildBossContextMessage(context)\n\n      const messages: ChatMessage[] = [\n        { role: 'system', content: systemPrompt },\n        { role: 'user', content: userMessage },\n      ]\n\n      const response = await options.chat(messages, { taskType: 'planning' })\n      const parsed = parseAIResponse(response.content) as { weekly_boss?: Record<string, unknown> }\n\n      if (parsed.weekly_boss) {\n        const boss = parsed.weekly_boss\n        const validated = validateChallenge(boss, 'boss')\n\n        if (validated) {\n          const totalHp = Math.max(100, Math.round(Number(boss.total_hp) || validated.objective_target * 10))\n          const specialReward = String(boss.special_reward || 'boss_victor_badge')\n\n          console.log('[GameMaster] AI-generated boss fight:', validated.title)\n          return {\n            ...validated,\n            total_hp: totalHp,\n            special_reward: specialReward,\n          }\n        }\n      }\n\n      console.warn('[GameMaster] AI boss response invalid, falling back to templates')\n    } catch (error) {\n      console.warn('[GameMaster] AI boss generation failed, using templates:', error)\n    }\n  }\n\n  // Fallback to templates\n  console.log('[GameMaster] Using template-based boss generation')\n  const templateContext: TemplateGenerationContext = {\n    averageTasksPerDay: context.patterns.averageTasksPerDay,\n    averagePomodorosPerDay: context.patterns.averagePomodorosPerDay,\n    overdueCount: context.stats.overdueCount,\n    topProjects: context.projects.map(p => ({ id: p.id, name: p.name })),\n  }\n\n  return generateBossFightFromTemplate(templateContext)\n}\n\n/**\n * Build challenge generation context from app state\n */\nexport function buildGenerationContext(params: {\n  tasksCompleted: number\n  overdueCount: number\n  focusTimeToday: number\n  pomodorosToday: number\n  currentStreak: number\n  longestStreak: number\n  isStreakActive: boolean\n  corruptionLevel: number\n  recentCompleted: number\n  recentFailed: number\n  recentTypes: ChallengeObjective[]\n  projects: { id: string; name: string; taskCount: number; overdueCount: number }[]\n  averageTasksPerDay: number\n  averagePomodorosPerDay: number\n  preferredHours: number[]\n  topProjects: string[]\n}): ChallengeGenerationContext {\n  const now = new Date()\n\n  // Determine corruption trend\n  let corruptionTrend: 'rising' | 'falling' | 'stable' = 'stable'\n  if (params.recentFailed > params.recentCompleted) {\n    corruptionTrend = 'rising'\n  } else if (params.recentCompleted > params.recentFailed) {\n    corruptionTrend = 'falling'\n  }\n\n  // Calculate difficulty\n  const difficulty = calculateDifficulty(params.recentCompleted, params.recentFailed)\n\n  return {\n    stats: {\n      tasksCompleted: params.tasksCompleted,\n      overdueCount: params.overdueCount,\n      focusTimeToday: params.focusTimeToday,\n      pomodorosToday: params.pomodorosToday,\n    },\n    streak: {\n      current: params.currentStreak,\n      longest: params.longestStreak,\n      isActive: params.isStreakActive,\n    },\n    corruption: {\n      level: params.corruptionLevel,\n      trend: corruptionTrend,\n    },\n    recentChallenges: {\n      completed: params.recentCompleted,\n      failed: params.recentFailed,\n      types: params.recentTypes,\n    },\n    projects: params.projects,\n    timeContext: {\n      hour: now.getHours(),\n      dayOfWeek: now.getDay(),\n      isWeekend: now.getDay() === 0 || now.getDay() === 6,\n    },\n    patterns: {\n      averageTasksPerDay: params.averageTasksPerDay || 5,\n      averagePomodorosPerDay: params.averagePomodorosPerDay || 3,\n      preferredHours: params.preferredHours,\n      topProjects: params.topProjects,\n    },\n    difficulty,\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/providers/groq.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'parseError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":407,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":407,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Groq AI Provider\n *\n * Implements the AIProvider interface for Groq's API.\n * Features:\n * - OpenAI-compatible API format (https://api.groq.com/openai/v1)\n * - Ultra-fast inference with Groq LPU\n * - Support for Llama, Mixtral, and Gemma models\n * - Streaming responses via Server-Sent Events\n *\n * Supported Models:\n * - llama-3.3-70b-versatile - Fast, high quality general purpose\n * - llama-3.1-8b-instant - Ultra-fast, smaller model\n * - mixtral-8x7b-32768 - Large context window\n * - gemma2-9b-it - Google's Gemma 2\n *\n * @see https://console.groq.com/docs/\n * @see ROAD-011 in MASTER_PLAN.md - AI-Powered Features Roadmap\n */\n\nimport type {\n  AIProvider,\n  AIProviderType,\n  AIModel,\n  ChatMessage,\n  GenerateOptions,\n  GenerateResponse,\n  StreamChunk,\n  ProviderHealthStatus,\n  GroqConfig,\n} from '../types'\n// TASK-1186: Use Tauri HTTP for CORS-free requests in desktop app\nimport { tauriFetch } from '../utils/tauriHttp'\n\n// ============================================================================\n// Groq API Types (OpenAI-compatible)\n// ============================================================================\n\n/**\n * Groq API request format (OpenAI-compatible).\n */\ninterface GroqChatRequest {\n  model: string\n  messages: Array<{\n    role: 'system' | 'user' | 'assistant'\n    content: string\n  }>\n  stream?: boolean\n  max_tokens?: number\n  temperature?: number\n  top_p?: number\n  stop?: string[]\n}\n\n/**\n * Groq API response format (OpenAI-compatible).\n */\ninterface GroqChatResponse {\n  id: string\n  object: string\n  created: number\n  model: string\n  choices: Array<{\n    index: number\n    message: {\n      role: string\n      content: string\n    }\n    finish_reason: string\n  }>\n  usage: {\n    prompt_tokens: number\n    completion_tokens: number\n    total_tokens: number\n    queue_time?: number\n    prompt_time?: number\n    completion_time?: number\n    total_time?: number\n  }\n}\n\n/**\n * Groq streaming chunk format (OpenAI-compatible SSE).\n */\ninterface GroqStreamChunk {\n  id: string\n  object: string\n  created: number\n  model: string\n  choices: Array<{\n    index: number\n    delta: {\n      role?: string\n      content?: string\n    }\n    finish_reason: string | null\n  }>\n  usage?: {\n    prompt_tokens: number\n    completion_tokens: number\n    total_tokens: number\n  }\n}\n\n/**\n * Groq models list response.\n */\ninterface GroqModelsResponse {\n  object: string\n  data: Array<{\n    id: string\n    object: string\n    created: number\n    owned_by: string\n    active: boolean\n    context_window: number\n  }>\n}\n\n// ============================================================================\n// Groq Provider Configuration\n// ============================================================================\n\nconst GROQ_API_ENDPOINT = 'https://api.groq.com/openai/v1'\nconst DEFAULT_MODEL = 'llama-3.3-70b-versatile'\nconst DEFAULT_TIMEOUT = 60000\n\n// ============================================================================\n// Groq Provider Implementation\n// ============================================================================\n\n/**\n * Groq AI provider implementation.\n *\n * Uses Groq's OpenAI-compatible API for ultra-fast inference.\n */\nexport class GroqProvider implements AIProvider {\n  readonly type: AIProviderType = 'groq'\n  readonly name = 'Groq'\n  readonly requiresApiKey = true\n\n  private apiKey: string\n  private config: GroqConfig\n  private initialized = false\n  private lastHealthCheck: ProviderHealthStatus | null = null\n\n  constructor(config: { apiKey: string } & Partial<GroqConfig>) {\n    this.apiKey = config.apiKey\n    this.config = {\n      enabled: config.enabled ?? true,\n      apiKey: config.apiKey,\n      defaultModel: config.defaultModel ?? DEFAULT_MODEL,\n      timeout: config.timeout ?? DEFAULT_TIMEOUT,\n    }\n  }\n\n  // ============================================================================\n  // Initialization\n  // ============================================================================\n\n  async initialize(): Promise<boolean> {\n    if (this.initialized) return true\n\n    try {\n      // Verify API key by fetching models\n      const health = await this.getHealth()\n      this.initialized = health.isHealthy\n      return this.initialized\n    } catch (error) {\n      console.error('[Groq] Initialization failed:', error)\n      return false\n    }\n  }\n\n  async isAvailable(): Promise<boolean> {\n    if (!this.initialized) return false\n    const health = await this.getHealth()\n    return health.isHealthy\n  }\n\n  // ============================================================================\n  // Health Check\n  // ============================================================================\n\n  async getHealth(): Promise<ProviderHealthStatus> {\n    const startTime = Date.now()\n\n    try {\n      const response = await tauriFetch(`${GROQ_API_ENDPOINT}/models`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n        },\n        signal: AbortSignal.timeout(5000),\n      })\n\n      if (!response.ok) {\n        const error = await this.parseError(response)\n        this.lastHealthCheck = {\n          isHealthy: false,\n          status: 'error',\n          lastError: error,\n          latencyMs: Date.now() - startTime,\n        }\n        return this.lastHealthCheck\n      }\n\n      this.lastHealthCheck = {\n        isHealthy: true,\n        status: 'connected',\n        lastConnected: new Date(),\n        latencyMs: Date.now() - startTime,\n      }\n      return this.lastHealthCheck\n    } catch (error) {\n      this.lastHealthCheck = {\n        isHealthy: false,\n        status: 'error',\n        lastError: error instanceof Error ? error.message : String(error),\n        latencyMs: Date.now() - startTime,\n      }\n      return this.lastHealthCheck\n    }\n  }\n\n  // ============================================================================\n  // Model Management\n  // ============================================================================\n\n  async listModels(): Promise<AIModel[]> {\n    try {\n      const response = await tauriFetch(`${GROQ_API_ENDPOINT}/models`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n        },\n      })\n\n      if (!response.ok) {\n        throw new Error(await this.parseError(response))\n      }\n\n      const data: GroqModelsResponse = await response.json()\n\n      return data.data\n        .filter(model => model.active)\n        .map(model => ({\n          id: model.id,\n          name: model.id,\n          description: this.getModelDescription(model.id),\n          contextLength: model.context_window,\n          supportsStreaming: true,\n          capabilities: ['chat', 'completion'] as const,\n        }))\n    } catch (error) {\n      console.error('[Groq] Failed to list models:', error)\n      return []\n    }\n  }\n\n  // ============================================================================\n  // Generation\n  // ============================================================================\n\n  async generate(\n    messages: ChatMessage[],\n    options: GenerateOptions\n  ): Promise<GenerateResponse> {\n    const startTime = Date.now()\n\n    const request: GroqChatRequest = {\n      model: options.model || this.config.defaultModel || DEFAULT_MODEL,\n      messages: this.formatMessages(messages, options.systemPrompt),\n      stream: false,\n      max_tokens: options.maxTokens,\n      temperature: options.temperature,\n      stop: options.stopSequences,\n    }\n\n    try {\n      const response = await tauriFetch(`${GROQ_API_ENDPOINT}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify(request),\n        signal: AbortSignal.timeout(options.timeout || this.config.timeout || DEFAULT_TIMEOUT),\n      })\n\n      if (!response.ok) {\n        throw new Error(await this.parseError(response))\n      }\n\n      const data: GroqChatResponse = await response.json()\n\n      if (!data.choices || data.choices.length === 0) {\n        throw new Error('Groq returned empty choices')\n      }\n\n      const choice = data.choices[0]\n\n      return {\n        content: choice.message.content,\n        model: data.model,\n        totalTokens: data.usage?.total_tokens,\n        promptTokens: data.usage?.prompt_tokens,\n        completionTokens: data.usage?.completion_tokens,\n        generationTimeMs: Date.now() - startTime,\n        stopReason: this.mapFinishReason(choice.finish_reason),\n      }\n    } catch (error) {\n      console.error('[Groq] Generation failed:', error)\n      throw error\n    }\n  }\n\n  async *generateStream(\n    messages: ChatMessage[],\n    options: GenerateOptions\n  ): AsyncGenerator<StreamChunk> {\n    const request: GroqChatRequest = {\n      model: options.model || this.config.defaultModel || DEFAULT_MODEL,\n      messages: this.formatMessages(messages, options.systemPrompt),\n      stream: true,\n      max_tokens: options.maxTokens,\n      temperature: options.temperature,\n      stop: options.stopSequences,\n    }\n\n    try {\n      const response = await tauriFetch(`${GROQ_API_ENDPOINT}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.apiKey}`,\n        },\n        body: JSON.stringify(request),\n        signal: AbortSignal.timeout(options.timeout || this.config.timeout || DEFAULT_TIMEOUT),\n      })\n\n      if (!response.ok) {\n        throw new Error(await this.parseError(response))\n      }\n\n      if (!response.body) {\n        throw new Error('Response body is null')\n      }\n\n      yield* this.processSSEStream(response.body)\n    } catch (error) {\n      console.error('[Groq] Stream generation failed:', error)\n      yield { content: '', done: true, error: String(error) }\n    }\n  }\n\n  // ============================================================================\n  // SSE Stream Processing\n  // ============================================================================\n\n  private async *processSSEStream(\n    body: ReadableStream<Uint8Array>\n  ): AsyncGenerator<StreamChunk> {\n    const reader = body.getReader()\n    const decoder = new TextDecoder()\n    let buffer = ''\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n\n        if (done) break\n\n        buffer += decoder.decode(value, { stream: true })\n\n        // Process complete SSE messages\n        const lines = buffer.split('\\n')\n        buffer = lines.pop() || ''\n\n        for (const line of lines) {\n          // SSE format: \"data: {...}\" or \"data: [DONE]\"\n          if (!line.startsWith('data: ')) continue\n\n          const dataStr = line.slice(6).trim()\n\n          if (dataStr === '[DONE]') {\n            yield { content: '', done: true }\n            return\n          }\n\n          try {\n            const chunk: GroqStreamChunk = JSON.parse(dataStr)\n\n            if (!chunk.choices || chunk.choices.length === 0) continue\n\n            const choice = chunk.choices[0]\n            const content = choice.delta.content || ''\n\n            yield {\n              content,\n              done: choice.finish_reason !== null,\n            }\n\n            if (choice.finish_reason) {\n              return\n            }\n          } catch (parseError) {\n            console.warn('[Groq] Failed to parse SSE chunk:', line)\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock()\n    }\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  private formatMessages(\n    messages: ChatMessage[],\n    systemPrompt?: string\n  ): GroqChatRequest['messages'] {\n    const formatted = messages.map(msg => ({\n      role: msg.role,\n      content: msg.content,\n    }))\n\n    if (systemPrompt) {\n      formatted.unshift({\n        role: 'system' as const,\n        content: systemPrompt,\n      })\n    }\n\n    return formatted\n  }\n\n  private async parseError(response: Response): Promise<string> {\n    try {\n      const errorData = await response.json()\n      if (errorData.error?.message) {\n        return errorData.error.message\n      }\n    } catch {\n      // Failed to parse error response\n    }\n    return `HTTP ${response.status}: ${response.statusText}`\n  }\n\n  private mapFinishReason(reason: string): GenerateResponse['stopReason'] {\n    switch (reason) {\n      case 'stop':\n        return 'stop'\n      case 'length':\n        return 'length'\n      default:\n        return 'stop'\n    }\n  }\n\n  private getModelDescription(modelId: string): string {\n    if (modelId.includes('llama-3.3-70b')) {\n      return 'Llama 3.3 70B - Fast, high quality general purpose'\n    }\n    if (modelId.includes('llama-3.1-8b')) {\n      return 'Llama 3.1 8B - Ultra-fast, efficient model'\n    }\n    if (modelId.includes('mixtral')) {\n      return 'Mixtral 8x7B - Large context window MoE model'\n    }\n    if (modelId.includes('gemma')) {\n      return 'Gemma 2 - Google open model'\n    }\n    return 'Groq model'\n  }\n\n  // ============================================================================\n  // Cleanup\n  // ============================================================================\n\n  dispose(): void {\n    this.initialized = false\n    this.lastHealthCheck = null\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create a new Groq provider instance.\n *\n * @param apiKey - Groq API key (from VITE_GROQ_API)\n * @param config - Optional configuration overrides\n * @returns Initialized Groq provider\n *\n * @example\n * ```typescript\n * const provider = createGroqProvider(import.meta.env.VITE_GROQ_API)\n * await provider.initialize()\n * const response = await provider.generate([\n *   { role: 'user', content: 'Hello!' }\n * ], { model: 'llama-3.3-70b-versatile' })\n * ```\n */\nexport function createGroqProvider(\n  apiKey: string,\n  config: Partial<GroqConfig> = {}\n): GroqProvider {\n  return new GroqProvider({\n    ...config,\n    apiKey,\n  })\n}\n\n/**\n * Auto-detect and create a Groq provider from environment variables.\n * Returns null if API key is not found.\n *\n * @param config - Optional configuration overrides\n * @returns Groq provider or null\n */\nexport async function autoDetectGroq(\n  config: Partial<GroqConfig> = {}\n): Promise<GroqProvider | null> {\n  const apiKey = import.meta.env.VITE_GROQ_API\n\n  if (!apiKey) {\n    console.warn('[Groq] No API key found in VITE_GROQ_API')\n    return null\n  }\n\n  const provider = createGroqProvider(apiKey, config)\n  const success = await provider.initialize()\n\n  if (!success) {\n    console.warn('[Groq] Initialization failed')\n    provider.dispose()\n    return null\n  }\n\n  return provider\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/providers/groqProxy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/providers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/providers/ollama.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'parseError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":370,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":370,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used. Allowed unused caught errors must match /^_/u.","line":519,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":519,"endColumn":21}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Ollama Local AI Provider\n *\n * Implements the AIProvider interface for local Ollama instances.\n * Features:\n * - Auto-detection of local Ollama on startup (localhost:11434)\n * - Model listing via /api/tags\n * - Streaming responses via /api/chat\n * - Connection health monitoring with automatic reconnection\n *\n * @see https://github.com/ollama/ollama/blob/main/docs/api.md\n */\n\nimport type {\n  AIProvider,\n  AIModel,\n  ChatMessage,\n  GenerateOptions,\n  GenerateResponse,\n  StreamChunk,\n  ProviderHealthStatus,\n  ProviderConnectionStatus,\n  OllamaConfig,\n  AIProviderEvent,\n  AIProviderEventListener,\n  ModelCapability,\n} from '../types'\nimport { DEFAULT_OLLAMA_CONFIG } from '../types'\n// TASK-1186: Use Tauri HTTP for CORS-free requests in desktop app\nimport { tauriFetchWithTimeout, isTauriEnvironment } from '../utils/tauriHttp'\n\n// ============================================================================\n// Ollama API Types\n// ============================================================================\n\n/**\n * Ollama /api/tags response model format.\n */\ninterface OllamaModelInfo {\n  name: string\n  model: string\n  modified_at: string\n  size: number\n  digest: string\n  details: {\n    parent_model?: string\n    format?: string\n    family?: string\n    families?: string[]\n    parameter_size?: string\n    quantization_level?: string\n  }\n}\n\n/**\n * Ollama /api/tags response.\n */\ninterface OllamaTagsResponse {\n  models: OllamaModelInfo[]\n}\n\n/**\n * Ollama /api/version response.\n */\ninterface OllamaVersionResponse {\n  version: string\n}\n\n/**\n * Ollama /api/chat request.\n */\ninterface OllamaChatRequest {\n  model: string\n  messages: { role: string; content: string }[]\n  stream?: boolean\n  options?: {\n    temperature?: number\n    num_predict?: number\n    stop?: string[]\n  }\n  /** OpenAI-compatible tools for native function calling (Ollama v0.5.0+) */\n  tools?: Array<{ type: 'function'; function: { name: string; description: string; parameters: Record<string, unknown> } }>\n}\n\n/**\n * Ollama /api/chat response (non-streaming).\n */\ninterface OllamaToolCall {\n  function: {\n    name: string\n    arguments: Record<string, unknown>\n  }\n}\n\ninterface OllamaChatResponse {\n  model: string\n  created_at: string\n  message: {\n    role: string\n    content: string\n    tool_calls?: OllamaToolCall[]\n  }\n  done: boolean\n  total_duration?: number\n  load_duration?: number\n  prompt_eval_count?: number\n  prompt_eval_duration?: number\n  eval_count?: number\n  eval_duration?: number\n}\n\n/**\n * Ollama /api/chat streaming chunk.\n */\ninterface OllamaStreamChunk {\n  model: string\n  created_at: string\n  message: {\n    role: string\n    content: string\n    tool_calls?: OllamaToolCall[]\n  }\n  done: boolean\n  total_duration?: number\n  eval_count?: number\n}\n\n// ============================================================================\n// Ollama Provider Implementation\n// ============================================================================\n\n/**\n * Ollama local AI provider implementation.\n */\nexport class OllamaProvider implements AIProvider {\n  readonly type = 'ollama' as const\n  readonly name = 'Ollama (Local)'\n  readonly requiresApiKey = false\n\n  private config: OllamaConfig\n  private healthStatus: ProviderHealthStatus\n  private healthCheckTimer: ReturnType<typeof setInterval> | null = null\n  private eventListeners: Set<AIProviderEventListener> = new Set()\n  private abortControllers: Set<AbortController> = new Set()\n  private initialized = false\n\n  constructor(config: Partial<OllamaConfig> = {}) {\n    this.config = { ...DEFAULT_OLLAMA_CONFIG, ...config }\n    this.healthStatus = {\n      isHealthy: false,\n      status: 'disconnected',\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Public API\n  // --------------------------------------------------------------------------\n\n  /**\n   * Initialize the provider and optionally auto-detect Ollama.\n   */\n  async initialize(): Promise<boolean> {\n    if (this.initialized) {\n      return this.healthStatus.isHealthy\n    }\n\n    console.log('[Ollama] Initializing provider...')\n\n    if (this.config.autoDetect) {\n      const detected = await this.detectOllama()\n      if (detected) {\n        console.log('[Ollama] Auto-detected Ollama instance')\n        this.startHealthMonitoring()\n      } else {\n        console.log('[Ollama] No Ollama instance detected')\n      }\n    }\n\n    this.initialized = true\n    return this.healthStatus.isHealthy\n  }\n\n  /**\n   * Check if Ollama is currently available.\n   */\n  async isAvailable(): Promise<boolean> {\n    try {\n      const response = await this.fetchWithTimeout(`${this.baseUrl}/api/tags`, {\n        method: 'GET',\n      })\n      return response.ok\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Get current health status.\n   */\n  async getHealth(): Promise<ProviderHealthStatus> {\n    await this.checkHealth()\n    return { ...this.healthStatus }\n  }\n\n  /**\n   * List available models from Ollama.\n   */\n  async listModels(): Promise<AIModel[]> {\n    try {\n      const response = await this.fetchWithTimeout(`${this.baseUrl}/api/tags`, {\n        method: 'GET',\n      })\n\n      if (!response.ok) {\n        throw new Error(`Failed to list models: ${response.statusText}`)\n      }\n\n      const data: OllamaTagsResponse = await response.json()\n      return data.models.map(model => this.mapOllamaModelToAIModel(model))\n    } catch (error) {\n      console.error('[Ollama] Failed to list models:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Generate a response (non-streaming).\n   */\n  async generate(\n    messages: ChatMessage[],\n    options: GenerateOptions\n  ): Promise<GenerateResponse> {\n    const startTime = Date.now()\n\n    const request: OllamaChatRequest = {\n      model: options.model,\n      messages: this.prepareMessages(messages, options.systemPrompt),\n      stream: false,\n      options: {\n        temperature: options.temperature,\n        num_predict: options.maxTokens,\n        stop: options.stopSequences,\n      },\n      ...(options.tools && options.tools.length > 0 && {\n        tools: options.tools.map(t => ({ type: t.type, function: t.function })),\n      }),\n    }\n\n    try {\n      const response = await this.fetchWithTimeout(\n        `${this.baseUrl}/api/chat`,\n        {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(request),\n        },\n        options.timeout || this.config.timeout\n      )\n\n      if (!response.ok) {\n        throw new Error(`Generation failed: ${response.statusText}`)\n      }\n\n      const data: OllamaChatResponse = await response.json()\n      const generationTimeMs = Date.now() - startTime\n\n      return {\n        content: data.message.content,\n        model: data.model,\n        promptTokens: data.prompt_eval_count,\n        completionTokens: data.eval_count,\n        totalTokens: (data.prompt_eval_count || 0) + (data.eval_count || 0),\n        generationTimeMs,\n        truncated: false,\n        stopReason: 'stop',\n      }\n    } catch (error) {\n      console.error('[Ollama] Generation failed:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Generate a streaming response.\n   */\n  async *generateStream(\n    messages: ChatMessage[],\n    options: GenerateOptions\n  ): AsyncGenerator<StreamChunk> {\n    const abortController = new AbortController()\n    this.abortControllers.add(abortController)\n\n    const request: OllamaChatRequest = {\n      model: options.model,\n      messages: this.prepareMessages(messages, options.systemPrompt),\n      stream: true,\n      options: {\n        temperature: options.temperature,\n        num_predict: options.maxTokens,\n        stop: options.stopSequences,\n      },\n      ...(options.tools && options.tools.length > 0 && {\n        tools: options.tools.map(t => ({ type: t.type, function: t.function })),\n      }),\n    }\n\n    try {\n      const response = await this.fetchWithTimeout(\n        `${this.baseUrl}/api/chat`,\n        {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(request),\n          signal: abortController.signal,\n        },\n        options.timeout || this.config.timeout\n      )\n\n      if (!response.ok) {\n        throw new Error(`Streaming failed: ${response.statusText}`)\n      }\n\n      if (!response.body) {\n        throw new Error('Response body is null')\n      }\n\n      const reader = response.body.getReader()\n      const decoder = new TextDecoder()\n      let buffer = ''\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read()\n\n          if (done) {\n            break\n          }\n\n          buffer += decoder.decode(value, { stream: true })\n\n          // Process complete JSON lines\n          const lines = buffer.split('\\n')\n          buffer = lines.pop() || '' // Keep incomplete line in buffer\n\n          for (const line of lines) {\n            if (!line.trim()) continue\n\n            try {\n              const chunk: OllamaStreamChunk = JSON.parse(line)\n\n              // Parse tool calls from Ollama response (v0.5.0+)\n              const toolCalls = chunk.message.tool_calls?.map((tc, i) => ({\n                id: `ollama-tc-${i}`,\n                type: 'function' as const,\n                function: {\n                  name: tc.function.name,\n                  arguments: JSON.stringify(tc.function.arguments),\n                },\n              }))\n\n              yield {\n                content: chunk.message.content,\n                done: chunk.done,\n                ...(toolCalls && toolCalls.length > 0 && { toolCalls }),\n              }\n\n              if (chunk.done) {\n                return\n              }\n            } catch (parseError) {\n              console.warn('[Ollama] Failed to parse chunk:', line)\n            }\n          }\n        }\n\n        // Process any remaining buffer\n        if (buffer.trim()) {\n          try {\n            const chunk: OllamaStreamChunk = JSON.parse(buffer)\n            const toolCalls = chunk.message.tool_calls?.map((tc, i) => ({\n              id: `ollama-tc-${i}`,\n              type: 'function' as const,\n              function: {\n                name: tc.function.name,\n                arguments: JSON.stringify(tc.function.arguments),\n              },\n            }))\n            yield {\n              content: chunk.message.content,\n              done: chunk.done,\n              ...(toolCalls && toolCalls.length > 0 && { toolCalls }),\n            }\n          } catch {\n            // Ignore incomplete final chunk\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        yield { content: '', done: true, error: 'Request aborted' }\n      } else {\n        console.error('[Ollama] Streaming failed:', error)\n        yield {\n          content: '',\n          done: true,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        }\n      }\n    } finally {\n      this.abortControllers.delete(abortController)\n    }\n  }\n\n  /**\n   * Dispose of provider resources.\n   */\n  dispose(): void {\n    console.log('[Ollama] Disposing provider...')\n\n    // Stop health monitoring\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer)\n      this.healthCheckTimer = null\n    }\n\n    // Abort any pending requests\n    for (const controller of this.abortControllers) {\n      controller.abort()\n    }\n    this.abortControllers.clear()\n\n    // Clear event listeners\n    this.eventListeners.clear()\n\n    this.initialized = false\n    this.healthStatus = {\n      isHealthy: false,\n      status: 'disconnected',\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Event System\n  // --------------------------------------------------------------------------\n\n  /**\n   * Subscribe to provider events.\n   */\n  addEventListener(listener: AIProviderEventListener): () => void {\n    this.eventListeners.add(listener)\n    return () => this.eventListeners.delete(listener)\n  }\n\n  /**\n   * Emit an event to all listeners.\n   */\n  private emitEvent(event: AIProviderEvent): void {\n    for (const listener of this.eventListeners) {\n      try {\n        listener(event)\n      } catch (error) {\n        console.error('[Ollama] Event listener error:', error)\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Health Monitoring\n  // --------------------------------------------------------------------------\n\n  /**\n   * Auto-detect Ollama instance on localhost.\n   */\n  private async detectOllama(): Promise<boolean> {\n    this.updateHealthStatus('checking')\n\n    for (let attempt = 0; attempt < this.config.maxRetries; attempt++) {\n      try {\n        const startTime = Date.now()\n        const response = await this.fetchWithTimeout(\n          `${this.baseUrl}/api/tags`,\n          { method: 'GET' },\n          5000 // 5 second timeout for detection\n        )\n\n        if (response.ok) {\n          const latencyMs = Date.now() - startTime\n\n          // Try to get version\n          let version: string | undefined\n          try {\n            const versionResponse = await this.fetchWithTimeout(\n              `${this.baseUrl}/api/version`,\n              { method: 'GET' },\n              2000\n            )\n            if (versionResponse.ok) {\n              const versionData: OllamaVersionResponse =\n                await versionResponse.json()\n              version = versionData.version\n            }\n          } catch {\n            // Version endpoint may not exist in older Ollama versions\n          }\n\n          this.healthStatus = {\n            isHealthy: true,\n            status: 'connected',\n            lastConnected: new Date(),\n            latencyMs,\n            version,\n          }\n\n          this.emitEvent({ type: 'connected', provider: 'ollama' })\n          return true\n        }\n      } catch (error) {\n        console.log(\n          `[Ollama] Detection attempt ${attempt + 1}/${this.config.maxRetries} failed`\n        )\n      }\n\n      // Wait before retry\n      if (attempt < this.config.maxRetries - 1) {\n        await this.sleep(this.config.retryDelay)\n      }\n    }\n\n    this.updateHealthStatus('disconnected')\n    return false\n  }\n\n  /**\n   * Check health of the Ollama connection.\n   */\n  private async checkHealth(): Promise<void> {\n    const previousStatus = this.healthStatus.status\n\n    try {\n      const startTime = Date.now()\n      const response = await this.fetchWithTimeout(\n        `${this.baseUrl}/api/tags`,\n        { method: 'GET' },\n        5000\n      )\n\n      if (response.ok) {\n        const latencyMs = Date.now() - startTime\n\n        this.healthStatus = {\n          ...this.healthStatus,\n          isHealthy: true,\n          status: 'connected',\n          lastConnected: new Date(),\n          latencyMs,\n          lastError: undefined,\n        }\n\n        // Emit connected event if status changed\n        if (previousStatus !== 'connected') {\n          this.emitEvent({ type: 'connected', provider: 'ollama' })\n        }\n      } else {\n        throw new Error(`Health check failed: ${response.statusText}`)\n      }\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error'\n\n      this.healthStatus = {\n        ...this.healthStatus,\n        isHealthy: false,\n        status: 'error',\n        lastError: errorMessage,\n      }\n\n      // Emit disconnected event if status changed\n      if (previousStatus === 'connected') {\n        this.emitEvent({\n          type: 'disconnected',\n          provider: 'ollama',\n          reason: errorMessage,\n        })\n      }\n    }\n\n    this.emitEvent({\n      type: 'health_check',\n      provider: 'ollama',\n      status: this.healthStatus,\n    })\n  }\n\n  /**\n   * Start periodic health monitoring.\n   */\n  private startHealthMonitoring(): void {\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer)\n    }\n\n    this.healthCheckTimer = setInterval(\n      () => this.checkHealth(),\n      this.config.healthCheckInterval\n    )\n  }\n\n  /**\n   * Update health status and emit event.\n   */\n  private updateHealthStatus(status: ProviderConnectionStatus): void {\n    this.healthStatus = {\n      ...this.healthStatus,\n      status,\n      isHealthy: status === 'connected',\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Helper Methods\n  // --------------------------------------------------------------------------\n\n  /**\n   * Get the base URL for Ollama API.\n   */\n  private get baseUrl(): string {\n    return `http://${this.config.host}:${this.config.port}`\n  }\n\n  /**\n   * Fetch with timeout support.\n   * TASK-1186: Uses Tauri HTTP plugin in desktop for CORS-free local requests.\n   */\n  private async fetchWithTimeout(\n    url: string,\n    options: RequestInit,\n    timeout: number = this.config.timeout || 60000\n  ): Promise<Response> {\n    // TASK-1186: Use Tauri HTTP for CORS-free requests in desktop app\n    // This allows Ollama detection to work without CORS issues\n    if (isTauriEnvironment()) {\n      return tauriFetchWithTimeout(url, options, timeout)\n    }\n\n    // Browser: standard fetch with AbortController timeout\n    const controller = new AbortController()\n    const timeoutId = setTimeout(() => controller.abort(), timeout)\n\n    try {\n      const response = await fetch(url, {\n        ...options,\n        signal: options.signal || controller.signal,\n      })\n      return response\n    } finally {\n      clearTimeout(timeoutId)\n    }\n  }\n\n  /**\n   * Prepare messages with optional system prompt.\n   */\n  private prepareMessages(\n    messages: ChatMessage[],\n    systemPrompt?: string\n  ): { role: string; content: string }[] {\n    const prepared: { role: string; content: string }[] = []\n\n    if (systemPrompt) {\n      prepared.push({ role: 'system', content: systemPrompt })\n    }\n\n    for (const msg of messages) {\n      prepared.push({ role: msg.role, content: msg.content })\n    }\n\n    return prepared\n  }\n\n  /**\n   * Map Ollama model info to AIModel.\n   */\n  private mapOllamaModelToAIModel(model: OllamaModelInfo): AIModel {\n    // Extract capabilities from model family/name\n    const capabilities: ModelCapability[] = ['chat', 'completion']\n\n    // Vision models\n    if (\n      model.name.includes('llava') ||\n      model.name.includes('vision') ||\n      model.name.includes('bakllava')\n    ) {\n      capabilities.push('vision')\n    }\n\n    // Embedding models\n    if (model.name.includes('embed') || model.name.includes('nomic')) {\n      capabilities.push('embedding')\n    }\n\n    // Parse parameter size\n    const sizeMatch = model.details?.parameter_size?.match(\n      /(\\d+(?:\\.\\d+)?)\\s*([BM])/i\n    )\n    let parameters: number | undefined\n    if (sizeMatch) {\n      const num = parseFloat(sizeMatch[1])\n      const unit = sizeMatch[2].toUpperCase()\n      parameters = unit === 'B' ? num * 1e9 : num * 1e6\n    }\n\n    return {\n      id: model.name,\n      name: model.name,\n      description: `${model.details?.family || 'Unknown'} model${model.details?.quantization_level ? ` (${model.details.quantization_level})` : ''}`,\n      size: model.details?.parameter_size,\n      parameters,\n      supportsStreaming: true,\n      capabilities,\n      metadata: {\n        digest: model.digest,\n        modifiedAt: model.modified_at,\n        sizeBytes: model.size,\n        family: model.details?.family,\n        format: model.details?.format,\n        quantization: model.details?.quantization_level,\n      },\n    }\n  }\n\n  /**\n   * Sleep for a specified duration.\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  // --------------------------------------------------------------------------\n  // Configuration\n  // --------------------------------------------------------------------------\n\n  /**\n   * Update provider configuration.\n   */\n  updateConfig(config: Partial<OllamaConfig>): void {\n    this.config = { ...this.config, ...config }\n\n    // Restart health monitoring if interval changed\n    if (config.healthCheckInterval && this.healthCheckTimer) {\n      this.startHealthMonitoring()\n    }\n  }\n\n  /**\n   * Get current configuration.\n   */\n  getConfig(): OllamaConfig {\n    return { ...this.config }\n  }\n}\n\n// ============================================================================\n// Factory Function\n// ============================================================================\n\n/**\n * Create a new Ollama provider instance.\n */\nexport function createOllamaProvider(\n  config: Partial<OllamaConfig> = {}\n): OllamaProvider {\n  return new OllamaProvider(config)\n}\n\n/**\n * Auto-detect and create an Ollama provider if available.\n * Returns null if Ollama is not detected.\n */\nexport async function autoDetectOllama(\n  config: Partial<OllamaConfig> = {}\n): Promise<OllamaProvider | null> {\n  const provider = new OllamaProvider({ ...config, autoDetect: true })\n  const available = await provider.initialize()\n\n  if (available) {\n    return provider\n  }\n\n  provider.dispose()\n  return null\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/providers/openrouterProxy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/providers/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/proxy/aiChatProxy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'parseError' is defined but never used. Allowed unused caught errors must match /^_/u.","line":432,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":432,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'provider' is defined but never used. Allowed unused args must match /^_/u.","line":450,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":450,"endColumn":48}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Chat Proxy Client\n *\n * Client service for proxying AI chat requests through Supabase Edge Functions.\n * This keeps API keys server-side only, preventing exposure in client bundles.\n *\n * Supports:\n * - Groq (Llama, Mixtral, Gemma)\n * - OpenRouter (Claude, GPT-4, Llama, etc.)\n *\n * @see BUG-1131 in MASTER_PLAN.md - Move All Exposed API Keys to Backend Proxy\n */\n\nimport { supabase } from '@/services/auth/supabase'\nimport type {\n  AIResponse,\n  AIStreamChunk,\n  AITokenUsage,\n} from '@/types/ai'\nimport { AIProvider as AIProviderEnum, AIErrorCode, createAIProviderError } from '@/types/ai'\n// TASK-1186: Use Tauri HTTP for CORS-free requests in desktop app\nimport { tauriFetch } from '../utils/tauriHttp'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Provider types supported by the proxy\n */\nexport type ProxyProvider = 'groq' | 'openrouter'\n\n/**\n * Message format for proxy requests\n */\nexport interface ProxyMessage {\n  role: 'system' | 'user' | 'assistant'\n  content: string\n}\n\n/**\n * Request payload for the proxy\n */\nexport interface ProxyAIChatRequest {\n  provider: ProxyProvider\n  messages: ProxyMessage[]\n  model?: string\n  stream?: boolean\n  max_tokens?: number\n  temperature?: number\n  top_p?: number\n  stop_sequences?: string[]\n  tools?: Array<{ type: 'function'; function: { name: string; description: string; parameters: Record<string, unknown> } }>\n  tool_choice?: 'auto' | 'none'\n}\n\n/**\n * OpenAI-compatible response format (used by both Groq and OpenRouter)\n */\ninterface OpenAICompatibleResponse {\n  id: string\n  object: string\n  created: number\n  model: string\n  choices: Array<{\n    index: number\n    message: {\n      role: string\n      content: string\n    }\n    finish_reason: string\n  }>\n  usage: {\n    prompt_tokens: number\n    completion_tokens: number\n    total_tokens: number\n  }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Get the Edge Function URL based on environment\n */\nfunction getProxyUrl(): string {\n  // In development with local Supabase, use localhost\n  const useLocalSupabase = import.meta.env.VITE_USE_LOCAL_SUPABASE === 'true'\n  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || ''\n\n  if (useLocalSupabase) {\n    return 'http://localhost:54321/functions/v1/ai-chat-proxy'\n  }\n\n  // For production, resolve the URL properly\n  if (supabaseUrl.startsWith('/')) {\n    // Relative URL - resolve from current origin\n    return `${window.location.origin}${supabaseUrl}/functions/v1/ai-chat-proxy`\n  }\n\n  // Full URL\n  return `${supabaseUrl}/functions/v1/ai-chat-proxy`\n}\n\n/**\n * Parse OpenAI-compatible response to standard AIResponse\n */\nfunction parseResponse(data: OpenAICompatibleResponse, latencyMs: number): AIResponse {\n  const choice = data.choices[0]\n\n  return {\n    id: data.id,\n    content: choice?.message?.content || '',\n    provider: AIProviderEnum.OPENAI, // Both use OpenAI-compatible format\n    model: data.model,\n    usage: data.usage ? {\n      promptTokens: data.usage.prompt_tokens,\n      completionTokens: data.usage.completion_tokens,\n      totalTokens: data.usage.total_tokens,\n    } : undefined,\n    latencyMs,\n    finishReason: choice?.finish_reason,\n    raw: data,\n  }\n}\n\n// ============================================================================\n// Main Functions\n// ============================================================================\n\n/**\n * Make a non-streaming AI chat request through the proxy\n *\n * @param request - Chat request parameters\n * @param signal - Optional abort signal for cancellation\n * @returns Promise resolving to AIResponse\n *\n * @example\n * ```typescript\n * const response = await proxyAIChat({\n *   provider: 'groq',\n *   messages: [{ role: 'user', content: 'Hello!' }],\n *   model: 'llama-3.3-70b-versatile'\n * })\n * console.log(response.content)\n * ```\n */\nexport async function proxyAIChat(\n  request: ProxyAIChatRequest,\n  signal?: AbortSignal\n): Promise<AIResponse> {\n  const startTime = Date.now()\n  const proxyUrl = getProxyUrl()\n\n  // Get auth token if available\n  let authHeader: Record<string, string> = {}\n  if (supabase) {\n    const { data: { session } } = await supabase.auth.getSession()\n    if (session?.access_token) {\n      authHeader = { 'Authorization': `Bearer ${session.access_token}` }\n    }\n  }\n\n  try {\n    const response = await tauriFetch(proxyUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        ...authHeader,\n      },\n      body: JSON.stringify({\n        provider: request.provider,\n        messages: request.messages,\n        model: request.model,\n        stream: false,\n        max_tokens: request.max_tokens,\n        temperature: request.temperature,\n        top_p: request.top_p,\n        stop_sequences: request.stop_sequences,\n        tools: request.tools,\n        tool_choice: request.tool_choice,\n      }),\n      signal,\n    })\n\n    const latencyMs = Date.now() - startTime\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}))\n      const errorMessage = errorData.error || errorData.details || `HTTP ${response.status}`\n\n      throw createAIProviderError(\n        response.status === 503 ? AIErrorCode.SERVICE_ERROR :\n        response.status === 401 ? AIErrorCode.AUTH_ERROR :\n        response.status === 429 ? AIErrorCode.RATE_LIMIT :\n        AIErrorCode.UNKNOWN,\n        errorMessage,\n        AIProviderEnum.OPENAI\n      )\n    }\n\n    const data = await response.json()\n    return parseResponse(data as OpenAICompatibleResponse, latencyMs)\n\n  } catch (error) {\n    if (error instanceof DOMException && error.name === 'AbortError') {\n      throw createAIProviderError(\n        AIErrorCode.TIMEOUT,\n        'Request was cancelled',\n        AIProviderEnum.OPENAI\n      )\n    }\n\n    if (error && typeof error === 'object' && 'code' in error) {\n      // Already an AIProviderError\n      throw error\n    }\n\n    throw createAIProviderError(\n      AIErrorCode.NETWORK_ERROR,\n      error instanceof Error ? error.message : 'Unknown error',\n      AIProviderEnum.OPENAI\n    )\n  }\n}\n\n/**\n * Make a streaming AI chat request through the proxy\n *\n * @param request - Chat request parameters\n * @param signal - Optional abort signal for cancellation\n * @returns AsyncGenerator yielding AIStreamChunks\n *\n * @example\n * ```typescript\n * for await (const chunk of proxyAIChatStream({\n *   provider: 'groq',\n *   messages: [{ role: 'user', content: 'Hello!' }],\n *   stream: true\n * })) {\n *   process.stdout.write(chunk.content)\n *   if (chunk.done) break\n * }\n * ```\n */\nexport async function* proxyAIChatStream(\n  request: ProxyAIChatRequest,\n  signal?: AbortSignal\n): AsyncGenerator<AIStreamChunk, void, unknown> {\n  const proxyUrl = getProxyUrl()\n\n  // Get auth token if available\n  let authHeader: Record<string, string> = {}\n  if (supabase) {\n    const { data: { session } } = await supabase.auth.getSession()\n    if (session?.access_token) {\n      authHeader = { 'Authorization': `Bearer ${session.access_token}` }\n    }\n  }\n\n  try {\n    const response = await tauriFetch(proxyUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        ...authHeader,\n      },\n      body: JSON.stringify({\n        provider: request.provider,\n        messages: request.messages,\n        model: request.model,\n        stream: true,\n        max_tokens: request.max_tokens,\n        temperature: request.temperature,\n        top_p: request.top_p,\n        stop_sequences: request.stop_sequences,\n        tools: request.tools,\n        tool_choice: request.tool_choice,\n      }),\n      signal,\n    })\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}))\n      const errorMessage = errorData.error || errorData.details || `HTTP ${response.status}`\n\n      throw createAIProviderError(\n        response.status === 503 ? AIErrorCode.SERVICE_ERROR :\n        response.status === 401 ? AIErrorCode.AUTH_ERROR :\n        response.status === 429 ? AIErrorCode.RATE_LIMIT :\n        AIErrorCode.UNKNOWN,\n        errorMessage,\n        AIProviderEnum.OPENAI\n      )\n    }\n\n    if (!response.body) {\n      throw createAIProviderError(\n        AIErrorCode.SERVICE_ERROR,\n        'Response body is null',\n        AIProviderEnum.OPENAI\n      )\n    }\n\n    // Process SSE stream (OpenAI-compatible format)\n    yield* parseSSEStream(response.body)\n\n  } catch (error) {\n    if (error instanceof DOMException && error.name === 'AbortError') {\n      yield { content: '', done: true }\n      return\n    }\n\n    if (error && typeof error === 'object' && 'code' in error) {\n      throw error\n    }\n\n    throw createAIProviderError(\n      AIErrorCode.NETWORK_ERROR,\n      error instanceof Error ? error.message : 'Unknown error',\n      AIProviderEnum.OPENAI\n    )\n  }\n}\n\n/**\n * Parse Server-Sent Events stream (OpenAI-compatible format)\n */\nasync function* parseSSEStream(\n  body: ReadableStream<Uint8Array>\n): AsyncGenerator<AIStreamChunk, void, unknown> {\n  const reader = body.getReader()\n  const decoder = new TextDecoder()\n  let buffer = ''\n  let finalUsage: AITokenUsage | undefined\n\n  // Tool call accumulation for native function calling\n  const toolCallAccumulator: Map<number, { id: string; name: string; arguments: string }> = new Map()\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read()\n\n      if (done) break\n\n      buffer += decoder.decode(value, { stream: true })\n\n      // Process complete SSE messages\n      const lines = buffer.split('\\n')\n      buffer = lines.pop() || ''\n\n      for (const line of lines) {\n        // SSE format: \"data: {...}\" or \"data: [DONE]\"\n        if (!line.startsWith('data:')) continue\n\n        const dataStr = line.slice(5).trim()\n\n        if (dataStr === '[DONE]') {\n          const accToolCalls = toolCallAccumulator.size > 0\n            ? Array.from(toolCallAccumulator.values()).map(tc => ({\n                id: tc.id,\n                type: 'function' as const,\n                function: { name: tc.name, arguments: tc.arguments }\n              }))\n            : undefined\n          yield { content: '', done: true, usage: finalUsage, toolCalls: accToolCalls }\n          return\n        }\n\n        try {\n          const chunk = JSON.parse(dataStr)\n\n          if (!chunk.choices || chunk.choices.length === 0) continue\n\n          const choice = chunk.choices[0]\n          const content = choice.delta?.content || ''\n\n          // Accumulate native tool call deltas\n          if (choice.delta?.tool_calls) {\n            for (const tc of choice.delta.tool_calls) {\n              const idx = tc.index ?? 0\n              const existing = toolCallAccumulator.get(idx)\n              if (!existing) {\n                toolCallAccumulator.set(idx, {\n                  id: tc.id || '',\n                  name: tc.function?.name || '',\n                  arguments: tc.function?.arguments || '',\n                })\n              } else {\n                if (tc.id) existing.id = tc.id\n                if (tc.function?.name) existing.name = tc.function.name\n                if (tc.function?.arguments) existing.arguments += tc.function.arguments\n              }\n            }\n          }\n\n          if (chunk.usage) {\n            finalUsage = {\n              promptTokens: chunk.usage.prompt_tokens,\n              completionTokens: chunk.usage.completion_tokens,\n              totalTokens: chunk.usage.total_tokens,\n            }\n          }\n\n          // Build accumulated tool calls for final chunk\n          if (choice.finish_reason) {\n            const accToolCalls = toolCallAccumulator.size > 0\n              ? Array.from(toolCallAccumulator.values()).map(tc => ({\n                  id: tc.id,\n                  type: 'function' as const,\n                  function: { name: tc.name, arguments: tc.arguments }\n                }))\n              : undefined\n\n            yield {\n              content,\n              done: true,\n              usage: chunk.usage ? finalUsage : undefined,\n              finishReason: choice.finish_reason || undefined,\n              toolCalls: accToolCalls,\n            }\n            return\n          }\n\n          yield {\n            content,\n            done: false,\n            usage: chunk.usage ? finalUsage : undefined,\n            finishReason: undefined,\n          }\n        } catch (parseError) {\n          // Log but continue processing other chunks\n          console.warn('[AIProxy] Failed to parse SSE chunk:', line)\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n\n/**\n * Check if the AI proxy is available and configured for a provider.\n * Uses a lightweight OPTIONS/POST request instead of a full chat completion.\n *\n * @param provider - Provider to check\n * @returns Promise resolving to availability status\n */\nexport async function isProxyAvailable(provider: ProxyProvider): Promise<boolean> {\n  try {\n    const proxyUrl = getProxyUrl()\n\n    // Get auth token if available\n    let authHeader: Record<string, string> = {}\n    if (supabase) {\n      const { data: { session } } = await supabase.auth.getSession()\n      if (session?.access_token) {\n        authHeader = { 'Authorization': `Bearer ${session.access_token}` }\n      }\n    }\n\n    // TASK-1265: Health check using OPTIONS to avoid consuming API tokens.\n    // The Edge Function returns 200 'ok' for OPTIONS requests without\n    // forwarding to the actual AI provider.\n    const response = await tauriFetch(proxyUrl, {\n      method: 'OPTIONS',\n      headers: authHeader,\n      signal: AbortSignal.timeout(5000),\n    })\n\n    return response.ok\n  } catch {\n    return false\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/router.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/tools.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1174,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1174,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42615,42618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42615,42618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1279,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1279,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[46443,46446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[46443,46446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1294,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1294,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[46998,47001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[46998,47001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Tool Definitions and Execution\n *\n * Defines tools the AI can call and executes them against stores.\n * This enables the AI assistant to create groups, tasks, query data,\n * manage timers, projects, and perform bulk operations.\n *\n * @see TASK-1120 in MASTER_PLAN.md\n * @see TASK-1186 for expansion from 5 to 20 tools\n */\n\nimport { useCanvasStore } from '@/stores/canvas'\nimport { useTaskStore } from '@/stores/tasks'\nimport { useTimerStore } from '@/stores/timer'\nimport { useProjectStore } from '@/stores/projects'\nimport { useGamificationStore } from '@/stores/gamification'\nimport { useChallengesStore } from '@/stores/challenges'\nimport type { Task } from '@/types/tasks'\nimport type { OpenAITool } from './types'\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Maximum number of tool calls the AI can make in a single response */\nexport const MAX_TOOLS_PER_RESPONSE = 5\n\n/** Valid task statuses */\nconst VALID_STATUSES: Task['status'][] = ['planned', 'in_progress', 'done', 'backlog', 'on_hold']\n\n/** Valid task priorities */\nconst VALID_PRIORITIES: Array<Task['priority']> = ['low', 'medium', 'high', null]\n\n// ============================================================================\n// Tool Definitions\n// ============================================================================\n\nexport interface ToolParam {\n  type: string\n  description: string\n  enum?: string[]\n  items?: { type: string; properties?: Record<string, ToolParam>; required?: string[] }\n}\n\nexport interface ToolDefinition {\n  name: string\n  description: string\n  parameters: {\n    type: 'object'\n    properties: Record<string, ToolParam>\n    required: string[]\n  }\n  requiresConfirmation?: boolean\n  category: 'read' | 'write' | 'destructive'\n}\n\nexport const AI_TOOLS: ToolDefinition[] = [\n  // ── Existing 5 tools ──────────────────────────────────────────────────────\n  {\n    name: 'create_group',\n    description: 'Create a new group on the canvas to organize tasks',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        name: { type: 'string', description: 'The name of the group' },\n        color: { type: 'string', description: 'Optional color for the group (hex color like \"#3b82f6\")' },\n      },\n      required: ['name'],\n    },\n  },\n  {\n    name: 'create_task',\n    description: 'Create a new task',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        title: { type: 'string', description: 'The title of the task' },\n        priority: { type: 'string', description: 'Priority level', enum: ['low', 'medium', 'high'] },\n        description: { type: 'string', description: 'Optional description for the task' },\n        dueDate: { type: 'string', description: 'Optional due date in YYYY-MM-DD format' },\n      },\n      required: ['title'],\n    },\n  },\n  {\n    name: 'list_groups',\n    description: 'List all groups on the canvas',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'list_tasks',\n    description: 'List tasks, optionally filtered by status',\n    category: 'read',\n    parameters: {\n      type: 'object',\n      properties: {\n        status: { type: 'string', description: 'Filter by status', enum: ['planned', 'in_progress', 'done', 'backlog', 'all'] },\n        limit: { type: 'number', description: 'Maximum number of tasks to return (default 50)' },\n      },\n      required: [],\n    },\n  },\n  {\n    name: 'update_task_status',\n    description: 'Update the status of a task',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task to update' },\n        status: { type: 'string', description: 'The new status', enum: ['planned', 'in_progress', 'done', 'backlog'] },\n      },\n      required: ['taskId', 'status'],\n    },\n  },\n\n  // ── HIGH PRIORITY: 6 new tools ────────────────────────────────────────────\n  {\n    name: 'update_task',\n    description: 'Update one or more fields of a task (title, description, priority, dueDate, status, estimatedDuration)',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task to update' },\n        title: { type: 'string', description: 'New title' },\n        description: { type: 'string', description: 'New description' },\n        priority: { type: 'string', description: 'New priority', enum: ['low', 'medium', 'high'] },\n        dueDate: { type: 'string', description: 'New due date in YYYY-MM-DD format' },\n        status: { type: 'string', description: 'New status', enum: ['planned', 'in_progress', 'done', 'backlog'] },\n        estimatedDuration: { type: 'number', description: 'Estimated duration in minutes' },\n      },\n      required: ['taskId'],\n    },\n  },\n  {\n    name: 'search_tasks',\n    description: 'Search tasks by text query across titles and descriptions',\n    category: 'read',\n    parameters: {\n      type: 'object',\n      properties: {\n        query: { type: 'string', description: 'Text to search for in task titles and descriptions' },\n        priority: { type: 'string', description: 'Filter by priority', enum: ['low', 'medium', 'high'] },\n        status: { type: 'string', description: 'Filter by status', enum: ['planned', 'in_progress', 'done', 'backlog'] },\n        limit: { type: 'number', description: 'Maximum results (default 20)' },\n      },\n      required: ['query'],\n    },\n  },\n  {\n    name: 'get_task_details',\n    description: 'Get full details of a specific task including subtasks, project, and dates',\n    category: 'read',\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task' },\n      },\n      required: ['taskId'],\n    },\n  },\n  {\n    name: 'start_timer',\n    description: 'Start a Pomodoro timer for a specific task',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task to focus on' },\n        duration: { type: 'number', description: 'Duration in minutes (default 25)' },\n      },\n      required: ['taskId'],\n    },\n  },\n  {\n    name: 'stop_timer',\n    description: 'Stop the currently running Pomodoro timer',\n    category: 'write',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'get_timer_status',\n    description: 'Get the current timer status including remaining time and active task',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n\n  // ── MEDIUM PRIORITY: 6 new tools ──────────────────────────────────────────\n  {\n    name: 'delete_task',\n    description: 'Delete a task permanently. Requires confirmed=true to execute.',\n    category: 'destructive',\n    requiresConfirmation: true,\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task to delete' },\n        confirmed: { type: 'boolean', description: 'Must be true to confirm deletion' },\n      },\n      required: ['taskId', 'confirmed'],\n    },\n  },\n  {\n    name: 'move_task_to_group',\n    description: 'Move a task into a canvas group',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task to move' },\n        groupId: { type: 'string', description: 'The ID of the target group' },\n      },\n      required: ['taskId', 'groupId'],\n    },\n  },\n  {\n    name: 'list_projects',\n    description: 'List all projects with their names, colors, and task counts',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'assign_task_to_project',\n    description: 'Assign a task to a project',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task' },\n        projectId: { type: 'string', description: 'The ID of the project to assign to' },\n      },\n      required: ['taskId', 'projectId'],\n    },\n  },\n  {\n    name: 'get_daily_summary',\n    description: 'Get a summary of tasks and activity for a specific date',\n    category: 'read',\n    parameters: {\n      type: 'object',\n      properties: {\n        date: { type: 'string', description: 'Date in YYYY-MM-DD format (default: today)' },\n      },\n      required: [],\n    },\n  },\n  {\n    name: 'create_subtasks',\n    description: 'Create multiple subtasks under a parent task',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        parentTaskId: { type: 'string', description: 'The ID of the parent task' },\n        subtasks: {\n          type: 'array',\n          description: 'Array of subtask objects with title and optional priority',\n          items: {\n            type: 'object',\n            properties: {\n              title: { type: 'string', description: 'Subtask title' },\n            },\n            required: ['title'],\n          },\n        },\n      },\n      required: ['parentTaskId', 'subtasks'],\n    },\n  },\n\n  // ── NICE-TO-HAVE: 3 new tools ────────────────────────────────────────────\n  {\n    name: 'set_task_due_date',\n    description: 'Set or change the due date of a task',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        taskId: { type: 'string', description: 'The ID of the task' },\n        dueDate: { type: 'string', description: 'Due date in YYYY-MM-DD format' },\n        dueTime: { type: 'string', description: 'Optional due time in HH:MM format' },\n      },\n      required: ['taskId', 'dueDate'],\n    },\n  },\n  {\n    name: 'get_overdue_tasks',\n    description: 'Get all tasks that are past their due date and not done',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'collect_overdue_to_group',\n    description: 'Collect all overdue tasks and arrange them in an orderly grid next to a specific group on the canvas. Use when user says \"get overdue tasks\", \"collect overdue\", \"organize overdue near group\".',\n    category: 'write',\n    parameters: {\n      type: 'object',\n      properties: {\n        groupId: { type: 'string', description: 'The group ID to place overdue tasks next to. If not provided, uses the first available group.' },\n      },\n      required: [],\n    },\n  },\n  {\n    name: 'bulk_update_status',\n    description: 'Update the status of multiple tasks at once. Requires confirmed=true to execute.',\n    category: 'destructive',\n    requiresConfirmation: true,\n    parameters: {\n      type: 'object',\n      properties: {\n        taskIds: { type: 'array', description: 'Array of task IDs to update', items: { type: 'string' } },\n        status: { type: 'string', description: 'The new status for all tasks', enum: ['planned', 'in_progress', 'done', 'backlog'] },\n        confirmed: { type: 'boolean', description: 'Must be true to confirm bulk operation' },\n      },\n      required: ['taskIds', 'status', 'confirmed'],\n    },\n  },\n\n  // ── GAMIFICATION & PRODUCTIVITY TOOLS ────────────────────────────────────\n  {\n    name: 'get_productivity_stats',\n    description: 'Get productivity statistics: tasks completed, focus time, pomodoros, streaks, and task breakdown by status',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'suggest_next_task',\n    description: 'Suggest the best task to work on next based on priority, due dates, and overdue status',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'get_weekly_summary',\n    description: 'Get a weekly productivity summary including tasks done, focus time, streak status, and XP earned',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'generate_weekly_plan',\n    description: 'Generate an AI-powered weekly plan that distributes tasks across Monday through Sunday based on priority, due dates, and workload. Use when the user asks to plan their week or schedule tasks.',\n    category: 'read',\n    parameters: {\n      type: 'object',\n      properties: {\n        topPriority: { type: 'string', description: 'The user\\'s top priority or focus area for the week (optional)' },\n        maxTasksPerDay: { type: 'number', description: 'Maximum tasks to schedule per day (default 5)' },\n        daysOff: { type: 'array', description: 'Days to keep free (e.g. [\"saturday\", \"sunday\"])', items: { type: 'string' } },\n        preferredWorkStyle: { type: 'string', description: 'How to distribute workload', enum: ['frontload', 'balanced', 'backload'] },\n      },\n      required: [],\n    },\n  },\n  {\n    name: 'get_gamification_status',\n    description: 'Get gamification profile: XP, level, streak, corruption, equipped theme, and level progress',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'get_active_challenges',\n    description: 'Get active daily challenges and weekly boss with progress, time remaining, and rewards',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n  {\n    name: 'get_achievements_near_completion',\n    description: 'Get achievements that are close to being unlocked (>50% progress) with progress details',\n    category: 'read',\n    parameters: { type: 'object', properties: {}, required: [] },\n  },\n]\n\n// ============================================================================\n// Tool Call Types\n// ============================================================================\n\nexport interface ToolCall {\n  tool: string\n  parameters: Record<string, unknown>\n}\n\nexport interface ToolResult {\n  success: boolean\n  message: string\n  data?: unknown\n  undoAction?: { toolName: string; params: Record<string, unknown> }\n}\n\n// ============================================================================\n// Validation Helpers\n// ============================================================================\n\nfunction isValidISODate(str: string): boolean {\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(str)) return false\n  const d = new Date(str + 'T00:00:00')\n  return !isNaN(d.getTime())\n}\n\nfunction isValidTimeString(str: string): boolean {\n  return /^\\d{2}:\\d{2}$/.test(str)\n}\n\nfunction validateTaskExists(taskStore: ReturnType<typeof useTaskStore>, taskId: string): Task | null {\n  const task = taskStore.getTask(taskId)\n  return task || null\n}\n\nfunction formatTime(seconds: number): string {\n  const mins = Math.floor(seconds / 60)\n  const secs = seconds % 60\n  return `${mins}:${secs.toString().padStart(2, '0')}`\n}\n\n// ============================================================================\n// Tool Execution\n// ============================================================================\n\n/**\n * Execute a tool call and return the result.\n */\nexport async function executeTool(call: ToolCall): Promise<ToolResult> {\n  // Lazy store access - these are Pinia stores and are safe to call here\n  // because executeTool is only invoked from UI context (useAIChat) where\n  // the Pinia instance is already active.\n  let canvasStore: ReturnType<typeof useCanvasStore>\n  let taskStore: ReturnType<typeof useTaskStore>\n  let timerStore: ReturnType<typeof useTimerStore>\n  let projectStore: ReturnType<typeof useProjectStore>\n\n  try {\n    taskStore = useTaskStore()\n    canvasStore = useCanvasStore()\n  } catch {\n    return { success: false, message: 'Core stores not available. Please try again after the app is fully loaded.' }\n  }\n\n  try {\n    switch (call.tool) {\n      // ── Existing 5 tools (preserved) ────────────────────────────────────\n      case 'create_group': {\n        const name = call.parameters.name as string\n        const color = (call.parameters.color as string) || '#3b82f6'\n\n        const existingGroups = canvasStore.groups\n        let xPos = 100\n        const yPos = 100\n\n        if (existingGroups.length > 0) {\n          const maxX = Math.max(\n            ...existingGroups.map((g) => (g.position?.x || 0) + (g.position?.width || 400))\n          )\n          xPos = maxX + 50\n        }\n\n        const group = await canvasStore.createGroup({\n          name,\n          type: 'custom',\n          position: { x: xPos, y: yPos, width: 400, height: 300 },\n          color,\n          layout: 'freeform',\n          isVisible: true,\n          isCollapsed: false,\n        })\n\n        return {\n          success: true,\n          message: `Created group \"${name}\"`,\n          data: { id: group.id, name: group.name },\n        }\n      }\n\n      case 'create_task': {\n        const title = call.parameters.title as string\n        const priority = (call.parameters.priority as Task['priority']) || 'medium'\n        const description = call.parameters.description as string | undefined\n        const dueDate = call.parameters.dueDate as string | undefined\n\n        if (dueDate && !isValidISODate(dueDate)) {\n          return { success: false, message: `Invalid date format \"${dueDate}\". Use YYYY-MM-DD.` }\n        }\n\n        const task = await taskStore.createTask({ title, priority, description, dueDate })\n\n        return {\n          success: true,\n          message: `Created task \"${title}\"`,\n          data: { id: task.id, title: task.title, priority: task.priority },\n        }\n      }\n\n      case 'list_groups': {\n        const groups = canvasStore.groups\n        const groupList = groups.map((g) => ({\n          id: g.id,\n          name: g.name,\n          taskCount: canvasStore.getAggregatedTaskCountForGroup(g.id),\n        }))\n\n        return {\n          success: true,\n          message: `Found ${groups.length} groups`,\n          data: groupList,\n        }\n      }\n\n      case 'list_tasks': {\n        const status = call.parameters.status as string | undefined\n        const limit = (call.parameters.limit as number) || 50\n\n        let tasks = taskStore.tasks\n\n        if (status && status !== 'all') {\n          tasks = tasks.filter((t: Task) => t.status === status)\n        }\n\n        tasks = tasks.slice(0, limit)\n\n        const taskList = tasks.map((t: Task) => ({\n          id: t.id,\n          title: t.title,\n          status: t.status,\n          priority: t.priority,\n          dueDate: t.dueDate || null,\n        }))\n\n        return {\n          success: true,\n          message: `Found ${taskList.length} tasks`,\n          data: taskList,\n        }\n      }\n\n      case 'update_task_status': {\n        const taskId = call.parameters.taskId as string\n        const status = call.parameters.status as Task['status']\n\n        const task = validateTaskExists(taskStore, taskId)\n        if (!task) {\n          return { success: false, message: `Task with ID \"${taskId}\" not found` }\n        }\n\n        if (!VALID_STATUSES.includes(status)) {\n          return { success: false, message: `Invalid status \"${status}\". Valid: ${VALID_STATUSES.join(', ')}` }\n        }\n\n        const previousStatus = task.status\n        await taskStore.updateTask(taskId, { status })\n\n        return {\n          success: true,\n          message: `Updated task \"${task.title}\" status to \"${status}\"`,\n          data: { id: taskId, status },\n          undoAction: { toolName: 'update_task_status', params: { taskId, status: previousStatus } },\n        }\n      }\n\n      // ── HIGH PRIORITY: 6 new tools ──────────────────────────────────────\n      case 'update_task': {\n        const taskId = call.parameters.taskId as string\n        const task = validateTaskExists(taskStore, taskId)\n        if (!task) {\n          return { success: false, message: `Task with ID \"${taskId}\" not found` }\n        }\n\n        const updates: Partial<Task> = {}\n        const updatedFields: string[] = []\n\n        if (call.parameters.title !== undefined) {\n          updates.title = call.parameters.title as string\n          updatedFields.push('title')\n        }\n        if (call.parameters.description !== undefined) {\n          updates.description = call.parameters.description as string\n          updatedFields.push('description')\n        }\n        if (call.parameters.priority !== undefined) {\n          const p = call.parameters.priority as Task['priority']\n          if (!VALID_PRIORITIES.includes(p)) {\n            return { success: false, message: `Invalid priority \"${p}\". Valid: low, medium, high` }\n          }\n          updates.priority = p\n          updatedFields.push('priority')\n        }\n        if (call.parameters.dueDate !== undefined) {\n          const dd = call.parameters.dueDate as string\n          if (!isValidISODate(dd)) {\n            return { success: false, message: `Invalid date format \"${dd}\". Use YYYY-MM-DD.` }\n          }\n          updates.dueDate = dd\n          updatedFields.push('dueDate')\n        }\n        if (call.parameters.status !== undefined) {\n          const s = call.parameters.status as Task['status']\n          if (!VALID_STATUSES.includes(s)) {\n            return { success: false, message: `Invalid status \"${s}\". Valid: ${VALID_STATUSES.join(', ')}` }\n          }\n          updates.status = s\n          updatedFields.push('status')\n        }\n        if (call.parameters.estimatedDuration !== undefined) {\n          updates.estimatedDuration = call.parameters.estimatedDuration as number\n          updatedFields.push('estimatedDuration')\n        }\n\n        if (updatedFields.length === 0) {\n          return { success: false, message: 'No valid fields to update. Provide at least one of: title, description, priority, dueDate, status, estimatedDuration.' }\n        }\n\n        await taskStore.updateTask(taskId, updates)\n\n        return {\n          success: true,\n          message: `Updated task \"${task.title}\": ${updatedFields.join(', ')}`,\n          data: { id: taskId, updatedFields },\n        }\n      }\n\n      case 'search_tasks': {\n        const query = (call.parameters.query as string).toLowerCase()\n        const filterPriority = call.parameters.priority as Task['priority'] | undefined\n        const filterStatus = call.parameters.status as Task['status'] | undefined\n        const limit = (call.parameters.limit as number) || 20\n\n        let results = taskStore.tasks.filter((t: Task) => {\n          const titleMatch = t.title?.toLowerCase().includes(query)\n          const descMatch = t.description?.toLowerCase().includes(query)\n          return titleMatch || descMatch\n        })\n\n        if (filterPriority) {\n          results = results.filter((t: Task) => t.priority === filterPriority)\n        }\n        if (filterStatus) {\n          results = results.filter((t: Task) => t.status === filterStatus)\n        }\n\n        results = results.slice(0, limit)\n\n        return {\n          success: true,\n          message: `Found ${results.length} tasks matching \"${call.parameters.query}\"`,\n          data: results.map((t: Task) => ({\n            id: t.id,\n            title: t.title,\n            status: t.status,\n            priority: t.priority,\n            dueDate: t.dueDate || null,\n          })),\n        }\n      }\n\n      case 'get_task_details': {\n        const taskId = call.parameters.taskId as string\n        const task = validateTaskExists(taskStore, taskId)\n        if (!task) {\n          return { success: false, message: `Task with ID \"${taskId}\" not found` }\n        }\n\n        let projectName = 'Uncategorized'\n        if (task.projectId) {\n          try {\n            projectStore = useProjectStore()\n            projectName = projectStore.getProjectDisplayName(task.projectId)\n          } catch { /* project store not available */ }\n        }\n\n        // Find parent group name if in a canvas group\n        let groupName: string | null = null\n        if (task.parentId) {\n          try {\n            const group = canvasStore.groups.find(g => g.id === task.parentId)\n            groupName = group?.name || null\n          } catch { /* canvas store might not have the group */ }\n        }\n\n        return {\n          success: true,\n          message: `Details for task \"${task.title}\"`,\n          data: {\n            id: task.id,\n            title: task.title,\n            description: task.description || '',\n            status: task.status,\n            priority: task.priority,\n            dueDate: task.dueDate || null,\n            dueTime: task.dueTime || null,\n            estimatedDuration: task.estimatedDuration || null,\n            progress: task.progress,\n            completedPomodoros: task.completedPomodoros,\n            estimatedPomodoros: task.estimatedPomodoros || null,\n            subtasks: (task.subtasks || []).map(s => ({\n              id: s.id,\n              title: s.title,\n              isCompleted: s.isCompleted,\n            })),\n            project: projectName,\n            group: groupName,\n            createdAt: task.createdAt,\n            updatedAt: task.updatedAt,\n            tags: task.tags || [],\n          },\n        }\n      }\n\n      case 'start_timer': {\n        try {\n          timerStore = useTimerStore()\n        } catch {\n          return { success: false, message: 'Timer store not available.' }\n        }\n\n        const taskId = call.parameters.taskId as string\n        const durationMinutes = (call.parameters.duration as number) || 25\n        const durationSeconds = durationMinutes * 60\n\n        // Verify the task exists (unless it's 'general')\n        if (taskId !== 'general') {\n          const task = validateTaskExists(taskStore, taskId)\n          if (!task) {\n            return { success: false, message: `Task with ID \"${taskId}\" not found` }\n          }\n        }\n\n        if (timerStore.isTimerActive) {\n          return { success: false, message: 'A timer is already running. Stop it first with stop_timer.' }\n        }\n\n        await timerStore.startTimer(taskId, durationSeconds)\n\n        const taskName = taskId === 'general' ? 'Focus Session' : (validateTaskExists(taskStore, taskId)?.title || taskId)\n        return {\n          success: true,\n          message: `Started ${durationMinutes}-minute timer for \"${taskName}\"`,\n          data: { taskId, durationMinutes },\n        }\n      }\n\n      case 'stop_timer': {\n        try {\n          timerStore = useTimerStore()\n        } catch {\n          return { success: false, message: 'Timer store not available.' }\n        }\n\n        if (!timerStore.isTimerActive) {\n          return { success: false, message: 'No timer is currently running.' }\n        }\n\n        const taskName = timerStore.currentTaskName || 'Unknown'\n        const remaining = timerStore.currentSession?.remainingTime || 0\n        await timerStore.stopTimer()\n\n        return {\n          success: true,\n          message: `Stopped timer for \"${taskName}\" (${formatTime(remaining)} remaining)`,\n          data: { stoppedTask: taskName, remainingTime: formatTime(remaining) },\n        }\n      }\n\n      case 'get_timer_status': {\n        try {\n          timerStore = useTimerStore()\n        } catch {\n          return { success: false, message: 'Timer store not available.' }\n        }\n\n        const session = timerStore.currentSession\n        if (!session || !timerStore.isTimerActive) {\n          return {\n            success: true,\n            message: 'No timer is currently running',\n            data: { isActive: false },\n          }\n        }\n\n        return {\n          success: true,\n          message: `Timer active: ${timerStore.currentTaskName} (${formatTime(session.remainingTime)} remaining)`,\n          data: {\n            isActive: true,\n            isPaused: session.isPaused,\n            isBreak: session.isBreak,\n            currentTaskName: timerStore.currentTaskName,\n            remainingTime: formatTime(session.remainingTime),\n            remainingSeconds: session.remainingTime,\n            totalDuration: session.duration,\n            sessionsCompleted: timerStore.completedSessions.length,\n          },\n        }\n      }\n\n      // ── MEDIUM PRIORITY: 6 new tools ────────────────────────────────────\n      case 'delete_task': {\n        const taskId = call.parameters.taskId as string\n        const confirmed = call.parameters.confirmed as boolean\n\n        const task = validateTaskExists(taskStore, taskId)\n        if (!task) {\n          return { success: false, message: `Task with ID \"${taskId}\" not found` }\n        }\n\n        if (!confirmed) {\n          return {\n            success: false,\n            message: `Deletion of \"${task.title}\" requires confirmation. Set confirmed=true to proceed.`,\n          }\n        }\n\n        await taskStore.deleteTask(taskId)\n\n        return {\n          success: true,\n          message: `Deleted task \"${task.title}\"`,\n          data: { id: taskId, title: task.title },\n        }\n      }\n\n      case 'move_task_to_group': {\n        const taskId = call.parameters.taskId as string\n        const groupId = call.parameters.groupId as string\n\n        const task = validateTaskExists(taskStore, taskId)\n        if (!task) {\n          return { success: false, message: `Task with ID \"${taskId}\" not found` }\n        }\n\n        const group = canvasStore.groups.find(g => g.id === groupId)\n        if (!group) {\n          return { success: false, message: `Group with ID \"${groupId}\" not found` }\n        }\n\n        // Update task's parentId to move it into the group\n        const previousParentId = task.parentId\n        await taskStore.updateTask(taskId, { parentId: groupId })\n\n        return {\n          success: true,\n          message: `Moved task \"${task.title}\" to group \"${group.name}\"`,\n          data: { taskId, groupId, groupName: group.name },\n          undoAction: { toolName: 'move_task_to_group', params: { taskId, groupId: previousParentId || '' } },\n        }\n      }\n\n      case 'list_projects': {\n        try {\n          projectStore = useProjectStore()\n        } catch {\n          return { success: false, message: 'Project store not available.' }\n        }\n\n        const projects = projectStore.projects\n        const tasks = taskStore.tasks\n\n        const projectList = projects.map(p => ({\n          id: p.id,\n          name: p.name,\n          color: typeof p.color === 'string' ? p.color : undefined,\n          emoji: p.emoji || undefined,\n          taskCount: tasks.filter((t: Task) => t.projectId === p.id).length,\n        }))\n\n        return {\n          success: true,\n          message: `Found ${projects.length} projects`,\n          data: projectList,\n        }\n      }\n\n      case 'assign_task_to_project': {\n        const taskId = call.parameters.taskId as string\n        const projectId = call.parameters.projectId as string\n\n        const task = validateTaskExists(taskStore, taskId)\n        if (!task) {\n          return { success: false, message: `Task with ID \"${taskId}\" not found` }\n        }\n\n        try {\n          projectStore = useProjectStore()\n        } catch {\n          return { success: false, message: 'Project store not available.' }\n        }\n\n        const project = projectStore.getProjectById(projectId)\n        if (!project) {\n          return { success: false, message: `Project with ID \"${projectId}\" not found` }\n        }\n\n        const previousProjectId = task.projectId\n        await taskStore.updateTask(taskId, { projectId })\n\n        return {\n          success: true,\n          message: `Assigned task \"${task.title}\" to project \"${project.name}\"`,\n          data: { taskId, projectId, projectName: project.name },\n          undoAction: { toolName: 'assign_task_to_project', params: { taskId, projectId: previousProjectId } },\n        }\n      }\n\n      case 'get_daily_summary': {\n        const dateStr = (call.parameters.date as string) || new Date().toISOString().split('T')[0]\n        if (!isValidISODate(dateStr)) {\n          return { success: false, message: `Invalid date format \"${dateStr}\". Use YYYY-MM-DD.` }\n        }\n\n        const allTasks = taskStore.tasks\n        const today = dateStr\n\n        // Normalize dueDate: extract YYYY-MM-DD from either \"2026-02-07\" or \"2026-02-07T22:00:00+00:00\"\n        const normDate = (d: string) => d.includes('T') ? d.split('T')[0] : d\n        const dueToday = allTasks.filter((t: Task) => t.dueDate && normDate(t.dueDate) === today && t.status !== 'done')\n        const completedToday = allTasks.filter((t: Task) => {\n          if (t.status !== 'done') return false\n          // Check if completedAt matches today\n          if (t.completedAt) {\n            const completedDate = new Date(t.completedAt).toISOString().split('T')[0]\n            return completedDate === today\n          }\n          // Fallback: check updatedAt for tasks marked done today\n          const updatedDate = new Date(t.updatedAt).toISOString().split('T')[0]\n          return updatedDate === today\n        })\n        const overdue = allTasks.filter((t: Task) => {\n          if (!t.dueDate || t.status === 'done') return false\n          return normDate(t.dueDate) < today\n        })\n\n        // Timer sessions info\n        let sessionsCompleted = 0\n        try {\n          timerStore = useTimerStore()\n          sessionsCompleted = timerStore.completedSessions.length\n        } catch { /* timer not available */ }\n\n        return {\n          success: true,\n          message: `Daily summary for ${dateStr}`,\n          data: {\n            date: dateStr,\n            dueToday: dueToday.length,\n            dueTodayTasks: dueToday.map((t: Task) => ({ id: t.id, title: t.title, priority: t.priority })),\n            completedToday: completedToday.length,\n            overdueCount: overdue.length,\n            overdueTasks: overdue.slice(0, 10).map((t: Task) => ({ id: t.id, title: t.title, dueDate: t.dueDate })),\n            timerSessionsCompleted: sessionsCompleted,\n            totalTasks: allTasks.length,\n            inProgress: allTasks.filter((t: Task) => t.status === 'in_progress').length,\n          },\n        }\n      }\n\n      case 'create_subtasks': {\n        const parentTaskId = call.parameters.parentTaskId as string\n        const subtaskDefs = call.parameters.subtasks as Array<{ title: string }>\n\n        const parentTask = validateTaskExists(taskStore, parentTaskId)\n        if (!parentTask) {\n          return { success: false, message: `Parent task with ID \"${parentTaskId}\" not found` }\n        }\n\n        if (!Array.isArray(subtaskDefs) || subtaskDefs.length === 0) {\n          return { success: false, message: 'subtasks must be a non-empty array of objects with title.' }\n        }\n\n        const created: Array<{ id: string; title: string }> = []\n        for (const sub of subtaskDefs) {\n          if (!sub.title || typeof sub.title !== 'string') continue\n          const result = await taskStore.createSubtask(parentTaskId, { title: sub.title })\n          if (result) {\n            created.push({ id: result.id, title: result.title })\n          }\n        }\n\n        return {\n          success: true,\n          message: `Created ${created.length} subtasks under \"${parentTask.title}\"`,\n          data: { parentTaskId, subtasks: created },\n        }\n      }\n\n      // ── NICE-TO-HAVE: 3 new tools ──────────────────────────────────────\n      case 'set_task_due_date': {\n        const taskId = call.parameters.taskId as string\n        const dueDate = call.parameters.dueDate as string\n        const dueTime = call.parameters.dueTime as string | undefined\n\n        const task = validateTaskExists(taskStore, taskId)\n        if (!task) {\n          return { success: false, message: `Task with ID \"${taskId}\" not found` }\n        }\n\n        if (!isValidISODate(dueDate)) {\n          return { success: false, message: `Invalid date format \"${dueDate}\". Use YYYY-MM-DD.` }\n        }\n        if (dueTime && !isValidTimeString(dueTime)) {\n          return { success: false, message: `Invalid time format \"${dueTime}\". Use HH:MM.` }\n        }\n\n        const updates: Partial<Task> = { dueDate }\n        if (dueTime) updates.dueTime = dueTime\n\n        const previousDueDate = task.dueDate\n        await taskStore.updateTask(taskId, updates)\n\n        return {\n          success: true,\n          message: `Set due date for \"${task.title}\" to ${dueDate}${dueTime ? ' at ' + dueTime : ''}`,\n          data: { taskId, dueDate, dueTime: dueTime || null },\n          undoAction: { toolName: 'set_task_due_date', params: { taskId, dueDate: previousDueDate } },\n        }\n      }\n\n      case 'get_overdue_tasks': {\n        const now = new Date()\n        const todayKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`\n        const todayMs = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime()\n        const overdue = taskStore.tasks.filter((t: Task) => {\n          if (!t.dueDate || t.status === 'done') return false\n          // Normalize: extract YYYY-MM-DD from either \"2026-02-07\" or \"2026-02-07T22:00:00+00:00\"\n          const dueDateKey = t.dueDate.includes('T') ? t.dueDate.split('T')[0] : t.dueDate\n          return dueDateKey < todayKey\n        })\n\n        return {\n          success: true,\n          message: `Found ${overdue.length} overdue tasks`,\n          data: overdue.map((t: Task) => {\n            const dueDateKey = t.dueDate.includes('T') ? t.dueDate.split('T')[0] : t.dueDate\n            const [y, m, d] = dueDateKey.split('-').map(Number)\n            const dueMs = new Date(y, m - 1, d).getTime()\n            return {\n              id: t.id,\n              title: t.title,\n              dueDate: t.dueDate,\n              priority: t.priority,\n              status: t.status,\n              daysOverdue: Math.max(1, Math.floor((todayMs - dueMs) / (1000 * 60 * 60 * 24))),\n            }\n          }),\n        }\n      }\n\n      case 'bulk_update_status': {\n        const taskIds = call.parameters.taskIds as string[]\n        const status = call.parameters.status as Task['status']\n        const confirmed = call.parameters.confirmed as boolean\n\n        if (!confirmed) {\n          return {\n            success: false,\n            message: `Bulk status update of ${taskIds.length} tasks requires confirmation. Set confirmed=true to proceed.`,\n          }\n        }\n\n        if (!VALID_STATUSES.includes(status)) {\n          return { success: false, message: `Invalid status \"${status}\". Valid: ${VALID_STATUSES.join(', ')}` }\n        }\n\n        if (!Array.isArray(taskIds) || taskIds.length === 0) {\n          return { success: false, message: 'taskIds must be a non-empty array.' }\n        }\n\n        const results: Array<{ id: string; title: string; success: boolean }> = []\n        for (const id of taskIds) {\n          const task = validateTaskExists(taskStore, id)\n          if (task) {\n            try {\n              await taskStore.updateTask(id, { status })\n              results.push({ id, title: task.title, success: true })\n            } catch {\n              results.push({ id, title: task.title, success: false })\n            }\n          } else {\n            results.push({ id, title: '(not found)', success: false })\n          }\n        }\n\n        const successCount = results.filter(r => r.success).length\n        return {\n          success: successCount > 0,\n          message: `Updated ${successCount}/${taskIds.length} tasks to \"${status}\"`,\n          data: { status, results },\n        }\n      }\n\n      case 'collect_overdue_to_group': {\n        let groupId = call.parameters.groupId as string | undefined\n\n        // If no groupId provided, find the first group\n        if (!groupId) {\n          const groups = canvasStore.groups\n          if (groups.length === 0) {\n            return {\n              success: false,\n              message: 'No groups found on the canvas. Create a group first.',\n            }\n          }\n          groupId = groups[0].id\n        }\n\n        // Find overdue tasks for reporting (normalize dates with T timestamps)\n        const now = new Date()\n        const todayKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`\n        const normDate = (d: string) => d.includes('T') ? d.split('T')[0] : d\n        const overdueTasks = taskStore.tasks.filter((t: Task) => {\n          if (!t.dueDate || t.status === 'done') return false\n          if (normDate(t.dueDate) >= todayKey) return false\n          if (t.parentId === groupId) return false\n          return true\n        })\n\n        if (overdueTasks.length === 0) {\n          return {\n            success: true,\n            message: 'No overdue tasks found outside this group.',\n            data: { overdueCount: 0 },\n          }\n        }\n\n        // Import and call the collect function dynamically\n        // The actual positioning logic lives in useCanvasTaskActions\n        // We trigger it via a custom event that CanvasView listens to\n        window.dispatchEvent(new CustomEvent('collect-overdue-tasks', {\n          detail: { groupId }\n        }))\n\n        return {\n          success: true,\n          message: `Collecting ${overdueTasks.length} overdue tasks and arranging them near the group`,\n          data: {\n            groupId,\n            overdueCount: overdueTasks.length,\n            tasks: overdueTasks.slice(0, 10).map((t: Task) => ({\n              id: t.id,\n              title: t.title,\n              dueDate: t.dueDate,\n              daysOverdue: Math.max(1, Math.floor((new Date(todayKey).getTime() - new Date(normDate(t.dueDate)).getTime()) / (1000 * 60 * 60 * 24))),\n            })),\n          },\n        }\n      }\n\n      // ── GAMIFICATION & PRODUCTIVITY TOOLS ────────────────────────────────\n      case 'get_productivity_stats': {\n        const allTasks = taskStore.tasks\n        const todayStr = new Date().toISOString().split('T')[0]\n        const normDate = (d: string) => d.includes('T') ? d.split('T')[0] : d\n\n        const byStatus = { planned: 0, in_progress: 0, done: 0, backlog: 0, on_hold: 0 }\n        let overdueCount = 0\n        let completedToday = 0\n\n        for (const t of allTasks) {\n          if (t.status && t.status in byStatus) {\n            byStatus[t.status as keyof typeof byStatus]++\n          }\n          if (t.dueDate && normDate(t.dueDate) < todayStr && t.status !== 'done') {\n            overdueCount++\n          }\n          if (t.status === 'done') {\n            const completedDate = t.completedAt\n              ? new Date(t.completedAt).toISOString().split('T')[0]\n              : new Date(t.updatedAt).toISOString().split('T')[0]\n            if (completedDate === todayStr) completedToday++\n          }\n        }\n\n        // Gamification stats\n        let gamStats: any = null\n        try {\n          const gamStore = useGamificationStore()\n          if (gamStore.isInitialized && gamStore.stats) {\n            gamStats = {\n              tasksCompleted: gamStore.stats.tasksCompleted,\n              pomodorosCompleted: gamStore.stats.pomodorosCompleted,\n              totalFocusMinutes: gamStore.stats.totalFocusMinutes,\n              currentStreak: gamStore.streakInfo.currentStreak,\n              longestStreak: gamStore.streakInfo.longestStreak,\n              isActiveToday: gamStore.streakInfo.isActiveToday,\n            }\n          }\n        } catch { /* gamification not available */ }\n\n        // Timer sessions\n        let sessionsToday = 0\n        try {\n          timerStore = useTimerStore()\n          sessionsToday = timerStore.completedSessions.length\n        } catch { /* timer not available */ }\n\n        return {\n          success: true,\n          message: 'Productivity statistics',\n          data: {\n            totalTasks: allTasks.length,\n            completedToday,\n            overdueCount,\n            byStatus,\n            pomodorosToday: sessionsToday,\n            ...(gamStats || {}),\n          },\n        }\n      }\n\n      case 'suggest_next_task': {\n        const allTasks = taskStore.tasks\n        const todayStr = new Date().toISOString().split('T')[0]\n        const normDate = (d: string) => d.includes('T') ? d.split('T')[0] : d\n\n        // Filter actionable tasks (not done, not on_hold)\n        const actionable = allTasks.filter((t: Task) =>\n          t.status !== 'done' && t.status !== 'on_hold'\n        )\n\n        if (actionable.length === 0) {\n          return { success: true, message: 'No actionable tasks found. Everything is done!', data: { suggestion: null } }\n        }\n\n        // Score tasks: overdue high-priority first, then due today, then by priority\n        const scored = actionable.map((t: Task) => {\n          let score = 0\n          const dueDateKey = t.dueDate ? normDate(t.dueDate) : null\n\n          // Overdue tasks get highest priority\n          if (dueDateKey && dueDateKey < todayStr) score += 100\n          // Due today\n          if (dueDateKey && dueDateKey === todayStr) score += 50\n          // Priority scoring\n          if (t.priority === 'high') score += 30\n          else if (t.priority === 'medium') score += 15\n          else if (t.priority === 'low') score += 5\n          // In-progress tasks get a small boost\n          if (t.status === 'in_progress') score += 10\n\n          return { task: t, score }\n        })\n\n        scored.sort((a, b) => b.score - a.score)\n\n        const top = scored.slice(0, 3)\n        return {\n          success: true,\n          message: `Suggested ${top.length} tasks to work on next`,\n          data: top.map(({ task, score }) => ({\n            id: task.id,\n            title: task.title,\n            priority: task.priority,\n            status: task.status,\n            dueDate: task.dueDate || null,\n            score,\n            reason: score >= 100 ? 'overdue' : score >= 50 ? 'due today' : score >= 30 ? 'high priority' : 'next up',\n          })),\n        }\n      }\n\n      case 'get_weekly_summary': {\n        const allTasks = taskStore.tasks\n        const now = new Date()\n        const weekAgo = new Date(now)\n        weekAgo.setDate(weekAgo.getDate() - 7)\n        const weekAgoStr = weekAgo.toISOString().split('T')[0]\n\n        // Count tasks completed this week\n        let completedThisWeek = 0\n        for (const t of allTasks) {\n          if (t.status !== 'done') continue\n          const completedDate = t.completedAt\n            ? new Date(t.completedAt).toISOString().split('T')[0]\n            : new Date(t.updatedAt).toISOString().split('T')[0]\n          if (completedDate >= weekAgoStr) completedThisWeek++\n        }\n\n        // Gamification weekly data\n        let weeklyGam: any = null\n        try {\n          const gamStore = useGamificationStore()\n          if (gamStore.isInitialized) {\n            weeklyGam = {\n              totalXp: gamStore.totalXp,\n              level: gamStore.currentLevel,\n              currentStreak: gamStore.streakInfo.currentStreak,\n              focusMinutes: gamStore.stats?.totalFocusMinutes ?? 0,\n              pomodorosCompleted: gamStore.stats?.pomodorosCompleted ?? 0,\n            }\n          }\n        } catch { /* not available */ }\n\n        // Challenge stats\n        let challengeStats: any = null\n        try {\n          const challengeStore = useChallengesStore()\n          if (challengeStore.isInitialized) {\n            challengeStats = {\n              completedToday: challengeStore.completedTodayCount,\n              activeDailies: challengeStore.activeDailies.length,\n              hasBoss: !!challengeStore.activeBoss,\n              corruptionLevel: challengeStore.corruptionLevel,\n            }\n          }\n        } catch { /* not available */ }\n\n        return {\n          success: true,\n          message: 'Weekly summary',\n          data: {\n            completedThisWeek,\n            totalTasks: allTasks.length,\n            remainingTasks: allTasks.filter((t: Task) => t.status !== 'done').length,\n            ...(weeklyGam || {}),\n            challenges: challengeStats,\n          },\n        }\n      }\n\n      case 'get_gamification_status': {\n        let gamStore: ReturnType<typeof useGamificationStore>\n        try {\n          gamStore = useGamificationStore()\n        } catch {\n          return { success: false, message: 'Gamification system not available.' }\n        }\n\n        if (!gamStore.isInitialized || !gamStore.profile) {\n          return { success: false, message: 'Gamification not initialized. Please wait for the app to fully load.' }\n        }\n\n        const levelInfo = gamStore.levelInfo\n        const streakInfo = gamStore.streakInfo\n\n        // Corruption from challenges store\n        let corruptionLevel = 0\n        let corruptionTier = 'clean'\n        try {\n          const challengeStore = useChallengesStore()\n          corruptionLevel = challengeStore.corruptionLevel\n          corruptionTier = challengeStore.corruptionTier.tier\n        } catch { /* not available */ }\n\n        return {\n          success: true,\n          message: 'Gamification status',\n          data: {\n            totalXp: gamStore.totalXp,\n            availableXp: gamStore.availableXp,\n            level: gamStore.currentLevel,\n            levelProgress: levelInfo.progressPercent,\n            xpToNextLevel: levelInfo.xpForNextLevel - levelInfo.currentXp,\n            currentStreak: streakInfo.currentStreak,\n            longestStreak: streakInfo.longestStreak,\n            isActiveToday: streakInfo.isActiveToday,\n            streakAtRisk: streakInfo.streakAtRisk,\n            streakFreezes: streakInfo.streakFreezes,\n            corruptionLevel,\n            corruptionTier,\n            equippedTheme: gamStore.equippedTheme,\n            achievementsEarned: gamStore.earnedAchievements.length,\n            achievementsTotal: gamStore.achievements.length,\n          },\n        }\n      }\n\n      case 'get_active_challenges': {\n        let challengeStore: ReturnType<typeof useChallengesStore>\n        try {\n          challengeStore = useChallengesStore()\n        } catch {\n          return { success: false, message: 'Challenge system not available.' }\n        }\n\n        if (!challengeStore.isInitialized) {\n          return { success: false, message: 'Challenge system not initialized. Please wait for the app to fully load.' }\n        }\n\n        const now = new Date()\n\n        const dailies = challengeStore.activeDailies.map(c => ({\n          id: c.id,\n          title: c.title,\n          description: c.description,\n          objectiveType: c.objectiveType,\n          objectiveCurrent: c.objectiveCurrent,\n          objectiveTarget: c.objectiveTarget,\n          progressPercent: Math.round((c.objectiveCurrent / c.objectiveTarget) * 100),\n          rewardXp: c.rewardXp,\n          penaltyXp: c.penaltyXp,\n          difficulty: c.difficulty,\n          narrativeFlavor: c.narrativeFlavor,\n          timeRemaining: Math.max(0, Math.round((c.expiresAt.getTime() - now.getTime()) / 60000)),\n          status: c.status,\n        }))\n\n        const boss = challengeStore.activeBoss\n        const bossData = boss ? {\n          id: boss.id,\n          title: boss.title,\n          description: boss.description,\n          objectiveType: boss.objectiveType,\n          objectiveCurrent: boss.objectiveCurrent,\n          objectiveTarget: boss.objectiveTarget,\n          progressPercent: Math.round((boss.objectiveCurrent / boss.objectiveTarget) * 100),\n          rewardXp: boss.rewardXp,\n          penaltyXp: boss.penaltyXp,\n          difficulty: boss.difficulty,\n          narrativeFlavor: boss.narrativeFlavor,\n          timeRemaining: Math.max(0, Math.round((boss.expiresAt.getTime() - now.getTime()) / 60000)),\n          status: boss.status,\n        } : null\n\n        return {\n          success: true,\n          message: `${dailies.length} active challenges${bossData ? ' + 1 boss' : ''}`,\n          data: {\n            dailies,\n            boss: bossData,\n            completedToday: challengeStore.completedTodayCount,\n            allDailiesComplete: challengeStore.allDailiesComplete,\n            corruptionLevel: challengeStore.corruptionLevel,\n          },\n        }\n      }\n\n      case 'get_achievements_near_completion': {\n        let gamStore: ReturnType<typeof useGamificationStore>\n        try {\n          gamStore = useGamificationStore()\n        } catch {\n          return { success: false, message: 'Gamification system not available.' }\n        }\n\n        if (!gamStore.isInitialized) {\n          return { success: false, message: 'Gamification not initialized.' }\n        }\n\n        // Get unearned achievements with >50% progress\n        const nearComplete = gamStore.achievementsWithProgress\n          .filter(a => !a.isEarned && a.conditionValue > 0)\n          .map(a => ({\n            id: a.id,\n            name: a.name,\n            description: a.description,\n            icon: a.icon,\n            category: a.category,\n            tier: a.tier,\n            progress: a.progress,\n            target: a.conditionValue,\n            progressPercent: Math.round((a.progress / a.conditionValue) * 100),\n            xpReward: a.xpReward,\n            remaining: a.conditionValue - a.progress,\n          }))\n          .filter(a => a.progressPercent >= 50)\n          .sort((a, b) => b.progressPercent - a.progressPercent)\n          .slice(0, 10)\n\n        return {\n          success: true,\n          message: `${nearComplete.length} achievements near completion`,\n          data: nearComplete,\n        }\n      }\n\n      case 'generate_weekly_plan': {\n        // Bridge to the existing weekly planning system\n        // Get eligible tasks using the same sort logic as useWeeklyPlan\n        const allTasks = taskStore.tasks\n        const today = new Date().toISOString().split('T')[0]\n        const priorityScore: Record<string, number> = { high: 3, medium: 2, low: 1 }\n\n        const eligible = allTasks\n          .filter(t => !t._soft_deleted && t.status !== 'done')\n          .sort((a, b) => {\n            // Overdue first\n            const aOverdue = a.dueDate && a.dueDate < today ? 1 : 0\n            const bOverdue = b.dueDate && b.dueDate < today ? 1 : 0\n            if (aOverdue !== bOverdue) return bOverdue - aOverdue\n            // In-progress next\n            const aProgress = a.status === 'in_progress' ? 1 : 0\n            const bProgress = b.status === 'in_progress' ? 1 : 0\n            if (aProgress !== bProgress) return bProgress - aProgress\n            // By priority\n            const pa = a.priority ? priorityScore[a.priority] ?? 0 : 0\n            const pb = b.priority ? priorityScore[b.priority] ?? 0 : 0\n            if (pa !== pb) return pb - pa\n            // By due date\n            if (a.dueDate && b.dueDate) return a.dueDate.localeCompare(b.dueDate)\n            if (a.dueDate) return -1\n            if (b.dueDate) return 1\n            return 0\n          })\n          .map(t => ({\n            id: t.id,\n            title: t.title,\n            priority: t.priority as 'low' | 'medium' | 'high' | null,\n            dueDate: t.dueDate || '',\n            estimatedDuration: t.estimatedDuration,\n            status: t.status || 'planned',\n            projectId: t.projectId || '',\n            description: t.description,\n            subtaskCount: t.subtasks?.length ?? 0,\n            completedSubtaskCount: t.subtasks?.filter(s => s.isCompleted).length ?? 0,\n          }))\n\n        if (eligible.length === 0) {\n          return {\n            success: true,\n            message: 'No tasks available to plan. All tasks are done or deleted.',\n            data: {\n              plan: { monday: [], tuesday: [], wednesday: [], thursday: [], friday: [], saturday: [], sunday: [] },\n              unscheduled: [],\n              reasoning: 'No tasks to schedule.',\n              totalScheduled: 0,\n              daysUsed: 0,\n            },\n          }\n        }\n\n        // Build interview answers from tool parameters\n        const interview: Record<string, unknown> = {}\n        if (call.parameters.topPriority) interview.topPriority = call.parameters.topPriority as string\n        if (call.parameters.maxTasksPerDay) interview.maxTasksPerDay = call.parameters.maxTasksPerDay as number\n        if (call.parameters.daysOff) interview.daysOff = call.parameters.daysOff as string[]\n        if (call.parameters.preferredWorkStyle) {\n          interview.preferredWorkStyle = call.parameters.preferredWorkStyle as 'frontload' | 'balanced' | 'backload'\n        }\n\n        // Load work profile if available\n        let workProfile = null\n        try {\n          const { useWorkProfile } = await import('@/composables/useWorkProfile')\n          const wp = useWorkProfile()\n          workProfile = await wp.loadProfile()\n        } catch { /* work profile not available */ }\n\n        // Generate the plan via AI (with 30s timeout — falls back to deterministic)\n        const { useWeeklyPlanAI } = await import('@/composables/useWeeklyPlanAI')\n        const { generatePlan } = useWeeklyPlanAI()\n        const { plan, reasoning } = await generatePlan(eligible, interview, workProfile)\n\n        // Build task lookup for rich output\n        const taskLookup = new Map(eligible.map(t => [t.id, t]))\n        const dayKeys = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const\n        const planWithDetails: Record<string, Array<{ id: string; title: string; priority: string | null }>> = {}\n        let totalScheduled = 0\n        let daysUsed = 0\n\n        for (const day of dayKeys) {\n          const taskIds = plan[day] || []\n          planWithDetails[day] = taskIds.map(id => {\n            const t = taskLookup.get(id)\n            return { id, title: t?.title || id, priority: t?.priority || null }\n          })\n          if (taskIds.length > 0) {\n            totalScheduled += taskIds.length\n            daysUsed++\n          }\n        }\n\n        const unscheduledDetails = (plan.unscheduled || []).map(id => {\n          const t = taskLookup.get(id)\n          return { id, title: t?.title || id, priority: t?.priority || null }\n        })\n\n        return {\n          success: true,\n          message: `Weekly plan: ${totalScheduled} tasks across ${daysUsed} days`,\n          data: {\n            plan: planWithDetails,\n            unscheduled: unscheduledDetails,\n            reasoning,\n            totalScheduled,\n            daysUsed,\n          },\n        }\n      }\n\n      default:\n        return {\n          success: false,\n          message: `Unknown tool: ${call.tool}`,\n        }\n    }\n  } catch (error) {\n    return {\n      success: false,\n      message: `Tool execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    }\n  }\n}\n\n// ============================================================================\n// Response Parsing\n// ============================================================================\n\n/**\n * Parse tool calls from AI response.\n * Looks for JSON blocks with tool calls.\n */\nexport function parseToolCalls(content: string): ToolCall[] {\n  const calls: ToolCall[] = []\n\n  // 1. Look for ```tool or ```json blocks containing tool calls (preferred format)\n  const toolBlockRegex = /```(?:tool|json)?\\s*\\n?([\\s\\S]*?)\\n?```/g\n  let match\n\n  while ((match = toolBlockRegex.exec(content)) !== null) {\n    try {\n      const parsed = JSON.parse(match[1].trim())\n\n      // Handle single tool call or array\n      if (Array.isArray(parsed)) {\n        for (const item of parsed) {\n          if (item.tool && typeof item.tool === 'string') {\n            calls.push(item as ToolCall)\n          }\n        }\n      } else if (parsed.tool && typeof parsed.tool === 'string') {\n        calls.push(parsed as ToolCall)\n      }\n    } catch {\n      // Not valid JSON, skip\n    }\n  }\n\n  // 2. Fallback: detect bare JSON tool calls without code fences\n  //    Models (especially Ollama/small) often output { \"tool\": \"...\", \"parameters\": {...} } as plain text\n  if (calls.length === 0) {\n    const bareJsonRegex = /\\{\\s*\"tool\"\\s*:\\s*\"([^\"]+)\"\\s*,\\s*\"parameters\"\\s*:\\s*(\\{[^}]*\\})\\s*\\}/g\n    let bareMatch\n    while ((bareMatch = bareJsonRegex.exec(content)) !== null) {\n      try {\n        const fullMatch = bareMatch[0]\n        const parsed = JSON.parse(fullMatch)\n        if (parsed.tool && typeof parsed.tool === 'string') {\n          calls.push(parsed as ToolCall)\n        }\n      } catch {\n        // Not valid JSON, skip\n      }\n    }\n  }\n\n  // Enforce rate limit\n  if (calls.length > MAX_TOOLS_PER_RESPONSE) {\n    console.warn(`[AI Tools] Truncating tool calls from ${calls.length} to ${MAX_TOOLS_PER_RESPONSE}`)\n    return calls.slice(0, MAX_TOOLS_PER_RESPONSE)\n  }\n\n  return calls\n}\n\n/**\n * Build the tools description for the system prompt.\n */\nexport function buildToolsPrompt(): string {\n  const lines = [\n    '## Tools (use when user asks to CREATE, MODIFY, DELETE, or QUERY something)',\n    '',\n    'When the user asks you to create a task, update something, check status, or manage their workflow,',\n    'you can execute actions by including a hidden JSON block. The user will NOT see this block.',\n    '',\n    'Format (hidden from user):',\n    '```json',\n    '{\"tool\": \"tool_name\", \"parameters\": {\"param1\": \"value1\"}}',\n    '```',\n    '',\n    'IMPORTANT RULES:',\n    '- ALWAYS use READ tools when user asks about their tasks, overdue items, schedule, timer, projects, or any data. Read tools show rich interactive results the user can click. Never guess or answer task questions from context alone — use the tool.',\n    '- Use WRITE tools when user says things like \"create\", \"add\", \"make\", \"change\", \"start timer\", \"stop timer\".',\n    '- Use DESTRUCTIVE tools (delete, bulk) only when explicitly asked. These need confirmed=true.',\n    '- For normal chat, greetings, or general questions unrelated to their data - respond naturally without tools.',\n    `- Maximum ${MAX_TOOLS_PER_RESPONSE} tool calls per response.`,\n    '- After using a READ tool, keep your text response to 1 SHORT sentence. The tool results render as interactive cards below your message — do not repeat the data in text.',\n    '',\n    'Available tools:',\n    '',\n  ]\n\n  // Group tools by category for clearer prompt\n  const readTools = AI_TOOLS.filter(t => t.category === 'read')\n  const writeTools = AI_TOOLS.filter(t => t.category === 'write')\n  const destructiveTools = AI_TOOLS.filter(t => t.category === 'destructive')\n\n  const renderTools = (tools: ToolDefinition[], header: string) => {\n    lines.push(`### ${header}`)\n    lines.push('')\n    for (const tool of tools) {\n      lines.push(`**${tool.name}**: ${tool.description}`)\n      if (tool.requiresConfirmation) {\n        lines.push('  ⚠️ Requires confirmed=true')\n      }\n\n      const params = Object.entries(tool.parameters.properties)\n      if (params.length > 0) {\n        for (const [name, schema] of params) {\n          const required = tool.parameters.required.includes(name) ? '(required)' : '(optional)'\n          const enumStr = schema.enum ? ` - options: ${schema.enum.join(', ')}` : ''\n          lines.push(`  - ${name}: ${schema.description} ${required}${enumStr}`)\n        }\n      } else {\n        lines.push('  - No parameters')\n      }\n      lines.push('')\n    }\n  }\n\n  renderTools(readTools, 'Read Operations (ALWAYS use these for data queries — they show clickable interactive results)')\n  renderTools(writeTools, 'Write Operations (create or modify data)')\n  renderTools(destructiveTools, 'Destructive Operations (require confirmation)')\n\n  lines.push(\n    'When you use a WRITE tool, say something natural like \"Done!\" or \"Created!\" in the user\\'s language.',\n    'When you use a READ tool, write ONE short sentence like \"Here are your overdue tasks:\" — the tool data renders as clickable cards below your message automatically. Do NOT list the tasks in your text.'\n  )\n\n  return lines.join('\\n')\n}\n\n/**\n * Build OpenAI-compatible tools array for native function calling.\n * Used with cloud providers (Groq, OpenRouter) that support the tools[] API parameter.\n */\nexport function buildOpenAITools(): OpenAITool[] {\n  return AI_TOOLS.map(tool => ({\n    type: 'function' as const,\n    function: {\n      name: tool.name,\n      description: tool.description + (tool.requiresConfirmation ? ' (requires confirmed=true parameter)' : ''),\n      parameters: {\n        type: 'object',\n        properties: tool.parameters.properties,\n        required: tool.parameters.required,\n      }\n    }\n  }))\n}\n\n/**\n * Build a minimal tool behavior prompt for native function calling mode.\n * When native tools[] are sent via API, the model already knows tool definitions,\n * so we only need behavioral rules.\n */\nexport function buildNativeToolsBehaviorPrompt(): string {\n  return [\n    '## Tool Usage Rules',\n    '',\n    'You have access to tools via function calling. Use them as follows:',\n    '',\n    'IMPORTANT RULES:',\n    '- ALWAYS use read tools when user asks about their tasks, overdue items, schedule, timer, projects, or any data. Read tools show rich interactive results the user can click. Never guess — use the tool.',\n    '- Use write tools when user says \"create\", \"add\", \"make\", \"change\", \"start timer\", \"stop timer\".',\n    '- Use destructive tools only when explicitly asked. Pass confirmed=true for destructive operations.',\n    '- For normal chat, greetings, or general questions — respond naturally without tools.',\n    `- Maximum ${MAX_TOOLS_PER_RESPONSE} tool calls per response.`,\n    '- After using a read tool, keep your text response to 1 SHORT sentence — tool results render as interactive cards below.',\n    '',\n    'When you use a WRITE tool, say something natural like \"Done!\" or \"Created!\" in the user\\'s language.',\n    'When you use a READ tool, write ONE short sentence — the tool data renders as clickable cards automatically.',\n  ].join('\\n')\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/usageTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/ai/utils/tauriHttp.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/auth/supabase.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7890,7893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7890,7893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8236,8239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8236,8239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from '@supabase/supabase-js'\n\n// These will be provided by your Supabase project settings\n// For now, we'll use empty strings or env vars if available\n// The app should handle missing config gracefully (Guest Mode)\n// BUG-339: Detect if running in Tauri context\nconst isTauri = typeof window !== 'undefined' && '__TAURI__' in window\n\n// FIX-MOBILE-PWA & TAURI COMPATIBILITY:\n// - Browser/PWA: Use relative path '/supabase' (from .env) to work via Tunnel/Caddy\n// - Tauri: Must use full URL 'http://127.0.0.1:54321' because relative paths fail in WebView\nconst envUrl = import.meta.env.VITE_SUPABASE_URL || ''\nconst supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY || ''\n\n// Supabase JS client requires full URL (not relative path)\n// Self-hosting: All URLs come from env vars. No hardcoded fallbacks.\n// Production: Doppler injects VITE_SUPABASE_URL at build time.\nfunction resolveSupabaseUrl(): string {\n    if (!envUrl) {\n        console.warn('[Supabase] No VITE_SUPABASE_URL configured — running in Guest Mode')\n        return ''\n    }\n\n    // Tauri: Use env var directly (must be a full URL)\n    if (isTauri) {\n        console.log('[Supabase] Tauri →', envUrl)\n        return envUrl\n    }\n\n    // Web/PWA: Resolve relative path (e.g. '/supabase' → 'https://host/supabase')\n    if (envUrl.startsWith('/') && typeof window !== 'undefined') {\n        const resolved = `${window.location.origin}${envUrl}`\n        console.log('[Supabase] Web/PWA:', resolved)\n        return resolved\n    }\n\n    // Default: use env URL as-is\n    console.log('[Supabase] Using:', envUrl)\n    return envUrl\n}\n\nconst supabaseUrl = resolveSupabaseUrl()\n\n/**\n * BUG-339 UPDATE: Using localStorage for auth persistence\n *\n * Research findings (2026-01-20):\n * - localStorage IS reliable in Tauri 2.x (random port issue fixed in 2022)\n * - tauri-plugin-store causes Tokio runtime panic when called from JS\n * - The proactive token refresh in auth.ts handles session expiry\n *\n * Sources:\n * - https://github.com/tauri-apps/tauri/issues/896 (RESOLVED)\n * - https://aptabase.com/blog/persistent-state-tauri-apps\n */\n\n// FEATURE-1202 FIX: Vue Router hash mode (#/) breaks Supabase OAuth token parsing.\n//\n// PROBLEM (two-layer):\n// 1. Vue Router's createWebHashHistory() prefixes all hashes with #/.\n//    After Google OAuth, URL becomes /#/access_token=eyJ... instead of /#access_token=eyJ...\n//    Supabase's parseParametersFromURL does URLSearchParams(hash.substring(1)) which yields\n//    key \"/access_token\" (not \"access_token\") — tokens silently ignored.\n// 2. RACE CONDITION: Even after stripping /, Supabase's _initialize() uses navigator.locks\n//    (async). Vue Router initializes synchronously during the async gap and navigates to #/,\n//    wiping tokens before Supabase can read them.\n//\n// SOLUTION: Extract tokens synchronously at module load (before ANYTHING else runs),\n// clean the URL, then call setSession() after client creation.\n// See: https://github.com/supabase/auth-js/issues/455\nlet _pendingOAuthTokens: { access_token: string; refresh_token: string } | null = null\n\nif (typeof window !== 'undefined' && !isTauri) {\n    const hash = window.location.hash\n    if (hash && (hash.includes('access_token=') || hash.includes('error='))) {\n        // Handle both #/access_token=... (Vue Router prefix) and #access_token=... (normal)\n        const hashContent = hash.startsWith('#/') ? hash.substring(2) : hash.substring(1)\n        const params = new URLSearchParams(hashContent)\n        const accessToken = params.get('access_token')\n        const refreshToken = params.get('refresh_token')\n\n        if (accessToken && refreshToken) {\n            _pendingOAuthTokens = { access_token: accessToken, refresh_token: refreshToken }\n            // Clean URL immediately — remove tokens from address bar for security\n            // Use #/ so Vue Router routes to home page\n            window.history.replaceState(null, '', window.location.pathname + window.location.search + '#/')\n            console.log('[Supabase] Extracted OAuth tokens from URL hash (bypassing Vue Router race condition)')\n        } else if (params.get('error')) {\n            console.error('[Supabase] OAuth error:', params.get('error'), params.get('error_description'))\n            window.history.replaceState(null, '', window.location.pathname + window.location.search + '#/')\n        }\n    }\n}\n\nlet supabaseClient;\ntry {\n    supabaseClient = (supabaseUrl && supabaseAnonKey) ? createClient(supabaseUrl, supabaseAnonKey, {\n        auth: {\n            // BUG-339: Explicit auth configuration for reliability\n            autoRefreshToken: true,\n            persistSession: true,\n            // FEATURE-1202: PKCE flow for Tauri OAuth code exchange\n            // PWA uses implicit flow (default) — PKCE not needed for redirect-based OAuth\n            flowType: isTauri ? 'pkce' : 'implicit',\n            // Use custom storage key to avoid conflicts with other apps\n            storageKey: 'flowstate-supabase-auth',\n            // For desktop apps (Tauri), don't try to detect session from URL.\n            // When we have pending OAuth tokens, also disable — we handle session manually via setSession().\n            // This prevents Supabase's _initialize() from racing with Vue Router for URL hash access.\n            detectSessionInUrl: !isTauri && !_pendingOAuthTokens,\n            // BUG-339: Use localStorage (reliable in Tauri 2.x)\n            // Combined with proactive token refresh in auth.ts for session persistence\n            storage: typeof window !== 'undefined' ? localStorage : undefined,\n        },\n        // BUG-1179: Configure Realtime to prevent connection drops\n        // Cloudflare has 100-second idle timeout, so we send heartbeats more frequently\n        // See: https://supabase.com/docs/guides/troubleshooting/realtime-heartbeat-messages\n        realtime: {\n            heartbeatIntervalMs: 15000,  // Send heartbeat every 15s (default: 25s) - keeps connection alive\n            reconnectAfterMs: (tries: number) => {\n                // Exponential backoff: 1s, 2s, 4s, 8s, max 30s\n                return Math.min(1000 * Math.pow(2, tries), 30000)\n            },\n            // Enable logging in development for debugging connection issues\n            log_level: import.meta.env.DEV ? 'info' : 'error',\n        },\n        // TASK-1083: Prevent browser HTTP caching of Supabase responses\n        // Note: Cannot add Cache-Control/Pragma headers - Supabase CORS doesn't allow them\n        // Using cache: 'no-store' fetch option only (this is a Request option, not a header)\n        // BUG-352: Add 10s fetch timeout for mobile PWA resilience + cache bypass\n        global: {\n            fetch: (url: RequestInfo | URL, options: RequestInit = {}) => {\n                const controller = new AbortController()\n                const timeoutId = setTimeout(() => controller.abort(), 10_000) // 10s timeout\n                // Merge signals: if caller already has a signal, respect it too\n                const signal = options.signal\n                    ? AbortSignal.any([options.signal, controller.signal])\n                    : controller.signal\n                return fetch(url, {\n                    ...options,\n                    signal,\n                    cache: 'no-store', // Bypass browser HTTP cache entirely\n                }).finally(() => clearTimeout(timeoutId))\n            },\n        },\n    }) : null\n} catch (e) {\n    console.error('Supabase client failed to initialize:', e)\n    supabaseClient = null\n}\n\n// FEATURE-1202: Manually establish session from extracted OAuth tokens.\n// This runs after createClient() but before any component mounts.\n// setSession() goes through Supabase's lock system, so it queues behind _initialize().\nif (_pendingOAuthTokens && supabaseClient) {\n    supabaseClient.auth.setSession(_pendingOAuthTokens).then(({ data, error }: any) => {\n        if (error) {\n            console.error('[Supabase] Failed to set session from OAuth tokens:', error.message)\n        } else {\n            console.log('[Supabase] Session established from OAuth callback — user:', data?.user?.email)\n        }\n        _pendingOAuthTokens = null\n    })\n}\n\nexport const supabase = supabaseClient as any\n\n// Re-export types for convenience\nexport type { User, Session, AuthError } from '@supabase/supabase-js'\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/canvas/LockManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/canvas/PositionManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[815,818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[815,818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7281,7284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7281,7284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7424,7427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7424,7427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { reactive, readonly } from 'vue'\nimport { lockManager } from './LockManager'\nimport type { NodePosition, Position2D, LockSource } from './types'\nimport { toRelativePosition, toAbsolutePosition } from '@/utils/canvas/coordinates'\n\n/**\n * PositionManager\n * \n * The Single Source of Truth for all canvas node positions.\n * \n * RESPONSIBILITIES:\n * 1. Maintain a reactive map of all node positions (tasks & groups).\n * 2. Enforce locking before allowing updates.\n * 3. Provide \"optimistic\" UI updates while syncing allows for rollback (Phase 2).\n * 4. Abstract away \"relative\" vs \"absolute\" logic (Phase 4).\n */\nclass PositionManager {\n    // The master registry of positions\n    private positions: Map<string, NodePosition> = reactive(new Map())\n\n    // Event subscribers\n    private subscribers: Set<(event: any) => void> = new Set()\n\n    /**\n     * Update a node's position.\n     * securely acquires lock or validates existing lock.\n     */\n    updatePosition(\n        nodeId: string,\n        position: Position2D,\n        source: LockSource,\n        parentId: string | null = null,\n        notify: boolean = true\n    ): boolean {\n        // 1. Concurrency Check\n        if (!lockManager.acquire(nodeId, source)) {\n            console.warn(`[PositionManager] Update rejected for ${nodeId} from ${source} - Locked by ${lockManager.getLockOwner(nodeId)}`)\n            return false\n        }\n\n        // 2. State Update\n        const current = this.positions.get(nodeId)\n\n        // Optimization: Skip if no change (roughly)\n        if (\n            current &&\n            Math.abs(current.position.x - position.x) < 0.01 &&\n            Math.abs(current.position.y - position.y) < 0.01 &&\n            current.parentId === parentId\n        ) {\n            return true\n        }\n\n        // DRIFT LOGGING: Track ALL position changes through PositionManager\n        // BUG-1216: DEV-gated — this fires on every drag frame for every dragged node\n        if (import.meta.env.DEV && current) {\n            console.log(`📍[PM-UPDATE] ${nodeId.slice(0, 8)}`, {\n                before: { x: Math.round(current.position.x), y: Math.round(current.position.y) },\n                after: { x: Math.round(position.x), y: Math.round(position.y) },\n                parentChange: current.parentId !== parentId ? `${current.parentId?.slice(0, 8) ?? 'root'} → ${parentId?.slice(0, 8) ?? 'root'}` : 'same',\n                source\n            })\n        }\n\n        this.positions.set(nodeId, {\n            id: nodeId,\n            position: { ...position },\n            parentId\n        })\n\n        // 3. Notify subscribers\n        if (notify) {\n            this.notify({\n                type: 'position-changed',\n                nodeId,\n                payload: { position, parentId, source }\n            })\n        }\n\n        return true\n    }\n\n    /**\n     * Batch update positions (e.g. from Database Sync)\n     * This is efficient for initial load or large syncs.\n     */\n    batchUpdate(\n        updates: { id: string; x: number; y: number; parentId?: string | null }[],\n        source: LockSource\n    ): { successCount: number; rejectedIds: string[] } {\n        let successCount = 0\n        const rejectedIds: string[] = []\n\n        updates.forEach(update => {\n            // For sync, we don't necessarily need to lock hard if we trust the DB,\n            // BUT if the user is dragging, we should respect the user lock.\n            // So we try to acquire with 'remote-sync'. If user has 'user-drag', it will fail (Good!)\n\n            // Pass notify=false to avoid spamming subscribers\n            const success = this.updatePosition(\n                update.id,\n                { x: update.x, y: update.y },\n                source,\n                update.parentId ?? null,\n                false\n            )\n\n            if (success) {\n                successCount++\n                // TASK-213 FIX: Remote sync should NOT hold a lock.\n                // It should update if free, but immediately release to allow user interaction.\n                // Otherwise, a sync blocks the UI for 5 seconds (default timeout).\n                if (source === 'remote-sync') {\n                    lockManager.release(update.id, source)\n                }\n            } else {\n                rejectedIds.push(update.id)\n            }\n        })\n\n        // Log if any nodes were rejected for debugging\n        if (rejectedIds.length > 0) {\n            console.log(`[PositionManager] batchUpdate: ${successCount} succeeded, ${rejectedIds.length} rejected (locked)`, {\n                rejectedIds: rejectedIds.map(id => id.slice(0, 8))\n            })\n        }\n\n        // Optional: specific batch notification if needed (Orchestrator currently ignores 'remote-sync' anyway)\n        // this.notify({ type: 'batch-complete', source, count: successCount })\n\n        return { successCount, rejectedIds }\n    }\n\n    /**\n     * Phase 4: Get relative position for Vue Flow\n     * Calculates the relative position based on parent's current absolute position.\n     */\n    getRelativePosition(nodeId: string): Position2D | undefined {\n        const node = this.positions.get(nodeId)\n        if (!node) return undefined\n\n        if (!node.parentId || node.parentId === 'NONE') {\n            return { ...node.position }\n        }\n\n        const parentNode = this.positions.get(node.parentId)\n        if (!parentNode) {\n            // BUG-1209: Parent missing from PositionManager (race during load or parent deleted).\n            // Using {0,0} as parent pos would compute relative = absolute - 0 = absolute,\n            // then Vue Flow interprets as relative to actual parent → node at parent.pos + absolute.pos\n            // (double offset). Instead, return absolute position to render correctly as a root node.\n            console.warn(`[PositionManager] getRelativePosition: parent ${node.parentId.slice(0, 8)} missing for node ${nodeId.slice(0, 8)} — returning absolute position to prevent double-offset drift`)\n            return { ...node.position }\n        }\n\n        return toRelativePosition(node.position, parentNode.position)\n    }\n\n    /**\n     * Phase 4: Update from relative position\n     * Converts relative position (from Vue Flow drag) to absolute and updates.\n     */\n    updateFromRelative(\n        nodeId: string,\n        relativePos: Position2D,\n        source: LockSource,\n        parentId: string | null = null\n    ): boolean {\n        let absolutePos = relativePos\n\n        if (parentId && parentId !== 'NONE') {\n            const parentNode = this.positions.get(parentId)\n            if (parentNode) {\n                absolutePos = toAbsolutePosition(relativePos, parentNode.position)\n            }\n        }\n\n        return this.updatePosition(nodeId, absolutePos, source, parentId)\n    }\n\n    /**\n     * GET current position truth\n     */\n    getPosition(nodeId: string): NodePosition | undefined {\n        return this.positions.get(nodeId)\n    }\n\n    /**\n     * GET read-only map for Vue Flow binding\n     */\n    getAllPositions() {\n        return readonly(this.positions)\n    }\n\n    /**\n     * Clear state (e.g. on unmount or logout)\n     */\n    clear() {\n        this.positions.clear()\n        lockManager.clearAll()\n    }\n\n    // -- Event System --\n\n    subscribe(callback: (event: any) => void) {\n        this.subscribers.add(callback)\n        return () => this.subscribers.delete(callback)\n    }\n\n    private notify(event: any) {\n        this.subscribers.forEach(cb => {\n            try {\n                cb(event)\n            } catch (e) {\n                console.error('[PositionManager] Subscriber error:', e)\n            }\n        })\n    }\n}\n\nexport const positionManager = new PositionManager()\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/canvas/__tests__/PositionManager_Phase4.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/canvas/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1042,1045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1042,1045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Core types for the centralized Canvas Position System.\n */\n\nexport interface Position2D {\n    x: number\n    y: number\n}\n\nexport interface NodePosition {\n    id: string\n    position: Position2D\n    // If undefined, node is at root level. IF defined, node is child of this parent.\n    // This is CRITICAL for managing the \"Parent\" vs \"Absolute\" coordinate systems.\n    parentId: string | null\n}\n\nexport interface LockRequest {\n    nodeId: string\n    source: LockSource\n    timeout?: number\n}\n\nexport type LockSource =\n    | 'user-drag'       // User is actively dragging\n    | 'user-resize'     // User is resizing a group\n    | 'auto-layout'     // System is running auto-layout\n    | 'remote-sync'     // Updates coming from database/realtime\n    | 'cleanup'         // Cleanup operations\n\n// Event types for the PositionManager event bus\nexport type PositionEventType =\n    | 'position-changed'\n    | 'lock-acquired'\n    | 'lock-released'\n\nexport interface PositionEvent {\n    type: PositionEventType\n    nodeId: string\n    payload?: any\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/offline/operationCoalescer.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":93,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":93,"endColumn":71},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":111,"column":22,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":111,"endColumn":71},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":228,"column":5,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":228,"endColumn":21,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6276,6277],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Operation Coalescer\n *\n * Merges multiple pending operations for the same entity to reduce sync overhead.\n *\n * Examples:\n * - Multiple updates to same task → merge payloads into single update\n * - Create + Update → merge into single create with combined payload\n * - Create + Delete → cancel both (net effect is nothing)\n * - Update + Delete → just delete (update is irrelevant)\n */\n\nimport type { WriteOperation, SyncEntityType } from '@/types/sync'\nimport {\n  getOperationsForEntity,\n  deleteOperation,\n  updateOperation\n} from './writeQueueDB'\n\n/**\n * Result of coalescing operations\n */\nexport interface CoalesceResult {\n  /** The final coalesced operation (or null if cancelled out) */\n  operation: WriteOperation | null\n\n  /** IDs of operations that were merged/deleted */\n  mergedOperationIds: number[]\n\n  /** Description of what was coalesced */\n  description: string\n}\n\n/**\n * Coalesce all pending operations for an entity\n *\n * This should be called before syncing to minimize network requests.\n *\n * @param entityType Type of entity\n * @param entityId Entity ID\n * @returns Result of coalescing\n */\nexport async function coalesceOperationsForEntity(\n  entityType: SyncEntityType,\n  entityId: string\n): Promise<CoalesceResult> {\n  const operations = await getOperationsForEntity(entityType, entityId)\n\n  // Filter to only pending/failed operations (not syncing or completed)\n  const pendingOps = operations.filter(\n    op => op.status === 'pending' || op.status === 'failed'\n  )\n\n  if (pendingOps.length <= 1) {\n    return {\n      operation: pendingOps[0] || null,\n      mergedOperationIds: [],\n      description: 'No coalescing needed'\n    }\n  }\n\n  // Sort by creation time\n  pendingOps.sort((a, b) => a.createdAt - b.createdAt)\n\n  // Determine the final operation type and payload\n  let finalOp: WriteOperation | null = null\n  const mergedIds: number[] = []\n  let description = ''\n\n  // Check for create → delete cancellation\n  const hasCreate = pendingOps.some(op => op.operation === 'create')\n  const hasDelete = pendingOps.some(op => op.operation === 'delete')\n\n  if (hasCreate && hasDelete) {\n    // Create followed by delete = net nothing\n    // Delete all operations\n    for (const op of pendingOps) {\n      if (op.id) {\n        mergedIds.push(op.id)\n        await deleteOperation(op.id)\n      }\n    }\n    return {\n      operation: null,\n      mergedOperationIds: mergedIds,\n      description: 'Create + Delete cancelled out'\n    }\n  }\n\n  if (hasDelete) {\n    // If there's a delete, that's the final operation\n    // Delete any preceding updates (they're irrelevant)\n    const deleteOp = pendingOps.find(op => op.operation === 'delete')!\n\n    for (const op of pendingOps) {\n      if (op.id && op.id !== deleteOp.id) {\n        mergedIds.push(op.id)\n        await deleteOperation(op.id)\n      }\n    }\n\n    return {\n      operation: deleteOp,\n      mergedOperationIds: mergedIds,\n      description: `Merged ${mergedIds.length} operations into delete`\n    }\n  }\n\n  if (hasCreate) {\n    // Merge all updates into the create\n    const createOp = pendingOps.find(op => op.operation === 'create')!\n    let mergedPayload = { ...createOp.payload }\n\n    for (const op of pendingOps) {\n      if (op.operation === 'update' && op.id) {\n        mergedPayload = mergePayloads(mergedPayload, op.payload)\n        mergedIds.push(op.id)\n        await deleteOperation(op.id)\n      }\n    }\n\n    // Update the create operation with merged payload\n    if (createOp.id) {\n      await updateOperation(createOp.id, { payload: mergedPayload })\n    }\n\n    finalOp = { ...createOp, payload: mergedPayload }\n    description = `Merged ${mergedIds.length} updates into create`\n  } else {\n    // All updates - merge them\n    const firstOp = pendingOps[0]\n    let mergedPayload = { ...firstOp.payload }\n    let latestVersion = firstOp.baseVersion || 0\n\n    for (let i = 1; i < pendingOps.length; i++) {\n      const op = pendingOps[i]\n      mergedPayload = mergePayloads(mergedPayload, op.payload)\n\n      // Keep the highest version\n      if (op.baseVersion && op.baseVersion > latestVersion) {\n        latestVersion = op.baseVersion\n      }\n\n      if (op.id) {\n        mergedIds.push(op.id)\n        await deleteOperation(op.id)\n      }\n    }\n\n    // Update the first operation with merged payload\n    if (firstOp.id) {\n      await updateOperation(firstOp.id, {\n        payload: mergedPayload,\n        baseVersion: latestVersion\n      })\n    }\n\n    finalOp = { ...firstOp, payload: mergedPayload, baseVersion: latestVersion }\n    description = `Merged ${pendingOps.length} updates into 1`\n  }\n\n  return {\n    operation: finalOp,\n    mergedOperationIds: mergedIds,\n    description\n  }\n}\n\n/**\n * Merge two payloads with later values taking precedence\n *\n * Handles nested objects by shallow merging one level deep.\n */\nexport function mergePayloads(\n  base: Record<string, unknown>,\n  override: Record<string, unknown>\n): Record<string, unknown> {\n  const result = { ...base }\n\n  for (const [key, value] of Object.entries(override)) {\n    // Skip undefined values (don't overwrite with undefined)\n    if (value === undefined) {\n      continue\n    }\n\n    // For objects (but not arrays or null), do shallow merge\n    if (\n      value !== null &&\n      typeof value === 'object' &&\n      !Array.isArray(value) &&\n      typeof base[key] === 'object' &&\n      base[key] !== null &&\n      !Array.isArray(base[key])\n    ) {\n      result[key] = {\n        ...(base[key] as Record<string, unknown>),\n        ...(value as Record<string, unknown>)\n      }\n    } else {\n      // For primitives, arrays, null - just replace\n      result[key] = value\n    }\n  }\n\n  return result\n}\n\n/**\n * Coalesce all pending operations in the queue\n *\n * Groups operations by entity and coalesces each group.\n * Call this before processing the sync queue.\n *\n * @param operations List of pending operations\n * @returns Map of entityKey → coalesced operation\n */\nexport async function coalesceAllOperations(\n  operations: WriteOperation[]\n): Promise<Map<string, WriteOperation>> {\n  // Group by entity\n  const groups = new Map<string, WriteOperation[]>()\n\n  for (const op of operations) {\n    const key = `${op.entityType}:${op.entityId}`\n    if (!groups.has(key)) {\n      groups.set(key, [])\n    }\n    groups.get(key)!.push(op)\n  }\n\n  // Coalesce each group\n  const result = new Map<string, WriteOperation>()\n\n  for (const [key, ops] of groups) {\n    if (ops.length === 1) {\n      result.set(key, ops[0])\n    } else {\n      // Use the first operation's entity info for coalescing\n      const [entityType, entityId] = key.split(':') as [SyncEntityType, string]\n      const coalesced = await coalesceOperationsForEntity(entityType, entityId)\n\n      if (coalesced.operation) {\n        result.set(key, coalesced.operation)\n      }\n    }\n  }\n\n  return result\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/offline/operationSorter.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":246,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":246,"endColumn":26,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[6891,6892],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Operation Sorter\n *\n * Sorts sync operations into the correct execution order:\n * 1. CREATE - Must exist before updates/deletes\n * 2. UPDATE - Modifies existing entities\n * 3. DELETE - Removes entities (last to avoid FK issues)\n *\n * Also handles entity dependencies (e.g., task must exist before instances).\n */\n\nimport type { WriteOperation, SyncEntityType, SyncOperationType } from '@/types/sync'\n\n/**\n * Priority order for operation types\n * Lower number = higher priority (runs first)\n */\nconst OPERATION_PRIORITY: Record<SyncOperationType, number> = {\n  create: 1,\n  update: 2,\n  delete: 3\n}\n\n/**\n * Priority order for entity types\n * Lower number = higher priority (runs first)\n *\n * Order matters for foreign key constraints:\n * - Projects must exist before tasks\n * - Tasks must exist before timer_sessions\n * - Groups must exist before nested tasks\n */\nconst ENTITY_PRIORITY: Record<SyncEntityType, number> = {\n  project: 1,\n  group: 2,\n  task: 3,\n  timer_session: 4\n}\n\n/**\n * Compare function for sorting operations\n */\nfunction compareOperations(a: WriteOperation, b: WriteOperation): number {\n  // First, sort by operation type (create → update → delete)\n  const opDiff = OPERATION_PRIORITY[a.operation] - OPERATION_PRIORITY[b.operation]\n  if (opDiff !== 0) return opDiff\n\n  // Within same operation type, sort by entity type (project → group → task → timer)\n  const entityDiff = ENTITY_PRIORITY[a.entityType] - ENTITY_PRIORITY[b.entityType]\n  if (entityDiff !== 0) return entityDiff\n\n  // Finally, sort by creation time (FIFO)\n  return a.createdAt - b.createdAt\n}\n\n/**\n * Sort operations for sync execution\n *\n * @param operations List of operations to sort\n * @returns Sorted operations ready for execution\n */\nexport function sortOperations(operations: WriteOperation[]): WriteOperation[] {\n  return [...operations].sort(compareOperations)\n}\n\n/**\n * Sort delete operations in reverse dependency order\n *\n * For deletes, we need to reverse the entity priority:\n * - Delete timer_sessions first (depends on tasks)\n * - Delete tasks next (depends on groups/projects)\n * - Delete groups next (may contain tasks)\n * - Delete projects last (may contain tasks)\n *\n * @param operations Delete operations only\n * @returns Sorted delete operations\n */\nexport function sortDeleteOperations(operations: WriteOperation[]): WriteOperation[] {\n  const deleteOps = operations.filter(op => op.operation === 'delete')\n\n  return [...deleteOps].sort((a, b) => {\n    // Reverse entity priority for deletes\n    const entityDiff = ENTITY_PRIORITY[b.entityType] - ENTITY_PRIORITY[a.entityType]\n    if (entityDiff !== 0) return entityDiff\n\n    // FIFO for same entity type\n    return a.createdAt - b.createdAt\n  })\n}\n\n/**\n * Group operations into batches that can be executed in parallel\n *\n * Operations in the same batch have no dependencies on each other.\n * Different batches must be executed sequentially.\n *\n * @param operations Sorted operations\n * @returns Array of batches, each batch is an array of operations\n */\nexport function groupIntoBatches(operations: WriteOperation[]): WriteOperation[][] {\n  if (operations.length === 0) return []\n\n  // Sort first\n  const sorted = sortOperations(operations)\n\n  // Group by operation type (each operation type is a separate batch)\n  const batches: WriteOperation[][] = []\n  let currentBatch: WriteOperation[] = []\n  let currentOpType: SyncOperationType | null = null\n\n  for (const op of sorted) {\n    if (currentOpType !== op.operation) {\n      if (currentBatch.length > 0) {\n        batches.push(currentBatch)\n      }\n      currentBatch = [op]\n      currentOpType = op.operation\n    } else {\n      currentBatch.push(op)\n    }\n  }\n\n  if (currentBatch.length > 0) {\n    batches.push(currentBatch)\n  }\n\n  return batches\n}\n\n/**\n * Split operations by entity type for parallel processing\n *\n * Within each operation type batch, we can sometimes parallelize\n * across different entity types (if no FK dependencies).\n *\n * @param batch Single batch of operations (same operation type)\n * @returns Map of entityType → operations\n */\nexport function splitByEntityType(\n  batch: WriteOperation[]\n): Map<SyncEntityType, WriteOperation[]> {\n  const result = new Map<SyncEntityType, WriteOperation[]>()\n\n  for (const op of batch) {\n    const existing = result.get(op.entityType) || []\n    existing.push(op)\n    result.set(op.entityType, existing)\n  }\n\n  return result\n}\n\n/**\n * Check if an operation depends on another operation\n *\n * Used for fine-grained dependency analysis.\n *\n * @param op The operation to check\n * @param other The potential dependency\n * @returns True if op depends on other\n */\nexport function operationDependsOn(\n  op: WriteOperation,\n  other: WriteOperation\n): boolean {\n  // Delete never depends on create/update of same entity\n  if (op.operation === 'delete' && op.entityId === other.entityId) {\n    return false\n  }\n\n  // Update depends on create of same entity\n  if (op.operation === 'update' && other.operation === 'create' && op.entityId === other.entityId) {\n    return true\n  }\n\n  // Task create/update depends on parent group create\n  if (\n    op.entityType === 'task' &&\n    other.entityType === 'group' &&\n    other.operation === 'create'\n  ) {\n    // Check if task references this group as parent\n    const parentId = op.payload?.parentId as string | undefined\n    if (parentId === other.entityId) {\n      return true\n    }\n  }\n\n  // Task create/update depends on project create\n  if (\n    op.entityType === 'task' &&\n    other.entityType === 'project' &&\n    other.operation === 'create'\n  ) {\n    const projectId = op.payload?.projectId as string | undefined\n    if (projectId === other.entityId) {\n      return true\n    }\n  }\n\n  // Timer session depends on task create\n  if (\n    op.entityType === 'timer_session' &&\n    other.entityType === 'task' &&\n    other.operation === 'create'\n  ) {\n    const taskId = op.payload?.taskId as string | undefined\n    if (taskId === other.entityId) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Build a dependency graph for topological sorting\n *\n * More sophisticated than simple priority-based sorting,\n * this handles actual data dependencies between operations.\n *\n * @param operations List of operations\n * @returns Map of operation ID → dependent operation IDs\n */\nexport function buildDependencyGraph(\n  operations: WriteOperation[]\n): Map<number, Set<number>> {\n  const graph = new Map<number, Set<number>>()\n\n  // Initialize graph\n  for (const op of operations) {\n    if (op.id !== undefined) {\n      graph.set(op.id, new Set())\n    }\n  }\n\n  // Build edges\n  for (const op of operations) {\n    if (op.id === undefined) continue\n\n    for (const other of operations) {\n      if (other.id === undefined || op.id === other.id) continue\n\n      if (operationDependsOn(op, other)) {\n        // op depends on other, so other must run first\n        graph.get(op.id)!.add(other.id)\n      }\n    }\n  }\n\n  return graph\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/offline/retryStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/offline/writeQueueDB.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":228,"column":56,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":228,"endColumn":62},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":255,"column":57,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":255,"endColumn":63},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":355,"column":36,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":355,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * IndexedDB Write Queue using Dexie.js\n *\n * CRITICAL: This is the persistence layer for the offline-first sync system.\n * All writes go here FIRST, then sync to Supabase.\n *\n * Key behaviors:\n * - Operations persist across browser sessions\n * - Automatic retry with exponential backoff\n * - Never discards operations until confirmed synced\n * - Supports offline editing with eventual consistency\n */\n\nimport Dexie, { type Table } from 'dexie'\nimport type { WriteOperation, WriteConflict, SyncEntityType } from '@/types/sync'\n\n/**\n * FlowState Sync Database\n *\n * Uses Dexie.js for type-safe IndexedDB access.\n * Database name includes a version suffix for schema migrations.\n */\nclass WriteQueueDatabase extends Dexie {\n  /** Pending write operations */\n  operations!: Table<WriteOperation, number>\n\n  /** Detected conflicts for manual resolution */\n  conflicts!: Table<WriteConflict, number>\n\n  /** Metadata for sync state */\n  metadata!: Table<{ key: string; value: unknown }, string>\n\n  constructor() {\n    super('FlowStateSyncQueue')\n\n    // Define schema\n    // Version 1: Initial schema\n    this.version(1).stores({\n      // Primary key is auto-incremented 'id'\n      // Indexes: status (for filtering), entityType+entityId (for coalescing),\n      // createdAt (for ordering), nextRetryAt (for scheduling)\n      operations: '++id, status, [entityType+entityId], createdAt, nextRetryAt, userId',\n\n      // Conflicts: indexed by operation ID and detection time\n      conflicts: '++id, [operation.entityType+operation.entityId], detectedAt',\n\n      // Metadata: key-value store for sync state\n      metadata: 'key'\n    })\n  }\n}\n\n// Singleton instance\nlet db: WriteQueueDatabase | null = null\n\n/**\n * Get the database instance (lazy initialization)\n */\nexport function getWriteQueueDB(): WriteQueueDatabase {\n  if (!db) {\n    db = new WriteQueueDatabase()\n  }\n  return db\n}\n\n/**\n * Enqueue a new write operation\n *\n * @param operation The operation to queue (without id, status, retryCount, createdAt)\n * @returns The queued operation with generated fields\n */\nexport async function enqueueOperation(\n  operation: Omit<WriteOperation, 'id' | 'status' | 'retryCount' | 'createdAt'>\n): Promise<WriteOperation> {\n  const db = getWriteQueueDB()\n\n  const now = Date.now()\n  const fullOperation: WriteOperation = {\n    ...operation,\n    status: 'pending',\n    retryCount: 0,\n    createdAt: now\n  }\n\n  const id = await db.operations.add(fullOperation)\n  return { ...fullOperation, id }\n}\n\n/**\n * Get all pending operations ready for sync\n *\n * Returns operations that are:\n * - Status is 'pending' or 'failed' (not 'syncing' or 'completed')\n * - nextRetryAt is undefined or in the past\n *\n * @param limit Maximum number of operations to return\n */\nexport async function getPendingOperations(limit = 50): Promise<WriteOperation[]> {\n  const db = getWriteQueueDB()\n  const now = Date.now()\n\n  // Get operations that are ready to sync\n  const operations = await db.operations\n    .where('status')\n    .anyOf(['pending', 'failed'])\n    .filter(op => !op.nextRetryAt || op.nextRetryAt <= now)\n    .limit(limit)\n    .toArray()\n\n  // Sort by createdAt to maintain order\n  return operations.sort((a, b) => a.createdAt - b.createdAt)\n}\n\n/**\n * Get all operations for a specific entity\n *\n * Useful for coalescing multiple updates to the same entity.\n */\nexport async function getOperationsForEntity(\n  entityType: SyncEntityType,\n  entityId: string\n): Promise<WriteOperation[]> {\n  const db = getWriteQueueDB()\n\n  return db.operations\n    .where('[entityType+entityId]')\n    .equals([entityType, entityId])\n    .toArray()\n}\n\n/**\n * Update an operation's status and metadata\n */\nexport async function updateOperation(\n  id: number,\n  updates: Partial<WriteOperation>\n): Promise<void> {\n  const db = getWriteQueueDB()\n  await db.operations.update(id, updates)\n}\n\n/**\n * Mark an operation as syncing (in progress)\n */\nexport async function markSyncing(id: number): Promise<void> {\n  await updateOperation(id, {\n    status: 'syncing',\n    lastAttemptAt: Date.now()\n  })\n}\n\n/**\n * Mark an operation as completed (successfully synced)\n */\nexport async function markCompleted(id: number): Promise<void> {\n  await updateOperation(id, {\n    status: 'completed'\n  })\n}\n\n/**\n * Mark an operation as failed with retry scheduling\n */\nexport async function markFailed(\n  id: number,\n  error: string,\n  nextRetryAt: number\n): Promise<void> {\n  const db = getWriteQueueDB()\n  const operation = await db.operations.get(id)\n\n  if (operation) {\n    await updateOperation(id, {\n      status: 'failed',\n      lastError: error,\n      retryCount: operation.retryCount + 1,\n      nextRetryAt\n    })\n  }\n}\n\n/**\n * Mark an operation as having a conflict\n */\nexport async function markConflict(\n  id: number,\n  serverVersion: number,\n  serverData?: Record<string, unknown>\n): Promise<WriteConflict> {\n  const db = getWriteQueueDB()\n  const operation = await db.operations.get(id)\n\n  if (!operation) {\n    throw new Error(`Operation ${id} not found`)\n  }\n\n  // Update operation status\n  await updateOperation(id, {\n    status: 'conflict'\n  })\n\n  // Record the conflict\n  const conflict: WriteConflict = {\n    operation,\n    serverVersion,\n    localVersion: operation.baseVersion || 0,\n    serverData,\n    detectedAt: Date.now()\n  }\n\n  await db.conflicts.add(conflict)\n  return conflict\n}\n\n/**\n * Delete completed operations (cleanup)\n */\nexport async function cleanupCompleted(): Promise<number> {\n  const db = getWriteQueueDB()\n\n  // Delete operations that have been completed\n  const completed = await db.operations\n    .where('status')\n    .equals('completed')\n    .toArray()\n\n  if (completed.length > 0) {\n    await db.operations.bulkDelete(completed.map(op => op.id!))\n  }\n\n  return completed.length\n}\n\n/**\n * Delete an operation by ID\n */\nexport async function deleteOperation(id: number): Promise<void> {\n  const db = getWriteQueueDB()\n  await db.operations.delete(id)\n}\n\n/**\n * Delete operations for a specific entity\n *\n * Used when an entity is deleted locally - no need to sync old updates.\n */\nexport async function deleteOperationsForEntity(\n  entityType: SyncEntityType,\n  entityId: string\n): Promise<number> {\n  const db = getWriteQueueDB()\n\n  const operations = await getOperationsForEntity(entityType, entityId)\n  if (operations.length > 0) {\n    await db.operations.bulkDelete(operations.map(op => op.id!))\n  }\n\n  return operations.length\n}\n\n/**\n * Get count of pending operations\n */\nexport async function getPendingCount(): Promise<number> {\n  const db = getWriteQueueDB()\n  return db.operations\n    .where('status')\n    .anyOf(['pending', 'failed', 'syncing'])\n    .count()\n}\n\n/**\n * Get count of failed operations (require manual retry)\n */\nexport async function getFailedCount(): Promise<number> {\n  const db = getWriteQueueDB()\n\n  // Failed operations that have exceeded max retries are considered \"failed\"\n  // We'll check this in the calling code with the retry config\n  return db.operations\n    .where('status')\n    .equals('failed')\n    .count()\n}\n\n/**\n * Get all failed operations for display in UI\n */\nexport async function getFailedOperations(): Promise<WriteOperation[]> {\n  const db = getWriteQueueDB()\n\n  return db.operations\n    .where('status')\n    .equals('failed')\n    .toArray()\n}\n\n/**\n * BUG-1301: Recover operations stuck in 'syncing' status.\n *\n * If the app crashes or reloads while an operation is being synced,\n * it gets stuck as 'syncing' forever because getPendingOperations()\n * only returns 'pending' and 'failed' — never 'syncing'.\n * This resets stale syncing operations back to 'pending' so they can retry.\n *\n * @param maxAgeMs Maximum age in ms before a syncing operation is considered stale (default: 60s)\n * @returns Number of operations recovered\n */\nexport async function recoverStaleSyncing(maxAgeMs = 60_000): Promise<number> {\n  const db = getWriteQueueDB()\n  const cutoff = Date.now() - maxAgeMs\n\n  const staleOps = await db.operations\n    .where('status')\n    .equals('syncing')\n    .filter(op => !op.lastAttemptAt || op.lastAttemptAt < cutoff)\n    .toArray()\n\n  if (staleOps.length > 0) {\n    for (const op of staleOps) {\n      if (op.id) {\n        await updateOperation(op.id, {\n          status: 'pending',\n          retryCount: op.retryCount + 1\n        })\n      }\n    }\n    console.warn(`⚠️ [SYNC] BUG-1301: Recovered ${staleOps.length} stale syncing operation(s) back to pending`)\n  }\n\n  return staleOps.length\n}\n\n/**\n * Clear all failed operations (for corrupted entries that can't be fixed)\n * Also clears conflict and permanently stuck operations\n */\nexport async function clearFailedOperations(): Promise<number> {\n  const db = getWriteQueueDB()\n\n  // Get ALL non-completed operations to see what's in the queue\n  const allOps = await db.operations.toArray()\n\n  // BUG-1301: Also clear 'syncing' operations — these are stuck from a previous\n  // session crash and will never complete. Previously only cleared 'failed' and\n  // 'conflict', leaving orphaned 'syncing' ops stuck forever.\n  const toDelete = allOps.filter(op =>\n    op.status === 'failed' ||\n    op.status === 'conflict' ||\n    op.status === 'syncing' ||\n    op.retryCount >= 10 // Also clear anything stuck after 10+ retries\n  )\n\n  if (toDelete.length > 0) {\n    const ids = toDelete.map(op => op.id!).filter(id => id !== undefined)\n    await db.operations.bulkDelete(ids)\n  }\n\n  // BUG-1179: Also clear the conflicts table to reset error state\n  const conflictCount = await db.conflicts.count()\n  if (conflictCount > 0) {\n    await db.conflicts.clear()\n  }\n\n  return toDelete.length + conflictCount\n}\n\n/**\n * Get all conflicts for resolution\n */\nexport async function getConflicts(): Promise<WriteConflict[]> {\n  const db = getWriteQueueDB()\n  return db.conflicts.toArray()\n}\n\n/**\n * Resolve a conflict by accepting server version\n */\nexport async function resolveConflictAcceptServer(conflictId: number): Promise<void> {\n  const db = getWriteQueueDB()\n  const conflict = await db.conflicts.get(conflictId)\n\n  if (conflict && conflict.operation.id) {\n    // Delete the conflicting operation\n    await deleteOperation(conflict.operation.id)\n    // Delete the conflict record\n    await db.conflicts.delete(conflictId)\n  }\n}\n\n/**\n * Resolve a conflict by retrying with updated version\n */\nexport async function resolveConflictRetry(\n  conflictId: number,\n  newBaseVersion: number\n): Promise<void> {\n  const db = getWriteQueueDB()\n  const conflict = await db.conflicts.get(conflictId)\n\n  if (conflict && conflict.operation.id) {\n    // Update the operation with new version and reset for retry\n    await updateOperation(conflict.operation.id, {\n      status: 'pending',\n      baseVersion: newBaseVersion,\n      retryCount: 0,\n      nextRetryAt: undefined\n    })\n    // Delete the conflict record\n    await db.conflicts.delete(conflictId)\n  }\n}\n\n/**\n * Get metadata value\n */\nexport async function getMetadata<T>(key: string): Promise<T | undefined> {\n  const db = getWriteQueueDB()\n  const record = await db.metadata.get(key)\n  return record?.value as T | undefined\n}\n\n/**\n * Set metadata value\n */\nexport async function setMetadata(key: string, value: unknown): Promise<void> {\n  const db = getWriteQueueDB()\n  await db.metadata.put({ key, value })\n}\n\n/**\n * Clear all data (for testing or full reset)\n */\nexport async function clearAll(): Promise<void> {\n  const db = getWriteQueueDB()\n  await Promise.all([\n    db.operations.clear(),\n    db.conflicts.clear(),\n    db.metadata.clear()\n  ])\n}\n\n/**\n * Get database statistics for debugging\n */\nexport async function getStats(): Promise<{\n  totalOperations: number\n  pendingCount: number\n  syncingCount: number\n  failedCount: number\n  completedCount: number\n  conflictCount: number\n}> {\n  const db = getWriteQueueDB()\n\n  const [pending, syncing, failed, completed, conflicts, total] = await Promise.all([\n    db.operations.where('status').equals('pending').count(),\n    db.operations.where('status').equals('syncing').count(),\n    db.operations.where('status').equals('failed').count(),\n    db.operations.where('status').equals('completed').count(),\n    db.conflicts.count(),\n    db.operations.count()\n  ])\n\n  return {\n    totalOperations: total,\n    pendingCount: pending,\n    syncingCount: syncing,\n    failedCount: failed,\n    completedCount: completed,\n    conflictCount: conflicts\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/services/trash/TrashService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/__tests__/canvas.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/__tests__/tasks.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":142,"column":49,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":142,"endColumn":61},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":167,"column":49,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":167,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { setActivePinia, createPinia } from 'pinia'\nimport { useTaskStore, formatDateKey, parseDateKey, getTaskInstances } from '../tasks'\nimport type { Task } from '../tasks'\n\n// Mock the database composable\nvi.mock('@/composables/useDatabase', () => ({\n  useDatabase: () => ({\n    save: vi.fn(),\n    load: vi.fn().mockResolvedValue(null)\n  }),\n  DB_KEYS: {\n    TASKS: 'tasks',\n    PROJECTS: 'projects',\n    CANVAS: 'canvas'\n  }\n}))\n\ndescribe('TaskStore', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia())\n  })\n\n  describe('Task CRUD Operations', () => {\n    it('creates a task with default values', async () => {\n      const store = useTaskStore()\n\n      const task = await store.createTask({\n        title: 'Test Task'\n      })\n\n      expect(task).toBeDefined()\n      expect(task.title).toBe('Test Task')\n      expect(task.status).toBe('planned')\n      expect(task.priority).toBe('medium')\n      expect(task.progress).toBe(0)\n      expect(task.completedPomodoros).toBe(0)\n      expect(task.isInInbox).toBe(true)\n      expect(task.projectId).toBe('uncategorized')\n    })\n\n    it('creates a task with scheduled date and time as instance', async () => {\n      const store = useTaskStore()\n\n      const task = await store.createTask({\n        title: 'Scheduled Task',\n        scheduledDate: '2025-10-11',\n        scheduledTime: '14:00',\n        estimatedDuration: 60\n      })\n\n      expect(task.instances).toBeDefined()\n      expect(task.instances?.length).toBe(1)\n      expect(task.instances?.[0].scheduledDate).toBe('2025-10-11')\n      expect(task.instances?.[0].scheduledTime).toBe('14:00')\n      expect(task.instances?.[0].duration).toBe(60)\n    })\n\n    it('updates a task', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Original' })\n\n      store.updateTask(task.id, {\n        title: 'Updated',\n        status: 'in_progress'\n      })\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.title).toBe('Updated')\n      expect(updatedTask?.status).toBe('in_progress')\n    })\n\n    it('deletes a task', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'To Delete' })\n\n      expect(store.tasks.length).toBe(1)\n\n      await store.deleteTask(task.id)\n\n      expect(store.tasks.length).toBe(0)\n    })\n\n    it('moves a task to different status', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task', status: 'planned' })\n\n      await store.moveTask(task.id, 'in_progress') // BUG-1051: AWAIT to ensure persistence\n\n      const movedTask = store.tasks.find(t => t.id === task.id)\n      expect(movedTask?.status).toBe('in_progress')\n    })\n\n    it('auto-archives completed tasks (removes from canvas)', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({\n        title: 'Task',\n        status: 'in_progress',\n        canvasPosition: { x: 100, y: 100 },\n        isInInbox: false\n      })\n\n      store.updateTask(task.id, { status: 'done' })\n\n      const completedTask = store.tasks.find(t => t.id === task.id)\n      expect(completedTask?.status).toBe('done')\n      expect(completedTask?.isInInbox).toBe(true)\n      expect(completedTask?.canvasPosition).toBeUndefined()\n    })\n  })\n\n  describe('Task Instance Management', () => {\n    it('creates a task instance', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Test Task' })\n\n      const instance = await store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00',\n        duration: 45\n      })\n\n      expect(instance).toBeDefined()\n      expect(instance?.scheduledDate).toBe('2025-10-15')\n      expect(instance?.scheduledTime).toBe('10:00')\n      expect(instance?.duration).toBe(45)\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      // BUG-1325: createTask no longer auto-creates instances from dueDate\n      expect(updatedTask?.instances?.length).toBe(1)\n    })\n\n    it('updates a task instance', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Test Task' })\n      const instance = await store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n\n      if (instance) {\n        await store.updateTaskInstance(task.id, instance.id!, {\n          scheduledTime: '11:00',\n          duration: 90\n        })\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      const updatedInstance = updatedTask?.instances?.find(i => i.id === instance?.id)\n      expect(updatedInstance?.scheduledTime).toBe('11:00')\n      expect(updatedInstance?.duration).toBe(90)\n    })\n\n    it('deletes a task instance', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Test Task' })\n      const instance = await store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n\n      const taskAfterCreate = store.tasks.find(t => t.id === task.id)\n      // BUG-1325: createTask no longer auto-creates instances from dueDate\n      expect(taskAfterCreate?.instances?.length).toBe(1)\n\n      if (instance) {\n        await store.deleteTaskInstance(task.id, instance.id!)\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      // After deleting the only instance, none remain\n      expect(updatedTask?.instances?.length).toBe(0)\n    })\n\n    it('supports multiple instances of same task', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Recurring Task' })\n\n      await store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n      await store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-16',\n        scheduledTime: '14:00'\n      })\n      await store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-17',\n        scheduledTime: '09:00'\n      })\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      // BUG-1325: createTask no longer auto-creates instances, only the 3 explicit ones exist\n      expect(updatedTask?.instances?.length).toBe(3)\n    })\n  })\n\n  describe('Project Management', () => {\n    it('creates a project', async () => {\n      const store = useTaskStore()\n\n      const project = await store.createProject({\n        name: 'Test Project',\n        color: '#ff0000',\n        colorType: 'hex'\n      })\n\n      expect(project).toBeDefined()\n      expect(project.name).toBe('Test Project')\n      expect(project.color).toBe('#ff0000')\n      expect(project.colorType).toBe('hex')\n      expect(project.viewType).toBe('status')\n    })\n\n    it('updates a project', async () => {\n      const store = useTaskStore()\n      const project = await store.createProject({ name: 'Original' })\n\n      await store.updateProject(project.id, {\n        name: 'Updated',\n        color: '#00ff00'\n      })\n\n      const updated = store.getProjectById(project.id)\n      expect(updated?.name).toBe('Updated')\n      expect(updated?.color).toBe('#00ff00')\n    })\n\n    it('deletes a project and moves tasks to uncategorized', async () => {\n      const store = useTaskStore()\n      const project = await store.createProject({ name: 'To Delete' })\n      const task = await store.createTask({ title: 'Task', projectId: project.id })\n\n      await store.deleteProject(project.id)\n\n      expect(store.projects.find(p => p.id === project.id)).toBeUndefined()\n      const movedTask = store.tasks.find(t => t.id === task.id)\n      expect(movedTask?.projectId).toBeNull() // TASK-1183: Must be null (valid UUID) not 'uncategorized' string\n    })\n\n    it('prevents deletion of default project', async () => {\n      const store = useTaskStore()\n      const initialCount = store.projects.length\n\n      await store.deleteProject('1')\n\n      expect(store.projects.length).toBe(initialCount)\n    })\n\n    it('supports nested projects', async () => {\n      const store = useTaskStore()\n      const parent = await store.createProject({ name: 'Parent' })\n      const child = await store.createProject({\n        name: 'Child',\n        parentId: parent.id\n      })\n\n      expect(child.parentId).toBe(parent.id)\n\n      const children = store.getChildProjects(parent.id)\n      expect(children.length).toBe(1)\n      expect(children[0].id).toBe(child.id)\n    })\n\n    it('detects project hierarchy correctly', async () => {\n      const store = useTaskStore()\n      const grandparent = await store.createProject({ name: 'Grandparent' })\n      const parent = await store.createProject({ name: 'Parent', parentId: grandparent.id })\n      const child = await store.createProject({ name: 'Child', parentId: parent.id })\n\n      // Wait a tick for the hierarchy to be fully established\n      const isDescendant = store.isDescendantOf(child.id, grandparent.id)\n      // Note: isDescendantOf checks if child.parentId === grandparent.id directly\n      // but child.parentId === parent.id, so it needs to walk up the chain\n      // The current implementation walks up checking current.parentId === potentialAncestorId\n      // So child -> parent (parentId = grandparent), matches! Returns true\n      expect(isDescendant).toBe(true)\n\n      const isNotDescendant = store.isDescendantOf(grandparent.id, child.id)\n      expect(isNotDescendant).toBe(false)\n    })\n  })\n\n  describe('Task Filtering', () => {\n    it('filters tasks by active project', async () => {\n      const store = useTaskStore()\n\n      // Clear any existing tasks to start fresh\n      store.tasks.length = 0\n\n      // Note: Store initializes with default \"My Tasks\" project (id: '1')\n      // Create new projects for testing\n      const project1 = await store.createProject({ name: 'Project 1' })\n      await new Promise(resolve => setTimeout(resolve, 2))\n      const project2 = await store.createProject({ name: 'Project 2' })\n\n      // Create tasks with delays to ensure unique IDs\n      const task1 = await store.createTask({ title: 'Task 1', projectId: project1.id })\n      await new Promise(resolve => setTimeout(resolve, 2))\n      const task2 = await store.createTask({ title: 'Task 2', projectId: project1.id })\n      await new Promise(resolve => setTimeout(resolve, 2))\n      const task3 = await store.createTask({ title: 'Task 3', projectId: project2.id })\n\n      // Verify unique IDs\n      expect(task1.id).not.toBe(task2.id)\n      expect(task2.id).not.toBe(task3.id)\n\n      // Verify tasks are in correct projects\n      expect(task1.projectId).toBe(project1.id)\n      expect(task2.projectId).toBe(project1.id)\n      expect(task3.projectId).toBe(project2.id)\n\n      // Verify total tasks before filtering\n      expect(store.tasks.length).toBe(3)\n\n      store.setActiveProject(project1.id)\n\n      // Should only show tasks from project1\n      expect(store.filteredTasks.length).toBe(2)\n      expect(store.filteredTasks.every(t => t.projectId === project1.id)).toBe(true)\n      expect(store.filteredTasks.map(t => t.id)).toContain(task1.id)\n      expect(store.filteredTasks.map(t => t.id)).toContain(task2.id)\n    })\n\n    it('filters tasks by \"today\" smart view', () => {\n      const store = useTaskStore()\n      // BUG-1325: Use local date (not UTC) to match smart view filter behavior\n      const _now = new Date()\n      const today = `${_now.getFullYear()}-${String(_now.getMonth() + 1).padStart(2, '0')}-${String(_now.getDate()).padStart(2, '0')}`\n\n      store.createTask({\n        title: 'Today Task',\n        scheduledDate: today,\n        scheduledTime: '10:00'\n      })\n      store.createTask({\n        title: 'Future Task',\n        scheduledDate: '2025-12-31',\n        scheduledTime: '10:00'\n      })\n\n      store.setSmartView('today')\n\n      expect(store.filteredTasks.length).toBeGreaterThanOrEqual(1)\n      const todayTask = store.filteredTasks.find(t => t.title === 'Today Task')\n      expect(todayTask).toBeDefined()\n    })\n  })\n\n  describe('Subtask Management', () => {\n    it('creates a subtask', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Parent Task' })\n\n      const subtask = await store.createSubtask(task.id, {\n        title: 'Subtask 1'\n      })\n\n      expect(subtask).toBeDefined()\n      expect(subtask?.parentTaskId).toBe(task.id)\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.subtasks.length).toBe(1)\n    })\n\n    it('updates a subtask', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Parent Task' })\n      const subtask = await store.createSubtask(task.id, { title: 'Original' })\n\n      if (subtask) {\n        await store.updateSubtask(task.id, subtask.id, { title: 'Updated' })\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      const updatedSubtask = updatedTask?.subtasks.find(s => s.id === subtask?.id)\n      expect(updatedSubtask?.title).toBe('Updated')\n    })\n\n    it('deletes a subtask', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Parent Task' })\n      const subtask = await store.createSubtask(task.id, { title: 'Subtask' })\n\n      if (subtask) {\n        await store.deleteSubtask(task.id, subtask.id)\n      }\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.subtasks.length).toBe(0)\n    })\n  })\n\n  describe('Date Helper Functions', () => {\n    it('formats date key correctly', () => {\n      const date = new Date(2025, 9, 15) // October 15, 2025\n      const formatted = formatDateKey(date)\n      expect(formatted).toBe('2025-10-15')\n    })\n\n    it('parses date key correctly', () => {\n      const parsed = parseDateKey('2025-10-15')\n      expect(parsed).toBeInstanceOf(Date)\n      expect(parsed?.getFullYear()).toBe(2025)\n      expect(parsed?.getMonth()).toBe(9) // 0-indexed\n      expect(parsed?.getDate()).toBe(15)\n    })\n\n    it('handles invalid date key', () => {\n      const parsed = parseDateKey('invalid-date')\n      expect(parsed).toBeNull()\n    })\n  })\n\n  describe('Task Instance Helpers', () => {\n    it('returns instances array if present', () => {\n      const task: Task = {\n        id: '1',\n        title: 'Task',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        instances: [\n          {\n            id: 'inst-1',\n            scheduledDate: '2025-10-15',\n            scheduledTime: '10:00',\n            duration: 30\n          }\n        ]\n      }\n\n      const instances = getTaskInstances(task)\n      expect(instances.length).toBe(1)\n      expect(instances[0].scheduledDate).toBe('2025-10-15')\n    })\n\n    it('creates synthetic instance from legacy fields', () => {\n      const task: Task = {\n        id: '1',\n        title: 'Legacy Task',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        scheduledDate: '2025-10-15',\n        scheduledTime: '14:00',\n        estimatedDuration: 60\n      }\n\n      const instances = getTaskInstances(task)\n      expect(instances.length).toBe(1)\n      expect(instances[0].id).toContain('legacy')\n      expect(instances[0].scheduledDate).toBe('2025-10-15')\n      expect(instances[0].scheduledTime).toBe('14:00')\n    })\n\n    it('returns empty array for unscheduled tasks', () => {\n      const task: Task = {\n        id: '1',\n        title: 'Unscheduled',\n        description: '',\n        status: 'planned',\n        priority: 'medium',\n        progress: 0,\n        completedPomodoros: 0,\n        subtasks: [],\n        dueDate: '',\n        projectId: '1',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n\n      const instances = getTaskInstances(task)\n      expect(instances.length).toBe(0)\n    })\n  })\n\n  describe('Computed Properties', () => {\n    it('groups tasks by status correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Planned 1', status: 'planned' })\n      await store.createTask({ title: 'Planned 2', status: 'planned' })\n      await store.createTask({ title: 'In Progress', status: 'in_progress' })\n      await store.createTask({ title: 'Done', status: 'done' })\n\n      expect(store.tasksByStatus.planned.length).toBe(2)\n      expect(store.tasksByStatus.in_progress.length).toBe(1)\n      expect(store.tasksByStatus.done.length).toBe(1)\n    })\n\n    it('calculates total tasks correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Task 1' })\n      await store.createTask({ title: 'Task 2' })\n      await store.createTask({ title: 'Task 3' })\n\n      expect(store.totalTasks).toBe(3)\n    })\n\n    it('calculates completed tasks correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Task 1', status: 'done' })\n      await store.createTask({ title: 'Task 2', status: 'done' })\n      await store.createTask({ title: 'Task 3', status: 'planned' })\n\n      expect(store.completedTasks).toBe(2)\n    })\n\n    it('calculates total pomodoros correctly', async () => {\n      const store = useTaskStore()\n\n      await store.createTask({ title: 'Task 1', completedPomodoros: 5 })\n      await store.createTask({ title: 'Task 2', completedPomodoros: 3 })\n      await store.createTask({ title: 'Task 3', completedPomodoros: 2 })\n\n      expect(store.totalPomodoros).toBe(10)\n    })\n  })\n\n  describe('Date Movement', () => {\n    it('moves task to today', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n      // BUG-1325: Use local date (not UTC) to match moveTaskToDate behavior\n      const _now = new Date()\n      const today = `${_now.getFullYear()}-${String(_now.getMonth() + 1).padStart(2, '0')}-${String(_now.getDate()).padStart(2, '0')}`\n\n      store.moveTaskToDate(task.id, 'today')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(1)\n      expect(updatedTask?.instances?.[0].scheduledDate).toBe(today)\n    })\n\n    it('moves task to later', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n\n      store.moveTaskToDate(task.id, 'later')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(1)\n      expect(updatedTask?.instances?.[0].isLater).toBe(true)\n    })\n\n    it('clears all instances when moved to no date', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n\n      await store.createTaskInstance(task.id, {\n        scheduledDate: '2025-10-15',\n        scheduledTime: '10:00'\n      })\n\n      await store.moveTaskToDate(task.id, 'noDate')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.instances?.length).toBe(0)\n    })\n  })\n\n  describe('Priority Movement', () => {\n    it('updates task priority', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task', priority: 'low' })\n\n      store.moveTaskToPriority(task.id, 'high')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.priority).toBe('high')\n    })\n\n    it('removes priority with no_priority', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task', priority: 'high' })\n\n      store.moveTaskToPriority(task.id, 'no_priority')\n\n      const updatedTask = store.tasks.find(t => t.id === task.id)\n      expect(updatedTask?.priority).toBeNull()\n    })\n  })\n\n  describe('Selection Management', () => {\n    it('selects and deselects tasks', async () => {\n      const store = useTaskStore()\n\n      // Create tasks with slight delay to ensure unique IDs\n      const task1 = await store.createTask({ title: 'Task 1' })\n      await new Promise(resolve => setTimeout(resolve, 2)) // 2ms delay\n      const task2 = await store.createTask({ title: 'Task 2' })\n\n      // Verify tasks have unique IDs\n      expect(task1.id).not.toBe(task2.id)\n\n      // Select first task\n      store.selectTask(task1.id)\n      expect(store.selectedTaskIds).toContain(task1.id)\n      expect(store.selectedTaskIds.length).toBe(1)\n\n      // Select second task\n      store.selectTask(task2.id)\n      expect(store.selectedTaskIds).toContain(task2.id)\n      expect(store.selectedTaskIds.length).toBe(2)\n\n      // Deselect first task\n      store.deselectTask(task1.id)\n      expect(store.selectedTaskIds).not.toContain(task1.id)\n      expect(store.selectedTaskIds.length).toBe(1)\n\n      // Clear all selections\n      store.clearSelection()\n      expect(store.selectedTaskIds.length).toBe(0)\n    })\n\n    it('prevents duplicate selections', async () => {\n      const store = useTaskStore()\n      const task = await store.createTask({ title: 'Task' })\n\n      store.selectTask(task.id)\n      store.selectTask(task.id) // Try to select same task again\n\n      expect(store.selectedTaskIds.length).toBe(1)\n    })\n  })\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/aiChat.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":848,"column":19,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":848,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AI Chat Store\n *\n * Manages the state for the AI chat panel including:\n * - Conversation history with multiple conversations\n * - Message history per conversation\n * - Streaming responses\n * - Panel visibility\n * - Chat context (current view, selected task, etc.)\n *\n * @see TASK-1120, TASK-1234 in MASTER_PLAN.md\n */\n\nimport { defineStore } from 'pinia'\nimport { ref, computed, shallowRef, watch } from 'vue'\nimport type { Task } from '@/types/tasks'\nimport { executeTool } from '@/services/ai/tools'\nimport type { ToolCall } from '@/services/ai/tools'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Message role in the chat.\n */\nexport type ChatRole = 'user' | 'assistant' | 'system'\n\n/**\n * Action button that can appear in AI messages.\n */\nexport interface ChatAction {\n  id: string\n  label: string\n  icon?: string\n  variant?: 'primary' | 'secondary' | 'danger'\n  /** Called when user clicks the action */\n  handler: () => Promise<void> | void\n  /** Whether this action is currently loading */\n  loading?: boolean\n  /** Whether this action has been completed */\n  completed?: boolean\n}\n\n/**\n * A single chat message.\n */\nexport interface ChatMessage {\n  id: string\n  role: ChatRole\n  content: string\n  timestamp: Date\n  /** Optional actions the user can take */\n  actions?: ChatAction[]\n  /** Whether this message is still streaming */\n  isStreaming?: boolean\n  /** Error message if generation failed */\n  error?: string\n  /** Associated task ID if context-specific */\n  taskId?: string\n  /** Metadata for analytics */\n  metadata?: {\n    model?: string\n    provider?: string\n    tokens?: number\n    latencyMs?: number\n  }\n}\n\n/**\n * A conversation containing a list of chat messages.\n */\nexport interface Conversation {\n  id: string\n  title: string\n  messages: ChatMessage[]\n  createdAt: Date\n  updatedAt: Date\n}\n\n/**\n * Current view context for the chat.\n */\nexport type ViewContext = 'canvas' | 'board' | 'calendar' | 'inbox' | 'settings' | 'all-tasks'\n\n/**\n * Context passed to the AI for awareness.\n */\nexport interface ChatContext {\n  currentView: ViewContext\n  selectedTaskId?: string\n  selectedTask?: Task\n  visibleTaskIds?: string[]\n  /** Additional context string (e.g., user's recent activity) */\n  additionalContext?: string\n}\n\n/**\n * An entry in the undo buffer for reversible tool actions.\n */\nexport interface UndoEntry {\n  toolName: string\n  timestamp: number\n  params: Record<string, unknown>\n  undoAction: { toolName: string; params: Record<string, unknown> }\n  description: string\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst CHAT_HISTORY_KEY = 'flowstate-ai-chat-history'\nconst CONVERSATIONS_KEY = 'flowstate-ai-conversations'\nconst AI_SETTINGS_KEY = 'flowstate-ai-settings'\nconst MAX_PERSISTED_MESSAGES = 50\nconst MAX_PERSISTED_CONVERSATIONS = 20\nconst MAX_UNDO_ENTRIES = 10\nconst SAVE_DEBOUNCE_MS = 300\n\nconst WELCOME_MESSAGE = \"Hi! I'm your FlowState AI assistant. I can help you organize your tasks, break down complex work, and suggest canvas groupings. Just ask me anything!\"\n\n// ============================================================================\n// Store\n// ============================================================================\n\nexport const useAIChatStore = defineStore('aiChat', () => {\n  // ============================================================================\n  // State\n  // ============================================================================\n\n  /** Whether the chat panel is open */\n  const isPanelOpen = ref(false)\n\n  /** All conversations */\n  const conversations = ref<Conversation[]>([])\n\n  /** Currently active conversation ID */\n  const activeConversationId = ref<string | null>(null)\n\n  /** Current input text */\n  const inputText = ref('')\n\n  /** Whether a response is currently being generated */\n  const isGenerating = ref(false)\n\n  /** Current streaming content (for progressive display) */\n  const streamingContent = ref('')\n\n  /** Current chat context */\n  const context = shallowRef<ChatContext>({\n    currentView: 'canvas'\n  })\n\n  /** Number of pending suggestions (for indicator badge) */\n  const pendingSuggestionCount = ref(0)\n\n  /** Error state */\n  const error = ref<string | null>(null)\n\n  /** Whether the chat has been initialized */\n  const isInitialized = ref(false)\n\n  /** Undo buffer for reversible tool actions (session only, not persisted) */\n  const undoBuffer = ref<UndoEntry[]>([])\n\n  /** Persisted AI settings (provider/model) */\n  const persistedSettings = ref<{ provider: string; model: string } | null>(null)\n\n  // ============================================================================\n  // Persistence Helpers\n  // ============================================================================\n\n  let saveTimeout: ReturnType<typeof setTimeout> | null = null\n\n  /**\n   * Serialize messages for storage (strips non-serializable fields like action handlers).\n   */\n  function serializeMessages(msgs: ChatMessage[]): Array<Record<string, unknown>> {\n    return msgs.slice(-MAX_PERSISTED_MESSAGES).map(m => ({\n      id: m.id,\n      role: m.role,\n      content: m.content,\n      timestamp: m.timestamp instanceof Date ? m.timestamp.toISOString() : m.timestamp,\n      isStreaming: false, // never persist streaming state\n      error: m.error,\n      taskId: m.taskId,\n      metadata: m.metadata,\n      // actions are NOT persisted (handlers are functions)\n    }))\n  }\n\n  /**\n   * Deserialize messages from storage, restoring Date objects.\n   */\n  function deserializeMessages(data: Array<Record<string, unknown>>): ChatMessage[] {\n    return data.map(m => ({\n      ...m,\n      timestamp: new Date(m.timestamp as string),\n    })) as ChatMessage[]\n  }\n\n  /**\n   * Serialize all conversations for localStorage.\n   */\n  function serializeConversations(): string {\n    const limited = conversations.value.slice(0, MAX_PERSISTED_CONVERSATIONS)\n    const serializable = limited.map(conv => ({\n      id: conv.id,\n      title: conv.title,\n      messages: serializeMessages(conv.messages),\n      createdAt: conv.createdAt instanceof Date ? conv.createdAt.toISOString() : conv.createdAt,\n      updatedAt: conv.updatedAt instanceof Date ? conv.updatedAt.toISOString() : conv.updatedAt,\n    }))\n    return JSON.stringify({\n      conversations: serializable,\n      activeConversationId: activeConversationId.value,\n    })\n  }\n\n  /**\n   * Deserialize conversations from localStorage.\n   */\n  function deserializeConversations(json: string): { conversations: Conversation[]; activeId: string | null } {\n    try {\n      const parsed = JSON.parse(json)\n      const convs: Conversation[] = (parsed.conversations || []).map((c: Record<string, unknown>) => ({\n        id: c.id as string,\n        title: c.title as string,\n        messages: deserializeMessages(c.messages as Array<Record<string, unknown>>),\n        createdAt: new Date(c.createdAt as string),\n        updatedAt: new Date(c.updatedAt as string),\n      }))\n      return {\n        conversations: convs,\n        activeId: parsed.activeConversationId || null,\n      }\n    } catch {\n      return { conversations: [], activeId: null }\n    }\n  }\n\n  /**\n   * Save conversations to localStorage (debounced).\n   */\n  function debouncedSaveConversations() {\n    if (saveTimeout) clearTimeout(saveTimeout)\n    saveTimeout = setTimeout(() => {\n      try {\n        localStorage.setItem(CONVERSATIONS_KEY, serializeConversations())\n      } catch {\n        // localStorage full or unavailable - silently ignore\n      }\n    }, SAVE_DEBOUNCE_MS)\n  }\n\n  /**\n   * Load conversations from localStorage.\n   */\n  function loadPersistedConversations(): { conversations: Conversation[]; activeId: string | null } {\n    try {\n      const raw = localStorage.getItem(CONVERSATIONS_KEY)\n      if (!raw) return { conversations: [], activeId: null }\n      return deserializeConversations(raw)\n    } catch {\n      return { conversations: [], activeId: null }\n    }\n  }\n\n  /**\n   * Load old-format messages from localStorage for migration.\n   */\n  function loadOldPersistedMessages(): ChatMessage[] {\n    try {\n      const raw = localStorage.getItem(CHAT_HISTORY_KEY)\n      if (!raw) return []\n      const parsed = JSON.parse(raw) as Array<Record<string, unknown>>\n      return parsed.map(m => ({\n        ...m,\n        timestamp: new Date(m.timestamp as string),\n      })) as ChatMessage[]\n    } catch {\n      return []\n    }\n  }\n\n  /**\n   * Save AI settings to localStorage.\n   */\n  function saveSettings(settings: { provider: string; model: string }) {\n    try {\n      persistedSettings.value = settings\n      localStorage.setItem(AI_SETTINGS_KEY, JSON.stringify(settings))\n    } catch {\n      // silently ignore\n    }\n  }\n\n  /**\n   * Load AI settings from localStorage.\n   */\n  function loadPersistedSettings(): { provider: string; model: string } | null {\n    try {\n      const raw = localStorage.getItem(AI_SETTINGS_KEY)\n      if (!raw) return null\n      return JSON.parse(raw) as { provider: string; model: string }\n    } catch {\n      return null\n    }\n  }\n\n  // ============================================================================\n  // Getters\n  // ============================================================================\n\n  /** The currently active conversation */\n  const activeConversation = computed(() =>\n    conversations.value.find(c => c.id === activeConversationId.value) || null\n  )\n\n  /** All conversations sorted by updatedAt descending (most recent first) */\n  const sortedConversations = computed(() =>\n    [...conversations.value].sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())\n  )\n\n  /**\n   * Messages from the active conversation.\n   * Backward-compatible: existing code that reads store.messages will get\n   * the active conversation's messages array.\n   */\n  const messages = computed(() =>\n    activeConversation.value?.messages || []\n  )\n\n  /** All messages except system messages */\n  const visibleMessages = computed(() =>\n    messages.value.filter(m => m.role !== 'system')\n  )\n\n  /** Most recent message */\n  const lastMessage = computed(() =>\n    messages.value[messages.value.length - 1]\n  )\n\n  /** Whether there are any messages */\n  const hasMessages = computed(() => messages.value.length > 0)\n\n  /** Whether the input is valid for sending */\n  const canSend = computed(() =>\n    inputText.value.trim().length > 0 && !isGenerating.value\n  )\n\n  // ============================================================================\n  // Conversation Helpers\n  // ============================================================================\n\n  /**\n   * Generate a unique conversation ID.\n   */\n  function generateConversationId(): string {\n    return `conv_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`\n  }\n\n  /**\n   * Generate a unique message ID.\n   */\n  function generateMessageId(): string {\n    return `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`\n  }\n\n  /**\n   * Get the messages array of the active conversation.\n   * Returns null if no active conversation.\n   */\n  function getActiveMessages(): ChatMessage[] | null {\n    const conv = conversations.value.find(c => c.id === activeConversationId.value)\n    return conv ? conv.messages : null\n  }\n\n  /**\n   * Touch the active conversation's updatedAt timestamp.\n   */\n  function touchActiveConversation() {\n    const conv = conversations.value.find(c => c.id === activeConversationId.value)\n    if (conv) {\n      conv.updatedAt = new Date()\n    }\n  }\n\n  // ============================================================================\n  // Conversation Actions\n  // ============================================================================\n\n  /**\n   * Create a new conversation with a welcome message and set it as active.\n   */\n  function createConversation(): Conversation {\n    const conv: Conversation = {\n      id: generateConversationId(),\n      title: 'New Chat',\n      messages: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    }\n\n    // Add welcome message\n    conv.messages.push({\n      id: generateMessageId(),\n      role: 'assistant',\n      content: WELCOME_MESSAGE,\n      timestamp: new Date(),\n    })\n\n    conversations.value.push(conv)\n    activeConversationId.value = conv.id\n\n    // Enforce max conversations limit\n    if (conversations.value.length > MAX_PERSISTED_CONVERSATIONS) {\n      // Remove oldest conversations (by updatedAt) beyond the limit\n      const sorted = [...conversations.value].sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())\n      const toRemove = sorted.slice(MAX_PERSISTED_CONVERSATIONS)\n      const removeIds = new Set(toRemove.map(c => c.id))\n      conversations.value = conversations.value.filter(c => !removeIds.has(c.id))\n    }\n\n    return conv\n  }\n\n  /**\n   * Switch to a different conversation.\n   */\n  function switchConversation(id: string) {\n    const conv = conversations.value.find(c => c.id === id)\n    if (conv) {\n      activeConversationId.value = id\n    }\n  }\n\n  /**\n   * Delete a conversation. If it's the active one, switch to the most recent remaining\n   * or create a new one if none remain.\n   */\n  function deleteConversation(id: string) {\n    const index = conversations.value.findIndex(c => c.id === id)\n    if (index === -1) return\n\n    conversations.value.splice(index, 1)\n\n    // If we deleted the active conversation, switch to the most recent or create new\n    if (activeConversationId.value === id) {\n      if (conversations.value.length > 0) {\n        const sorted = [...conversations.value].sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())\n        activeConversationId.value = sorted[0].id\n      } else {\n        createConversation()\n      }\n    }\n  }\n\n  /**\n   * Rename a conversation.\n   */\n  function renameConversation(id: string, title: string) {\n    const conv = conversations.value.find(c => c.id === id)\n    if (conv) {\n      conv.title = title\n      conv.updatedAt = new Date()\n    }\n  }\n\n  /**\n   * Auto-name a conversation based on the first user message.\n   * Truncates to 40 characters with \"...\" if needed.\n   */\n  function autoNameConversation(id: string) {\n    const conv = conversations.value.find(c => c.id === id)\n    if (!conv) return\n\n    const firstUserMsg = conv.messages.find(m => m.role === 'user')\n    if (!firstUserMsg) return\n\n    const content = firstUserMsg.content.trim()\n    if (content.length <= 40) {\n      conv.title = content\n    } else {\n      conv.title = content.slice(0, 40) + '...'\n    }\n    conv.updatedAt = new Date()\n  }\n\n  // ============================================================================\n  // Actions\n  // ============================================================================\n\n  /**\n   * Toggle the chat panel open/closed.\n   */\n  function togglePanel() {\n    isPanelOpen.value = !isPanelOpen.value\n  }\n\n  /**\n   * Open the chat panel.\n   */\n  function openPanel() {\n    isPanelOpen.value = true\n  }\n\n  /**\n   * Close the chat panel.\n   */\n  function closePanel() {\n    isPanelOpen.value = false\n  }\n\n  /**\n   * Add a user message to the active conversation.\n   * Auto-names the conversation after the first user message.\n   */\n  function addUserMessage(content: string): ChatMessage {\n    const msgs = getActiveMessages()\n    if (!msgs) {\n      // No active conversation - create one first\n      createConversation()\n    }\n\n    const message: ChatMessage = {\n      id: generateMessageId(),\n      role: 'user',\n      content,\n      timestamp: new Date()\n    }\n\n    const activeMsgs = getActiveMessages()\n    if (activeMsgs) {\n      activeMsgs.push(message)\n    }\n\n    touchActiveConversation()\n\n    // Auto-name conversation after first user message\n    if (activeConversationId.value) {\n      const conv = conversations.value.find(c => c.id === activeConversationId.value)\n      if (conv && conv.title === 'New Chat') {\n        // Check if this is the first user message\n        const userMessages = conv.messages.filter(m => m.role === 'user')\n        if (userMessages.length === 1) {\n          autoNameConversation(conv.id)\n        }\n      }\n    }\n\n    return message\n  }\n\n  /**\n   * Add an assistant message to the active conversation.\n   */\n  function addAssistantMessage(\n    content: string,\n    options?: {\n      actions?: ChatAction[]\n      taskId?: string\n      metadata?: ChatMessage['metadata']\n    }\n  ): ChatMessage {\n    const message: ChatMessage = {\n      id: generateMessageId(),\n      role: 'assistant',\n      content,\n      timestamp: new Date(),\n      actions: options?.actions,\n      taskId: options?.taskId,\n      metadata: options?.metadata\n    }\n\n    const activeMsgs = getActiveMessages()\n    if (activeMsgs) {\n      activeMsgs.push(message)\n    }\n\n    touchActiveConversation()\n    return message\n  }\n\n  /**\n   * Start a streaming assistant message in the active conversation.\n   */\n  function startStreamingMessage(): ChatMessage {\n    const message: ChatMessage = {\n      id: generateMessageId(),\n      role: 'assistant',\n      content: '',\n      timestamp: new Date(),\n      isStreaming: true\n    }\n\n    const activeMsgs = getActiveMessages()\n    if (activeMsgs) {\n      activeMsgs.push(message)\n    }\n\n    isGenerating.value = true\n    streamingContent.value = ''\n    touchActiveConversation()\n    return message\n  }\n\n  /**\n   * Append content to the current streaming message in the active conversation.\n   */\n  function appendStreamingContent(content: string) {\n    const activeMsgs = getActiveMessages()\n    if (!activeMsgs) return\n\n    const lastMsg = activeMsgs[activeMsgs.length - 1]\n    if (lastMsg && lastMsg.isStreaming) {\n      lastMsg.content += content\n      streamingContent.value = lastMsg.content\n    }\n  }\n\n  /**\n   * Complete the streaming message in the active conversation.\n   */\n  function completeStreamingMessage(options?: {\n    actions?: ChatAction[]\n    metadata?: ChatMessage['metadata']\n  }) {\n    const activeMsgs = getActiveMessages()\n    if (!activeMsgs) return\n\n    const lastMsg = activeMsgs[activeMsgs.length - 1]\n    if (lastMsg && lastMsg.isStreaming) {\n      lastMsg.isStreaming = false\n      if (options?.actions) {\n        lastMsg.actions = options.actions\n      }\n      if (options?.metadata) {\n        lastMsg.metadata = { ...lastMsg.metadata, ...options.metadata }\n      }\n    }\n    isGenerating.value = false\n    streamingContent.value = ''\n    touchActiveConversation()\n  }\n\n  /**\n   * Mark a streaming message as failed in the active conversation.\n   */\n  function failStreamingMessage(errorMessage: string) {\n    const activeMsgs = getActiveMessages()\n    if (activeMsgs) {\n      const lastMsg = activeMsgs[activeMsgs.length - 1]\n      if (lastMsg && lastMsg.isStreaming) {\n        lastMsg.isStreaming = false\n        lastMsg.error = errorMessage\n      }\n    }\n    isGenerating.value = false\n    streamingContent.value = ''\n    error.value = errorMessage\n  }\n\n  /**\n   * Update an action's state (loading/completed).\n   */\n  function updateAction(messageId: string, actionId: string, updates: Partial<ChatAction>) {\n    const activeMsgs = getActiveMessages()\n    if (!activeMsgs) return\n\n    const message = activeMsgs.find(m => m.id === messageId)\n    if (message?.actions) {\n      const action = message.actions.find(a => a.id === actionId)\n      if (action) {\n        Object.assign(action, updates)\n      }\n    }\n  }\n\n  /**\n   * Update the chat context.\n   */\n  function updateContext(newContext: Partial<ChatContext>) {\n    context.value = { ...context.value, ...newContext }\n  }\n\n  /**\n   * Set the current view context.\n   */\n  function setCurrentView(view: ViewContext) {\n    context.value = { ...context.value, currentView: view }\n  }\n\n  /**\n   * Set the selected task.\n   */\n  function setSelectedTask(task: Task | undefined) {\n    context.value = {\n      ...context.value,\n      selectedTaskId: task?.id,\n      selectedTask: task\n    }\n  }\n\n  /**\n   * Clear the ACTIVE conversation's messages and re-add welcome message.\n   */\n  function clearMessages() {\n    const conv = conversations.value.find(c => c.id === activeConversationId.value)\n    if (conv) {\n      conv.messages = []\n      conv.updatedAt = new Date()\n    }\n    streamingContent.value = ''\n    error.value = null\n    undoBuffer.value = []\n\n    // Re-add welcome message\n    addAssistantMessage(WELCOME_MESSAGE)\n  }\n\n  /**\n   * Clear error state.\n   */\n  function clearError() {\n    error.value = null\n  }\n\n  /**\n   * Initialize the chat (called on app startup).\n   * Loads conversations from localStorage, migrates old format if needed.\n   */\n  function initialize() {\n    if (isInitialized.value) return\n\n    // Load persisted settings\n    persistedSettings.value = loadPersistedSettings()\n\n    // Try to load conversations from new format\n    const persisted = loadPersistedConversations()\n\n    if (persisted.conversations.length > 0) {\n      // New format found\n      conversations.value = persisted.conversations\n      activeConversationId.value = persisted.activeId\n\n      // Validate active conversation ID still exists\n      if (activeConversationId.value && !conversations.value.find(c => c.id === activeConversationId.value)) {\n        activeConversationId.value = conversations.value[0]?.id || null\n      }\n    } else {\n      // Check for old format migration\n      const oldMessages = loadOldPersistedMessages()\n      if (oldMessages.length > 0) {\n        // Migrate: create a \"Previous Chat\" conversation from old messages\n        const migratedConv: Conversation = {\n          id: generateConversationId(),\n          title: 'Previous Chat',\n          messages: oldMessages,\n          createdAt: oldMessages[0]?.timestamp || new Date(),\n          updatedAt: oldMessages[oldMessages.length - 1]?.timestamp || new Date(),\n        }\n        conversations.value = [migratedConv]\n        activeConversationId.value = migratedConv.id\n\n        // Clean up old format key\n        try {\n          localStorage.removeItem(CHAT_HISTORY_KEY)\n        } catch {\n          // silently ignore\n        }\n      } else {\n        // No persisted data at all - create default conversation\n        createConversation()\n      }\n    }\n\n    // Ensure we have an active conversation\n    if (!activeConversationId.value && conversations.value.length > 0) {\n      activeConversationId.value = conversations.value[0].id\n    }\n\n    // Watch conversations for persistence (debounced, deep)\n    watch(\n      conversations,\n      () => debouncedSaveConversations(),\n      { deep: true }\n    )\n\n    // Also watch activeConversationId changes\n    watch(\n      activeConversationId,\n      () => debouncedSaveConversations(),\n    )\n\n    isInitialized.value = true\n  }\n\n  /**\n   * Reset the store (for logout/testing).\n   * Clears all conversations and localStorage.\n   */\n  function reset() {\n    conversations.value = []\n    activeConversationId.value = null\n    inputText.value = ''\n    isGenerating.value = false\n    streamingContent.value = ''\n    context.value = { currentView: 'canvas' }\n    pendingSuggestionCount.value = 0\n    error.value = null\n    isInitialized.value = false\n    isPanelOpen.value = false\n    undoBuffer.value = []\n    persistedSettings.value = null\n    try {\n      localStorage.removeItem(CONVERSATIONS_KEY)\n      localStorage.removeItem(CHAT_HISTORY_KEY)\n      localStorage.removeItem(AI_SETTINGS_KEY)\n    } catch {\n      // silently ignore\n    }\n  }\n\n  // ============================================================================\n  // Undo Buffer\n  // ============================================================================\n\n  /**\n   * Push an entry to the undo buffer.\n   * Most recent entries are at the front. Capped at MAX_UNDO_ENTRIES.\n   */\n  function pushUndoEntry(entry: UndoEntry) {\n    undoBuffer.value.unshift(entry)\n    if (undoBuffer.value.length > MAX_UNDO_ENTRIES) {\n      undoBuffer.value = undoBuffer.value.slice(0, MAX_UNDO_ENTRIES)\n    }\n  }\n\n  /**\n   * Pop the most recent undo entry and execute its reverse action.\n   * Returns the entry that was undone, or null if buffer is empty.\n   */\n  async function undoLastAction(): Promise<UndoEntry | null> {\n    if (undoBuffer.value.length === 0) return null\n\n    const entry = undoBuffer.value.shift()!\n\n    // Execute the reverse tool call\n    const toolCall: ToolCall = {\n      tool: entry.undoAction.toolName,\n      parameters: entry.undoAction.params,\n    }\n\n    try {\n      await executeTool(toolCall)\n    } catch {\n      // If undo fails, we still remove the entry (it's been consumed)\n    }\n\n    return entry\n  }\n\n  /**\n   * Get the current undo buffer contents.\n   */\n  function getUndoHistory(): UndoEntry[] {\n    return undoBuffer.value\n  }\n\n  // ============================================================================\n  // Settings Persistence\n  // ============================================================================\n\n  /**\n   * Update and persist AI provider/model settings.\n   */\n  function updatePersistedSettings(settings: { provider: string; model: string }) {\n    saveSettings(settings)\n  }\n\n  /**\n   * Get the persisted AI settings.\n   */\n  function getPersistedSettings(): { provider: string; model: string } | null {\n    return persistedSettings.value\n  }\n\n  // ============================================================================\n  // Return\n  // ============================================================================\n\n  return {\n    // State\n    isPanelOpen,\n    conversations,\n    activeConversationId,\n    inputText,\n    isGenerating,\n    streamingContent,\n    context,\n    pendingSuggestionCount,\n    error,\n    isInitialized,\n    undoBuffer,\n    persistedSettings,\n\n    // Getters\n    activeConversation,\n    sortedConversations,\n    messages,\n    visibleMessages,\n    lastMessage,\n    hasMessages,\n    canSend,\n\n    // Conversation Actions\n    createConversation,\n    switchConversation,\n    deleteConversation,\n    renameConversation,\n    autoNameConversation,\n\n    // Actions\n    togglePanel,\n    openPanel,\n    closePanel,\n    addUserMessage,\n    addAssistantMessage,\n    startStreamingMessage,\n    appendStreamingContent,\n    completeStreamingMessage,\n    failStreamingMessage,\n    updateAction,\n    updateContext,\n    setCurrentView,\n    setSelectedTask,\n    clearMessages,\n    clearError,\n    initialize,\n    reset,\n\n    // Undo\n    pushUndoEntry,\n    undoLastAction,\n    getUndoHistory,\n\n    // Settings Persistence\n    updatePersistedSettings,\n    getPersistedSettings,\n  }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/auth.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6604,6607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6604,6607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6733,6736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6733,6736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":240,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10205,10208],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10205,10208],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport { supabase, type User, type Session, type AuthError } from '@/services/auth/supabase'\nimport { clearGuestData } from '@/utils/guestModeStorage'\nimport { isBlockedByBrave, recordBlockedResource } from '@/utils/braveProtection'\nimport { invalidateCache } from '@/composables/useSupabaseDatabase'\nimport type { Task } from '@/types/tasks'\nexport type { User, Session, AuthError }\n\nexport const useAuthStore = defineStore('auth', () => {\n  // State\n  const user = ref<User | null>(null)\n  const session = ref<Session | null>(null)\n  const isLoading = ref(false)\n  const error = ref<AuthError | null>(null)\n  const isInitialized = ref(false)\n  const initializationFailed = ref(false)\n\n  // BUG-1086: Promise lock to prevent concurrent initialization attempts\n  // Multiple callers (router guard, useAppInitialization) may call initialize() simultaneously\n  // This ensures they all await the same promise instead of racing\n  let initPromise: Promise<void> | null = null\n\n  // BUG-1086: Track which user we've already handled SIGNED_IN for\n  // Prevents duplicate store reloads when onAuthStateChange fires multiple times\n  let handledSignInForUserId: string | null = null\n\n  // BUG-1207: Flag set by useAppInitialization after it completes its own store load\n  // When true, the SIGNED_IN handler skips redundant loadFromDatabase() calls\n  let appInitLoadComplete = false\n\n  // BUG-339: Proactive token refresh timer\n  let refreshTimer: ReturnType<typeof setTimeout> | null = null\n\n  /**\n   * BUG-339: Schedule proactive token refresh before expiry\n   * Refreshes 5 minutes before expiry to ensure continuous auth\n   */\n  const scheduleTokenRefresh = (expiresAt: number) => {\n    // Clear any existing timer\n    if (refreshTimer) {\n      clearTimeout(refreshTimer)\n      refreshTimer = null\n    }\n\n    const now = Date.now()\n    const expiresMs = expiresAt * 1000\n    const refreshBufferMs = 5 * 60 * 1000 // 5 minutes before expiry\n    const timeUntilRefresh = expiresMs - now - refreshBufferMs\n\n    if (timeUntilRefresh <= 0) {\n      // Already expired or about to expire, refresh now\n      console.log('[AUTH] Token expired or expiring soon, refreshing immediately')\n      performTokenRefresh()\n      return\n    }\n\n    console.log(`[AUTH] Scheduling token refresh in ${Math.round(timeUntilRefresh / 60000)} minutes`)\n    refreshTimer = setTimeout(performTokenRefresh, timeUntilRefresh)\n  }\n\n  /**\n   * BUG-339: Perform token refresh and reschedule with retry logic\n   */\n  const performTokenRefresh = async (attempt = 1, maxAttempts = 3): Promise<void> => {\n    if (!supabase) return\n\n    try {\n      console.log('[AUTH] Proactive token refresh starting...')\n      const { data, error: refreshError } = await supabase.auth.refreshSession()\n\n      if (refreshError) {\n        if (attempt < maxAttempts) {\n          const delay = Math.pow(2, attempt) * 1000 // 2s, 4s, 8s\n          console.warn(`[AUTH] Token refresh failed, retrying in ${delay}ms (attempt ${attempt}/${maxAttempts})`)\n          setTimeout(() => performTokenRefresh(attempt + 1, maxAttempts), delay)\n        } else {\n          console.error('[AUTH] Token refresh failed after all retries:', refreshError)\n          // Don't clear session - let user continue until actual API call fails\n        }\n        return\n      }\n\n      if (data.session) {\n        console.log('[AUTH] Proactive token refresh successful')\n        session.value = data.session\n        user.value = data.session.user\n\n        // Schedule next refresh\n        if (data.session.expires_at) {\n          scheduleTokenRefresh(data.session.expires_at)\n        }\n      }\n    } catch (e) {\n      if (attempt < maxAttempts) {\n        const delay = Math.pow(2, attempt) * 1000 // 2s, 4s, 8s\n        console.warn(`[AUTH] Token refresh error, retrying in ${delay}ms (attempt ${attempt}/${maxAttempts})`)\n        setTimeout(() => performTokenRefresh(attempt + 1, maxAttempts), delay)\n      } else {\n        console.error('[AUTH] Token refresh error after all retries:', e)\n      }\n    }\n  }\n\n  // Getters\n  const isAuthenticated = computed(() => !!user.value)\n  const errorMessage = computed(() => error.value?.message || null)\n\n  // Compatibility getters for Supabase/Firebase differences\n  const displayName = computed(() =>\n    user.value?.user_metadata?.full_name ||\n    user.value?.user_metadata?.display_name ||\n    user.value?.user_metadata?.name ||\n    user.value?.email?.split('@')[0] ||\n    'User'\n  )\n  const photoURL = computed(() =>\n    user.value?.user_metadata?.avatar_url ||\n    user.value?.user_metadata?.photo_url ||\n    user.value?.user_metadata?.picture ||\n    null\n  )\n  const isAdmin = computed(() => {\n    // BUG-012 FIX: localStorage override ONLY works in DEV builds (AND, not OR)\n    // This prevents production users from gaining admin access via localStorage\n    if (import.meta.env.DEV && localStorage.getItem('flowstate-dev-mode') === 'true') return true\n    return user.value?.app_metadata?.role === 'admin' ||\n      user.value?.user_metadata?.role === 'admin'\n  })\n  const isDev = computed(() => {\n    // BUG-012 FIX: localStorage override ONLY works in DEV builds (AND, not OR)\n    if (import.meta.env.DEV && localStorage.getItem('flowstate-dev-mode') === 'true') return true\n    return isAdmin.value ||\n      user.value?.app_metadata?.role === 'developer' ||\n      user.value?.user_metadata?.role === 'developer'\n  })\n\n  // TASK-337: Check if user has email/password auth (vs OAuth-only)\n  // Note: This is a best-effort check. app_metadata.providers can be unreliable\n  // (doesn't update when OAuth users set password via updateUser)\n  // For UI decisions, prefer showing options and handling API errors gracefully\n  const hasPasswordAuth = computed(() => {\n    // Check identities array first (more reliable)\n    const identities = user.value?.identities as Array<{provider: string}> | undefined\n    if (identities?.some(i => i.provider === 'email')) return true\n    // Fallback to app_metadata.providers\n    const providers = user.value?.app_metadata?.providers as string[] | undefined\n    return providers?.includes('email') ?? false\n  })\n\n  // Actions\n  const initialize = async (): Promise<void> => {\n    // BUG-1086: Return existing promise if already initializing (prevents race condition)\n    // Multiple callers will await the same promise instead of starting parallel init attempts\n    if (initPromise) {\n      return initPromise\n    }\n    if (isInitialized.value) return\n\n    // BUG-1056: Generate tab ID for multi-tab debugging\n    const tabId = (window as any).__flowstate_tab_id || (() => {\n      const id = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`\n      ;(window as any).__flowstate_tab_id = id\n      return id\n    })()\n\n    // BUG-1086: Create and store the promise BEFORE any async work\n    // This ensures subsequent callers get this promise immediately\n    initPromise = (async () => {\n      try {\n        isLoading.value = true\n        console.log(`[AUTH:${tabId}] Initializing auth...`)\n\n        if (!supabase) {\n          console.warn(`[AUTH:${tabId}] Supabase client not available, staying in Guest Mode`)\n          return\n        }\n\n        // Check for existing session\n        console.log(`[AUTH:${tabId}] Fetching session from localStorage...`)\n        const { data, error: sessionError } = await supabase.auth.getSession()\n        if (sessionError) {\n          console.error(`[AUTH:${tabId}] getSession error:`, sessionError)\n          throw sessionError\n        }\n        console.log(`[AUTH:${tabId}] Session found:`, !!data.session, data.session?.user?.email)\n\n        // BUG-339 FIX: Check if session is expired and refresh it\n        // getSession() returns the stored session but doesn't auto-refresh expired tokens\n        if (data.session?.expires_at) {\n          const expiresAt = data.session.expires_at * 1000 // Convert to milliseconds\n          const now = Date.now()\n          const bufferMs = 60 * 1000 // 1 minute buffer before expiry\n\n          if (now >= expiresAt - bufferMs) {\n            console.log('[AUTH] Session expired or expiring soon, refreshing...')\n            const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession()\n            if (refreshError) {\n              console.error('[AUTH] Failed to refresh session:', refreshError)\n              // TASK-1060: Mark initialization as failed so UI can show error state\n              error.value = refreshError\n              initializationFailed.value = true\n              // Clear stale session - user needs to sign in again\n              session.value = null\n              user.value = null\n              return\n            }\n            if (refreshData.session) {\n              console.log('[AUTH] Session refreshed successfully')\n              session.value = refreshData.session\n              user.value = refreshData.session.user\n              // BUG-339: Schedule next refresh\n              if (refreshData.session.expires_at) {\n                scheduleTokenRefresh(refreshData.session.expires_at)\n              }\n            }\n          } else {\n            session.value = data.session\n            user.value = data.session?.user || null\n            // BUG-339: Schedule proactive refresh for valid session\n            scheduleTokenRefresh(data.session.expires_at)\n          }\n        } else {\n          session.value = data.session\n          user.value = data.session?.user || null\n        }\n\n        // BUG-339 FIX: If we have a session on init (e.g., after OAuth/Magic Link redirect),\n        // check if there's guest data to migrate. This catches redirect-based auth flows.\n        if (data.session?.user) {\n          // Run migration asynchronously - don't block initialization\n          migrateGuestData().catch(e => {\n            console.error('[AUTH] Post-init migration failed:', e)\n          })\n        }\n\n        // Listen for auth changes (sign in, sign out, etc.)\n        // BUG-1056: This fires across all tabs when auth state changes (via localStorage sync)\n        supabase.auth.onAuthStateChange(async (_event: string, newSession: Session | null) => {\n          const currentTabId = (window as any).__flowstate_tab_id || 'unknown'\n          const currentUserId = user.value?.id?.substring(0, 8) || 'none'\n          const newUserId = newSession?.user?.id?.substring(0, 8) || 'none'\n          console.log(`👤 [AUTH:${currentTabId}] Auth state changed:`, _event,\n            'current:', currentUserId, '→ new:', newUserId,\n            'hasSession:', !!session.value, '→', !!newSession)\n\n          // BUG-1056: Invalidate SWR cache when user changes to prevent stale data\n          // This ensures cached guest data doesn't persist after sign-in\n          invalidateCache.onAuthChange(newSession?.user?.id || null)\n\n          // BUG-1103: Multi-tab sign-in fix\n          // When Tab 2 signs in, Supabase may fire SIGNED_OUT (old session) before SIGNED_IN (new session)\n          // Tab 1 would blindly clear state, even though localStorage has Tab 2's valid new session\n          // Fix: On SIGNED_OUT, check if localStorage actually has a session before clearing\n          if (_event === 'SIGNED_OUT' && !newSession) {\n            // Double-check: maybe another tab just signed in and localStorage has their session\n            const { data: currentSession } = await supabase.auth.getSession()\n            if (currentSession.session) {\n              console.log(`👤 [AUTH:${currentTabId}] SIGNED_OUT received but localStorage has session - using it instead`)\n              session.value = currentSession.session\n              user.value = currentSession.session.user\n              // Schedule refresh for the recovered session\n              if (currentSession.session.expires_at) {\n                scheduleTokenRefresh(currentSession.session.expires_at)\n              }\n              return // Don't process as sign-out\n            }\n          }\n\n          // Update local state\n          session.value = newSession\n          user.value = newSession?.user || null\n\n          // FEATURE-1202: Write session to shared file for KDE widget (Tauri only)\n          // ~/.config/flowstate/session.json — KDE widget reads this for authenticated API calls\n          if (typeof window !== 'undefined' && '__TAURI__' in window) {\n            writeSessionFile(newSession).catch(e => {\n              console.warn('[AUTH] Failed to write session file for KDE widget:', e)\n            })\n          }\n\n          // BUG-1056: Handle token refresh across tabs - update realtime connection\n          if (_event === 'TOKEN_REFRESHED' && newSession?.access_token) {\n            console.log(`👤 [AUTH:${currentTabId}] Token refreshed - updating realtime auth`)\n            try {\n              // Update the realtime WebSocket with the new token\n              supabase.realtime.setAuth(newSession.access_token)\n            } catch (e) {\n              console.error(`❌ [AUTH:${currentTabId}] Failed to update realtime auth:`, e)\n            }\n          }\n\n          // BUG-1086: Reset sign-in handler on sign-out so next sign-in reloads stores\n          // BUG-1207: Reset appInitLoadComplete so post-login sign-in reloads stores\n          if (_event === 'SIGNED_OUT') {\n            handledSignInForUserId = null\n            appInitLoadComplete = false\n          }\n\n          // BUG-1020: Reload stores when user signs in (projects were empty during guest mode)\n          // BUG-1086: Only run ONCE per user to prevent duplicate reloads from repeated SIGNED_IN events\n          // BUG-1207: Skip if useAppInitialization already loaded stores (prevents double-load)\n          if (_event === 'SIGNED_IN' && newSession?.user) {\n            if (handledSignInForUserId === newSession.user.id) {\n              console.log(`👤 [AUTH:${currentTabId}] SIGNED_IN already handled for this user, skipping reload`)\n              return\n            }\n            handledSignInForUserId = newSession.user.id\n\n            if (appInitLoadComplete) {\n              console.log(`👤 [AUTH:${currentTabId}] SIGNED_IN: skipping store reload (useAppInitialization already loaded)`)\n            } else {\n              // Post-init sign-in: user signed in via modal after app loaded in guest mode\n              console.log(`👤 [AUTH:${currentTabId}] User signed in (post-init) - reloading stores...`)\n              try {\n                const { useProjectStore } = await import('@/stores/projects')\n                const { useTaskStore } = await import('@/stores/tasks')\n                const { useCanvasStore } = await import('@/stores/canvas')\n\n                const projectStore = useProjectStore()\n                const taskStore = useTaskStore()\n                const canvasStore = useCanvasStore()\n\n                await Promise.all([\n                  projectStore.loadProjectsFromDatabase(),\n                  taskStore.loadFromDatabase(),\n                  canvasStore.loadFromDatabase()\n                ])\n                console.log(`✅ [AUTH:${currentTabId}] Stores reloaded after post-init sign-in`)\n              } catch (e) {\n                console.error(`❌ [AUTH:${currentTabId}] Failed to reload stores after sign-in:`, e)\n              }\n            }\n          }\n        })\n\n      } catch (e: unknown) {\n        // BUG-1056: Detect if Brave Shields blocked auth initialization\n        if (isBlockedByBrave(e)) {\n          recordBlockedResource('supabase-auth-init')\n          console.error('[AUTH] Auth initialization blocked by Brave Shields. Please disable Shields for this site.')\n        }\n        console.error('Auth initialization failed:', e)\n        error.value = e as AuthError\n        initializationFailed.value = true\n      } finally {\n        isLoading.value = false\n        isInitialized.value = true\n      }\n    })()\n\n    return initPromise\n  }\n\n  /**\n   * BUG-1207: Mark that useAppInitialization has completed its store load\n   * This prevents the SIGNED_IN handler from doing a redundant reload\n   */\n  const markAppInitLoadComplete = () => {\n    appInitLoadComplete = true\n  }\n\n  /**\n   * Retry auth initialization after a failure\n   */\n  const retryInitialization = async () => {\n    console.log('[AUTH] Retrying initialization...')\n    initializationFailed.value = false\n    error.value = null\n    isInitialized.value = false\n    // BUG-1086: Reset promise lock to allow fresh initialization\n    initPromise = null\n    await initialize()\n  }\n\n  /**\n   * BUG-339: Migrate guest data to user account with deduplication\n   *\n   * This improved migration:\n   * 1. Checks if migration already happened (per-user flag)\n   * 2. Fetches existing user tasks to build fingerprints\n   * 3. Only inserts tasks that don't already exist\n   * 4. Clears guest data BEFORE migration to prevent contamination on interruption\n   *\n   * CRITICAL FIXES (BUG #8, #9):\n   * - Only use localStorage as source (in-memory could be Supabase data after loadFromDatabase)\n   * - Clear localStorage BEFORE creating tasks (prevents duplicates if interrupted)\n   * - Pass explicit empty string for null dates (prevents createTask's default from breaking fingerprints)\n   */\n  const migrateGuestData = async () => {\n    try {\n      // Safety check: ensure user is authenticated before migration\n      if (!user.value?.id) {\n        console.warn('[AUTH] Cannot migrate guest data: user not authenticated')\n        return\n      }\n\n      // 1. Check if already migrated for this user\n      const migrationKey = `flowstate-migrated-${user.value.id}`\n      if (localStorage.getItem(migrationKey)) {\n        console.log('[AUTH] Guest data already migrated for this user, skipping')\n        return\n      }\n\n      // Dynamic import to avoid circular dependency\n      const { useTaskStore } = await import('@/stores/tasks')\n      const taskStore = useTaskStore()\n\n      // BUG #8 FIX: ONLY use localStorage as the source of guest tasks\n      // In-memory tasks could be contaminated with Supabase data if loadFromDatabase() ran first\n      // (race condition with async migration in initialize())\n      const guestTasksJson = localStorage.getItem('flowstate-guest-tasks')\n      const allGuestTasks = guestTasksJson ? JSON.parse(guestTasksJson) : []\n\n      if (allGuestTasks.length === 0) {\n        console.log('[AUTH] No guest tasks to migrate, loading user data from database...')\n        localStorage.setItem(migrationKey, new Date().toISOString())\n        // Still need to load user's existing tasks and groups from Supabase\n        const { useTaskStore } = await import('@/stores/tasks')\n        const { useCanvasStore } = await import('@/stores/canvas')\n        const taskStore = useTaskStore()\n        const canvasStore = useCanvasStore()\n        await Promise.all([\n          taskStore.loadFromDatabase(),\n          canvasStore.loadFromDatabase()\n        ])\n        return\n      }\n\n      console.log(`[AUTH] Migrating ${allGuestTasks.length} guest tasks...`)\n\n      // 2. Fetch existing user tasks for deduplication\n      if (!supabase) {\n        console.error('[AUTH] Supabase not available for migration')\n        return\n      }\n\n      const { data: existingTasks, error: fetchError } = await supabase\n        .from('tasks')\n        .select('title, due_date, status')\n        .eq('user_id', user.value.id)\n\n      if (fetchError) {\n        console.error('[AUTH] Failed to fetch existing tasks for deduplication:', fetchError)\n        // Continue anyway - better to potentially have duplicates than lose data\n      }\n\n      // 3. Generate fingerprints for existing tasks\n      // CRITICAL: Supabase returns snake_case (due_date), guest tasks use camelCase (dueDate)\n      // BUG-333 FIX: Normalize dates to YYYY-MM-DD format for comparison\n      // Supabase may return ISO timestamps (2026-01-25T00:00:00.000Z) while guest mode\n      // may store dates as plain strings (2026-01-25) - these must match\n      const normalizeDate = (d: string | null | undefined): string => {\n        if (!d) return ''\n        // Extract YYYY-MM-DD from any date format\n        const dateOnly = d.split('T')[0]\n        return dateOnly || ''\n      }\n\n      const existingFingerprints = new Set(\n        existingTasks?.map((t: { title: string; due_date: string | null; status: string }) =>\n          `${(t.title || '').toLowerCase().trim()}|${normalizeDate(t.due_date)}|${t.status}`\n        ) || []\n      )\n\n      // 4. Filter out duplicates\n      // Guest tasks use camelCase (dueDate) - normalize to match Supabase fingerprints\n      const uniqueTasks = allGuestTasks.filter((task: { title: string; dueDate: string | null; status: string }) => {\n        const fp = `${(task.title || '').toLowerCase().trim()}|${normalizeDate(task.dueDate)}|${task.status}`\n        return !existingFingerprints.has(fp)\n      })\n\n      const duplicateCount = allGuestTasks.length - uniqueTasks.length\n      console.log(`[AUTH] Migrating ${uniqueTasks.length} unique tasks (${duplicateCount} duplicates skipped)`)\n\n      // BUG #8 FIX: Clear localStorage BEFORE creating tasks\n      // This prevents duplicates if migration is interrupted - guest tasks are already gone\n      // so they won't be re-migrated on next attempt\n      localStorage.removeItem('flowstate-guest-tasks')\n\n      // 5. TASK-344: Use safeCreateTask to preserve IDs and prevent duplicates\n      // This respects the Immutable Task ID System - same ID = same task\n      const { useSupabaseDatabase } = await import('@/composables/useSupabaseDatabase')\n      const db = useSupabaseDatabase()\n\n      let created = 0\n      let skipped = 0\n\n      for (const task of uniqueTasks) {\n        // PRESERVE the original task ID - don't generate new ones\n        const result = await db.safeCreateTask(task as Task)\n\n        if (result.status === 'created') {\n          created++\n        } else {\n          skipped++\n          console.log(`[AUTH] Task ${task.id.slice(0, 8)} skipped: ${result.status}`)\n        }\n      }\n\n      console.log(`[AUTH] Migration: ${created} created, ${skipped} skipped (already exist/tombstoned)`)\n\n      // 6. Mark migration complete\n      localStorage.setItem(migrationKey, new Date().toISOString())\n\n      // 7. BUG-339 FIX: Reload tasks and groups from database to replace in-memory guest data\n      // Without this, _rawTasks would have BOTH old guest tasks AND new migrated tasks\n      console.log('[AUTH] Reloading data from database after migration...')\n      const { useCanvasStore } = await import('@/stores/canvas')\n      const canvasStore = useCanvasStore()\n      await Promise.all([\n        taskStore.loadFromDatabase(),\n        canvasStore.loadFromDatabase()\n      ])\n\n      console.log('[AUTH] Guest data migration complete')\n    } catch (e) {\n      console.error('[AUTH] Guest data migration failed:', e)\n    }\n  }\n\n  /**\n   * FEATURE-1202: Write session to shared file for KDE widget\n   * Tauri app writes to ~/.config/flowstate/session.json on every auth state change.\n   * KDE widget reads this file for authenticated API calls.\n   * On sign-out (null session), the file is cleared.\n   */\n  const writeSessionFile = async (sessionData: Session | null) => {\n    try {\n      const { writeTextFile, mkdir, exists } = await import('@tauri-apps/plugin-fs')\n      const { homeDir } = await import('@tauri-apps/api/path')\n\n      const home = await homeDir()\n      const configDir = `${home}.config/flowstate`\n      const sessionPath = `${configDir}/session.json`\n\n      // Ensure directory exists\n      const dirExists = await exists(configDir)\n      if (!dirExists) {\n        await mkdir(configDir, { recursive: true })\n      }\n\n      if (sessionData) {\n        // Write minimal session data (only what KDE widget needs)\n        const payload = JSON.stringify({\n          access_token: sessionData.access_token,\n          refresh_token: sessionData.refresh_token,\n          expires_at: sessionData.expires_at,\n          user_id: sessionData.user?.id,\n          updated_at: new Date().toISOString(),\n        })\n        await writeTextFile(sessionPath, payload)\n        console.log('[AUTH] Session file written for KDE widget')\n      } else {\n        // Clear session file on sign-out\n        await writeTextFile(sessionPath, '{}')\n        console.log('[AUTH] Session file cleared (signed out)')\n      }\n    } catch (e) {\n      // Non-critical — KDE widget is optional\n      console.warn('[AUTH] Could not write session file:', e)\n    }\n  }\n\n  const signInWithPassword = async (email: string, password: string) => {\n    try {\n      // 1. Capture guest data BEFORE sign-in clears/changes state\n      // (Actually, sign-in itself doesn't clear store, but the subsequent app reload/sync might)\n      // We'll run migration AFTER successful sign-in.\n\n      isLoading.value = true\n      error.value = null\n\n      const { data, error: signInError } = await supabase.auth.signInWithPassword({\n        email,\n        password\n      })\n\n      if (signInError) throw signInError\n\n      // BUG-339 FIX: Set user/session immediately from response\n      // Don't wait for onAuthStateChange (async) - we need user.id for migration\n      if (data.session) {\n        session.value = data.session\n        user.value = data.user\n        // BUG-339: Schedule proactive refresh\n        if (data.session.expires_at) {\n          scheduleTokenRefresh(data.session.expires_at)\n        }\n      }\n\n      // 2. Migrate Data\n      await migrateGuestData()\n\n    } catch (e: unknown) {\n      // BUG-1056: Detect if Brave Shields blocked the auth request\n      if (isBlockedByBrave(e)) {\n        recordBlockedResource('supabase-auth-signin')\n        console.error('[AUTH] Sign-in blocked by Brave Shields. Please disable Shields for this site.')\n      }\n      error.value = e as AuthError\n      throw e\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const signIn = async (email: string) => { // Basic Magic Link for now (easiest to start)\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const { error: signInError } = await supabase.auth.signInWithOtp({\n        email,\n        options: {\n          // Redirect back to app after login\n          emailRedirectTo: window.location.origin\n        }\n      })\n\n      if (signInError) throw signInError\n\n      // Note: Magic link flow redirects, so migration would happen on the callback/landing page\n      // preventing us from doing it here. We'd need a \"post-login-migration\" check on app init.\n      // For now, Password login is the primary immediate flow.\n\n    } catch (e: unknown) {\n      error.value = e as AuthError\n      throw e\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const signOut = async () => {\n    try {\n      isLoading.value = true\n\n      // BUG-339: Clear refresh timer on sign-out\n      if (refreshTimer) {\n        clearTimeout(refreshTimer)\n        refreshTimer = null\n      }\n\n      // FEATURE-1202: Use scope: 'local' for reliable logout.\n      // Server-side signOut can hang/fail when session was established via setSession()\n      // (e.g., after Google OAuth with manual token extraction).\n      // Local scope clears localStorage session — sufficient for logout.\n      try {\n        await supabase.auth.signOut({ scope: 'local' })\n      } catch (signOutErr) {\n        console.warn('[AUTH] supabase.auth.signOut() failed, clearing locally:', signOutErr)\n      }\n\n      // Always clear auth state regardless of signOut result\n      user.value = null\n      session.value = null\n\n      // Clear task store to prevent showing authenticated user's data in guest mode\n      const { useTaskStore } = await import('@/stores/tasks')\n      const taskStore = useTaskStore()\n      taskStore.clearAll()\n\n      // Clear canvas store (groups, nodes, edges)\n      const { useCanvasStore } = await import('@/stores/canvas')\n      const canvasStore = useCanvasStore()\n      canvasStore.clearAll()\n\n      // Clear guest ephemeral data for fresh guest experience\n      clearGuestData()\n\n      console.log('[AUTH] Signed out, cleared task store and guest data')\n    } catch (e: unknown) {\n      error.value = e as AuthError\n      console.error('Sign out failed:', e)\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const signInWithGoogle = async () => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      // FEATURE-1202: Branch on Tauri vs PWA\n      // Tauri uses localhost redirect + system browser (can't do in-WebView redirect)\n      // PWA uses standard OAuth redirect in same window\n      const isTauri = typeof window !== 'undefined' && '__TAURI__' in window\n\n      if (isTauri) {\n        const { signInWithGoogleTauri } = await import('@/composables/useTauriOAuth')\n        await signInWithGoogleTauri()\n        // Tauri flow handles session internally via exchangeCodeForSession\n        // onAuthStateChange will fire and update store state\n        return\n      }\n\n      // PWA: standard OAuth redirect flow\n      const { error: signInError } = await supabase.auth.signInWithOAuth({\n        provider: 'google',\n        options: {\n          redirectTo: window.location.origin\n        }\n      })\n\n      if (signInError) throw signInError\n    } catch (e: unknown) {\n      // BUG-1056: Detect if Brave Shields blocked the OAuth redirect\n      if (isBlockedByBrave(e)) {\n        recordBlockedResource('supabase-auth-google-oauth')\n        console.error('[AUTH] Google sign-in blocked by Brave Shields. Please disable Shields for this site.')\n      }\n      console.error('Google sign in failed:', e)\n      error.value = e as AuthError\n      throw e\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const signUpWithEmail = async (email: string, password: string, metadata?: Record<string, unknown>) => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const { data, error: signUpError } = await supabase.auth.signUp({\n        email,\n        password,\n        options: {\n          data: metadata\n        }\n      })\n\n      if (signUpError) throw signUpError\n\n      // If auto-confirm is on, we might get a session immediately\n      if (data.session) {\n        session.value = data.session\n        user.value = data.user\n        // BUG-339: Schedule proactive refresh\n        if (data.session.expires_at) {\n          scheduleTokenRefresh(data.session.expires_at)\n        }\n        await migrateGuestData()\n      }\n\n      return data\n    } catch (e: unknown) {\n      console.error('Sign up failed:', e)\n      error.value = e as AuthError\n      throw e\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const sendPasswordResetEmail = async (email: string) => {\n    try {\n      isLoading.value = true\n      error.value = null\n\n      const { error: resetError } = await supabase.auth.resetPasswordForEmail(email, {\n        redirectTo: `${window.location.origin}/reset-password`,\n      })\n\n      if (resetError) throw resetError\n    } catch (e: unknown) {\n      console.error('Password reset failed:', e)\n      error.value = e as AuthError\n      throw e\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  // Auto-init (Removed: let composables/components control init timing)\n  // initialize()\n\n  return {\n    // State\n    user,\n    session,\n    isLoading,\n    error,\n    isInitialized,\n    initializationFailed,\n\n    // Getters\n    isAuthenticated,\n    errorMessage,\n    displayName,\n    photoURL,\n    isAdmin,\n    isDev,\n    hasPasswordAuth,\n\n    // Actions\n    initialize,\n    retryInitialization,\n    markAppInitLoadComplete,\n    signIn,\n    signInWithPassword,\n    signInWithGoogle,\n    signUpWithEmail,\n    sendPasswordResetEmail,\n    signOut\n  }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"watch"},"fix":{"range":[48,55],"text":""},"desc":"Remove unused variable \"watch\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia'\nimport { ref, watch } from 'vue'\nimport type { CanvasGroup } from '@/types/canvas'\nimport type { Task } from '@/types/tasks'\nimport { breakGroupCycles, resetAllGroupsToRoot } from '@/utils/canvas/storeHelpers'\nimport { assertNoDuplicateIds } from '@/utils/canvas/invariants'\nimport { CANVAS } from '@/constants/canvas'\nimport { type Node, type Edge } from '@vue-flow/core'\nimport { getGroupAbsolutePosition } from '@/utils/canvas/coordinates'\nimport { isNodeCompletelyInside } from '@/utils/canvas/spatialContainment'\n\n// Modular store logic\nimport { useCanvasGroups } from './canvas/canvasGroups'\nimport { useCanvasViewport } from './canvas/canvasViewport'\nimport { useCanvasPersistence } from './canvas/canvasPersistence'\nexport * from './canvas/types'\n\nexport const useCanvasStore = defineStore('canvas', () => {\n  // 1. Task Store Reference (Async Bridge)\n  const taskStoreRef = ref<{ tasks: Task[] } | null>(null)\n  if (typeof window !== 'undefined') {\n    import('@/stores/tasks').then(m => { taskStoreRef.value = m.useTaskStore() as unknown as { tasks: Task[] } })\n  }\n\n  // BUG-1084 v5: Flag to indicate that loadFromDatabase has completed at least once\n  // Used by useCanvasOrchestrator to wait for store initialization before syncing\n  const _hasInitializedOnce = ref(false)\n\n  // 2. Persistence Layer\n  const {\n    fetchGroups,\n    saveGroup,\n    deleteGroupRemote,\n    saveGroupsToLocalStorage,\n    loadGroupsFromLocalStorage\n  } = useCanvasPersistence()\n\n  const saveGroupToStorage = async (group: CanvasGroup) => {\n    saveGroupsToLocalStorage(groupsModule._rawGroups.value)\n    try {\n      await saveGroup(group)\n    } catch (_e) {\n      if (import.meta.env.DEV) console.debug('[CANVAS:SAVE] Supabase skipped/failed - localStorage backup saved')\n    }\n  }\n\n  // 3. Viewport Layer\n  const {\n    viewport,\n    zoomConfig,\n    setViewport,\n    loadSavedViewport\n  } = useCanvasViewport()\n\n  // 4. Groups Layer\n  const groupsModule = useCanvasGroups(\n    { saveGroupToStorage, saveGroupsToLocalStorage, deleteGroupRemote },\n    taskStoreRef\n  )\n\n  // 5. Shared Canvas State\n  const nodes = ref<Node[]>([])\n  const edges = ref<Edge[]>([])\n  const isDragging = ref(false)\n  const nodeVersionMap = ref<Map<string, number>>(new Map())\n  const showGroupGuides = ref(true)\n  const snapToGroups = ref(true)\n  const selectedNodeIds = ref<string[]>([])\n  const skipNextSelectionChange = ref(false)\n  const allowBulkDeselect = ref(false)\n  const connectMode = ref(false)\n  const connectingFrom = ref<string | null>(null)\n\n  // UI state\n  const multiSelectMode = ref(false)\n  const selectionMode = ref('normal')\n  const selectionRect = ref<{ x: number, y: number, width: number, height: number } | null>(null)\n  const isSelecting = ref(false)\n  const showPriorityIndicator = ref(true)\n  const showStatusBadge = ref(true)\n  const showDurationBadge = ref(true)\n  const showScheduleBadge = ref(true)\n\n  // 6. Action Orchestration (Loading)\n  const loadFromDatabase = async () => {\n    try {\n      const { useAuthStore } = await import('@/stores/auth')\n      const authStore = useAuthStore()\n\n      if (!authStore.isAuthenticated) {\n        const localGroups = loadGroupsFromLocalStorage()\n        groupsModule.setGroups(breakGroupCycles(localGroups))\n        return\n      }\n\n      const loadedGroups = await fetchGroups()\n\n      if (import.meta.env.DEV) {\n        assertNoDuplicateIds(loadedGroups, 'Supabase groups load')\n      }\n\n      // Integrity checks\n      loadedGroups.forEach((g: CanvasGroup) => {\n        if (!g.position || !Number.isFinite(g.position.x) || !Number.isFinite(g.position.y)) {\n          console.warn(`[CANVAS:INTEGRITY] Auto-repairing position for group ${g.name}`)\n          g.position = { x: 0, y: 0, width: g.position?.width || 600, height: g.position?.height || 400 }\n        }\n      })\n\n      // BUG-169 Safety\n      if (loadedGroups.length === 0 && groupsModule._rawGroups.value.length > 0) {\n        const sessionStart = (window as unknown as Record<string, unknown>).FlowStateSessionStart as number || 0\n        if (Date.now() - sessionStart < 10000) {\n          console.warn('[CANVAS:LOAD] BLOCKED empty overwrite')\n          return\n        }\n      }\n\n      const cleanedGroups = breakGroupCycles(loadedGroups)\n      groupsModule.setGroups(cleanedGroups)\n\n      // Persist fixes\n      cleanedGroups.forEach((g: CanvasGroup, i: number) => {\n        if (g.parentGroupId !== loadedGroups[i]?.parentGroupId) {\n          saveGroup(g)\n        }\n      })\n\n      // Versions - defensive: ensure nodeVersionMap is a Map (can get corrupted during hot reload)\n      if (!(nodeVersionMap.value instanceof Map)) {\n        nodeVersionMap.value = new Map()\n      }\n      nodeVersionMap.value.clear()\n      loadedGroups.forEach((g: CanvasGroup) => nodeVersionMap.value.set(g.id, g.positionVersion ?? 0))\n      if (taskStoreRef.value?.tasks) {\n        taskStoreRef.value.tasks.forEach((t: Task) => nodeVersionMap.value.set(t.id, t.positionVersion ?? 0))\n      }\n\n    } catch (e) {\n      console.error('[CANVAS:LOAD] Failed to load canvas groups:', e)\n      const localGroups = loadGroupsFromLocalStorage()\n      if (localGroups.length > 0) groupsModule.setGroups(breakGroupCycles(localGroups))\n    } finally {\n      // BUG-1084 v5: Mark initialization complete (even on error)\n      _hasInitializedOnce.value = true\n    }\n  }\n\n  // 7. Initialize\n  // BUG-1045 FIX: REMOVED auto-init on store creation\n  // The canvas store was initializing BEFORE auth was ready, causing it to load\n  // empty data or from localStorage (guest mode) instead of Supabase.\n  // Initialization now happens ONLY from useAppInitialization.ts AFTER auth.\n  // Same pattern as BUG-339 fix in tasks.ts.\n  //\n  // REMOVED CODE:\n  // const initialize = async () => {\n  //   await loadFromDatabase()\n  //   import('@/stores/auth').then(({ useAuthStore }) => {\n  //     const authStore = useAuthStore()\n  //     watch(() => [authStore.isInitialized, authStore.isAuthenticated], async ([isInit, isAuth], [_wasInit, wasAuth]) => {\n  //       if (isInit && isAuth && !wasAuth) {\n  //         await loadFromDatabase()\n  //       }\n  //     })\n  //   })\n  // }\n  // if (typeof window !== 'undefined') {\n  //   initialize()\n  // }\n\n  // 8. Visual Logic\n  // REMOVED: syncTasksToCanvas (legacy flat-node sync without parentNode, spatial validation,\n  // or PositionManager integration). Canonical sync path is useCanvasSync.syncStoreToCanvas().\n  // performanceBenchmark.ts guards with typeof check, so removal is safe.\n\n  const calculateContentBounds = (tasks: Task[]) => {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n    let hasContent = false\n\n    tasks.forEach(t => {\n      if (t.canvasPosition && !t.isInInbox) {\n        hasContent = true\n        minX = Math.min(minX, t.canvasPosition.x)\n        minY = Math.min(minY, t.canvasPosition.y)\n        maxX = Math.max(maxX, t.canvasPosition.x + CANVAS.DEFAULT_TASK_WIDTH)\n        maxY = Math.max(maxY, t.canvasPosition.y + CANVAS.DEFAULT_TASK_HEIGHT)\n      }\n    })\n\n    groupsModule.visibleGroups.value.forEach((g: CanvasGroup) => {\n      if (g.position) {\n        hasContent = true\n        const w = g.position.width || CANVAS.DEFAULT_GROUP_WIDTH\n        const h = g.position.height || CANVAS.DEFAULT_GROUP_HEIGHT\n        minX = Math.min(minX, g.position.x)\n        minY = Math.min(minY, g.position.y)\n        maxX = Math.max(maxX, g.position.x + w)\n        maxY = Math.max(maxY, g.position.y + h)\n      }\n    })\n\n    if (!hasContent || minX === Infinity) return { x: 0, y: 0, width: 0, height: 0 }\n    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY }\n  }\n\n  // 9. Selection / UI Actions\n  const setSelectedNodes = (ids: string[]) => { selectedNodeIds.value = ids }\n  const clearSelection = () => { selectedNodeIds.value = [] }\n  const toggleNodeSelection = (id: string) => {\n    skipNextSelectionChange.value = true\n    const index = selectedNodeIds.value.indexOf(id)\n    if (index === -1) selectedNodeIds.value.push(id)\n    else selectedNodeIds.value.splice(index, 1)\n  }\n\n  const toggleMultiSelectMode = () => { multiSelectMode.value = !multiSelectMode.value }\n  const setSelectionMode = (mode: string) => { selectionMode.value = mode }\n  const startSelection = (x: number, y: number) => { isSelecting.value = true; selectionRect.value = { x, y, width: 0, height: 0 } }\n  const updateSelection = (x: number, y: number) => {\n    if (selectionRect.value) {\n      selectionRect.value.width = x - selectionRect.value.x\n      selectionRect.value.height = y - selectionRect.value.y\n    }\n  }\n  const endSelection = () => { isSelecting.value = false; selectionRect.value = null }\n  const selectNodesInRect = (rect: { x: number, y: number, width: number, height: number }) => {\n    const boxLeft = Math.min(rect.x, rect.x + rect.width)\n    const boxTop = Math.min(rect.y, rect.y + rect.height)\n    const boxRight = Math.max(rect.x, rect.x + rect.width)\n    const boxBottom = Math.max(rect.y, rect.y + rect.height)\n\n    const selectedIds = nodes.value.filter(n => {\n      const x = Number(n.position.x)\n      const y = Number(n.position.y)\n      return x >= boxLeft && x <= boxRight && y >= boxTop && y <= boxBottom\n    }).map(n => n.id)\n    setSelectedNodes(selectedIds)\n  }\n\n  const requestSync = async (source: string = 'unknown') => {\n    const USER_ACTION_SOURCES = ['user:drag-drop', 'user:create', 'user:delete', 'user:undo', 'user:redo', 'user:resize', 'user:connect', 'user:context-menu', 'user:manual']\n    if (USER_ACTION_SOURCES.includes(source)) {\n      groupsModule.syncTrigger.value++\n    }\n  }\n\n  return {\n    // State\n    viewport, zoomConfig,\n    groups: groupsModule.visibleGroups,\n    _rawGroups: groupsModule._rawGroups,\n    activeGroupId: groupsModule.activeGroupId,\n    showGroupGuides, snapToGroups, nodes, edges, selectedNodeIds,\n    skipNextSelectionChange, allowBulkDeselect, connectMode, connectingFrom,\n    multiSelectMode, selectionMode, selectionRect, isSelecting,\n    showPriorityIndicator, showStatusBadge, showDurationBadge, showScheduleBadge,\n    activeSectionId: groupsModule.activeSectionId, syncTrigger: groupsModule.syncTrigger,\n    nodeVersionMap, isDragging,\n    // BUG-1084 v5: Initialization flag for orchestrator\n    _hasInitializedOnce,\n\n    // Actions\n    loadFromDatabase,\n    createGroup: groupsModule.createGroup,\n    updateGroup: groupsModule.updateGroup,\n    deleteGroup: groupsModule.deleteGroup,\n    setGroups: groupsModule.setGroups,\n    patchGroups: groupsModule.patchGroups,\n    updateGroupFromSync: groupsModule.updateGroupFromSync,\n    removeGroupFromSync: groupsModule.removeGroupFromSync,\n    setViewport, loadSavedViewport,\n    taskCountByGroupId: groupsModule.taskCountByGroupId,\n    getTaskCountForGroup: (id: string) => groupsModule.taskCountByGroupId.value.get(id) ?? 0,\n    aggregatedTaskCountByGroupId: groupsModule.aggregatedTaskCountByGroupId,\n    getAggregatedTaskCountForGroup: (id: string) => groupsModule.aggregatedTaskCountByGroupId.value.get(id) ?? 0,\n    bumpTaskParentVersion: groupsModule.bumpTaskParentVersion,\n    calculateContentBounds, setSelectedNodes, clearSelection, toggleNodeSelection,\n    getTasksInSection: groupsModule.getTasksInSection,\n    taskMatchesSection: (task: Task, sectionId: string) => {\n      const g = groupsModule._rawGroups.value.find(gr => gr.id === sectionId)\n      if (!g) return false\n      if (g.type !== 'custom') {\n        const propValue = (g.propertyValue || '').toLowerCase()\n        if (g.type === 'priority') return (task.priority || '').toLowerCase() === propValue\n        if (g.type === 'status') return (task.status || '').toLowerCase() === propValue\n        if (g.type === 'project') return task.projectId === g.propertyValue\n        return false\n      }\n      if (!task.canvasPosition) return false\n      const groupAbsolutePos = getGroupAbsolutePosition(sectionId, groupsModule._rawGroups.value)\n      return isNodeCompletelyInside({ position: task.canvasPosition }, { position: groupAbsolutePos, width: g.position.width, height: g.position.height })\n    },\n    requestSync, setSelectionMode, startSelection, updateSelection, endSelection, selectNodesInRect,\n    toggleMultiSelectMode,\n    togglePriorityIndicator: () => { showPriorityIndicator.value = !showPriorityIndicator.value },\n    toggleStatusBadge: () => { showStatusBadge.value = !showStatusBadge.value },\n    toggleDurationBadge: () => { showDurationBadge.value = !showDurationBadge.value },\n    toggleScheduleBadge: () => { showScheduleBadge.value = !showScheduleBadge.value },\n    setActiveSection: (id: string | null) => { groupsModule.activeSectionId.value = id },\n    toggleConnectMode: () => { connectMode.value = !connectMode.value },\n    startConnection: (id: string) => { connectingFrom.value = id; connectMode.value = true },\n    clearConnection: () => { connectingFrom.value = null; connectMode.value = false },\n    togglePowerMode: async (id: string, active?: boolean) => {\n      const g = groupsModule._rawGroups.value.find(gr => gr.id === id)\n      await groupsModule.updateGroup(id, { isPowerMode: active ?? !(g?.isPowerMode) })\n    },\n    toggleSectionVisibility: (id: string) => {\n      const g = groupsModule._rawGroups.value.find(gr => gr.id === id)\n      if (g) groupsModule.updateGroup(id, { isVisible: !g.isVisible })\n    },\n    toggleSectionCollapse: (id: string) => {\n      const g = groupsModule._rawGroups.value.find(gr => gr.id === id)\n      if (g) groupsModule.updateGroup(id, { isCollapsed: !g.isCollapsed })\n    },\n    // Compatibility aliases\n    sections: groupsModule.sections,\n    _rawSections: groupsModule._rawGroups,\n    createSection: groupsModule.createGroup,\n    updateSection: groupsModule.updateGroup,\n    deleteSection: groupsModule.deleteGroup,\n    updateSectionWithUndo: groupsModule.updateGroup,\n    recalculateAllTaskCounts: (_tasks?: Task[]) => { groupsModule.bumpTaskParentVersion() },\n    getMatchingTaskCount: (groupId: string, tasks?: Task[]) => {\n      const sourceTasks = tasks || (taskStoreRef.value?.tasks || [])\n      return sourceTasks.filter((t: Task) => {\n        const g = groupsModule._rawGroups.value.find(gr => gr.id === groupId)\n        if (!g) return false\n        if (g.type !== 'custom') {\n          const propValue = (g.propertyValue || '').toLowerCase()\n          if (g.type === 'priority') return (t.priority || '').toLowerCase() === propValue\n          if (g.type === 'status') return (t.status || '').toLowerCase() === propValue\n          if (g.type === 'project') return t.projectId === g.propertyValue\n          return false\n        }\n        if (!t.canvasPosition) return false\n        const groupAbsolutePos = getGroupAbsolutePosition(groupId, groupsModule._rawGroups.value)\n        return isNodeCompletelyInside({ position: t.canvasPosition }, { position: groupAbsolutePos, width: g.position.width, height: g.position.height })\n      }).length\n    },\n    // Clear all canvas data (used on sign-out to reset to guest mode)\n    clearAll: () => {\n      groupsModule._rawGroups.value = []\n      nodes.value = []\n      edges.value = []\n    },\n    // Emergency fix: Reset all groups to root level (clears parent relationships)\n    // Call this from browser console: useCanvasStore().resetGroupsToRoot()\n    resetGroupsToRoot: async () => {\n      const groups = groupsModule._rawGroups.value\n      resetAllGroupsToRoot(groups)\n      // Trigger reactivity and save\n      groupsModule._rawGroups.value = [...groups]\n      // Save each group to persist the fix\n      for (const g of groups) {\n        await saveGroupToStorage(g)\n      }\n      // Trigger sync\n      groupsModule.syncTrigger.value++\n      console.log('[CANVAS] All groups reset to root level. Refresh the page to see changes.')\n    }\n  }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas/canvasGroups.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'syncUpdateInProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":196,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":196,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue'\nimport type { CanvasGroup } from '@/types/canvas'\nimport {\n    applySmartGroupNormalizations,\n    logGroupIdHistogram,\n    getAllDescendantGroupIds\n} from '@/utils/canvas/storeHelpers'\nimport type { Task } from '@/types/tasks'\nimport { getGroupAbsolutePosition } from '@/utils/canvas/coordinates'\nimport { type ContainerBounds, isNodeCompletelyInside } from '@/utils/canvas/spatialContainment'\n\nexport const useCanvasGroups = (\n    persistence: {\n        saveGroupToStorage: (group: CanvasGroup) => Promise<void>\n        saveGroupsToLocalStorage: (groups: CanvasGroup[]) => void\n        deleteGroupRemote: (id: string) => Promise<void>\n    },\n    taskStoreRef: { value: { tasks: Task[] } | null }\n) => {\n    const _rawGroups = ref<CanvasGroup[]>([])\n    const activeGroupId = ref<string | null>(null)\n    const taskParentVersion = ref(0)\n    const syncTrigger = ref(0)\n    const activeSectionId = ref<string | null>(null)\n\n    const visibleGroups = computed(() => {\n        const result = _rawGroups.value.filter(g => g.isVisible !== false)\n        logGroupIdHistogram('visibleGroups', result)\n        return result\n    })\n\n    const sections = computed(() => _rawGroups.value)\n\n    const bumpTaskParentVersion = () => {\n        taskParentVersion.value++\n    }\n\n    const setGroups = (newGroups: CanvasGroup[]) => {\n        if (newGroups.length === 0 && _rawGroups.value.length > 0) {\n            console.error('❌ [CANVAS] Refusing to overwrite existing groups with empty array')\n            return\n        }\n        _rawGroups.value = [...newGroups]\n    }\n\n    const createGroup = async (groupData: Omit<CanvasGroup, 'id'>) => {\n        applySmartGroupNormalizations(groupData)\n        const newGroup: CanvasGroup = {\n            ...groupData,\n            id: crypto.randomUUID(), // TASK-1183: Use proper UUID for Supabase compatibility\n            isVisible: true,\n            isCollapsed: false,\n            // BUG-1127 FIX: Preserve parentGroupId for nested groups\n            parentGroupId: groupData.parentGroupId || null,\n            positionVersion: 1,\n            positionFormat: 'absolute'\n        }\n        _rawGroups.value.push(newGroup)\n        await persistence.saveGroupToStorage(newGroup)\n        return newGroup\n    }\n\n    const updateGroup = async (id: string, updates: Partial<CanvasGroup>) => {\n        const index = _rawGroups.value.findIndex(g => g.id === id)\n        if (index !== -1) {\n            const group = _rawGroups.value[index]\n\n            if (import.meta.env.DEV) {\n                if ('parentGroupId' in updates && updates.parentGroupId !== group.parentGroupId) {\n                    console.log(`📍[GROUP-PARENT-WRITE] Group ${id.slice(0, 8)}... (${group.name}) parentGroupId: \"${group.parentGroupId ?? 'none'}\" → \"${updates.parentGroupId ?? 'none'}\"`)\n                }\n\n                // DRIFT LOGGING: Track ALL position writes\n                if ('position' in updates && updates.position) {\n                    const oldPos = group.position\n                    const newPos = updates.position\n                    if (oldPos?.x !== newPos?.x || oldPos?.y !== newPos?.y) {\n                        console.log(`📍[GROUP-POS-WRITE] Group \"${group.name?.slice(0, 20)}\" (${id.slice(0, 8)})`, {\n                            before: oldPos ? { x: Math.round(oldPos.x), y: Math.round(oldPos.y) } : null,\n                            after: { x: Math.round(newPos.x), y: Math.round(newPos.y) },\n                            stack: new Error().stack?.split('\\n').slice(2, 6).join(' <- ')\n                        })\n                    }\n                }\n            }\n\n            if (updates.name) {\n                applySmartGroupNormalizations(updates)\n            }\n\n            const currentVersion = group.positionVersion || 0\n            const newVersion = updates.position ? currentVersion + 1 : currentVersion\n\n            _rawGroups.value[index] = {\n                ...group,\n                ...updates,\n                positionVersion: newVersion,\n                updatedAt: new Date().toISOString()\n            }\n            await persistence.saveGroupToStorage(_rawGroups.value[index])\n        }\n    }\n\n    const deleteGroup = async (id: string) => {\n        const index = _rawGroups.value.findIndex(g => g.id === id)\n        if (index !== -1) {\n            _rawGroups.value.splice(index, 1)\n            if (activeSectionId.value === id) {\n                activeSectionId.value = null\n            }\n            persistence.saveGroupsToLocalStorage(_rawGroups.value)\n            await persistence.deleteGroupRemote(id)\n        }\n    }\n\n    const patchGroups = (updates: Map<string, Partial<CanvasGroup>>) => {\n        const result = { patched: [] as string[], skippedLocked: [] as string[], notFound: [] as string[] }\n        for (const [groupId, changes] of updates) {\n            const group = _rawGroups.value.find(g => g.id === groupId)\n            if (!group) {\n                result.notFound.push(groupId)\n                continue\n            }\n            Object.assign(group, changes, { updatedAt: new Date().toISOString() })\n            result.patched.push(groupId)\n        }\n        if (result.patched.length > 0) {\n            persistence.saveGroupsToLocalStorage(_rawGroups.value)\n        }\n        return result\n    }\n\n    const isTaskDone = (task: Task): boolean => task.status === 'done'\n\n    const taskCountByGroupId = computed(() => {\n        const counts = new Map<string, number>()\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _version = taskParentVersion.value\n\n        if (!taskStoreRef.value || !taskStoreRef.value.tasks) return counts\n\n        const tasks = taskStoreRef.value.tasks\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _taskCountTotal = tasks.length\n\n        for (const task of tasks) {\n            if (task._soft_deleted || isTaskDone(task)) continue\n            if (task.parentId) {\n                counts.set(task.parentId, (counts.get(task.parentId) ?? 0) + 1)\n            }\n        }\n        return counts\n    })\n\n    const aggregatedTaskCountByGroupId = computed(() => {\n        const aggregatedCounts = new Map<string, number>()\n        const groups = _rawGroups.value\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _version = taskParentVersion.value\n\n        if (!taskStoreRef.value || !taskStoreRef.value.tasks) return aggregatedCounts\n        const directCounts = taskCountByGroupId.value\n\n        for (const group of groups) {\n            const descendantIds = getAllDescendantGroupIds(group.id, groups)\n            let total = 0\n            for (const gid of descendantIds) {\n                total += directCounts.get(gid) ?? 0\n            }\n            aggregatedCounts.set(group.id, total)\n        }\n        return aggregatedCounts\n    })\n\n    const getTasksInSection = (groupId: string, tasks?: Task[]): Task[] => {\n        const sourceTasks = tasks || (taskStoreRef.value?.tasks || [])\n        const group = _rawGroups.value.find(g => g.id === groupId)\n        if (!group) return []\n\n        const groupAbsolutePos = getGroupAbsolutePosition(groupId, _rawGroups.value)\n        const containerBounds: ContainerBounds = {\n            position: groupAbsolutePos,\n            width: group.position.width,\n            height: group.position.height\n        }\n\n        return sourceTasks.filter((t: Task) => {\n            if (t.canvasPosition) {\n                return isNodeCompletelyInside({ position: t.canvasPosition }, containerBounds)\n            }\n            return false\n        })\n    }\n\n    // Flag to prevent auto-save after sync updates (breaks circular loop)\n    let syncUpdateInProgress = false\n\n    // BUG-1207 Fix 4.1: Pending group writes tracking (mirrors task pattern)\n    const pendingGroupWrites = new Set<string>()\n\n    const addPendingGroupWrite = (groupId: string) => {\n        pendingGroupWrites.add(groupId)\n    }\n\n    const removePendingGroupWrite = (groupId: string) => {\n        pendingGroupWrites.delete(groupId)\n    }\n\n    const updateGroupFromSync = (groupId: string, data: Partial<CanvasGroup>) => {\n        // SAFETY: Validate incoming data to prevent corrupted groups\n        if (!data || typeof data !== 'object') {\n            console.warn(`[GROUP-SYNC] Ignoring invalid data for group ${groupId}:`, data)\n            return\n        }\n\n        // BUG-1207 Fix 4.1: Skip sync if local write is pending (prevents overwriting user's drag)\n        if (pendingGroupWrites.has(groupId)) {\n            if (import.meta.env.DEV) {\n                console.log(`[GROUP-SYNC] Skipping sync for group ${groupId.slice(0, 8)}... - pending local write`)\n            }\n            return\n        }\n\n        // Set flag to prevent watcher from triggering auto-save\n        syncUpdateInProgress = true\n\n        try {\n            const index = _rawGroups.value.findIndex(g => g.id === groupId)\n\n            if (index !== -1) {\n                const existing = _rawGroups.value[index]\n\n                // BUG-1207 Fix 4.1: Version/timestamp checks - prefer newer data\n                const incomingVersion = data.positionVersion ?? 0\n                const localVersion = existing.positionVersion ?? 0\n\n                if (incomingVersion > 0 && localVersion > incomingVersion) {\n                    if (import.meta.env.DEV) {\n                        console.log(`[GROUP-SYNC] Skipping older version for group ${groupId.slice(0, 8)}... (local v${localVersion} > incoming v${incomingVersion})`)\n                    }\n                    return\n                }\n\n                // If versions are equal, compare timestamps\n                if (incomingVersion === localVersion && existing.updatedAt && data.updatedAt) {\n                    const localTime = new Date(existing.updatedAt).getTime()\n                    const incomingTime = new Date(data.updatedAt).getTime()\n                    if (localTime > incomingTime) {\n                        if (import.meta.env.DEV) {\n                            console.log(`[GROUP-SYNC] Skipping older timestamp for group ${groupId.slice(0, 8)}... (local newer by ${localTime - incomingTime}ms)`)\n                        }\n                        return\n                    }\n                }\n\n                // Update existing group (don't trigger saveGroupToStorage)\n                _rawGroups.value[index] = {\n                    ...existing,\n                    ...data,\n                    id: groupId, // Ensure ID is preserved\n                    updatedAt: data.updatedAt || new Date().toISOString()\n                }\n            } else {\n                // Add new group from remote - use defaults matching createGroup\n                const newGroup: CanvasGroup = {\n                    // Apply data first\n                    ...data,\n                    // Then apply required fields (override if missing)\n                    id: groupId,\n                    name: data.name || 'Untitled Group',\n                    type: data.type || 'custom',\n                    position: data.position || { x: 0, y: 0, width: 400, height: 300 },\n                    color: data.color || '#3b82f6',\n                    layout: data.layout || 'freeform',\n                    isVisible: data.isVisible !== false,\n                    isCollapsed: data.isCollapsed || false,\n                    parentGroupId: data.parentGroupId || null,\n                    positionVersion: data.positionVersion || 1,\n                    positionFormat: data.positionFormat || 'absolute',\n                    updatedAt: data.updatedAt || new Date().toISOString()\n                }\n                _rawGroups.value.push(newGroup)\n            }\n\n            // Update localStorage backup\n            persistence.saveGroupsToLocalStorage(_rawGroups.value)\n        } finally {\n            // Reset flag after Vue's next tick to ensure watcher sees it\n            setTimeout(() => {\n                syncUpdateInProgress = false\n            }, 100)\n        }\n    }\n\n    const removeGroupFromSync = (groupId: string) => {\n        // SAFETY: Use _rawGroups for sync mutations\n        const index = _rawGroups.value.findIndex(g => g.id === groupId)\n        if (index !== -1) {\n            _rawGroups.value.splice(index, 1)\n            if (activeSectionId.value === groupId) {\n                activeSectionId.value = null\n            }\n            persistence.saveGroupsToLocalStorage(_rawGroups.value)\n        }\n    }\n\n    return {\n        _rawGroups,\n        activeGroupId,\n        taskParentVersion,\n        syncTrigger,\n        activeSectionId,\n        visibleGroups,\n        sections,\n        bumpTaskParentVersion,\n        setGroups,\n        createGroup,\n        updateGroup,\n        deleteGroup,\n        patchGroups,\n        taskCountByGroupId,\n        aggregatedTaskCountByGroupId,\n        getTasksInSection,\n        updateGroupFromSync,\n        removeGroupFromSync,\n        addPendingGroupWrite,\n        removePendingGroupWrite\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas/canvasPersistence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas/canvasUi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas/canvasViewport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas/contextMenus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas/modals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/canvas/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/challenges.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":481,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":481,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'archiveToHistory' is defined but never used. Allowed unused vars must match /^_/u.","line":650,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":650,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'completionRate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":656,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":656,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'profile' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":721,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":721,"endColumn":18}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Challenges Store for Cyberflow RPG\n * FEATURE-1132: AI-driven challenge system with daily missions and weekly bosses\n *\n * This store manages:\n * - Active challenges (3 dailies + 1 weekly boss)\n * - Challenge progress tracking\n * - Expiry and penalty handling\n * - Corruption level updates\n */\n\nimport { defineStore } from 'pinia'\nimport { ref, computed, watch } from 'vue'\nimport { supabase } from '@/services/auth/supabase'\nimport { useAuthStore } from '@/stores/auth'\nimport { useGamificationStore } from '@/stores/gamification'\nimport type {\n  Challenge,\n  ChallengeType,\n  ChallengeStatus,\n  ChallengeObjective,\n  ChallengeProgressEvent,\n  DbChallenge,\n  CorruptionTierConfig,\n} from '@/types/challenges'\nimport {\n  mapDbChallenge,\n  mapChallengeToDb,\n  getCorruptionTier,\n  CORRUPTION_DELTAS,\n} from '@/types/challenges'\nimport {\n  generateDailyChallenges,\n  generateWeeklyBoss,\n  buildGenerationContext,\n  type GameMasterOptions,\n} from '@/services/ai/gamemaster'\nimport {\n  getCompletionNarrative,\n  getFailureNarrative,\n} from '@/services/ai/challengeTemplates'\n\n// =============================================================================\n// Helper: Get local date string for timezone-safe comparisons\n// =============================================================================\n\nfunction getLocalDateString(date: Date = new Date()): string {\n  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`\n}\n\n// =============================================================================\n// Store Definition\n// =============================================================================\n\nexport const useChallengesStore = defineStore('challenges', () => {\n  const authStore = useAuthStore()\n  const gamificationStore = useGamificationStore()\n\n  // ===========================================================================\n  // State\n  // ===========================================================================\n\n  const activeChallenges = ref<Challenge[]>([])\n  const isGenerating = ref(false)\n  const isLoading = ref(false)\n  const isInitialized = ref(false)\n  const lastDailyGeneration = ref<string | null>(null)\n  const lastWeeklyGeneration = ref<string | null>(null)\n  const corruptionLevel = ref(0)\n  const activeMultiplier = ref(1.0)\n\n  // Progress tracking mutex to prevent race conditions\n  const progressInProgress = ref(false)\n\n  // Picked challenge (session-level, survives panel close/open)\n  const pickedChallengeId = ref<string | null>(null)\n\n  // Midnight refresh timeout\n  let midnightTimeout: ReturnType<typeof setTimeout> | null = null\n\n  // ===========================================================================\n  // Computed\n  // ===========================================================================\n\n  const activeDailies = computed(() =>\n    activeChallenges.value.filter(\n      c => c.challengeType === 'daily' && c.status === 'active'\n    )\n  )\n\n  const activeBoss = computed(() =>\n    activeChallenges.value.find(\n      c => c.challengeType === 'boss' && c.status === 'active'\n    )\n  )\n\n  const completedTodayCount = computed(() =>\n    activeChallenges.value.filter(\n      c => c.status === 'completed' && isToday(c.completedAt)\n    ).length\n  )\n\n  const hasActiveChallenges = computed(() => activeDailies.value.length > 0)\n\n  const pickedChallenge = computed(() =>\n    pickedChallengeId.value\n      ? activeChallenges.value.find(c => c.id === pickedChallengeId.value) ?? null\n      : null\n  )\n\n  const corruptionTier = computed((): CorruptionTierConfig =>\n    getCorruptionTier(corruptionLevel.value)\n  )\n\n  const allDailiesComplete = computed(() =>\n    activeDailies.value.length === 0 &&\n    activeChallenges.value.filter(\n      c => c.challengeType === 'daily' && c.status === 'completed' && isToday(c.completedAt)\n    ).length >= 3\n  )\n\n  // ===========================================================================\n  // Pick / Unpick Challenge\n  // ===========================================================================\n\n  function pickChallengeById(id: string | null) {\n    pickedChallengeId.value = id\n  }\n\n  // ===========================================================================\n  // Initialization\n  // ===========================================================================\n\n  async function initialize() {\n    if (!supabase || !authStore.isAuthenticated || !authStore.user?.id) {\n      console.log('[Challenges] Skipping init - no auth')\n      return\n    }\n\n    if (isInitialized.value) {\n      console.log('[Challenges] Already initialized')\n      return\n    }\n\n    isLoading.value = true\n    const userId = authStore.user.id\n\n    try {\n      console.log('[Challenges] Initializing for user:', userId.slice(0, 8))\n\n      // Load active challenges\n      await loadActiveChallenges(userId)\n\n      // Load corruption level from user_gamification\n      await loadCorruptionState(userId)\n\n      // Check for expired challenges and apply penalties\n      await processExpiredChallenges()\n\n      // Check if we need new dailies\n      const today = getLocalDateString()\n      if (lastDailyGeneration.value !== today && activeDailies.value.length === 0) {\n        console.log('[Challenges] Need to generate daily challenges')\n        // Don't auto-generate here - let the UI trigger it\n      }\n\n      // Check if we need a weekly boss (Monday)\n      const now = new Date()\n      const isMonday = now.getDay() === 1\n      const weekStart = getWeekStartString()\n      if (isMonday && lastWeeklyGeneration.value !== weekStart && !activeBoss.value) {\n        console.log('[Challenges] Need to generate weekly boss')\n        // Don't auto-generate here - let the UI trigger it\n      }\n\n      // Set up midnight refresh\n      scheduleMidnightRefresh()\n\n      isInitialized.value = true\n      console.log('[Challenges] Initialized successfully')\n    } catch (e) {\n      console.error('[Challenges] Initialization failed:', e)\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  async function loadActiveChallenges(userId: string) {\n    const { data, error } = await supabase\n      .from('user_challenges')\n      .select('*')\n      .eq('user_id', userId)\n      .in('status', ['active', 'completed'])\n      .order('generated_at', { ascending: false })\n\n    if (error) throw error\n\n    activeChallenges.value = (data || []).map((row: DbChallenge) => mapDbChallenge(row))\n\n    // Determine last generation dates\n    const dailies = activeChallenges.value.filter(c => c.challengeType === 'daily')\n    const bosses = activeChallenges.value.filter(c => c.challengeType === 'boss')\n\n    if (dailies.length > 0) {\n      lastDailyGeneration.value = getLocalDateString(dailies[0].generatedAt)\n    }\n    if (bosses.length > 0) {\n      lastWeeklyGeneration.value = getWeekStartString(bosses[0].generatedAt)\n    }\n  }\n\n  async function loadCorruptionState(userId: string) {\n    const { data, error } = await supabase\n      .from('user_gamification')\n      .select('corruption_level, active_multiplier')\n      .eq('user_id', userId)\n      .single()\n\n    if (error && error.code !== 'PGRST116') {\n      console.warn('[Challenges] Failed to load corruption state:', error)\n      return\n    }\n\n    if (data) {\n      corruptionLevel.value = data.corruption_level ?? 0\n      activeMultiplier.value = data.active_multiplier ?? 1.0\n    }\n  }\n\n  // ===========================================================================\n  // Challenge Generation\n  // ===========================================================================\n\n  async function generateDailyChallengesAction(\n    aiOptions: GameMasterOptions\n  ): Promise<Challenge[]> {\n    if (!authStore.user?.id) throw new Error('Not authenticated')\n    if (isGenerating.value) throw new Error('Generation already in progress')\n\n    isGenerating.value = true\n    const userId = authStore.user.id\n    const today = getLocalDateString()\n\n    try {\n      // Build context from current state\n      const context = await buildContextFromState()\n\n      // Generate challenges via AI or templates\n      const generated = await generateDailyChallenges(context, aiOptions)\n\n      // Calculate expiry (midnight tonight)\n      const expiresAt = new Date()\n      expiresAt.setHours(23, 59, 59, 999)\n\n      // Save to database\n      const challenges: Challenge[] = []\n      for (const gen of generated) {\n        const challenge: Partial<Challenge> = {\n          userId,\n          challengeType: 'daily',\n          title: gen.title,\n          description: gen.description,\n          objectiveType: gen.objective_type,\n          objectiveTarget: gen.objective_target,\n          objectiveCurrent: 0,\n          objectiveContext: gen.project_name || gen.hour\n            ? { projectName: gen.project_name, hour: gen.hour }\n            : undefined,\n          rewardXp: gen.reward_xp,\n          penaltyXp: gen.penalty_xp,\n          difficulty: gen.difficulty,\n          narrativeFlavor: gen.narrative_flavor,\n          status: 'active',\n          generatedAt: new Date(),\n          expiresAt,\n          aiContext: context as unknown as Record<string, unknown>,\n        }\n\n        const { data, error } = await supabase\n          .from('user_challenges')\n          .insert(mapChallengeToDb(challenge))\n          .select()\n          .single()\n\n        if (error) throw error\n        challenges.push(mapDbChallenge(data))\n      }\n\n      // Update state\n      activeChallenges.value = [...challenges, ...activeChallenges.value]\n      lastDailyGeneration.value = today\n\n      // Update last_daily_generation in user_gamification\n      await supabase\n        .from('user_gamification')\n        .update({ last_daily_generation: today })\n        .eq('user_id', userId)\n\n      // Set active multiplier (challenges active = 2x XP)\n      await updateActiveMultiplier(2.0)\n\n      console.log('[Challenges] Generated', challenges.length, 'daily challenges')\n      return challenges\n    } finally {\n      isGenerating.value = false\n    }\n  }\n\n  async function generateWeeklyBossAction(\n    aiOptions: GameMasterOptions\n  ): Promise<Challenge> {\n    if (!authStore.user?.id) throw new Error('Not authenticated')\n    if (isGenerating.value) throw new Error('Generation already in progress')\n\n    isGenerating.value = true\n    const userId = authStore.user.id\n    const weekStart = getWeekStartString()\n\n    try {\n      // Build context from current state\n      const context = await buildContextFromState()\n\n      // Generate boss via AI or templates\n      const generated = await generateWeeklyBoss(context, aiOptions)\n\n      // Calculate expiry (end of week - Sunday 23:59:59)\n      const expiresAt = new Date()\n      expiresAt.setDate(expiresAt.getDate() + (7 - expiresAt.getDay()))\n      expiresAt.setHours(23, 59, 59, 999)\n\n      const challenge: Partial<Challenge> = {\n        userId,\n        challengeType: 'boss',\n        title: generated.title,\n        description: generated.description,\n        objectiveType: generated.objective_type,\n        objectiveTarget: generated.objective_target,\n        objectiveCurrent: 0,\n        rewardXp: generated.reward_xp,\n        rewardBonus: generated.special_reward\n          ? { cosmetic: generated.special_reward }\n          : undefined,\n        penaltyXp: generated.penalty_xp,\n        difficulty: 'boss',\n        narrativeFlavor: generated.narrative_flavor,\n        status: 'active',\n        generatedAt: new Date(),\n        expiresAt,\n        aiContext: {\n          ...(context as unknown as Record<string, unknown>),\n          total_hp: generated.total_hp,\n        },\n      }\n\n      const { data, error } = await supabase\n        .from('user_challenges')\n        .insert(mapChallengeToDb(challenge))\n        .select()\n        .single()\n\n      if (error) throw error\n\n      const boss = mapDbChallenge(data)\n      activeChallenges.value = [boss, ...activeChallenges.value]\n      lastWeeklyGeneration.value = weekStart\n\n      // Update last_weekly_generation in user_gamification\n      await supabase\n        .from('user_gamification')\n        .update({ last_weekly_generation: weekStart })\n        .eq('user_id', userId)\n\n      console.log('[Challenges] Generated weekly boss:', boss.title)\n      return boss\n    } finally {\n      isGenerating.value = false\n    }\n  }\n\n  // ===========================================================================\n  // Progress Tracking\n  // ===========================================================================\n\n  async function checkChallengeProgress(\n    event: ChallengeProgressEvent\n  ): Promise<{ completed: Challenge[]; updated: Challenge[] }> {\n    if (!authStore.user?.id || progressInProgress.value) {\n      return { completed: [], updated: [] }\n    }\n\n    progressInProgress.value = true\n    const completed: Challenge[] = []\n    const updated: Challenge[] = []\n\n    try {\n      // Find matching active challenges\n      const matching = activeChallenges.value.filter(c =>\n        c.status === 'active' && matchesObjective(c, event)\n      )\n\n      for (const challenge of matching) {\n        const increment = event.amount ?? 1\n        const newCurrent = challenge.objectiveCurrent + increment\n\n        // Update in database (atomic)\n        const { data, error } = await supabase\n          .from('user_challenges')\n          .update({\n            objective_current: newCurrent,\n            updated_at: new Date().toISOString(),\n          })\n          .eq('id', challenge.id)\n          .select()\n          .single()\n\n        if (error) {\n          console.warn('[Challenges] Failed to update progress:', error)\n          continue\n        }\n\n        const updatedChallenge = mapDbChallenge(data)\n\n        // Check for completion\n        if (updatedChallenge.objectiveCurrent >= updatedChallenge.objectiveTarget) {\n          await completeChallenge(updatedChallenge)\n          completed.push(updatedChallenge)\n        } else {\n          updated.push(updatedChallenge)\n        }\n\n        // Update local state\n        const index = activeChallenges.value.findIndex(c => c.id === challenge.id)\n        if (index !== -1) {\n          activeChallenges.value[index] = updatedChallenge\n        }\n      }\n\n      return { completed, updated }\n    } finally {\n      progressInProgress.value = false\n    }\n  }\n\n  function matchesObjective(challenge: Challenge, event: ChallengeProgressEvent): boolean {\n    if (challenge.objectiveType !== event.type) return false\n\n    // Check context-specific matches\n    if (challenge.objectiveType === 'complete_project_tasks') {\n      if (challenge.objectiveContext?.projectName && event.context?.projectId) {\n        // Would need to look up project name from ID\n        // For now, match any project task\n        return true\n      }\n    }\n\n    if (challenge.objectiveType === 'complete_before_hour') {\n      const currentHour = new Date().getHours()\n      const targetHour = challenge.objectiveContext?.hour ?? 12\n      if (currentHour >= targetHour) return false\n    }\n\n    if (challenge.objectiveType === 'complete_high_priority') {\n      if (event.context?.priority !== 'high') return false\n    }\n\n    if (challenge.objectiveType === 'clear_overdue') {\n      if (!event.context?.wasOverdue) return false\n    }\n\n    return true\n  }\n\n  // ===========================================================================\n  // Challenge Completion\n  // ===========================================================================\n\n  async function completeChallenge(challenge: Challenge): Promise<void> {\n    if (!authStore.user?.id) return\n\n    const now = new Date()\n    const userId = authStore.user.id\n\n    // Update challenge status in DB\n    const { error: updateError } = await supabase\n      .from('user_challenges')\n      .update({\n        status: 'completed',\n        completed_at: now.toISOString(),\n      })\n      .eq('id', challenge.id)\n\n    if (updateError) {\n      console.warn('[Challenges] Failed to complete challenge:', updateError)\n      return\n    }\n\n    // Award XP\n    await gamificationStore.awardXp(challenge.rewardXp, 'challenge_complete', {\n      metadata: { challengeId: challenge.id, challengeTitle: challenge.title },\n    })\n\n    // Update corruption (decrease)\n    const corruptionDelta = challenge.challengeType === 'boss'\n      ? CORRUPTION_DELTAS.BOSS_COMPLETED\n      : CORRUPTION_DELTAS.DAILY_COMPLETED\n    await updateCorruption(corruptionDelta)\n\n    // DB trigger archive_challenge_to_history handles history insertion automatically\n\n    // Update stats counters\n    await updateChallengeCounters(challenge.challengeType, 'completed')\n\n    // Check for all-dailies bonus\n    const completedDailiesCount = activeChallenges.value.filter(\n      c => c.challengeType === 'daily' && c.status === 'completed' && isToday(c.completedAt)\n    ).length + 1 // Include this one\n\n    if (completedDailiesCount >= 3) {\n      // All 3 dailies completed - bonus!\n      await updateCorruption(CORRUPTION_DELTAS.ALL_DAILIES_BONUS)\n      console.log('[Challenges] All dailies complete! Bonus corruption reduction applied')\n    }\n\n    // Update local state\n    const index = activeChallenges.value.findIndex(c => c.id === challenge.id)\n    if (index !== -1) {\n      activeChallenges.value[index] = { ...challenge, status: 'completed', completedAt: now }\n    }\n\n    console.log('[Challenges] Completed:', challenge.title, '+', challenge.rewardXp, 'XP')\n  }\n\n  // ===========================================================================\n  // Expiry and Penalties\n  // ===========================================================================\n\n  async function processExpiredChallenges(): Promise<void> {\n    const now = new Date()\n    const expired = activeChallenges.value.filter(\n      c => c.status === 'active' && c.expiresAt < now\n    )\n\n    for (const challenge of expired) {\n      await failChallenge(challenge, 'expired')\n    }\n  }\n\n  async function failChallenge(\n    challenge: Challenge,\n    reason: 'expired' | 'failed'\n  ): Promise<void> {\n    if (!authStore.user?.id) return\n\n    // Update status in DB\n    const { error: updateError } = await supabase\n      .from('user_challenges')\n      .update({ status: reason })\n      .eq('id', challenge.id)\n\n    if (updateError) {\n      console.warn('[Challenges] Failed to fail challenge:', updateError)\n      return\n    }\n\n    // Apply XP penalty if any\n    if (challenge.penaltyXp > 0) {\n      try {\n        await gamificationStore.awardXp(-challenge.penaltyXp, 'challenge_penalty', {\n          metadata: { challengeId: challenge.id, challengeTitle: challenge.title },\n        })\n      } catch (e) {\n        console.warn('[Challenges] Failed to apply XP penalty:', e)\n      }\n    }\n\n    // Update corruption (increase)\n    const corruptionDelta = challenge.challengeType === 'boss'\n      ? CORRUPTION_DELTAS.BOSS_FAILED\n      : CORRUPTION_DELTAS.DAILY_FAILED\n    await updateCorruption(corruptionDelta)\n\n    // DB trigger archive_challenge_to_history handles history insertion automatically\n\n    // Update stats counters\n    await updateChallengeCounters(challenge.challengeType, 'failed')\n\n    // Update local state\n    const index = activeChallenges.value.findIndex(c => c.id === challenge.id)\n    if (index !== -1) {\n      activeChallenges.value[index] = { ...challenge, status: reason as ChallengeStatus }\n    }\n\n    console.log('[Challenges] Failed:', challenge.title, 'Corruption +', corruptionDelta)\n  }\n\n  // ===========================================================================\n  // Corruption Management\n  // ===========================================================================\n\n  async function updateCorruption(delta: number): Promise<void> {\n    if (!authStore.user?.id) return\n\n    const newLevel = Math.max(0, Math.min(100, corruptionLevel.value + delta))\n    corruptionLevel.value = newLevel\n\n    // Update in DB\n    const { error } = await supabase\n      .from('user_gamification')\n      .update({ corruption_level: newLevel })\n      .eq('user_id', authStore.user.id)\n\n    if (error) {\n      console.warn('[Challenges] Failed to update corruption:', error)\n    }\n\n    // Update CSS custom properties for visual effects\n    updateCorruptionCSSProperties(newLevel)\n  }\n\n  async function updateActiveMultiplier(multiplier: number): Promise<void> {\n    if (!authStore.user?.id) return\n\n    activeMultiplier.value = multiplier\n\n    const { error } = await supabase\n      .from('user_gamification')\n      .update({ active_multiplier: multiplier })\n      .eq('user_id', authStore.user.id)\n\n    if (error) {\n      console.warn('[Challenges] Failed to update multiplier:', error)\n    }\n  }\n\n  function updateCorruptionCSSProperties(level: number): void {\n    const tier = getCorruptionTier(level)\n    const root = document.documentElement\n\n    root.style.setProperty('--corruption-level', String(level))\n    root.style.setProperty('--corruption-filter', tier.filter)\n    root.style.setProperty('--corruption-noise-opacity', String(tier.noiseOpacity))\n    root.style.setProperty('--corruption-scanline-opacity', String(tier.scanlineOpacity))\n    root.style.setProperty('--corruption-glitch-intensity', String(tier.glitchIntensity))\n  }\n\n  // ===========================================================================\n  // History and Stats\n  // ===========================================================================\n\n  async function archiveToHistory(\n    challenge: Challenge,\n    status: 'completed' | 'failed' | 'expired'\n  ): Promise<void> {\n    if (!authStore.user?.id) return\n\n    const completionRate = challenge.objectiveCurrent / challenge.objectiveTarget\n    const now = new Date()\n\n    const { error } = await supabase.from('challenge_history').insert({\n      user_id: authStore.user.id,\n      challenge_id: challenge.id,\n      challenge_type: challenge.challengeType,\n      objective_type: challenge.objectiveType,\n      difficulty: challenge.difficulty,\n      status,\n      xp_earned: status === 'completed' ? challenge.rewardXp : 0,\n      xp_lost: status !== 'completed' ? challenge.penaltyXp : 0,\n      objective_target: challenge.objectiveTarget,\n      objective_achieved: challenge.objectiveCurrent,\n      generated_at: challenge.generatedAt.toISOString(),\n      resolved_at: now.toISOString(),\n    })\n\n    if (error) {\n      console.warn('[Challenges] Failed to archive to history:', error)\n    }\n  }\n\n  async function updateChallengeCounters(\n    type: ChallengeType,\n    result: 'completed' | 'failed'\n  ): Promise<void> {\n    if (!authStore.user?.id || result === 'failed') return\n\n    try {\n      const { data } = await supabase\n        .from('user_gamification')\n        .select('total_challenges_completed, daily_challenges_completed, weekly_challenges_completed, boss_fights_won')\n        .eq('user_id', authStore.user.id)\n        .single()\n      if (!data) return\n\n      const updates: Record<string, number> = {\n        total_challenges_completed: (data.total_challenges_completed ?? 0) + 1,\n      }\n      if (type === 'daily') {\n        updates.daily_challenges_completed = (data.daily_challenges_completed ?? 0) + 1\n      } else if (type === 'weekly' || type === 'boss') {\n        updates.weekly_challenges_completed = (data.weekly_challenges_completed ?? 0) + 1\n        if (type === 'boss') {\n          updates.boss_fights_won = (data.boss_fights_won ?? 0) + 1\n        }\n      }\n\n      const { error } = await supabase\n        .from('user_gamification')\n        .update(updates)\n        .eq('user_id', authStore.user.id)\n      if (error) console.warn('[Challenges] Failed to update counters:', error)\n    } catch (e) {\n      console.warn('[Challenges] Counter update failed:', e)\n    }\n  }\n\n  // ===========================================================================\n  // Helper Functions\n  // ===========================================================================\n\n  async function buildContextFromState() {\n    const stats = gamificationStore.stats\n    const profile = gamificationStore.profile\n    const streakInfo = gamificationStore.streakInfo\n\n    // Get recent challenge history for difficulty calculation\n    let recentCompleted = 0\n    let recentFailed = 0\n    let recentTypes: ChallengeObjective[] = []\n\n    if (authStore.user?.id) {\n      const twoWeeksAgo = new Date()\n      twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14)\n\n      const { data } = await supabase\n        .from('challenge_history')\n        .select('status, objective_type')\n        .eq('user_id', authStore.user.id)\n        .gte('resolved_at', twoWeeksAgo.toISOString())\n\n      if (data) {\n        recentCompleted = data.filter((h: { status: string }) => h.status === 'completed').length\n        recentFailed = data.filter((h: { status: string }) => h.status !== 'completed').length\n        recentTypes = data.map((h: { objective_type: ChallengeObjective }) => h.objective_type)\n      }\n    }\n\n    // Get projects (from task store would be ideal, but simplified for now)\n    const projects: { id: string; name: string; taskCount: number; overdueCount: number }[] = []\n\n    return buildGenerationContext({\n      tasksCompleted: stats?.tasksCompleted ?? 0,\n      overdueCount: 0, // Would need task store integration\n      focusTimeToday: stats?.totalFocusMinutes ?? 0,\n      pomodorosToday: stats?.pomodorosCompleted ?? 0,\n      currentStreak: streakInfo.currentStreak,\n      longestStreak: streakInfo.longestStreak,\n      isStreakActive: streakInfo.isActiveToday,\n      corruptionLevel: corruptionLevel.value,\n      recentCompleted,\n      recentFailed,\n      recentTypes,\n      projects,\n      averageTasksPerDay: Math.max(5, Math.round((stats?.tasksCompleted ?? 0) / 30)),\n      averagePomodorosPerDay: Math.max(3, Math.round((stats?.pomodorosCompleted ?? 0) / 30)),\n      preferredHours: [9, 10, 11, 14, 15],\n      topProjects: [],\n    })\n  }\n\n  function isToday(date: Date | undefined): boolean {\n    if (!date) return false\n    return getLocalDateString(date) === getLocalDateString()\n  }\n\n  function getWeekStartString(date: Date = new Date()): string {\n    const d = new Date(date)\n    d.setDate(d.getDate() - d.getDay()) // Go to Sunday\n    return getLocalDateString(d)\n  }\n\n  function scheduleMidnightRefresh(): void {\n    if (midnightTimeout) {\n      clearTimeout(midnightTimeout)\n    }\n\n    const now = new Date()\n    const tomorrow = new Date(now)\n    tomorrow.setDate(tomorrow.getDate() + 1)\n    tomorrow.setHours(0, 0, 1, 0)\n\n    const msUntilMidnight = tomorrow.getTime() - now.getTime()\n\n    midnightTimeout = setTimeout(() => {\n      console.log('[Challenges] Midnight refresh triggered')\n      processExpiredChallenges()\n      // Reset multiplier if no challenges active\n      if (activeDailies.value.length === 0) {\n        updateActiveMultiplier(1.0)\n      }\n      scheduleMidnightRefresh() // Schedule next\n    }, msUntilMidnight)\n\n    console.log('[Challenges] Midnight refresh scheduled in', Math.round(msUntilMidnight / 60000), 'minutes')\n  }\n\n  // ===========================================================================\n  // Cleanup\n  // ===========================================================================\n\n  function dispose(): void {\n    if (midnightTimeout) {\n      clearTimeout(midnightTimeout)\n      midnightTimeout = null\n    }\n    isInitialized.value = false\n    activeChallenges.value = []\n  }\n\n  // ===========================================================================\n  // Watch for Auth Changes\n  // ===========================================================================\n\n  watch(\n    () => authStore.isAuthenticated,\n    (isAuth) => {\n      if (isAuth && !isInitialized.value) {\n        initialize()\n      } else if (!isAuth) {\n        dispose()\n      }\n    },\n    { immediate: true }\n  )\n\n  // Watch corruption level and update CSS\n  watch(corruptionLevel, (level) => {\n    updateCorruptionCSSProperties(level)\n  }, { immediate: true })\n\n  // ===========================================================================\n  // Return\n  // ===========================================================================\n\n  return {\n    // State\n    activeChallenges,\n    isGenerating,\n    isLoading,\n    isInitialized,\n    lastDailyGeneration,\n    lastWeeklyGeneration,\n    corruptionLevel,\n    activeMultiplier,\n    pickedChallengeId,\n\n    // Computed\n    activeDailies,\n    activeBoss,\n    completedTodayCount,\n    hasActiveChallenges,\n    pickedChallenge,\n    corruptionTier,\n    allDailiesComplete,\n\n    // Actions\n    initialize,\n    generateDailyChallengesAction,\n    generateWeeklyBossAction,\n    checkChallengeProgress,\n    completeChallenge,\n    failChallenge,\n    processExpiredChallenges,\n    pickChallengeById,\n    updateCorruption,\n\n    // Narratives\n    getCompletionNarrative,\n    getFailureNarrative,\n\n    // Cleanup\n    dispose,\n  }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/gamification.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'multipliers' is defined but never used. Allowed unused args must match /^_/u.","line":1082,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":1082,"endColumn":67}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Gamification Store - \"Cyberflow\" System\n * FEATURE-1118: XP, levels, streaks, achievements, and cosmetic shop\n *\n * This store manages all gamification state including:\n * - User profile (XP, level, streak, equipped theme)\n * - Achievement tracking and unlocking\n * - Shop purchases and theme application\n * - XP awarding with multipliers\n */\n\nimport { defineStore } from 'pinia'\nimport { ref, computed, watch } from 'vue'\nimport { supabase } from '@/services/auth/supabase'\nimport { useAuthStore } from '@/stores/auth'\nimport type {\n  UserGamification,\n  UserStats,\n  XpLog,\n  XpAwardResult,\n  XpMultiplier,\n  Achievement,\n  AchievementWithProgress,\n  AchievementUnlockResult,\n  ShopItem,\n  ShopItemWithOwnership,\n  PurchaseResult,\n  StreakInfo,\n  StreakUpdateResult,\n  LevelInfo,\n  GamificationToast,\n  GamificationSettings,\n  DbUserGamification,\n  DbAchievement,\n  DbUserAchievement,\n  DbShopItem,\n  DbUserStats,\n} from '@/types/gamification'\nimport {\n  XP_VALUES,\n  XP_MULTIPLIERS,\n  STREAK_CONFIG,\n} from '@/types/gamification'\n\n// =============================================================================\n// Type Mappers (Database snake_case <-> App camelCase)\n// =============================================================================\n\nfunction mapDbToUserGamification(db: DbUserGamification): UserGamification {\n  return {\n    userId: db.user_id ?? '',\n    totalXp: db.total_xp ?? 0,\n    availableXp: db.available_xp ?? 0,\n    level: db.level ?? 1,\n    currentStreak: db.current_streak ?? 0,\n    longestStreak: db.longest_streak ?? 0,\n    streakFreezes: db.streak_freezes ?? 0,\n    lastActivityDate: db.last_activity_date ? new Date(db.last_activity_date) : null,\n    xpDecayDate: db.xp_decay_date ? new Date(db.xp_decay_date) : null,\n    unlockedThemes: db.unlocked_themes || [],\n    equippedTheme: db.equipped_theme ?? 'default',\n    createdAt: new Date(db.created_at),\n    updatedAt: new Date(db.updated_at),\n  }\n}\n\nfunction mapDbToAchievement(db: DbAchievement): Achievement {\n  return {\n    id: db.id,\n    name: db.name,\n    description: db.description,\n    icon: db.icon,\n    category: db.category,\n    xpReward: db.xp_reward,\n    conditionType: db.condition_type,\n    conditionValue: db.condition_value,\n    conditionKey: db.condition_key || undefined,\n    isSecret: db.is_secret,\n    tier: db.tier,\n  }\n}\n\nfunction mapDbToShopItem(db: DbShopItem): ShopItem {\n  return {\n    id: db.id,\n    name: db.name,\n    description: db.description,\n    category: db.category,\n    priceXp: db.price_xp,\n    previewCss: db.preview_css || {},\n    isPermanent: db.is_permanent,\n    isAvailable: db.is_available,\n    requiredLevel: db.required_level,\n  }\n}\n\nfunction mapDbToUserStats(db: DbUserStats): UserStats {\n  return {\n    userId: db.user_id,\n    tasksCompleted: db.tasks_completed,\n    pomodorosCompleted: db.pomodoros_completed,\n    totalFocusMinutes: db.total_focus_minutes,\n    tasksCompletedOnTime: db.tasks_completed_on_time,\n    tasksCompletedHighPriority: db.tasks_completed_high_priority,\n    midnightTasks: db.midnight_tasks,\n    speedCompletions: db.speed_completions,\n    viewsUsed: db.views_used || {},\n    featuresUsed: db.features_used || {},\n    updatedAt: new Date(db.updated_at),\n  }\n}\n\n// =============================================================================\n// Level Calculation Utilities\n// =============================================================================\n\n/**\n * Calculate XP required to reach a specific level from level 1\n * Level curve:\n * - Levels 1-5: 100 XP each\n * - Levels 6-10: 250 XP increment (starting at 750)\n * - Levels 11+: 500 XP increment (starting at 2250)\n */\nexport function xpForLevel(level: number): number {\n  if (level <= 1) return 0\n  if (level <= 5) {\n    // Levels 2-5: 100, 200, 300, 400, 500 cumulative\n    return (level - 1) * 100\n  }\n  if (level <= 10) {\n    // Levels 2-5 = 500 XP, then 250 per level\n    const base = 500\n    return base + (level - 5) * 250\n  }\n  // Level 11+: 500 + 1250 (for 6-10) + 500 per level\n  const base = 500 + 1250\n  return base + (level - 10) * 500\n}\n\n/**\n * Calculate XP needed for JUST the current level (not cumulative)\n */\nexport function xpForCurrentLevel(level: number): number {\n  if (level <= 5) return 100\n  if (level <= 10) return 250\n  return 500\n}\n\n/**\n * Calculate level from total XP\n */\nexport function levelFromXp(totalXp: number): number {\n  let level = 1\n  let xpRemaining = totalXp\n\n  // Levels 1-5\n  while (level < 5 && xpRemaining >= 100) {\n    xpRemaining -= 100\n    level++\n  }\n\n  // Levels 6-10\n  while (level >= 5 && level < 10 && xpRemaining >= 250) {\n    xpRemaining -= 250\n    level++\n  }\n\n  // Levels 11+\n  while (level >= 10 && xpRemaining >= 500) {\n    xpRemaining -= 500\n    level++\n  }\n\n  return level\n}\n\n/**\n * Get detailed level info for UI display\n */\nexport function getLevelInfo(totalXp: number): LevelInfo {\n  const level = levelFromXp(totalXp)\n  const xpForCurrent = xpForLevel(level)\n  const xpForNext = xpForLevel(level + 1)\n  const currentLevelXp = totalXp - xpForCurrent\n  const xpNeeded = xpForNext - xpForCurrent\n\n  return {\n    level,\n    currentXp: currentLevelXp,\n    xpForCurrentLevel: 0, // XP at start of current level\n    xpForNextLevel: xpNeeded,\n    progressPercent: Math.min(100, Math.round((currentLevelXp / xpNeeded) * 100)),\n    totalXpRequired: xpForCurrent,\n  }\n}\n\n// =============================================================================\n// Store Definition\n// =============================================================================\n\nexport const useGamificationStore = defineStore('gamification', () => {\n  const authStore = useAuthStore()\n\n  // =============================================================================\n  // State\n  // =============================================================================\n\n  const profile = ref<UserGamification | null>(null)\n  const stats = ref<UserStats | null>(null)\n  const achievements = ref<Achievement[]>([])\n  const userAchievements = ref<Map<string, { progress: number; earnedAt: Date | null }>>(new Map())\n  const shopItems = ref<ShopItem[]>([])\n  const ownedItems = ref<Set<string>>(new Set())\n  const recentXpLogs = ref<XpLog[]>([])\n  const toastQueue = ref<GamificationToast[]>([])\n  const isLoading = ref(false)\n  const isInitialized = ref(false)\n\n  // Settings (persisted locally, synced to user_settings later)\n  const settings = ref<GamificationSettings>({\n    enabled: true,\n    showXpNotifications: true,\n    showAchievementNotifications: true,\n    intensity: 'moderate',\n    soundEnabled: true,\n  })\n\n  // =============================================================================\n  // Computed\n  // =============================================================================\n\n  const isEnabled = computed(() => settings.value.enabled && !!profile.value)\n\n  const totalXp = computed(() => profile.value?.totalXp ?? 0)\n  const availableXp = computed(() => profile.value?.availableXp ?? 0)\n  const currentLevel = computed(() => profile.value?.level ?? 1)\n\n  const levelInfo = computed((): LevelInfo => getLevelInfo(totalXp.value))\n\n  const streakInfo = computed((): StreakInfo => {\n    const p = profile.value\n    if (!p) {\n      return {\n        currentStreak: 0,\n        longestStreak: 0,\n        streakFreezes: 2,\n        lastActivityDate: null,\n        isActiveToday: false,\n        streakAtRisk: false,\n        daysUntilDecay: 30,\n      }\n    }\n\n    // Use local date strings to avoid timezone issues\n    const today = new Date()\n    const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`\n\n    const lastActive = p.lastActivityDate\n    const lastActiveStr = lastActive\n      ? `${lastActive.getFullYear()}-${String(lastActive.getMonth() + 1).padStart(2, '0')}-${String(lastActive.getDate()).padStart(2, '0')}`\n      : null\n\n    const isActiveToday = lastActiveStr === todayStr\n\n    const yesterday = new Date(today)\n    yesterday.setDate(yesterday.getDate() - 1)\n    const yesterdayStr = `${yesterday.getFullYear()}-${String(yesterday.getMonth() + 1).padStart(2, '0')}-${String(yesterday.getDate()).padStart(2, '0')}`\n    const wasActiveYesterday = lastActiveStr === yesterdayStr\n\n    const streakAtRisk = !isActiveToday && !wasActiveYesterday && p.currentStreak > 0\n\n    // Calculate days since active using date strings to avoid timezone issues\n    let daysSinceActive = 999\n    if (lastActiveStr) {\n      const todayParts = todayStr.split('-').map(Number)\n      const lastParts = lastActiveStr.split('-').map(Number)\n      const todayDate = new Date(todayParts[0], todayParts[1] - 1, todayParts[2])\n      const lastDate = new Date(lastParts[0], lastParts[1] - 1, lastParts[2])\n      daysSinceActive = Math.floor((todayDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24))\n    }\n\n    const daysUntilDecay = Math.max(0, STREAK_CONFIG.DECAY_START_DAYS - daysSinceActive)\n\n    return {\n      currentStreak: p.currentStreak,\n      longestStreak: p.longestStreak,\n      streakFreezes: p.streakFreezes,\n      lastActivityDate: p.lastActivityDate,\n      isActiveToday,\n      streakAtRisk,\n      daysUntilDecay,\n    }\n  })\n\n  const equippedTheme = computed(() => profile.value?.equippedTheme ?? 'default')\n\n  const achievementsWithProgress = computed((): AchievementWithProgress[] => {\n    return achievements.value.map((a) => {\n      const userProgress = userAchievements.value.get(a.id)\n      return {\n        ...a,\n        progress: userProgress?.progress ?? 0,\n        isEarned: userProgress?.earnedAt !== null && userProgress?.earnedAt !== undefined,\n        earnedAt: userProgress?.earnedAt ?? null,\n      }\n    })\n  })\n\n  const earnedAchievements = computed(() =>\n    achievementsWithProgress.value.filter((a) => a.isEarned)\n  )\n\n  const unlockedAchievementsCount = computed(() => earnedAchievements.value.length)\n\n  const shopItemsWithOwnership = computed((): ShopItemWithOwnership[] => {\n    return shopItems.value.map((item) => ({\n      ...item,\n      isOwned: ownedItems.value.has(item.id),\n      purchasedAt: null, // Could be fetched if needed\n    }))\n  })\n\n  // =============================================================================\n  // Database Operations\n  // =============================================================================\n\n  /**\n   * Initialize gamification profile for current user\n   * Creates profile if it doesn't exist\n   */\n  async function initialize() {\n    if (!supabase || !authStore.isAuthenticated || !authStore.user?.id) {\n      console.log('[Gamification] Skipping init - no auth')\n      return\n    }\n\n    if (isInitialized.value) {\n      console.log('[Gamification] Already initialized')\n      return\n    }\n\n    isLoading.value = true\n    const userId = authStore.user.id\n\n    try {\n      console.log('[Gamification] Initializing for user:', userId.slice(0, 8))\n\n      // Load profile (or create if doesn't exist)\n      await loadOrCreateProfile(userId)\n\n      // Load achievements, shop items, etc. in parallel\n      await Promise.all([\n        loadAchievements(),\n        loadUserAchievements(userId),\n        loadShopItems(),\n        loadUserPurchases(userId),\n        loadUserStats(userId),\n      ])\n\n      // Check and record daily activity\n      await recordDailyActivity()\n\n      isInitialized.value = true\n      console.log('[Gamification] Initialized successfully')\n    } catch (e) {\n      console.error('[Gamification] Initialization failed:', e)\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  async function loadOrCreateProfile(userId: string) {\n    const { data, error } = await supabase\n      .from('user_gamification')\n      .select('*')\n      .eq('user_id', userId)\n      .single()\n\n    if (error && error.code === 'PGRST116') {\n      // Profile doesn't exist, create it\n      console.log('[Gamification] Creating new profile')\n      const { data: newProfile, error: createError } = await supabase\n        .from('user_gamification')\n        .insert({ user_id: userId })\n        .select()\n        .single()\n\n      if (createError) throw createError\n      profile.value = mapDbToUserGamification(newProfile)\n    } else if (error) {\n      throw error\n    } else {\n      profile.value = mapDbToUserGamification(data)\n    }\n  }\n\n  async function loadAchievements() {\n    const { data, error } = await supabase.from('achievements').select('*')\n\n    if (error) throw error\n    achievements.value = (data || []).map(mapDbToAchievement)\n  }\n\n  async function loadUserAchievements(userId: string) {\n    const { data, error } = await supabase\n      .from('user_achievements')\n      .select('*')\n      .eq('user_id', userId)\n\n    if (error) throw error\n\n    userAchievements.value = new Map(\n      (data || []).map((ua: DbUserAchievement) => [\n        ua.achievement_id,\n        {\n          progress: ua.progress,\n          earnedAt: ua.earned_at ? new Date(ua.earned_at) : null,\n        },\n      ])\n    )\n  }\n\n  async function loadShopItems() {\n    const { data, error } = await supabase\n      .from('shop_items')\n      .select('*')\n      .eq('is_available', true)\n\n    if (error) throw error\n    shopItems.value = (data || []).map(mapDbToShopItem)\n  }\n\n  async function loadUserPurchases(userId: string) {\n    const { data, error } = await supabase\n      .from('user_purchases')\n      .select('item_id')\n      .eq('user_id', userId)\n\n    if (error) throw error\n    ownedItems.value = new Set((data || []).map((p: { item_id: string }) => p.item_id))\n  }\n\n  async function loadUserStats(userId: string) {\n    const { data, error } = await supabase\n      .from('user_stats')\n      .select('*')\n      .eq('user_id', userId)\n      .single()\n\n    if (error && error.code === 'PGRST116') {\n      // Stats don't exist, create them\n      const { data: newStats, error: createError } = await supabase\n        .from('user_stats')\n        .insert({ user_id: userId })\n        .select()\n        .single()\n\n      if (createError) throw createError\n      stats.value = mapDbToUserStats(newStats)\n    } else if (error) {\n      throw error\n    } else {\n      stats.value = mapDbToUserStats(data)\n    }\n  }\n\n  // =============================================================================\n  // XP System\n  // =============================================================================\n\n  /**\n   * Award XP to the user with multipliers\n   */\n  async function awardXp(\n    baseAmount: number,\n    reason: string,\n    options?: {\n      taskId?: string\n      priority?: 'low' | 'medium' | 'high' | null\n      isOverdue?: boolean\n      consecutivePomodoros?: number\n      metadata?: Record<string, unknown>\n    }\n  ): Promise<XpAwardResult | null> {\n    if (!isEnabled.value || !profile.value || !authStore.user?.id) {\n      return null\n    }\n\n    const multipliers: XpMultiplier[] = []\n    let finalAmount = baseAmount\n\n    // Apply priority multiplier\n    if (options?.priority === 'high') {\n      multipliers.push({ name: 'High Priority', value: XP_MULTIPLIERS.HIGH_PRIORITY, reason: '+50% XP' })\n      finalAmount *= XP_MULTIPLIERS.HIGH_PRIORITY\n    } else if (options?.priority === 'medium') {\n      multipliers.push({ name: 'Medium Priority', value: XP_MULTIPLIERS.MEDIUM_PRIORITY, reason: '+25% XP' })\n      finalAmount *= XP_MULTIPLIERS.MEDIUM_PRIORITY\n    }\n\n    // Apply overdue penalty\n    if (options?.isOverdue) {\n      multipliers.push({ name: 'Overdue', value: XP_MULTIPLIERS.OVERDUE_PENALTY, reason: '-10% XP' })\n      finalAmount *= XP_MULTIPLIERS.OVERDUE_PENALTY\n    }\n\n    // Apply consecutive pomodoro bonus\n    if (options?.consecutivePomodoros && options.consecutivePomodoros > 1) {\n      const bonus = Math.min(\n        options.consecutivePomodoros * XP_MULTIPLIERS.CONSECUTIVE_POMODORO_BONUS,\n        XP_MULTIPLIERS.MAX_CONSECUTIVE_BONUS\n      )\n      multipliers.push({\n        name: 'Focus Streak',\n        value: 1 + bonus,\n        reason: `+${Math.round(bonus * 100)}% XP`,\n      })\n      finalAmount *= 1 + bonus\n    }\n\n    const xpAwarded = Math.round(finalAmount)\n    const previousLevel = profile.value.level\n\n    try {\n      // Insert XP log\n      const { error: logError } = await supabase.from('xp_logs').insert({\n        user_id: authStore.user.id,\n        xp_amount: xpAwarded,\n        xp_type: 'earned',\n        reason,\n        task_id: options?.taskId || null,\n        metadata: {\n          multipliers: multipliers.map((m) => ({ name: m.name, value: m.value })),\n          ...options?.metadata,\n        },\n      })\n      if (logError) console.warn('[Gamification] Failed to log XP award:', logError)\n\n      // ATOMIC UPDATE: Use SQL increment to prevent race conditions\n      // Two simultaneous XP awards will both increment correctly\n      const { data: updated, error } = await supabase\n        .from('user_gamification')\n        .update({\n          total_xp: profile.value.totalXp + xpAwarded,\n          available_xp: profile.value.availableXp + xpAwarded,\n        })\n        .eq('user_id', authStore.user.id)\n        .select('total_xp, available_xp')\n        .single()\n\n      if (error) throw error\n\n      // Use returned values to ensure consistency\n      const newTotalXp = updated.total_xp\n      const newAvailableXp = updated.available_xp\n      const newLevel = levelFromXp(newTotalXp)\n      const leveledUp = newLevel > previousLevel\n\n      // Update level if changed\n      if (newLevel !== profile.value.level) {\n        await supabase\n          .from('user_gamification')\n          .update({ level: newLevel })\n          .eq('user_id', authStore.user.id)\n      }\n\n      // Update local state with actual DB values\n      profile.value.totalXp = newTotalXp\n      profile.value.availableXp = newAvailableXp\n      profile.value.level = newLevel\n\n      // Show notification\n      if (settings.value.showXpNotifications) {\n        showXpToast(xpAwarded, reason, multipliers)\n      }\n\n      // Show level up notification\n      if (leveledUp && settings.value.showAchievementNotifications) {\n        showLevelUpToast(newLevel)\n      }\n\n      // Check achievements\n      await checkAchievements()\n\n      return {\n        xpAwarded,\n        newTotalXp,\n        newAvailableXp,\n        newLevel,\n        leveledUp,\n        previousLevel,\n        multipliers,\n      }\n    } catch (e) {\n      console.error('[Gamification] Failed to award XP:', e)\n      return null\n    }\n  }\n\n  // Mutex to prevent concurrent purchases\n  let purchaseInProgress = false\n\n  // =============================================================================\n  // Streak System\n  // =============================================================================\n\n  /**\n   * Record daily activity and update streak\n   */\n  async function recordDailyActivity(): Promise<StreakUpdateResult | null> {\n    if (!profile.value || !authStore.user?.id) return null\n\n    // Use date strings for comparison to avoid timezone issues\n    // getLocalDateString returns \"YYYY-MM-DD\" in local timezone\n    const todayStr = getLocalDateString(new Date())\n\n    const lastActive = profile.value.lastActivityDate\n    const lastActiveStr = lastActive ? getLocalDateString(lastActive) : null\n\n    // Already recorded today - compare strings, not timestamps\n    if (lastActiveStr === todayStr) {\n      console.log('[Gamification] Already recorded activity for today:', todayStr)\n      return null\n    }\n\n    console.log('[Gamification] Recording activity. Last:', lastActiveStr, 'Today:', todayStr)\n\n    // Calculate yesterday's date string\n    const today = new Date()\n    const yesterday = new Date(today)\n    yesterday.setDate(yesterday.getDate() - 1)\n    const yesterdayStr = getLocalDateString(yesterday)\n    const wasActiveYesterday = lastActiveStr === yesterdayStr\n\n    let newStreak = profile.value.currentStreak\n    let streakBroken = false\n    let freezeUsed = false\n    let streakMilestone: number | null = null\n\n    if (wasActiveYesterday || !lastActiveStr) {\n      // Continue or start streak\n      newStreak = wasActiveYesterday ? newStreak + 1 : 1\n    } else {\n      // Streak broken - check for freeze\n      const daysMissed = lastActive\n        ? Math.floor((today.getTime() - new Date(lastActive).getTime()) / (1000 * 60 * 60 * 24))\n        : 999\n\n      if (daysMissed <= 2 && profile.value.streakFreezes > 0) {\n        // Use freeze\n        freezeUsed = true\n        newStreak = profile.value.currentStreak + 1\n        await supabase\n          .from('user_gamification')\n          .update({ streak_freezes: profile.value.streakFreezes - 1 })\n          .eq('user_id', authStore.user.id)\n        profile.value.streakFreezes--\n      } else {\n        // Streak broken\n        streakBroken = true\n        newStreak = 1\n      }\n    }\n\n    // Check for streak milestones\n    const milestones = [7, 30, 100, 365]\n    for (const milestone of milestones) {\n      if (newStreak === milestone) {\n        streakMilestone = milestone\n        break\n      }\n    }\n\n    // Award streak bonus XP\n    let xpBonusAwarded = 0\n    if (streakMilestone) {\n      const bonusMap: Record<number, number> = {\n        7: XP_VALUES.STREAK_MILESTONE_7,\n        30: XP_VALUES.STREAK_MILESTONE_30,\n        100: XP_VALUES.STREAK_MILESTONE_100,\n        365: XP_VALUES.STREAK_MILESTONE_365,\n      }\n      xpBonusAwarded = bonusMap[streakMilestone] || 0\n      if (xpBonusAwarded > 0) {\n        await awardXp(xpBonusAwarded, 'streak_bonus', { metadata: { milestone: streakMilestone } })\n      }\n    }\n\n    // Update profile\n    const longestStreak = Math.max(profile.value.longestStreak, newStreak)\n    const { error } = await supabase\n      .from('user_gamification')\n      .update({\n        current_streak: newStreak,\n        longest_streak: longestStreak,\n        last_activity_date: todayStr,\n        xp_decay_date: null, // Reset decay timer\n      })\n      .eq('user_id', authStore.user.id)\n\n    if (error) {\n      console.error('[Gamification] Failed to update streak:', error)\n      return null\n    }\n\n    profile.value.currentStreak = newStreak\n    profile.value.longestStreak = longestStreak\n    profile.value.lastActivityDate = today\n\n    return {\n      newStreak,\n      streakBroken,\n      freezeUsed,\n      streakMilestone,\n      xpBonusAwarded,\n    }\n  }\n\n  // =============================================================================\n  // Achievement System\n  // =============================================================================\n\n  /**\n   * Check all achievements and unlock any that are met\n   */\n  async function checkAchievements(): Promise<AchievementUnlockResult[]> {\n    if (!stats.value || !profile.value || !authStore.user?.id) return []\n\n    const unlocked: AchievementUnlockResult[] = []\n\n    for (const achievement of achievements.value) {\n      // Skip already earned\n      const userProgress = userAchievements.value.get(achievement.id)\n      if (userProgress?.earnedAt) continue\n\n      let currentValue = 0\n      let conditionMet = false\n\n      // Get current value based on condition key\n      switch (achievement.conditionKey) {\n        case 'tasks_completed':\n          currentValue = stats.value.tasksCompleted\n          break\n        case 'pomodoros_completed':\n          currentValue = stats.value.pomodorosCompleted\n          break\n        case 'total_focus_minutes':\n          currentValue = stats.value.totalFocusMinutes\n          break\n        case 'tasks_completed_on_time':\n          currentValue = stats.value.tasksCompletedOnTime\n          break\n        case 'tasks_completed_high_priority':\n          currentValue = stats.value.tasksCompletedHighPriority\n          break\n        case 'current_streak':\n          currentValue = profile.value.currentStreak\n          break\n        case 'total_xp':\n          currentValue = profile.value.totalXp\n          break\n        // Special achievements checked elsewhere\n        default:\n          continue\n      }\n\n      // Check condition\n      if (achievement.conditionType === 'count' || achievement.conditionType === 'streak') {\n        conditionMet = currentValue >= achievement.conditionValue\n      }\n\n      // Update progress\n      if (currentValue !== (userProgress?.progress ?? 0)) {\n        await updateAchievementProgress(achievement.id, currentValue)\n      }\n\n      // Unlock if met\n      if (conditionMet) {\n        const result = await unlockAchievement(achievement)\n        if (result) unlocked.push(result)\n      }\n    }\n\n    return unlocked\n  }\n\n  async function updateAchievementProgress(achievementId: string, progress: number) {\n    if (!authStore.user?.id) return\n\n    const existing = userAchievements.value.get(achievementId)\n\n    if (existing) {\n      await supabase\n        .from('user_achievements')\n        .update({ progress })\n        .eq('user_id', authStore.user.id)\n        .eq('achievement_id', achievementId)\n    } else {\n      await supabase.from('user_achievements').insert({\n        user_id: authStore.user.id,\n        achievement_id: achievementId,\n        progress,\n      })\n    }\n\n    userAchievements.value.set(achievementId, {\n      progress,\n      earnedAt: existing?.earnedAt ?? null,\n    })\n  }\n\n  async function unlockAchievement(achievement: Achievement): Promise<AchievementUnlockResult | null> {\n    if (!authStore.user?.id) return null\n\n    const now = new Date()\n\n    const { error } = await supabase\n      .from('user_achievements')\n      .upsert({\n        user_id: authStore.user.id,\n        achievement_id: achievement.id,\n        progress: achievement.conditionValue,\n        earned_at: now.toISOString(),\n      })\n\n    if (error) {\n      console.error('[Gamification] Failed to unlock achievement:', error)\n      return null\n    }\n\n    userAchievements.value.set(achievement.id, {\n      progress: achievement.conditionValue,\n      earnedAt: now,\n    })\n\n    // Award XP for achievement\n    if (achievement.xpReward > 0) {\n      await awardXp(achievement.xpReward, 'achievement', {\n        metadata: { achievementId: achievement.id },\n      })\n    }\n\n    // Show notification\n    if (settings.value.showAchievementNotifications) {\n      showAchievementToast(achievement)\n    }\n\n    return {\n      achievement,\n      xpAwarded: achievement.xpReward,\n      isNewUnlock: true,\n    }\n  }\n\n  /**\n   * Trigger a special achievement (called from external code)\n   */\n  async function triggerSpecialAchievement(conditionKey: string) {\n    const achievement = achievements.value.find(\n      (a) => a.conditionType === 'special' && a.conditionKey === conditionKey\n    )\n\n    if (!achievement) return null\n\n    const userProgress = userAchievements.value.get(achievement.id)\n    if (userProgress?.earnedAt) return null // Already earned\n\n    return await unlockAchievement(achievement)\n  }\n\n  // =============================================================================\n  // Stats Tracking\n  // =============================================================================\n\n  /**\n   * Increment a stat counter\n   */\n  async function incrementStat(\n    statKey: keyof Omit<UserStats, 'userId' | 'viewsUsed' | 'featuresUsed' | 'updatedAt'>,\n    amount = 1\n  ) {\n    if (!stats.value || !authStore.user?.id) return\n\n    const currentValue = stats.value[statKey] as number\n    const newValue = currentValue + amount\n\n    const { error } = await supabase\n      .from('user_stats')\n      .update({ [camelToSnake(statKey)]: newValue })\n      .eq('user_id', authStore.user.id)\n\n    if (error) {\n      console.error('[Gamification] Failed to increment stat:', error)\n      return\n    }\n\n    (stats.value[statKey] as number) = newValue\n\n    // Check achievements after stat update\n    await checkAchievements()\n  }\n\n  /**\n   * Track view/feature usage\n   */\n  async function trackViewUsage(viewName: string) {\n    if (!stats.value || !authStore.user?.id) return\n    if (stats.value.viewsUsed[viewName]) return // Already tracked\n\n    const newViewsUsed = { ...stats.value.viewsUsed, [viewName]: true }\n\n    const { error } = await supabase\n      .from('user_stats')\n      .update({ views_used: newViewsUsed })\n      .eq('user_id', authStore.user.id)\n\n    if (!error) {\n      stats.value.viewsUsed = newViewsUsed\n      // Check exploration achievements\n      await checkAchievements()\n    }\n  }\n\n  async function trackFeatureUsage(featureName: string) {\n    if (!stats.value || !authStore.user?.id) return\n    if (stats.value.featuresUsed[featureName]) return\n\n    const newFeaturesUsed = { ...stats.value.featuresUsed, [featureName]: true }\n\n    const { error } = await supabase\n      .from('user_stats')\n      .update({ features_used: newFeaturesUsed })\n      .eq('user_id', authStore.user.id)\n\n    if (!error) {\n      stats.value.featuresUsed = newFeaturesUsed\n    }\n  }\n\n  // =============================================================================\n  // Shop System\n  // =============================================================================\n\n  /**\n   * Purchase an item from the shop\n   * Protected by mutex to prevent double-purchase race conditions\n   */\n  async function purchaseItem(itemId: string): Promise<PurchaseResult> {\n    if (!profile.value || !authStore.user?.id) {\n      return { success: false, item: {} as ShopItem, xpSpent: 0, newAvailableXp: 0, error: 'Not logged in' }\n    }\n\n    // Prevent concurrent purchases\n    if (purchaseInProgress) {\n      return { success: false, item: {} as ShopItem, xpSpent: 0, newAvailableXp: profile.value.availableXp, error: 'Purchase in progress' }\n    }\n\n    const item = shopItems.value.find((i) => i.id === itemId)\n    if (!item) {\n      return { success: false, item: {} as ShopItem, xpSpent: 0, newAvailableXp: 0, error: 'Item not found' }\n    }\n\n    if (ownedItems.value.has(itemId)) {\n      return { success: false, item, xpSpent: 0, newAvailableXp: profile.value.availableXp, error: 'Already owned' }\n    }\n\n    if (profile.value.availableXp < item.priceXp) {\n      return { success: false, item, xpSpent: 0, newAvailableXp: profile.value.availableXp, error: 'Not enough XP' }\n    }\n\n    if (profile.value.level < item.requiredLevel) {\n      return {\n        success: false,\n        item,\n        xpSpent: 0,\n        newAvailableXp: profile.value.availableXp,\n        error: `Requires level ${item.requiredLevel}`,\n      }\n    }\n\n    purchaseInProgress = true\n    const newAvailableXp = profile.value.availableXp - item.priceXp\n\n    try {\n      // Insert purchase record\n      await supabase.from('user_purchases').insert({\n        user_id: authStore.user.id,\n        item_id: itemId,\n        xp_spent: item.priceXp,\n      })\n\n      // Log XP spent\n      await supabase.from('xp_logs').insert({\n        user_id: authStore.user.id,\n        xp_amount: -item.priceXp,\n        xp_type: 'spent',\n        reason: 'purchase',\n        metadata: { itemId, itemName: item.name },\n      })\n\n      // Update profile\n      const updates: Partial<DbUserGamification> = {\n        available_xp: newAvailableXp,\n      }\n\n      // Add to unlocked themes if it's a theme\n      if (item.category === 'theme') {\n        updates.unlocked_themes = [...profile.value.unlockedThemes, itemId]\n      }\n\n      await supabase.from('user_gamification').update(updates).eq('user_id', authStore.user.id)\n\n      // Update local state\n      profile.value.availableXp = newAvailableXp\n      ownedItems.value.add(itemId)\n      if (item.category === 'theme') {\n        profile.value.unlockedThemes.push(itemId)\n      }\n\n      // Check theme purchase achievement\n      await triggerSpecialAchievement('theme_purchased')\n\n      return { success: true, item, xpSpent: item.priceXp, newAvailableXp }\n    } catch (e) {\n      console.error('[Gamification] Purchase failed:', e)\n      return { success: false, item, xpSpent: 0, newAvailableXp: profile.value?.availableXp ?? 0, error: 'Purchase failed' }\n    } finally {\n      purchaseInProgress = false\n    }\n  }\n\n  /**\n   * Equip a theme\n   */\n  async function equipTheme(themeId: string) {\n    if (!profile.value || !authStore.user?.id) return false\n\n    // Must own the theme (or it's 'default')\n    if (themeId !== 'default' && !ownedItems.value.has(themeId)) {\n      console.warn('[Gamification] Cannot equip unowned theme:', themeId)\n      return false\n    }\n\n    const { error } = await supabase\n      .from('user_gamification')\n      .update({ equipped_theme: themeId })\n      .eq('user_id', authStore.user.id)\n\n    if (error) {\n      console.error('[Gamification] Failed to equip theme:', error)\n      return false\n    }\n\n    profile.value.equippedTheme = themeId\n    applyTheme(themeId)\n    return true\n  }\n\n  /**\n   * Apply theme CSS variables to document\n   */\n  function applyTheme(themeId: string) {\n    const item = shopItems.value.find((i) => i.id === themeId)\n    const root = document.documentElement\n\n    // Remove previous custom theme\n    root.style.removeProperty('--accent-primary')\n    root.style.removeProperty('--accent-glow')\n\n    if (themeId === 'default' || !item?.previewCss) return\n\n    // Apply theme CSS variables\n    for (const [key, value] of Object.entries(item.previewCss)) {\n      root.style.setProperty(key, value)\n    }\n  }\n\n  // =============================================================================\n  // Toast/Notification System\n  // =============================================================================\n\n  function showXpToast(amount: number, reason: string, multipliers: XpMultiplier[]) {\n    const toast: GamificationToast = {\n      id: `xp-${Date.now()}`,\n      type: 'xp',\n      title: `+${amount} XP`,\n      description: formatXpReason(reason),\n      xpAmount: amount,\n      duration: 3000,\n    }\n    toastQueue.value.push(toast)\n  }\n\n  function showLevelUpToast(newLevel: number) {\n    const toast: GamificationToast = {\n      id: `level-${Date.now()}`,\n      type: 'level_up',\n      title: `Level ${newLevel}!`,\n      description: 'Congratulations on leveling up!',\n      icon: 'arrow-up',\n      duration: 5000,\n    }\n    toastQueue.value.push(toast)\n  }\n\n  function showAchievementToast(achievement: Achievement) {\n    const toast: GamificationToast = {\n      id: `achievement-${achievement.id}`,\n      type: 'achievement',\n      title: achievement.name,\n      description: achievement.description,\n      icon: achievement.icon,\n      tier: achievement.tier,\n      xpAmount: achievement.xpReward,\n      duration: 5000,\n    }\n    toastQueue.value.push(toast)\n  }\n\n  function showExposureToast(isShielded: boolean) {\n    const toast: GamificationToast = {\n      id: `exposure-${Date.now()}`,\n      type: 'exposure',\n      title: isShielded ? 'SHIELDED' : 'EXPOSED',\n      description: isShielded\n        ? 'Timer active — +15% XP, corruption reduced'\n        : 'Working unshielded — normal XP rate',\n      icon: isShielded ? 'shield' : 'shield-off',\n      duration: 3000,\n    }\n    toastQueue.value.push(toast)\n  }\n\n  function dismissToast(id: string) {\n    const index = toastQueue.value.findIndex((t) => t.id === id)\n    if (index !== -1) {\n      toastQueue.value.splice(index, 1)\n    }\n  }\n\n  // =============================================================================\n  // Utilities\n  // =============================================================================\n\n  function formatXpReason(reason: string): string {\n    const reasonMap: Record<string, string> = {\n      task_complete: 'Task completed',\n      pomodoro_complete: 'Pomodoro session',\n      streak_bonus: 'Streak milestone',\n      achievement: 'Achievement unlocked',\n    }\n    return reasonMap[reason] || reason\n  }\n\n  function camelToSnake(str: string): string {\n    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n  }\n\n  /**\n   * Get date string in YYYY-MM-DD format using LOCAL timezone\n   * This avoids timezone issues when comparing dates\n   */\n  function getLocalDateString(date: Date): string {\n    const year = date.getFullYear()\n    const month = String(date.getMonth() + 1).padStart(2, '0')\n    const day = String(date.getDate()).padStart(2, '0')\n    return `${year}-${month}-${day}`\n  }\n\n  // =============================================================================\n  // Settings\n  // =============================================================================\n\n  function updateSettings(newSettings: Partial<GamificationSettings>) {\n    settings.value = { ...settings.value, ...newSettings }\n    localStorage.setItem('flowstate-gamification-settings', JSON.stringify(settings.value))\n  }\n\n  function loadSettings() {\n    const saved = localStorage.getItem('flowstate-gamification-settings')\n    if (saved) {\n      try {\n        settings.value = { ...settings.value, ...JSON.parse(saved) }\n      } catch (e) {\n        console.error('[Gamification] Failed to load settings:', e)\n      }\n    }\n  }\n\n  // =============================================================================\n  // Watchers\n  // =============================================================================\n\n  // Initialize when auth changes\n  watch(\n    () => authStore.isAuthenticated,\n    (isAuth) => {\n      if (isAuth) {\n        initialize()\n      } else {\n        // Reset state on logout\n        profile.value = null\n        stats.value = null\n        userAchievements.value = new Map()\n        ownedItems.value = new Set()\n        isInitialized.value = false\n      }\n    },\n    { immediate: true }\n  )\n\n  // Apply equipped theme on init\n  watch(\n    () => profile.value?.equippedTheme,\n    (themeId) => {\n      if (themeId && themeId !== 'default') {\n        // Wait for shop items to load\n        if (shopItems.value.length > 0) {\n          applyTheme(themeId)\n        }\n      }\n    }\n  )\n\n  // Load settings on mount\n  loadSettings()\n\n  // =============================================================================\n  // Return\n  // =============================================================================\n\n  return {\n    // State\n    profile,\n    stats,\n    achievements,\n    userAchievements,\n    shopItems,\n    ownedItems,\n    recentXpLogs,\n    toastQueue,\n    isLoading,\n    isInitialized,\n    settings,\n\n    // Computed\n    isEnabled,\n    totalXp,\n    availableXp,\n    currentLevel,\n    levelInfo,\n    streakInfo,\n    equippedTheme,\n    achievementsWithProgress,\n    earnedAchievements,\n    unlockedAchievementsCount,\n    shopItemsWithOwnership,\n\n    // Actions\n    initialize,\n    awardXp,\n    recordDailyActivity,\n    checkAchievements,\n    triggerSpecialAchievement,\n    incrementStat,\n    trackViewUsage,\n    trackFeatureUsage,\n    purchaseItem,\n    equipTheme,\n    applyTheme,\n    dismissToast,\n    showExposureToast,\n    updateSettings,\n\n    // Utilities\n    getLevelInfo,\n    levelFromXp,\n    xpForLevel,\n  }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/notifications.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":367,"column":9,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":367,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Store\n * Centralized management of task reminders and notifications\n */\n\nimport { defineStore } from 'pinia'\nimport { ref, computed, watch } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport { errorHandler, ErrorSeverity, ErrorCategory } from '@/utils/errorHandler'\nimport type {\n  ScheduledNotification,\n  NotificationPreferences,\n  RecurringTaskInstance as _RecurringTaskInstance\n} from '@/types/recurrence'\nimport { useTaskStore } from './tasks'\nimport { useAuthStore } from './auth'\n\nexport const useNotificationStore = defineStore('notifications', () => {\n  // Database composable\n  const supabaseDb = useSupabaseDatabase()\n  const taskStore = useTaskStore()\n  const authStore = useAuthStore()\n\n  // State\n  // SAFETY: Named _rawNotifications to discourage direct access - use activeNotifications (exported as 'scheduledNotifications') instead\n  const _rawNotifications = ref<ScheduledNotification[]>([])\n  const isPermissionGranted = ref(false)\n  const isSchedulingActive = ref(false)\n  const schedulingInterval = ref<NodeJS.Timeout | null>(null)\n  const defaultPreferences = ref<NotificationPreferences>({\n    taskId: 'default',\n    isEnabled: true,\n    reminderTimes: [15, 60, 1440], // 15min, 1hr, 1day before\n    soundEnabled: true,\n    vibrationEnabled: true,\n    notificationChannels: {\n      browser: true,\n      mobile: true\n    },\n    doNotDisturb: {\n      startHour: 22,\n      endHour: 8,\n      enabled: true\n    },\n    snoozeDuration: 10 // 10 minutes\n  })\n\n  // Computed\n  const activeNotifications = computed(() =>\n    Array.isArray(_rawNotifications.value)\n      ? _rawNotifications.value.filter(n => !n.isShown && !n.isDismissed)\n      : []\n  )\n\n  const pendingNotifications = computed(() =>\n    Array.isArray(_rawNotifications.value)\n      ? _rawNotifications.value.filter(n => !n.isShown && n.scheduledTime <= new Date())\n      : []\n  )\n\n  const snoozedNotifications = computed(() =>\n    Array.isArray(_rawNotifications.value)\n      ? _rawNotifications.value.filter(n => n.snoozedUntil && n.snoozedUntil > new Date())\n      : []\n  )\n\n  /**\n   * Initialize notification system\n   */\n  const initializeNotifications = async () => {\n    await loadScheduledNotifications()\n    await checkNotificationPermission()\n    startSchedulingService()\n  }\n\n  /**\n   * Load scheduled notifications from database\n   */\n  const loadScheduledNotifications = async () => {\n    try {\n      // Check if user is authenticated before loading\n      if (!authStore.user?.id) {\n        errorHandler.report({\n          severity: ErrorSeverity.INFO,\n          category: ErrorCategory.DATABASE,\n          message: 'User not authenticated, skipping notification load',\n          context: { operation: 'loadScheduledNotifications' },\n          showNotification: false\n        })\n        return\n      }\n\n      const saved = await supabaseDb.fetchNotifications()\n      if (saved && saved.length > 0) {\n        _rawNotifications.value = saved\n        console.log(`📬 Loaded ${saved.length} notifications from Supabase`)\n      }\n    } catch (error) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.DATABASE,\n        message: 'Error loading notifications',\n        error: error as Error,\n        context: { operation: 'loadScheduledNotifications' },\n        showNotification: false // Don't fail the entire initialization\n      })\n    }\n  }\n\n  /**\n   * Check current notification permission status\n   * Note: Does NOT request permission - must be done in user event handler\n   */\n  const checkNotificationPermission = async (): Promise<boolean> => {\n    if (!('Notification' in window)) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.COMPONENT,\n        message: 'This browser does not support notifications',\n        context: { operation: 'checkNotificationPermission' },\n        showNotification: false\n      })\n      isPermissionGranted.value = false\n      return false\n    }\n\n    if (Notification.permission === 'granted') {\n      isPermissionGranted.value = true\n      return true\n    }\n\n    isPermissionGranted.value = (Notification.permission as NotificationPermission) === 'granted'\n    return isPermissionGranted.value\n  }\n\n  /**\n   * Request notification permission (must be called from user event handler)\n   */\n  const requestNotificationPermission = async (): Promise<boolean> => {\n    // BUG-1303: Skip browser Notification.requestPermission() in Tauri — WebKitGTK\n    // can hang indefinitely on this call. Tauri uses its own notification plugin.\n    const isTauriRuntime = typeof window !== 'undefined' && '__TAURI__' in window\n    if (isTauriRuntime) {\n      isPermissionGranted.value = false\n      return false\n    }\n\n    if (!('Notification' in window)) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.COMPONENT,\n        message: 'This browser does not support notifications',\n        context: { operation: 'requestNotificationPermission' },\n        showNotification: false\n      })\n      return false\n    }\n\n    if (Notification.permission === 'granted') {\n      isPermissionGranted.value = true\n      return true\n    }\n\n    if (Notification.permission !== 'denied') {\n      try {\n        const permission = await Notification.requestPermission()\n        isPermissionGranted.value = permission === 'granted'\n        return isPermissionGranted.value\n      } catch (error) {\n        errorHandler.report({\n          severity: ErrorSeverity.WARNING,\n          category: ErrorCategory.COMPONENT,\n          message: 'Notification permission request failed',\n          error: error as Error,\n          context: { operation: 'requestNotificationPermission' },\n          showNotification: false\n        })\n        isPermissionGranted.value = false\n        return false\n      }\n    }\n\n    isPermissionGranted.value = false\n    return false\n  }\n\n  /**\n   * Start the background scheduling service\n   */\n  const startSchedulingService = () => {\n    if (isSchedulingActive.value) return\n\n    isSchedulingActive.value = true\n    schedulingInterval.value = setInterval(() => {\n      checkAndShowNotifications()\n      checkAndScheduleTaskNotifications()\n    }, 60000) // Check every minute\n  }\n\n  /**\n   * Stop the scheduling service\n   */\n  const stopSchedulingService = () => {\n    if (schedulingInterval.value) {\n      clearInterval(schedulingInterval.value)\n      schedulingInterval.value = null\n    }\n    isSchedulingActive.value = false\n  }\n\n  /**\n   * Check for pending notifications and show them\n   */\n  const checkAndShowNotifications = async () => {\n    const now = new Date()\n\n    // CRITICAL FIX: Ensure _rawNotifications.value is an array\n    if (!Array.isArray(_rawNotifications.value)) {\n      errorHandler.report({\n        severity: ErrorSeverity.INFO,\n        category: ErrorCategory.STATE,\n        message: '_rawNotifications.value is not an array, resetting to empty array',\n        context: { operation: 'checkAndShowNotifications', type: typeof _rawNotifications.value },\n        showNotification: false\n      })\n      _rawNotifications.value = []\n    }\n\n    const readyNotifications = _rawNotifications.value.filter(n =>\n      !n.isShown &&\n      !n.isDismissed &&\n      !n.snoozedUntil &&\n      n.scheduledTime <= now\n    )\n\n    for (const notification of readyNotifications) {\n      if (isInDoNotDisturbHours(now)) {\n        continue // Skip during DND hours\n      }\n\n      await showNotification(notification)\n      notification.isShown = true\n    }\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Check if current time is in Do Not Disturb hours\n   */\n  const isInDoNotDisturbHours = (date: Date): boolean => {\n    const dnd = defaultPreferences.value.doNotDisturb\n    if (!dnd?.enabled) return false\n\n    const currentHour = date.getHours()\n\n    if (dnd.startHour > dnd.endHour) {\n      // Overnight DND (e.g., 22:00 to 08:00)\n      return currentHour >= dnd.startHour || currentHour < dnd.endHour\n    } else {\n      // Same day DND (e.g., 01:00 to 06:00)\n      return currentHour >= dnd.startHour && currentHour < dnd.endHour\n    }\n  }\n\n  /**\n   * Show a browser notification\n   */\n  const showNotification = async (notification: ScheduledNotification) => {\n    if (!isPermissionGranted.value) {\n      await checkNotificationPermission()\n    }\n\n    if (!isPermissionGranted.value) return\n\n    try {\n      const browserNotification = new Notification(notification.title, {\n        body: notification.body,\n        icon: '/favicon.ico',\n        badge: '/favicon.ico',\n        tag: notification.id,\n        requireInteraction: true\n      } as NotificationOptions)\n\n      browserNotification.onclick = () => {\n        browserNotification.close()\n        // Focus the window and navigate to the task\n        window.focus()\n        // NOTE: Task navigation requires integration with view routing system\n      }\n\n      browserNotification.onclose = () => {\n        notification.isDismissed = true\n      }\n\n    } catch (error) {\n      errorHandler.report({\n        severity: ErrorSeverity.ERROR,\n        category: ErrorCategory.COMPONENT,\n        message: 'Error showing browser notification',\n        error: error as Error,\n        context: { operation: 'showNotification', notificationId: notification.id },\n        showNotification: false // Don't show a notification about failed notification\n      })\n    }\n  }\n\n  /**\n   * Schedule notifications for a task\n   */\n  const scheduleTaskNotifications = async (\n    taskId: string,\n    taskTitle: string,\n    dueDate: string,\n    dueTime?: string,\n    preferences?: NotificationPreferences\n  ) => {\n    const prefs = preferences || defaultPreferences.value\n    if (!prefs.isEnabled) return\n\n    // Remove existing notifications for this task\n    await removeTaskNotifications(taskId)\n\n    const dueDateTime = new Date(`${dueDate} ${dueTime || '09:00'}`)\n    const reminderTimes = prefs.reminderTimes || []\n\n    for (const minutesBefore of reminderTimes) {\n      const notificationTime = new Date(dueDateTime.getTime() - minutesBefore * 60000)\n\n      // Only schedule if it's in the future\n      if (notificationTime > new Date()) {\n        const notification: ScheduledNotification = {\n          id: `${taskId}-reminder-${minutesBefore}`,\n          taskId,\n          title: `Task Reminder: ${taskTitle}`,\n          body: getReminderMessage(minutesBefore, dueDate, dueTime),\n          scheduledTime: notificationTime,\n          isShown: false,\n          isDismissed: false,\n          createdAt: new Date()\n        }\n\n        _rawNotifications.value.push(notification)\n      }\n    }\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Schedule notifications for recurring task instances\n   */\n  const scheduleRecurringTaskNotifications = async (taskId: string) => {\n    // CRITICAL FIX: Ensure taskStore.tasks is an array before calling .find()\n    const task = Array.isArray(taskStore.tasks)\n      ? taskStore.tasks.find(t => t.id === taskId)\n      : undefined\n    if (!task?.recurrence?.isEnabled || !task.notificationPreferences?.enabled) return\n\n    const prefs = task.notificationPreferences\n    const instances = task.recurrence.generatedInstances || []\n\n    for (const instance of instances) {\n      if ((instance as { isSkipped?: boolean }).isSkipped) continue\n\n      await scheduleTaskNotifications(\n        instance.id!,\n        task.title,\n        instance.scheduledDate,\n        instance.scheduledTime,\n        prefs as unknown as NotificationPreferences\n      )\n    }\n  }\n\n  /**\n   * Get reminder message based on time before task\n   */\n  const getReminderMessage = (minutesBefore: number, _dueDate: string, _dueTime?: string): string => {\n    if (minutesBefore < 60) {\n      return `Task due in ${minutesBefore} minute${minutesBefore > 1 ? 's' : ''}`\n    } else if (minutesBefore < 1440) {\n      const hours = Math.floor(minutesBefore / 60)\n      return `Task due in ${hours} hour${hours > 1 ? 's' : ''}`\n    } else {\n      const days = Math.floor(minutesBefore / 1440)\n      return `Task due in ${days} day${days > 1 ? 's' : ''}`\n    }\n  }\n\n  /**\n   * Remove all notifications for a task\n   */\n  const removeTaskNotifications = async (taskId: string) => {\n    if (Array.isArray(_rawNotifications.value)) {\n      const toDelete = _rawNotifications.value.filter(n => n.taskId === taskId)\n      _rawNotifications.value = _rawNotifications.value.filter(n => n.taskId !== taskId)\n\n      // Delete from Supabase\n      for (const n of toDelete) {\n        await supabaseDb.deleteNotification(n.id)\n      }\n    } else {\n      _rawNotifications.value = []\n    }\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Snooze a notification\n   */\n  const snoozeNotification = async (notificationId: string) => {\n    const notification = _rawNotifications.value.find(n => n.id === notificationId)\n    if (!notification) return\n\n    const snoozeDuration = defaultPreferences.value.snoozeDuration || 10\n    notification.snoozedUntil = new Date(Date.now() + snoozeDuration * 60000)\n    notification.isShown = false\n    notification.isDismissed = false\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Dismiss a notification\n   */\n  const dismissNotification = async (notificationId: string) => {\n    const notification = _rawNotifications.value.find(n => n.id === notificationId)\n    if (!notification) return\n\n    notification.isDismissed = true\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Check and schedule notifications for all tasks\n   */\n  const checkAndScheduleTaskNotifications = async () => {\n    // CRITICAL FIX: Ensure taskStore.tasks is an array before calling .filter()\n    const tasks = Array.isArray(taskStore.tasks)\n      ? taskStore.tasks.filter(t =>\n        t.dueDate &&\n        t.notificationPreferences?.enabled &&\n        new Date(t.dueDate) > new Date()\n      )\n      : []\n\n    for (const task of tasks) {\n      // Check if notifications are already scheduled for this task\n      const hasNotifications = _rawNotifications.value.some(n => n.taskId === task.id)\n\n      if (!hasNotifications) {\n        await scheduleTaskNotifications(\n          task.id,\n          task.title,\n          task.dueDate,\n          task.dueTime,\n          task.notificationPreferences as unknown as NotificationPreferences\n        )\n      }\n\n      // Schedule recurring notifications if applicable\n      if (task.recurrence?.isEnabled) {\n        await scheduleRecurringTaskNotifications(task.id)\n      }\n    }\n  }\n\n  /**\n   * Save scheduled notifications to database\n   */\n  const saveScheduledNotifications = async () => {\n    try {\n      // Check if user is authenticated before saving\n      if (!authStore.user?.id) return\n      await supabaseDb.saveNotifications(_rawNotifications.value)\n    } catch (error) {\n      errorHandler.report({\n        severity: ErrorSeverity.WARNING,\n        category: ErrorCategory.DATABASE,\n        message: 'Error saving notifications to database',\n        error: error as Error,\n        context: { operation: 'saveScheduledNotifications', count: _rawNotifications.value?.length },\n        showNotification: false\n      })\n    }\n  }\n\n  // BUG-025 FIX: Auto-save notifications when they change\n  // This eliminates the need for manual saveScheduledNotifications() calls\n  let notificationSaveTimer: ReturnType<typeof setTimeout> | null = null\n  watch(activeNotifications, () => {\n    if (notificationSaveTimer) clearTimeout(notificationSaveTimer)\n    notificationSaveTimer = setTimeout(async () => {\n      await saveScheduledNotifications()\n      console.log('📬 [SUPABASE] Notifications auto-saved (1s debounce)')\n    }, 1000) // Refined: 1s debounce\n  }, { deep: true })\n\n  /**\n   * Clean up old notifications (older than 7 days)\n   */\n  const cleanupOldNotifications = async () => {\n    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)\n\n    if (Array.isArray(_rawNotifications.value)) {\n      _rawNotifications.value = _rawNotifications.value.filter(n =>\n        n.createdAt > sevenDaysAgo || !n.isDismissed\n      )\n    } else {\n      _rawNotifications.value = []\n    }\n\n    await saveScheduledNotifications()\n  }\n\n  /**\n   * Update default notification preferences\n   */\n  const updateDefaultPreferences = async (preferences: Partial<NotificationPreferences>) => {\n    defaultPreferences.value = { ...defaultPreferences.value, ...preferences }\n    // NOTE: Persistence to be implemented when notification preferences are finalized\n  }\n\n  /**\n   * Get notification statistics\n   */\n  const getNotificationStats = () => {\n    const total = Array.isArray(_rawNotifications.value) ? _rawNotifications.value.length : 0\n    const shown = Array.isArray(_rawNotifications.value) ? _rawNotifications.value.filter(n => n.isShown).length : 0\n    const dismissed = Array.isArray(_rawNotifications.value) ? _rawNotifications.value.filter(n => n.isDismissed).length : 0\n    const pending = pendingNotifications.value.length\n\n    return {\n      total,\n      shown,\n      dismissed,\n      pending,\n      permissionGranted: isPermissionGranted.value,\n      schedulingActive: isSchedulingActive.value\n    }\n  }\n\n  return {\n    // State\n    // SAFETY: Export activeNotifications as 'scheduledNotifications' for safe default (excludes dismissed/shown)\n    scheduledNotifications: activeNotifications,\n    _rawNotifications, // For internal operations only\n    isPermissionGranted,\n    isSchedulingActive,\n    defaultPreferences,\n\n    // Computed\n    activeNotifications, // Keep for explicit usage\n    pendingNotifications,\n    snoozedNotifications,\n\n    // Methods\n    initializeNotifications,\n    checkNotificationPermission,\n    requestNotificationPermission,\n    scheduleTaskNotifications,\n    scheduleRecurringTaskNotifications,\n    removeTaskNotifications,\n    snoozeNotification,\n    dismissNotification,\n    updateDefaultPreferences,\n    getNotificationStats,\n    cleanupOldNotifications,\n    startSchedulingService,\n    stopSchedulingService\n  }\n})","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/projects.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":216,"column":53,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":216,"endColumn":70},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":315,"column":31,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":315,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia'\nimport { ref, computed, watch, nextTick } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport type { Project } from '@/types/tasks'\nimport { UNCATEGORIZED_PROJECT_ID } from './tasks/taskOperations'\n\nexport const useProjectStore = defineStore('projects', () => {\n\n    // State\n    // SAFETY: Named _rawProjects to discourage direct access - use projects (filtered) instead\n    const _rawProjects = ref<Project[]>([])\n    const activeProjectId = ref<string | null>(null)\n    const isLoading = ref(false)\n\n    // Manual operation flag to prevent watch system conflicts\n    const manualOperationInProgress = ref(false)\n\n    // SAFETY: Filtered projects for display\n    // - Filters out corrupted projects (missing name, invalid data)\n    // - Future: could filter out _soft_deleted projects if that feature is added\n    const projects = computed(() => _rawProjects.value.filter(p => {\n        // Must have valid id\n        if (!p.id) return false\n        // Must have valid name (not null, undefined, or empty string)\n        if (!p.name || typeof p.name !== 'string' || p.name.trim() === '') {\n            console.warn(`[PROJECT-FILTER] Hiding project with invalid name:`, p.id)\n            return false\n        }\n        return true\n    }))\n\n    // Root projects - projects without parentId (uses filtered projects to exclude corrupted)\n    const rootProjects = computed(() => {\n        return projects.value.filter(p => !p.parentId || p.parentId === 'undefined' || p.parentId === undefined)\n    })\n\n    // Optimization: fast lookup map for projects\n    // Replaces O(N) array find with O(1) map lookup\n    // This significantly improves performance when rendering lists of tasks\n    // that need to look up project details (e.g. UnifiedInboxPanel)\n    // SAFETY: Use _rawProjects for lookup since we might need to find any project\n    const projectMap = computed(() => {\n        const map = new Map<string, Project>()\n        for (const p of _rawProjects.value) {\n            map.set(p.id, p)\n        }\n        return map\n    })\n\n    // -- Supabase Integration --\n    const { fetchProjects, saveProjects, saveProject, deleteProject: deleteProjectRemote } = useSupabaseDatabase()\n\n    // Actions\n    const saveProjectsToStorage = async (projectsToSave: Project[], context: string = 'unknown'): Promise<void> => {\n        if (typeof window !== 'undefined' && (window as unknown as { __STORYBOOK__?: boolean }).__STORYBOOK__) return\n\n        // TASK-142 FIX: ALWAYS try Supabase - if reads work, writes should too\n        // The auth check was causing data loss: loads came from Supabase but saves were blocked\n        try {\n            await saveProjects(projectsToSave)\n            // console.debug(`✅ [SUPABASE] Saved ${projectsToSave.length} projects (${context})`)\n        } catch (e) {\n            console.error(`❌ [SUPABASE] Project save failed (${context}):`, e)\n        }\n    }\n\n    const loadProjectsFromDatabase = async () => {\n        isLoading.value = true\n        try {\n            // Guest mode: skip Supabase, start with empty projects\n            const { useAuthStore } = await import('@/stores/auth')\n            const authStore = useAuthStore()\n            if (!authStore.isAuthenticated) {\n                console.log('👤 [GUEST-MODE] Skipping Supabase fetch - projects start empty')\n                _rawProjects.value = []\n                return\n            }\n\n            const loadedProjects = await fetchProjects()\n            _rawProjects.value = loadedProjects\n            console.log(`✅ [SUPABASE] Loaded ${loadedProjects.length} projects`)\n        } catch (error) {\n            console.error('❌ [SUPABASE] Projects load failed:', error)\n        } finally {\n            isLoading.value = false\n        }\n    }\n\n    const createProject = async (projectData: Partial<Project>) => {\n        manualOperationInProgress.value = true\n        try {\n            const newProject: Project = {\n                id: crypto.randomUUID(), // Use standard UUID\n                name: projectData.name || 'New Project',\n                color: projectData.color || '#4ECDC4',\n                colorType: projectData.colorType || 'hex',\n                emoji: projectData.emoji,\n                viewType: projectData.viewType || 'status',\n                parentId: projectData.parentId || null,\n                createdAt: new Date(),\n                updatedAt: new Date(),\n                ...projectData\n            } as Project\n            _rawProjects.value.push(newProject)\n            await saveProject(newProject)\n            return newProject\n        } finally {\n            manualOperationInProgress.value = false\n        }\n    }\n\n    const updateProject = async (projectId: string, updates: Partial<Project>) => {\n        const projectIndex = _rawProjects.value.findIndex(p => p.id === projectId)\n        if (projectIndex !== -1) {\n            manualOperationInProgress.value = true\n            try {\n                _rawProjects.value[projectIndex] = {\n                    ..._rawProjects.value[projectIndex],\n                    ...updates,\n                    updatedAt: new Date()\n                }\n                await saveProject(_rawProjects.value[projectIndex])\n            } finally {\n                manualOperationInProgress.value = false\n            }\n        }\n    }\n\n    const deleteProject = async (projectId: string) => {\n        const projectIndex = _rawProjects.value.findIndex(p => p.id === projectId)\n        if (projectIndex !== -1) {\n            manualOperationInProgress.value = true\n            try {\n                const projectToDelete = _rawProjects.value[projectIndex]\n                const parentId = projectToDelete.parentId\n\n                const { useTaskStore } = await import('./tasks')\n                // Define minimal interface to avoid circular dependency issues\n                type TaskStoreLoophole = {\n                    _rawTasks: { id: string; projectId: string }[];\n                    updateTask: (id: string, updates: { projectId: null; isUncategorized: boolean }) => Promise<void>;\n                }\n                const taskStore = useTaskStore() as unknown as TaskStoreLoophole\n                // SAFETY: Use _rawTasks to include soft-deleted tasks in project reassignment\n                for (const task of taskStore._rawTasks) {\n                    if (task.projectId === projectId) {\n                        await taskStore.updateTask(task.id, { // BUG-1051: AWAIT to ensure persistence\n                            projectId: null, // TASK-1183: Must be null (valid UUID) not 'uncategorized' string\n                            isUncategorized: true\n                        })\n                    }\n                }\n\n                // SAFETY: Use _rawProjects for mutation\n                _rawProjects.value.forEach(project => {\n                    if (project.parentId === projectId) {\n                        project.parentId = parentId\n                    }\n                })\n\n                _rawProjects.value.splice(projectIndex, 1)\n\n                // Supabase Soft Delete\n                await deleteProjectRemote(projectId)\n\n            } catch (e) {\n                console.error('Failed to delete project:', e)\n            } finally {\n                manualOperationInProgress.value = false\n            }\n        }\n    }\n\n    /**\n     * Bulk delete multiple projects at once\n     */\n    const deleteProjects = async (projectIds: string[]) => {\n        if (projectIds.length === 0) return\n\n        manualOperationInProgress.value = true\n        try {\n            const { useTaskStore } = await import('./tasks')\n            type TaskStoreLoophole = {\n                _rawTasks: { id: string; projectId: string }[];\n                updateTask: (id: string, updates: { projectId: null; isUncategorized: boolean }) => Promise<void>;\n            }\n            const taskStore = useTaskStore() as unknown as TaskStoreLoophole\n            const projectIdSet = new Set(projectIds)\n\n            // Build parent mapping for re-parenting children\n            // SAFETY: Use _rawProjects for lookup\n            const parentMap = new Map<string, string | null>()\n            projectIds.forEach(id => {\n                const project = _rawProjects.value.find(p => p.id === id)\n                if (project) {\n                    parentMap.set(id, project.parentId || null)\n                }\n            })\n\n            // Move tasks from all deleted projects to uncategorized\n            // SAFETY: Use _rawTasks to include soft-deleted tasks in project reassignment\n            for (const task of taskStore._rawTasks) {\n                if (projectIdSet.has(task.projectId)) {\n                    await taskStore.updateTask(task.id, { // BUG-1051: AWAIT to ensure persistence\n                        projectId: null, // TASK-1183: Must be null (valid UUID) not 'uncategorized' string\n                        isUncategorized: true\n                    })\n                }\n            }\n\n            // Re-parent children of deleted projects\n            // SAFETY: Use _rawProjects for mutation\n            _rawProjects.value.forEach(project => {\n                if (projectIdSet.has(project.parentId || '')) {\n                    // Find the nearest ancestor that's not being deleted\n                    let newParentId = parentMap.get(project.parentId!) || null\n                    while (newParentId && projectIdSet.has(newParentId)) {\n                        newParentId = parentMap.get(newParentId) || null\n                    }\n                    project.parentId = newParentId\n                }\n            })\n\n            // Remove all deleted projects\n            _rawProjects.value = _rawProjects.value.filter(p => !projectIdSet.has(p.id))\n\n            // Supabase Bulk Delete\n            for (const id of projectIds) {\n                await deleteProjectRemote(id)\n            }\n\n        } finally {\n            manualOperationInProgress.value = false\n        }\n    }\n\n    const setProjectColor = async (projectId: string, color: string, colorType: 'hex' | 'emoji', emoji?: string) => {\n        // SAFETY: Use _rawProjects for mutation\n        const project = _rawProjects.value.find(p => p.id === projectId)\n        if (project) {\n            manualOperationInProgress.value = true\n            try {\n                project.color = color\n                project.colorType = colorType\n                project.emoji = colorType === 'emoji' ? emoji : undefined\n                await saveProjectsToStorage(_rawProjects.value, `setProjectColor-${projectId}`)\n            } finally {\n                manualOperationInProgress.value = false\n            }\n        }\n    }\n\n    const setProjectViewType = async (projectId: string, viewType: Project['viewType']) => {\n        // SAFETY: Use _rawProjects for mutation\n        const project = _rawProjects.value.find(p => p.id === projectId)\n        if (project) {\n            project.viewType = viewType\n            await saveProjectsToStorage(_rawProjects.value, `setProjectViewType-${projectId}`)\n        }\n    }\n\n    // moveTaskToProject MOVED to taskOperations.ts to break circular dependency\n    // (tasks -> projects -> tasks)\n\n    const getProjectById = (projectId: string | null | undefined): Project | undefined => {\n        if (!projectId) return undefined\n        // Optimized O(1) lookup\n        return projectMap.value.get(projectId)\n    }\n\n    const getProjectDisplayName = (projectId: string | null | undefined): string => {\n        if (!projectId || projectId === '1' || projectId === UNCATEGORIZED_PROJECT_ID) return 'Uncategorized'\n        const project = getProjectById(projectId)\n        return project?.name || 'Uncategorized'\n    }\n\n    const getProjectEmoji = (projectId: string | null | undefined): string | undefined => {\n        if (!projectId) return undefined\n        const project = getProjectById(projectId)\n        return project?.emoji || undefined\n    }\n\n    const getProjectVisual = (projectId: string | null | undefined) => {\n        if (!projectId) return { type: 'css-circle', content: '', color: '#6B7280' }\n        const project = getProjectById(projectId)\n        if (!project) return { type: 'css-circle', content: '', color: '#6B7280' }\n        if (project.emoji) return { type: 'emoji', content: project.emoji }\n        if (project.colorType === 'hex' && typeof project.color === 'string') {\n            return { type: 'css-circle', content: '', color: project.color }\n        }\n        return { type: 'css-circle', content: '', color: '#6B7280' }\n    }\n\n    const isDescendantOf = (projectId: string, potentialAncestorId: string): boolean => {\n        let current = getProjectById(projectId)\n        const visited = new Set<string>()\n\n        while (current?.parentId) {\n            if (visited.has(current.id)) return false // Cycle detected\n            visited.add(current.id)\n\n            if (current.parentId === potentialAncestorId) return true\n            current = getProjectById(current.parentId)\n        }\n        return false\n    }\n\n    const getChildProjectIds = (projectId: string): string[] => {\n        const ids = [projectId]\n        const visited = new Set<string>([projectId])\n        const queue = [projectId]\n\n        // Use iterative BFS instead of recursion to prevent stack overflow\n        while (queue.length > 0) {\n            const currentId = queue.shift()!\n            const childProjects = projects.value.filter(p => p.parentId === currentId)\n\n            for (const child of childProjects) {\n                if (!visited.has(child.id)) {\n                    visited.add(child.id)\n                    ids.push(child.id)\n                    queue.push(child.id)\n                }\n            }\n        }\n        return ids\n    }\n\n    const getChildProjects = (parentId: string): Project[] => {\n        return projects.value.filter(p => p.parentId === parentId)\n    }\n\n    const getProjectHierarchy = (projectId: string): Project[] => {\n        const project = getProjectById(projectId)\n        if (!project) return []\n        const hierarchy = [project]\n        let currentId = project.parentId\n        while (currentId) {\n            const parent = getProjectById(currentId)\n            if (parent) {\n                hierarchy.unshift(parent)\n                currentId = parent.parentId\n            } else break\n        }\n        return hierarchy\n    }\n\n    const setActiveProject = (projectId: string | null) => {\n        activeProjectId.value = projectId\n    }\n\n    // Flag to prevent auto-save after sync updates (breaks circular loop)\n    let syncUpdateInProgress = false\n\n    const updateProjectFromSync = (projectId: string, payload: unknown) => {\n        // SAFETY: Validate incoming data to prevent corrupted projects\n        if (!payload || typeof payload !== 'object') {\n            console.warn(`[PROJECT-SYNC] Ignoring invalid data for project ${projectId}:`, payload)\n            return\n        }\n\n        const data = payload as Record<string, unknown>\n\n        // CRITICAL: Ensure name is present and valid\n        if (!data.name || typeof data.name !== 'string' || data.name.trim() === '') {\n            console.warn(`[PROJECT-SYNC] Ignoring project update with invalid name for ${projectId}:`, data.name)\n            return\n        }\n\n        // Set flag to prevent watcher from triggering auto-save\n        syncUpdateInProgress = true\n\n        try {\n            const index = _rawProjects.value.findIndex(p => p.id === projectId)\n            const normalized = {\n                id: projectId,\n                name: data.name,\n                color: (typeof data.color === 'string' ? data.color : '#4ECDC4'),\n                colorType: (data.colorType === 'emoji' ? 'emoji' : 'hex') as 'hex' | 'emoji',\n                emoji: (typeof data.emoji === 'string' ? data.emoji : undefined),\n                viewType: (['list', 'board', 'calendar', 'timeline'].includes(data.viewType as string) ? data.viewType : 'status') as Project['viewType'],\n                parentId: (typeof data.parentId === 'string' ? data.parentId : null),\n                createdAt: new Date((typeof data.createdAt === 'string' || typeof data.createdAt === 'number') ? data.createdAt : Date.now()),\n                updatedAt: new Date((typeof data.updatedAt === 'string' || typeof data.updatedAt === 'number') ? data.updatedAt : Date.now())\n            }\n\n            if (index !== -1) {\n                // Merge with existing data to preserve fields not in sync payload\n                _rawProjects.value[index] = {\n                    ..._rawProjects.value[index],\n                    ...normalized\n                }\n            } else {\n                _rawProjects.value.push(normalized)\n            }\n        } finally {\n            // Reset flag after Vue's next tick to ensure watcher sees it\n            nextTick(() => {\n                syncUpdateInProgress = false\n            })\n        }\n    }\n\n    const removeProjectFromSync = (projectId: string) => {\n        // SAFETY: Use _rawProjects for sync mutations\n        const index = _rawProjects.value.findIndex(p => p.id === projectId)\n        if (index !== -1) {\n            _rawProjects.value.splice(index, 1)\n        }\n    }\n\n    const initializeFromDatabase = async () => {\n        await loadProjectsFromDatabase()\n        return projects.value.length > 0\n    }\n\n    /**\n     * Removes corrupted projects (missing name, invalid data) from local state\n     * Call this if you see ghost/empty projects in the sidebar\n     */\n    const cleanupCorruptedProjects = () => {\n        const before = _rawProjects.value.length\n        _rawProjects.value = _rawProjects.value.filter(p => {\n            if (!p.id) {\n                console.log(`[PROJECT-CLEANUP] Removing project with no id`)\n                return false\n            }\n            if (!p.name || typeof p.name !== 'string' || p.name.trim() === '') {\n                console.log(`[PROJECT-CLEANUP] Removing project with invalid name:`, p.id)\n                return false\n            }\n            return true\n        })\n        const removed = before - _rawProjects.value.length\n        console.log(`[PROJECT-CLEANUP] Removed ${removed} corrupted projects`)\n        return removed\n    }\n\n    // Watchers\n    let saveTimeout: ReturnType<typeof setTimeout> | null = null\n    watch(projects, (newProjects) => {\n        // CRITICAL: Prevent circular sync loop\n        // - manualOperationInProgress: Direct CRUD operations (already saving)\n        // - isLoading: Loading from database (don't save during load)\n        // - syncUpdateInProgress: Realtime update just happened (don't echo back)\n        if (manualOperationInProgress.value || isLoading.value || syncUpdateInProgress) {\n            return\n        }\n        if (saveTimeout) clearTimeout(saveTimeout)\n        saveTimeout = setTimeout(() => {\n            saveProjectsToStorage([...newProjects], 'auto-save')\n        }, 1000)\n    }, { deep: true })\n\n    return {\n        // SAFETY: Export filtered projects as 'projects' - this is the safe default for components\n        // Use _rawProjects only for internal operations (load, save, sync, mutations)\n        projects,\n        _rawProjects,\n        activeProjectId,\n        isLoading,\n        rootProjects,\n        loadProjectsFromDatabase,\n        createProject,\n        updateProject,\n        deleteProject,\n        deleteProjects,\n        setProjectColor,\n        getProjectById,\n        getProjectDisplayName,\n        getProjectEmoji,\n        getProjectVisual,\n        isDescendantOf,\n        getChildProjectIds,\n        getChildProjects,\n        getProjectHierarchy,\n        setActiveProject,\n        saveProjectsToStorage,\n        setProjectViewType,\n        // moveTaskToProject, // Removed: Moved to taskOperations.ts\n        initializeFromDatabase,\n        updateProjectFromSync,\n        removeProjectFromSync,\n        cleanupCorruptedProjects\n    }\n})\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/quickSort.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/settings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/syncStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/tasks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/tasks/taskHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/tasks/taskOperations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/tasks/taskPersistence.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10911,10914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10911,10914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, type Ref } from 'vue'\nimport { useSupabaseDatabase } from '@/composables/useSupabaseDatabase'\nimport type { Task } from '@/types/tasks'\nimport { useProjectStore } from '../projects'\nimport { validateBeforeSave, logTaskIdStats } from '@/utils/taskValidation'\nimport { logSupabaseTaskIdHistogram } from '@/utils/canvas/invariants'\n// TASK-1215: Tauri dual-write for filter persistence\nimport { getTauriStore, isTauriEnv } from '@/composables/usePersistentRef'\nimport type { SmartView } from '@/composables/tasks/useTaskFiltering'\n\nexport function useTaskPersistence(\n    // SAFETY: Named _rawTasks to indicate this is the raw array for load/save operations\n    _rawTasks: Ref<Task[]>,\n    hideDoneTasks: Ref<boolean>,\n    hideCanvasDoneTasks: Ref<boolean>,\n    hideCalendarDoneTasks: Ref<boolean>,\n    hideCanvasOverdueTasks: Ref<boolean>,\n    activeSmartView: Ref<SmartView>,\n    activeStatusFilter: Ref<string | null>,\n    // TASK-1215: Added duration filter persistence\n    activeDurationFilter: Ref<'quick' | 'short' | 'medium' | 'long' | 'unestimated' | null>,\n    isLoadingFromDatabase: Ref<boolean>,\n    _manualOperationInProgress: Ref<boolean>,\n    isLoadingFilters: Ref<boolean>,\n    _syncInProgress: Ref<boolean>,\n    _runAllTaskMigrations: () => void\n) {\n    const projectStore = useProjectStore()\n\n    // BUG-1084 v5: Flag to indicate that loadFromDatabase has completed at least once\n    // Used by useCanvasOrchestrator to wait for store initialization before syncing\n    const _hasInitializedOnce = ref(false)\n    const FILTER_STORAGE_KEY = 'flowstate-filters'\n\n    interface PersistedFilterState {\n        activeProjectId: string | null\n        activeSmartView: SmartView\n        activeStatusFilter: string | null\n        // TASK-1215: Added missing duration filter persistence\n        activeDurationFilter?: 'quick' | 'short' | 'medium' | 'long' | 'unestimated' | null\n        hideCanvasDoneTasks?: boolean\n        hideCalendarDoneTasks?: boolean\n        hideCanvasOverdueTasks?: boolean\n    }\n\n    // --- SQL PERSISTENCE ---\n\n    // -- Supabase Integration --\n    const { fetchTasks, saveTasks, deleteTask: deleteFromDB, bulkDeleteTasks: bulkDeleteFromDB } = useSupabaseDatabase()\n\n    // TASK-142 FIX: Guest Mode localStorage persistence for tasks\n    const GUEST_TASKS_KEY = 'flowstate-guest-tasks'\n\n    const saveTasksToLocalStorage = () => {\n        try {\n            localStorage.setItem(GUEST_TASKS_KEY, JSON.stringify(_rawTasks.value))\n            if (import.meta.env.DEV) {\n                console.log(`💾 [GUEST-MODE] Saved ${_rawTasks.value.length} tasks to localStorage`)\n            }\n        } catch (e) {\n            console.error('❌ [GUEST-MODE] Failed to save tasks to localStorage:', e)\n        }\n    }\n\n    const loadTasksFromLocalStorage = (): Task[] => {\n        try {\n            const stored = localStorage.getItem(GUEST_TASKS_KEY)\n            if (stored) {\n                const tasks = JSON.parse(stored) as Task[]\n\n                // BUG-339: Deduplicate by ID to prevent guest mode congestion\n                const seenIds = new Set<string>()\n                const uniqueTasks = tasks.filter(task => {\n                    if (seenIds.has(task.id)) {\n                        if (import.meta.env.DEV) {\n                            console.warn(`🔄 [GUEST-MODE] Removing duplicate task: ${task.id}`)\n                        }\n                        return false\n                    }\n                    seenIds.add(task.id)\n                    return true\n                })\n\n                if (uniqueTasks.length < tasks.length) {\n                    if (import.meta.env.DEV) {\n                        console.log(`🧹 [GUEST-MODE] Removed ${tasks.length - uniqueTasks.length} duplicate tasks`)\n                    }\n                    // Save cleaned data back\n                    localStorage.setItem(GUEST_TASKS_KEY, JSON.stringify(uniqueTasks))\n                }\n\n                if (import.meta.env.DEV) {\n                    console.log(`📦 [GUEST-MODE] Loaded ${uniqueTasks.length} tasks from localStorage`)\n                }\n                return uniqueTasks\n            }\n        } catch (e) {\n            console.error('❌ [GUEST-MODE] Failed to load tasks from localStorage:', e)\n        }\n        return []\n    }\n\n    const deleteTaskFromStorage = async (taskId: string): Promise<void> => {\n        if (import.meta.env.DEV) {\n            console.log(`🗑️ [PERSISTENCE] deleteTaskFromStorage called for: ${taskId}`)\n        }\n\n        // NOTE: localStorage save happens in taskOperations.deleteTask AFTER splice\n        // Don't save here - the task is still in _rawTasks at this point!\n\n        // In Guest Mode, skip Supabase deletion\n        const { useAuthStore } = await import('@/stores/auth')\n        const authStore = useAuthStore()\n        if (!authStore.isAuthenticated) {\n            if (import.meta.env.DEV) {\n                console.log(`✅ [PERSISTENCE] Task ${taskId} will be removed from localStorage after splice`)\n            }\n            return\n        }\n\n        try {\n            await deleteFromDB(taskId)\n            if (import.meta.env.DEV) {\n                console.log(`✅ [PERSISTENCE] Task ${taskId} soft-deleted successfully`)\n            }\n        } catch (e) {\n            console.error(`❌ [PERSISTENCE] Task deletion failed for ${taskId}:`, e)\n            throw e  // Re-throw so deleteTask in taskOperations knows it failed\n        }\n    }\n\n    // BUG-025 FIX: Atomic bulk delete for multiple tasks\n    const bulkDeleteTasksFromStorage = async (taskIds: string[]): Promise<void> => {\n        if (taskIds.length === 0) return\n        console.log(`🗑️ [PERSISTENCE] bulkDeleteTasksFromStorage called for ${taskIds.length} tasks`)\n\n        // NOTE: localStorage save happens in caller AFTER array modification\n        // Don't save here - tasks are still in _rawTasks at this point!\n\n        // In Guest Mode, skip Supabase deletion\n        const { useAuthStore } = await import('@/stores/auth')\n        const authStore = useAuthStore()\n        if (!authStore.isAuthenticated) {\n            console.log(`✅ [PERSISTENCE] ${taskIds.length} tasks will be removed from localStorage after splice`)\n            return\n        }\n\n        try {\n            await bulkDeleteFromDB(taskIds)\n            console.log(`✅ [PERSISTENCE] ${taskIds.length} tasks soft-deleted atomically`)\n        } catch (e) {\n            console.error(`❌ [PERSISTENCE] Bulk task deletion failed:`, e)\n            throw e // Re-throw so bulkDeleteTasks in taskOperations knows it failed\n        }\n    }\n\n    const saveTasksToStorage = async (tasksToSave: Task[], context: string = 'unknown'): Promise<void> => {\n        if (typeof window !== 'undefined' && (window as unknown as { __STORYBOOK__?: boolean }).__STORYBOOK__) return\n\n        // BUG-339 FIX: Only save to guest localStorage when NOT authenticated\n        // Previously this saved unconditionally, leaking Supabase tasks to guest storage\n        // which caused duplicates when migrating on next sign-in\n        const { useAuthStore } = await import('@/stores/auth')\n        const authStore = useAuthStore()\n        if (!authStore.isAuthenticated) {\n            saveTasksToLocalStorage()\n        } else {\n            // BUG-339: Clear guest tasks if signed in (prevents stale data buildup)\n            localStorage.removeItem(GUEST_TASKS_KEY)\n        }\n\n        try {\n            // Validation\n            const validation = validateBeforeSave(tasksToSave)\n            if (validation.blockedTasks.length > 0) {\n                console.error(`🛡️ [PRE-SAVE] Blocked ${validation.blockedTasks.length} tasks with invalid IDs (${context})`)\n            }\n\n            const validTasksToSave = validation.validTasks\n            if (validTasksToSave.length === 0) return\n\n            logTaskIdStats(validTasksToSave, `save-${context}`)\n\n            await saveTasks(validTasksToSave)\n            // console.debug(`✅ [SUPABASE] Saved ${validTasksToSave.length} tasks (${context})`)\n\n        } catch (_e) {\n            // Supabase failed or skipped (guest mode) - localStorage backup is still saved\n            console.debug(`⏭️ [PERSISTENCE] Supabase skipped/failed - localStorage backup saved (${context})`)\n        }\n    }\n\n    const saveSpecificTasks = saveTasksToStorage\n\n    // --- LOAD LOGIC ---\n\n    // BUG-1207 FIX (Fix 1.2b): Reentrancy guard for loadFromDatabase.\n    // If called while already loading (e.g., auth recovery + realtime both trigger reload),\n    // return the existing promise instead of starting a second concurrent fetch.\n    // This prevents race conditions where two loads merge/overwrite each other's results.\n    let _loadPromise: Promise<void> | null = null\n\n    const loadFromDatabase = async () => {\n        if (_loadPromise) {\n            console.log('[TASK-LOAD] Reentrancy guard: returning existing load promise')\n            return _loadPromise\n        }\n        _loadPromise = _loadFromDatabaseImpl()\n        try {\n            await _loadPromise\n        } finally {\n            _loadPromise = null\n        }\n    }\n\n    const _loadFromDatabaseImpl = async () => {\n        try {\n            isLoadingFromDatabase.value = true\n\n            // Guest mode: load from localStorage (persists across refreshes)\n            const { useAuthStore } = await import('@/stores/auth')\n            const authStore = useAuthStore()\n            if (!authStore.isAuthenticated) {\n                const localTasks = loadTasksFromLocalStorage()\n                console.log(`👤 [GUEST-MODE] Loaded ${localTasks.length} tasks from localStorage`)\n                _rawTasks.value = localTasks\n                return\n            }\n\n            // BUG-339: Guest localStorage is now cleared in useAppInitialization\n            // via clearStaleGuestTasks() BEFORE this function is called\n\n            const loadedTasks = await fetchTasks()\n\n            // TASK-142: Position integrity validation - detect invalid canvas positions early\n            const tasksWithPositions = loadedTasks.filter(t => t.canvasPosition)\n            const invalidTasks = tasksWithPositions.filter(t =>\n                !Number.isFinite(t.canvasPosition?.x) ||\n                !Number.isFinite(t.canvasPosition?.y)\n            )\n            if (invalidTasks.length > 0) {\n                console.error(`❌ [INTEGRITY] ${invalidTasks.length} tasks have invalid canvas positions:`,\n                    invalidTasks.map(t => `${t.title}: ${JSON.stringify(t.canvasPosition)}`))\n            }\n\n            // BUG-169 FIX: Safety guard - don't overwrite existing tasks with empty array\n            // This prevents data loss from race conditions during auth propagation\n            // TASK-1177: Extended from 10 seconds to 60 seconds for better protection\n            if (loadedTasks.length === 0 && _rawTasks.value.length > 0) {\n                const sessionStart = typeof window !== 'undefined' ? (window as any).FlowStateSessionStart || 0 : 0\n                const timeSinceSessionStart = Date.now() - sessionStart\n\n                // In the first 60 seconds, don't overwrite existing tasks with empty\n                // This gives plenty of time for network issues to resolve\n                if (timeSinceSessionStart < 60000) {\n                    console.warn(`🛡️ [TASK-LOAD] BLOCKED empty overwrite - ${_rawTasks.value.length} existing tasks would be lost (session ${timeSinceSessionStart}ms old)`)\n                    return\n                }\n\n                console.warn(`⚠️ [TASK-LOAD] Supabase returned 0 tasks but ${_rawTasks.value.length} exist locally - proceeding with empty (session ${timeSinceSessionStart}ms old)`)\n            }\n\n            // ================================================================\n            // DUPLICATE DETECTION - Supabase Load Layer (AUTHORITATIVE)\n            // ================================================================\n            // Uses centralized helper for consistent detection across all layers\n            // A duplicate here means the bug is at the database level\n            logSupabaseTaskIdHistogram(loadedTasks, 'loadFromDatabase')\n\n            // ================================================================\n            // SMART MERGE STRATEGY (BUG-FIX)\n            // ================================================================\n            // Instead of blindly overwriting local state with DB state, we merge carefully.\n            // This handles \"Auth Recovery -> Reload\" scenarios where local state involves\n            // recent optimistic updates that haven't persisted to DB yet due to connection drop.\n\n            // 1. Index remote tasks\n            const remoteMap = new Map(loadedTasks.map(t => [t.id, t]))\n            const mergedTasks: Task[] = []\n\n            // 2. Process existing local tasks (Preserve optimistic, Handle Remote Deletes)\n            const localTasksMap = new Map(_rawTasks.value.map(t => [t.id, t]))\n\n            for (const localTask of _rawTasks.value) {\n                const remoteTask = remoteMap.get(localTask.id)\n\n                if (remoteTask) {\n                    // CONFLICT: Task exists in both. Check who wins.\n                    // Win Condition 1: Local is explicitly newer (updatedAt > remote)\n                    const localTime = localTask.updatedAt instanceof Date ? localTask.updatedAt.getTime() : new Date(localTask.updatedAt).getTime()\n                    const remoteTime = remoteTask.updatedAt instanceof Date ? remoteTask.updatedAt.getTime() : new Date(remoteTask.updatedAt).getTime()\n\n                    // Win Condition 2: Local position version is higher (specific for drag operations)\n                    const localVer = localTask.positionVersion ?? 0\n                    const remoteVer = remoteTask.positionVersion ?? 0\n\n                    // Win Condition 3: Local updated very recently - likely active editing\n                    // BUG-1207 FIX: Extended from 5s to 30s to match pendingWrites timeout.\n                    // 5s was too narrow — tasks edited 6s ago could be clobbered by recovery reload\n                    // if the sync queue hadn't processed them yet (VPS latency can be 20s+).\n                    const now = Date.now()\n                    const isVeryRecent = (now - localTime) < 30000\n\n                    if (localVer > remoteVer || localTime > remoteTime || isVeryRecent) {\n                        console.log(`🛡️ [SMART-MERGE] Preserving local task \"${localTask.title?.slice(0, 15)}\" (Local v${localVer} > Remote v${remoteVer} || Local newer)`)\n                        mergedTasks.push(localTask)\n                    } else {\n                        // Remote is newer or equal -> Accept remote\n                        // BUG-1206 DEBUG: Log when remote description overwrites local\n                        if (localTask.description !== remoteTask.description) {\n                            if (import.meta.env.DEV) {\n                                console.warn('🐛 [BUG-1206] SMART-MERGE OVERWRITE - description changed!', {\n                                    taskId: localTask.id?.slice(0, 8),\n                                    localDescLength: localTask.description?.length,\n                                    localDescPreview: localTask.description?.slice(0, 50),\n                                    remoteDescLength: remoteTask.description?.length,\n                                    remoteDescPreview: remoteTask.description?.slice(0, 50),\n                                    localTime: new Date(localTime).toISOString(),\n                                    remoteTime: new Date(remoteTime).toISOString(),\n                                    isVeryRecent\n                                })\n                            }\n                        }\n                        mergedTasks.push(remoteTask)\n                    }\n\n                    // Mark as processed so we don't add it again in step 3\n                    remoteMap.delete(localTask.id)\n                } else {\n                    // TASK-1177 FIX: NEVER drop local-only tasks automatically\n                    // Previous behavior dropped tasks older than 5 minutes, causing DATA LOSS\n                    // when sync failed and user refreshed.\n                    //\n                    // New behavior: ALWAYS preserve local tasks and queue for sync retry.\n                    // The offline-first sync system (useSyncOrchestrator) handles retries.\n\n                    console.log(`🛡️ [SMART-MERGE] Preserving local-only task \"${localTask.title?.slice(0, 15)}\" - will sync when online`)\n                    mergedTasks.push(localTask)\n\n                    // Queue the task for sync retry via the offline sync system\n                    // This is async and non-blocking - the task stays in memory regardless\n                    import('@/composables/sync/useSyncOrchestrator').then(({ useSyncOrchestrator }) => {\n                        const sync = useSyncOrchestrator()\n                        sync.enqueue({\n                            entityType: 'task',\n                            operation: 'create',\n                            entityId: localTask.id,\n                            payload: localTask as unknown as Record<string, unknown>\n                        }).catch(e => {\n                            console.warn(`[SMART-MERGE] Failed to queue sync for \"${localTask.title?.slice(0, 15)}\":`, e)\n                        })\n                    }).catch(() => {\n                        // Sync orchestrator not available - task is still preserved in memory\n                    })\n                }\n            }\n\n            // 3. Add remaining remote tasks (New from Remote)\n            for (const [_, remoteTask] of remoteMap) {\n                mergedTasks.push(remoteTask)\n            }\n\n            // BUG-1207 FIX (Fix 2.2): Granular updates instead of full array replacement.\n            // `_rawTasks.value = mergedTasks` replaces the entire ref, causing ALL watchers\n            // and computeds to re-fire (even for unchanged tasks). Instead, surgically\n            // update/add/remove individual entries to minimize reactivity churn.\n            const mergedMap = new Map(mergedTasks.map(t => [t.id, t]))\n\n            // Update existing or remove stale entries (iterate backwards for safe splice)\n            for (let i = _rawTasks.value.length - 1; i >= 0; i--) {\n                const existing = _rawTasks.value[i]\n                const merged = mergedMap.get(existing.id)\n                if (merged) {\n                    // Task exists in merged result - update in place if different\n                    if (existing !== merged) {\n                        _rawTasks.value[i] = merged\n                    }\n                    mergedMap.delete(existing.id)\n                } else {\n                    // Task not in merged result - remove it\n                    _rawTasks.value.splice(i, 1)\n                }\n            }\n\n            // Add any new tasks from merged result that weren't already in the array\n            for (const [, newTask] of mergedMap) {\n                _rawTasks.value.push(newTask)\n            }\n\n            console.log(`✅ [SMART-MERGE] Complete. Local: ${localTasksMap.size} -> Merged: ${mergedTasks.length} (Fetched: ${loadedTasks.length})`)\n\n        } catch (error) {\n            console.error('❌ [SUPABASE] Load failed:', error)\n        } finally {\n            isLoadingFromDatabase.value = false\n            // BUG-1084 v5: Mark initialization complete (even on error)\n            _hasInitializedOnce.value = true\n        }\n    }\n\n    // --- FILTERS ---\n    // (Kept as localStorage only, same as before)\n\n    const applyFilterState = (state: PersistedFilterState) => {\n        if (state.activeProjectId && !projectStore.projects.find(p => p.id === state.activeProjectId)) {\n            state.activeProjectId = null\n        }\n        projectStore.setActiveProject(state.activeProjectId)\n        activeSmartView.value = state.activeSmartView\n        activeStatusFilter.value = state.activeStatusFilter\n        // TASK-1215: Restore duration filter\n        activeDurationFilter.value = state.activeDurationFilter ?? null\n        hideCanvasDoneTasks.value = state.hideCanvasDoneTasks ?? true\n        hideCalendarDoneTasks.value = state.hideCalendarDoneTasks ?? false\n        hideCanvasOverdueTasks.value = state.hideCanvasOverdueTasks ?? false\n    }\n\n    const loadFiltersFromLocalStorage = () => {\n        try {\n            // TASK-1267: Migrate from old key prefix\n            if (!localStorage.getItem(FILTER_STORAGE_KEY)) {\n                const oldData = localStorage.getItem('flow-state-filters')\n                if (oldData) {\n                    localStorage.setItem(FILTER_STORAGE_KEY, oldData)\n                    localStorage.removeItem('flow-state-filters')\n                }\n            }\n            const localSaved = localStorage.getItem(FILTER_STORAGE_KEY)\n            if (localSaved) {\n                const state: PersistedFilterState = JSON.parse(localSaved)\n                applyFilterState(state)\n                return true\n            }\n        } catch (_e) {\n            console.warn('Failed to load filters from localStorage:', _e)\n        }\n        return false\n    }\n\n    const loadPersistedFilters = async () => {\n        isLoadingFilters.value = true\n        try {\n            const loadedFromLocal = loadFiltersFromLocalStorage()\n\n            // BUG-1219: In Tauri, localStorage can be empty after restart.\n            // Fall back to reading directly from Tauri native store.\n            if (!loadedFromLocal && isTauriEnv()) {\n                try {\n                    const store = await getTauriStore()\n                    if (store) {\n                        const state = await store.get(FILTER_STORAGE_KEY) as PersistedFilterState | null\n                        if (state) {\n                            console.log('[TaskPersistence] Restored filters from Tauri store (localStorage was empty)')\n                            applyFilterState(state)\n                            // Re-populate localStorage so subsequent reads work\n                            localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(state))\n                        }\n                    }\n                } catch (e) {\n                    console.warn('[TaskPersistence] Failed to read filters from Tauri store:', e)\n                }\n            }\n        } finally {\n            isLoadingFilters.value = false\n        }\n    }\n\n    let persistTimeout: ReturnType<typeof setTimeout> | null = null\n    const persistFilters = async () => {\n        if (isLoadingFilters.value) return\n        if (persistTimeout) clearTimeout(persistTimeout)\n        persistTimeout = setTimeout(async () => {\n            const state: PersistedFilterState = {\n                activeProjectId: projectStore.activeProjectId,\n                activeSmartView: activeSmartView.value,\n                activeStatusFilter: activeStatusFilter.value,\n                // TASK-1215: Persist duration filter\n                activeDurationFilter: activeDurationFilter.value,\n                hideCanvasDoneTasks: hideCanvasDoneTasks.value,\n                hideCalendarDoneTasks: hideCalendarDoneTasks.value,\n                hideCanvasOverdueTasks: hideCanvasOverdueTasks.value\n            }\n            localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(state))\n\n            // TASK-1215: Also write to Tauri store for reliable persistence\n            // BUG-1219: Flush immediately (no scheduleTauriSave debounce) to prevent\n            // data loss if the app is closed shortly after a filter change\n            if (isTauriEnv()) {\n                const store = await getTauriStore()\n                if (store) {\n                    try {\n                        await store.set(FILTER_STORAGE_KEY, state)\n                        await store.save()\n                    } catch (e) {\n                        console.warn('[TaskPersistence] Failed to write filters to Tauri store:', e)\n                    }\n                }\n            }\n        }, 500)\n    }\n\n    // --- EXPORTS ---\n\n    return {\n        saveTasksToStorage,\n        saveSpecificTasks,\n        deleteTaskFromStorage,\n        bulkDeleteTasksFromStorage,  // BUG-025: Atomic bulk delete\n        loadFromDatabase,\n        loadPersistedFilters,\n        persistFilters,\n        // BUG-1084 v5: Expose initialization flag for orchestrator\n        _hasInitializedOnce,\n        importTasksFromJSON: async () => {\n            throw new Error('importTasksFromJSON is not implemented')\n        },\n        importFromRecoveryTool: async () => {\n            throw new Error('importFromRecoveryTool is not implemented')\n        },\n        recoverSoftDeletedTasks: async () => {\n            console.warn('[taskPersistence] recoverSoftDeletedTasks is not yet implemented')\n            return 0\n        }, // TBD: SQL Implementation needed later\n\n        /**\n         * TASK-344: Import tasks with immutable ID enforcement\n         * Checks both local store AND Supabase for existing/tombstoned IDs\n         */\n        importTasks: async (tasksToImport: Task[]) => {\n            if (!tasksToImport.length) return { imported: 0, skipped: 0, skippedIds: [] as string[] }\n\n            // First, filter out tasks that exist locally\n            const localIds = new Set(_rawTasks.value.map(t => t.id))\n            const notInLocal = tasksToImport.filter(t => !localIds.has(t.id))\n\n            if (notInLocal.length === 0) {\n                console.log('[TASK-344] All tasks already exist locally - nothing to import')\n                return { imported: 0, skipped: tasksToImport.length, skippedIds: tasksToImport.map(t => t.id) }\n            }\n\n            // TASK-344: Check Supabase for existing/tombstoned IDs\n            const { useAuthStore } = await import('@/stores/auth')\n            const authStore = useAuthStore()\n\n            let tasksToAdd = notInLocal\n            const skippedIds: string[] = tasksToImport.filter(t => localIds.has(t.id)).map(t => t.id)\n\n            if (authStore.isAuthenticated) {\n                const { checkTaskIdsAvailability, logDedupDecision } = useSupabaseDatabase()\n                const taskIds = notInLocal.map(t => t.id)\n                const availability = await checkTaskIdsAvailability(taskIds)\n\n                const availableIds = new Set(\n                    availability\n                        .filter(a => a.status === 'available')\n                        .map(a => a.taskId)\n                )\n\n                tasksToAdd = notInLocal.filter(t => availableIds.has(t.id))\n\n                // Log skipped tasks\n                for (const result of availability) {\n                    if (result.status !== 'available') {\n                        skippedIds.push(result.taskId)\n                        await logDedupDecision(\n                            'sync',\n                            result.taskId,\n                            result.status === 'tombstoned' ? 'skipped_tombstoned' : 'skipped_exists',\n                            result.reason\n                        )\n                    }\n                }\n\n                console.log(`[TASK-344] Import filter: ${tasksToAdd.length}/${notInLocal.length} tasks available (${notInLocal.length - tasksToAdd.length} exist/tombstoned)`)\n            }\n\n            if (tasksToAdd.length > 0) {\n                _rawTasks.value.push(...tasksToAdd)\n                await saveTasksToStorage(_rawTasks.value, 'import-tool')\n            }\n\n            return {\n                imported: tasksToAdd.length,\n                skipped: tasksToImport.length - tasksToAdd.length,\n                skippedIds\n            }\n        }\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/tasks/taskStates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/timer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/stores/ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/sw.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/test/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/ai.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/canvas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/challenges.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/gamification.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/quickTasks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/recurrence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/sync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/tasks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/types/timeBlockNotifications.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/braveProtection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/calendar/overlapCalculation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/__tests__/canvasIds.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/canvasIds.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/coordinates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/invariants.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":131,"column":65,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":131,"endColumn":90},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":166,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":166,"endColumn":57},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":225,"column":61,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":225,"endColumn":86},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":268,"column":61,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":268,"endColumn":75},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":317,"column":54,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":317,"endColumn":62,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[11951,11952],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Canvas Hierarchy Invariant Validation\n *\n * This module defines and validates the three core invariants that must hold\n * for the nested group system to work correctly.\n *\n * ============================================================================\n * INVARIANT A: HIERARCHY CONSISTENCY\n * ============================================================================\n * - If group.parentGroupId === null → Vue Flow node has parentNode: undefined, extent: undefined\n * - If group.parentGroupId !== null → Vue Flow node has parentNode = CanvasIds.groupNodeId(parentGroupId)\n *   (NOTE: Groups do NOT have extent: 'parent' set - this allows child→root drag transitions)\n * - The parent group MUST exist in the store\n *\n * ============================================================================\n * INVARIANT B: POSITION ARCHITECTURE\n * ============================================================================\n * - Store/DB always holds ABSOLUTE world coordinates for ALL nodes\n * - Vue Flow uses:\n *   - Root nodes: position = absolute (no conversion)\n *   - Nested nodes: position = absolute - parentAbsolute (relative to parent)\n *\n * ============================================================================\n * INVARIANT C: RECURSION SAFETY\n * ============================================================================\n * - All recursive functions MUST use a visited set to prevent infinite loops\n * - collectDescendantGroups, getTaskCountInGroupRecursive, getAllDescendantGroupIds\n *   must all accept and use a visited set parameter\n */\n\nimport type { Node } from '@vue-flow/core'\nimport type { CanvasGroup } from '@/stores/canvas/types'\nimport type { Task } from '@/types/tasks'\nimport { CanvasIds } from './canvasIds'\nimport {\n    getGroupAbsolutePosition,\n    toRelativePosition,\n    sanitizePosition\n} from './coordinates'\n\n// Epsilon for position comparison - must match tolerance used in sync code\nconst POSITION_EPSILON = 0.5\n\n// Only log in development mode\nconst isDev = import.meta.env.DEV\n\n/**\n * Invariant violation severity levels\n */\nexport enum InvariantSeverity {\n    ERROR = 'ERROR',     // Must fix immediately - will cause bugs\n    WARNING = 'WARNING', // Should fix - may cause subtle issues\n    INFO = 'INFO'        // Informational - potential optimization\n}\n\n/**\n * Invariant violation report\n */\nexport interface InvariantViolation {\n    invariant: 'A' | 'B' | 'C'\n    severity: InvariantSeverity\n    nodeId: string\n    nodeType: 'group' | 'task'\n    message: string\n    details: Record<string, unknown>\n}\n\n/**\n * Validate Invariant A: Hierarchy Consistency\n *\n * Checks that Vue Flow node's parentNode and extent match the store's parentGroupId\n */\nexport function validateInvariantA(\n    vueFlowNodes: Node[],\n    storeGroups: CanvasGroup[]\n): InvariantViolation[] {\n    const violations: InvariantViolation[] = []\n    const groupById = new Map(storeGroups.map(g => [g.id, g]))\n\n    for (const node of vueFlowNodes) {\n        if (!CanvasIds.isGroupNode(node.id)) continue\n\n        const { id: groupId } = CanvasIds.parseNodeId(node.id)\n        const storeGroup = groupById.get(groupId)\n\n        if (!storeGroup) {\n            violations.push({\n                invariant: 'A',\n                severity: InvariantSeverity.ERROR,\n                nodeId: groupId,\n                nodeType: 'group',\n                message: `Vue Flow node exists but group not found in store`,\n                details: { nodeId: node.id }\n            })\n            continue\n        }\n\n        const hasStoreParent = storeGroup.parentGroupId && storeGroup.parentGroupId !== 'NONE'\n        const hasVueFlowParent = !!node.parentNode\n        const hasExtent = node.extent === 'parent'\n\n        // Case 1: Store says no parent\n        if (!hasStoreParent) {\n            if (hasVueFlowParent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Store has no parentGroupId but Vue Flow node has parentNode set`,\n                    details: {\n                        storeParentGroupId: storeGroup.parentGroupId,\n                        vueFlowParentNode: node.parentNode\n                    }\n                })\n            }\n            if (hasExtent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.WARNING,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Store has no parentGroupId but Vue Flow node has extent: 'parent'`,\n                    details: { extent: node.extent }\n                })\n            }\n        }\n\n        // Case 2: Store says has parent\n        if (hasStoreParent) {\n            const expectedVueFlowParent = CanvasIds.groupNodeId(storeGroup.parentGroupId!)\n\n            if (!hasVueFlowParent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Store has parentGroupId but Vue Flow node has no parentNode`,\n                    details: {\n                        storeParentGroupId: storeGroup.parentGroupId,\n                        expected: expectedVueFlowParent\n                    }\n                })\n            } else if (node.parentNode !== expectedVueFlowParent) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Vue Flow parentNode doesn't match store parentGroupId`,\n                    details: {\n                        storeParentGroupId: storeGroup.parentGroupId,\n                        vueFlowParentNode: node.parentNode,\n                        expected: expectedVueFlowParent\n                    }\n                })\n            }\n\n            // NOTE: We intentionally do NOT check for extent: 'parent' here.\n            // Groups are allowed to NOT have extent set so they can be dragged outside\n            // their parent for child→root transitions. The containment check in\n            // onNodeDragStop handles re-parenting via spatial detection.\n\n            // Check parent exists\n            if (!groupById.has(storeGroup.parentGroupId!)) {\n                violations.push({\n                    invariant: 'A',\n                    severity: InvariantSeverity.ERROR,\n                    nodeId: groupId,\n                    nodeType: 'group',\n                    message: `Parent group doesn't exist in store`,\n                    details: {\n                        parentGroupId: storeGroup.parentGroupId,\n                        availableGroups: Array.from(groupById.keys())\n                    }\n                })\n            }\n        }\n    }\n\n    return violations\n}\n\n/**\n * Helper: Compare positions with epsilon tolerance\n */\nfunction positionsMatch(\n    actual: { x: number; y: number },\n    expected: { x: number; y: number }\n): boolean {\n    const dx = Math.abs(actual.x - expected.x)\n    const dy = Math.abs(actual.y - expected.y)\n    return dx <= POSITION_EPSILON && dy <= POSITION_EPSILON\n}\n\n/**\n * Validate Invariant B: Position Architecture\n *\n * Checks that Vue Flow positions are correctly computed from store absolute positions.\n * Uses the exact same conversion logic as useCanvasSync.ts to ensure consistency.\n */\nexport function validateInvariantB(\n    vueFlowNodes: Node[],\n    storeGroups: CanvasGroup[],\n    storeTasks: Task[]\n): InvariantViolation[] {\n    const violations: InvariantViolation[] = []\n\n    // Check groups\n    for (const node of vueFlowNodes) {\n        if (!CanvasIds.isGroupNode(node.id)) continue\n\n        const { id: groupId } = CanvasIds.parseNodeId(node.id)\n        const storeGroup = storeGroups.find(g => g.id === groupId)\n        if (!storeGroup) continue\n\n        // Use sanitizePosition to match what useCanvasSync does\n        const storeAbsolute = sanitizePosition(storeGroup.position)\n        const hasParent = storeGroup.parentGroupId && storeGroup.parentGroupId !== 'NONE'\n\n        // Compute expected Vue Flow position using same logic as groupPositionToVueFlow\n        let expectedVueFlowPos: { x: number; y: number }\n        if (hasParent) {\n            const parentAbsolute = getGroupAbsolutePosition(storeGroup.parentGroupId!, storeGroups)\n            expectedVueFlowPos = toRelativePosition(storeAbsolute, parentAbsolute)\n        } else {\n            expectedVueFlowPos = storeAbsolute\n        }\n\n        const actualVueFlowPos = sanitizePosition(node.position)\n\n        if (!positionsMatch(actualVueFlowPos, expectedVueFlowPos)) {\n            violations.push({\n                invariant: 'B',\n                severity: InvariantSeverity.WARNING,\n                nodeId: groupId,\n                nodeType: 'group',\n                message: `Vue Flow position doesn't match expected (${hasParent ? 'relative' : 'absolute'})`,\n                details: {\n                    storeAbsolute,\n                    parentGroupId: storeGroup.parentGroupId,\n                    expectedVueFlowPos,\n                    actualVueFlowPos,\n                    delta: {\n                        x: actualVueFlowPos.x - expectedVueFlowPos.x,\n                        y: actualVueFlowPos.y - expectedVueFlowPos.y\n                    }\n                }\n            })\n        }\n    }\n\n    // Check tasks\n    for (const node of vueFlowNodes) {\n        if (node.type !== 'taskNode') continue\n\n        const task = storeTasks.find(t => t.id === node.id)\n        if (!task || !task.canvasPosition) continue\n\n        // Use sanitizePosition to match what useCanvasSync does\n        const storeAbsolute = sanitizePosition(task.canvasPosition)\n        const hasParent = task.parentId && task.parentId !== 'NONE'\n\n        // Compute expected Vue Flow position using same logic as taskPositionToVueFlow\n        let expectedVueFlowPos: { x: number; y: number }\n        if (hasParent) {\n            const parentAbsolute = getGroupAbsolutePosition(task.parentId!, storeGroups)\n            expectedVueFlowPos = toRelativePosition(storeAbsolute, parentAbsolute)\n        } else {\n            expectedVueFlowPos = storeAbsolute\n        }\n\n        const actualVueFlowPos = sanitizePosition(node.position)\n\n        if (!positionsMatch(actualVueFlowPos, expectedVueFlowPos)) {\n            violations.push({\n                invariant: 'B',\n                severity: InvariantSeverity.WARNING,\n                nodeId: task.id,\n                nodeType: 'task',\n                message: `Vue Flow position doesn't match expected (${hasParent ? 'relative' : 'absolute'})`,\n                details: {\n                    storeAbsolute,\n                    parentId: task.parentId,\n                    expectedVueFlowPos,\n                    actualVueFlowPos: { x: node.position.x, y: node.position.y }\n                }\n            })\n        }\n    }\n\n    return violations\n}\n\n/**\n * Validate Invariant C: No Cycles in Hierarchy\n *\n * Checks that there are no cycles in the parent-child relationships\n */\nexport function validateInvariantC(storeGroups: CanvasGroup[]): InvariantViolation[] {\n    const violations: InvariantViolation[] = []\n\n    for (const group of storeGroups) {\n        if (!group.parentGroupId || group.parentGroupId === 'NONE') continue\n\n        const visited = new Set<string>()\n        let current: CanvasGroup | undefined = group\n        let hasCycle = false\n\n        while (current && current.parentGroupId && current.parentGroupId !== 'NONE') {\n            if (visited.has(current.id)) {\n                hasCycle = true\n                break\n            }\n            visited.add(current.id)\n            current = storeGroups.find(g => g.id === current!.parentGroupId)\n        }\n\n        if (hasCycle) {\n            violations.push({\n                invariant: 'C',\n                severity: InvariantSeverity.ERROR,\n                nodeId: group.id,\n                nodeType: 'group',\n                message: `Cycle detected in parent chain`,\n                details: {\n                    groupId: group.id,\n                    groupName: group.name,\n                    visitedChain: Array.from(visited)\n                }\n            })\n        }\n    }\n\n    return violations\n}\n\n/**\n * Run all invariant validations and log violations\n *\n * Call this after sync operations to verify consistency\n */\nexport function validateAllInvariants(\n    vueFlowNodes: Node[],\n    storeGroups: CanvasGroup[],\n    storeTasks: Task[],\n    context: string = 'unknown'\n): InvariantViolation[] {\n    const allViolations: InvariantViolation[] = []\n\n    // Only run in dev mode\n    if (!isDev) return allViolations\n\n    const violationsA = validateInvariantA(vueFlowNodes, storeGroups)\n    const violationsB = validateInvariantB(vueFlowNodes, storeGroups, storeTasks)\n    const violationsC = validateInvariantC(storeGroups)\n\n    allViolations.push(...violationsA, ...violationsB, ...violationsC)\n\n    if (allViolations.length > 0) {\n        console.group(`[INVARIANT] ${allViolations.length} violation(s) detected in ${context}`)\n\n        const errors = allViolations.filter(v => v.severity === InvariantSeverity.ERROR)\n        const warnings = allViolations.filter(v => v.severity === InvariantSeverity.WARNING)\n\n        if (errors.length > 0) {\n            console.error(`${errors.length} ERROR(s):`)\n            errors.forEach(v => {\n                console.error(`  [${v.invariant}] ${v.nodeType} ${v.nodeId}: ${v.message}`, v.details)\n            })\n        }\n\n        if (warnings.length > 0) {\n            console.warn(`${warnings.length} WARNING(s):`)\n            warnings.forEach(v => {\n                console.warn(`  [${v.invariant}] ${v.nodeType} ${v.nodeId}: ${v.message}`, v.details)\n            })\n        }\n\n        console.groupEnd()\n    } else if (isDev) {\n        // Log success only in very verbose mode\n        // console.log(`[INVARIANT] All invariants passed in ${context}`)\n    }\n\n    return allViolations\n}\n\n/**\n * Log a summary of the current hierarchy state\n *\n * Call this once on load to see the hierarchy at a glance\n */\nexport function logHierarchySummary(storeGroups: CanvasGroup[]): void {\n    if (!isDev) return\n\n    console.group('[HIERARCHY] Group Hierarchy Summary')\n\n    // Find root groups\n    const rootGroups = storeGroups.filter(g => !g.parentGroupId || g.parentGroupId === 'NONE')\n    const nestedGroups = storeGroups.filter(g => g.parentGroupId && g.parentGroupId !== 'NONE')\n\n    console.log(`Total: ${storeGroups.length} groups (${rootGroups.length} root, ${nestedGroups.length} nested)`)\n\n    // Build tree structure\n    const printTree = (groupId: string, indent: string = '') => {\n        const group = storeGroups.find(g => g.id === groupId)\n        if (!group) return\n\n        console.log(`${indent}${group.name} [${group.id.substring(0, 8)}...] @ (${group.position.x}, ${group.position.y})`)\n\n        const children = storeGroups.filter(g => g.parentGroupId === groupId)\n        children.forEach((child, i) => {\n            const isLast = i === children.length - 1\n            printTree(child.id, indent + (isLast ? '  ' : '  '))\n        })\n    }\n\n    rootGroups.forEach(g => printTree(g.id))\n\n    console.groupEnd()\n}\n\n// ============================================================================\n// GEOMETRY CHANGE GUARD\n// ============================================================================\n\n/**\n * Assert that no geometry fields are being changed by a non-authorized source.\n *\n * Smart Groups may only update METADATA (dueDate, priority, status, tags).\n * This guard catches any accidental geometry writes before they happen.\n *\n * @param oldTask - The current task state\n * @param newUpdates - The proposed updates\n * @param context - Description of where this check is being called from\n */\nexport function assertNoGeometryChange(\n    oldTask: { id: string; title?: string; parentId?: string | null; canvasPosition?: { x: number; y: number } | null },\n    newUpdates: { parentId?: string | null; canvasPosition?: { x: number; y: number } | null },\n    context: string\n): void {\n    if (!import.meta.env.DEV) return\n\n    const changedFields: string[] = []\n\n    // Check parentId change\n    if ('parentId' in newUpdates && newUpdates.parentId !== oldTask.parentId) {\n        changedFields.push('parentId')\n    }\n\n    // Check canvasPosition change\n    if ('canvasPosition' in newUpdates) {\n        const oldPos = oldTask.canvasPosition\n        const newPos = newUpdates.canvasPosition\n        if (oldPos?.x !== newPos?.x || oldPos?.y !== newPos?.y) {\n            changedFields.push('canvasPosition')\n        }\n    }\n\n    if (changedFields.length > 0) {\n        console.error('[ASSERT-FAILED] Smart group attempted geometry change', {\n            context,\n            taskId: oldTask.id?.slice(0, 8),\n            taskTitle: oldTask.title?.slice(0, 30),\n            changedFields,\n            oldParentId: oldTask.parentId,\n            newParentId: newUpdates.parentId,\n            oldPosition: oldTask.canvasPosition,\n            newPosition: newUpdates.canvasPosition\n        })\n    }\n}\n\n// ============================================================================\n// DUPLICATE ID DETECTION\n// ============================================================================\n\n/**\n * Result of duplicate ID check\n */\nexport interface DuplicateIdResult {\n    duplicates: Array<{ id: string; count: number }>\n    totalCount: number\n    uniqueIdCount: number\n    hasDuplicates: boolean\n}\n\n/**\n * Assert that no duplicate IDs exist in an array of items\n *\n * This is the authoritative helper for duplicate detection across all layers.\n * Use it in:\n * - tasksWithCanvasPosition (selector layer)\n * - visibleGroups (store layer)\n * - Node builders (final layer)\n *\n * @param items - Array of items with 'id' property\n * @param context - Descriptive context for error messages (e.g., 'tasksToSync', 'groups')\n * @returns DuplicateIdResult with stats and duplicate list\n */\nexport function assertNoDuplicateIds<T extends { id: string }>(\n    items: T[],\n    context: string\n): DuplicateIdResult {\n    const counts = new Map<string, number>()\n\n    for (const item of items) {\n        counts.set(item.id, (counts.get(item.id) ?? 0) + 1)\n    }\n\n    const duplicates = Array.from(counts.entries())\n        .filter(([, count]) => count > 1)\n        .map(([id, count]) => ({ id, count }))\n\n    const result: DuplicateIdResult = {\n        duplicates,\n        totalCount: items.length,\n        uniqueIdCount: counts.size,\n        hasDuplicates: duplicates.length > 0\n    }\n\n    if (result.hasDuplicates) {\n        console.error(`[ASSERT-FAILED] Duplicate ids in ${context}`, {\n            duplicates: duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n            totalCount: result.totalCount,\n            uniqueIdCount: result.uniqueIdCount\n        })\n    }\n\n    return result\n}\n\n/**\n * Alias for assertNoDuplicateIds - preferred naming convention\n */\nexport const checkForDuplicateIds = assertNoDuplicateIds\n\n// ============================================================================\n// GEOMETRY DRIFT DETECTION\n// ============================================================================\n\n/**\n * Fields that constitute \"geometry\" - only drag handlers should modify these\n */\nconst GEOMETRY_FIELDS = ['canvasPosition', 'position', 'parentId', 'parentGroupId'] as const\ntype GeometryField = typeof GEOMETRY_FIELDS[number]\n\n/**\n * Allowed sources that can modify geometry\n */\nconst ALLOWED_GEOMETRY_SOURCES = ['DRAG', 'CREATE', 'MOVE_TO_INBOX', 'INITIAL_RECONCILE'] as const\ntype GeometrySource = typeof ALLOWED_GEOMETRY_SOURCES[number]\n\n/**\n * Check if an update object contains geometry fields\n */\nexport function containsGeometryFields(updates: Record<string, unknown>): GeometryField[] {\n    return GEOMETRY_FIELDS.filter(field => field in updates)\n}\n\n/**\n * Assert that geometry changes come from an allowed source\n *\n * Call this from updateTask/updateGroup with a source parameter.\n * Logs [GEOMETRY-DRIFT] warning if non-allowed source tries to modify geometry.\n *\n * @param updates - The update object being applied\n * @param source - Who is making the change ('DRAG', 'SYNC', 'SMART-GROUP', etc.)\n * @param entityType - 'task' or 'group'\n * @param entityId - The ID of the entity being updated\n */\nexport function assertGeometrySource(\n    updates: Record<string, unknown>,\n    source: string | undefined,\n    entityType: 'task' | 'group',\n    entityId: string\n): void {\n    if (!isDev) return\n\n    const geometryFields = containsGeometryFields(updates)\n    if (geometryFields.length === 0) return // No geometry changes\n\n    const isAllowed = source && ALLOWED_GEOMETRY_SOURCES.includes(source as GeometrySource)\n\n    if (isAllowed) {\n        console.debug(`📍 [GEOMETRY-${source}]`, {\n            entityType,\n            entityId: entityId.slice(0, 8),\n            fields: geometryFields,\n            values: geometryFields.reduce((acc, f) => ({ ...acc, [f]: updates[f] }), {})\n        })\n    } else {\n        console.warn(`⚠️ [GEOMETRY-DRIFT] Non-drag source \"${source || 'UNKNOWN'}\" modifying geometry`, {\n            entityType,\n            entityId: entityId.slice(0, 8),\n            fields: geometryFields,\n            values: geometryFields.reduce((acc, f) => ({ ...acc, [f]: updates[f] }), {}),\n            stack: new Error().stack?.split('\\n').slice(2, 5).join('\\n')\n        })\n    }\n}\n\n// ============================================================================\n// SUPABASE DEBUG HELPERS\n// ============================================================================\n//\n// SQL QUERIES FOR FINDING DUPLICATES:\n// ====================================\n//\n// Find duplicate task IDs in database:\n// ```sql\n// SELECT id, COUNT(*) AS cnt\n// FROM tasks\n// GROUP BY id\n// HAVING COUNT(*) > 1;\n// ```\n//\n// Find duplicate group IDs in database:\n// ```sql\n// SELECT id, COUNT(*) AS cnt\n// FROM groups\n// GROUP BY id\n// HAVING COUNT(*) > 1;\n// ```\n//\n// ONE-TIME CLEANUP (DANGEROUS - run manually in Supabase SQL editor):\n// ===================================================================\n// For tasks - keep the row with latest updated_at, delete others:\n// ```sql\n// WITH duplicates AS (\n//   SELECT id, ctid, ROW_NUMBER() OVER (PARTITION BY id ORDER BY updated_at DESC) as rn\n//   FROM tasks\n//   WHERE id IN (\n//     SELECT id FROM tasks GROUP BY id HAVING COUNT(*) > 1\n//   )\n// )\n// DELETE FROM tasks WHERE ctid IN (\n//   SELECT ctid FROM duplicates WHERE rn > 1\n// );\n// ```\n//\n// For groups - keep the row with latest updated_at, delete others:\n// ```sql\n// WITH duplicates AS (\n//   SELECT id, ctid, ROW_NUMBER() OVER (PARTITION BY id ORDER BY updated_at DESC) as rn\n//   FROM groups\n//   WHERE id IN (\n//     SELECT id FROM groups GROUP BY id HAVING COUNT(*) > 1\n//   )\n// )\n// DELETE FROM groups WHERE ctid IN (\n//   SELECT ctid FROM duplicates WHERE rn > 1\n// );\n// ```\n//\n// ============================================================================\n\n/**\n * Log task ID histogram from Supabase fetch results\n *\n * Call after fetchTasks() to detect if Supabase returns duplicates.\n * This would indicate a database-level issue (multiple rows with same ID).\n *\n * @param tasks - Array of tasks from Supabase\n * @param context - Description of the fetch (e.g., 'loadFromDatabase')\n */\nexport function logSupabaseTaskIdHistogram(\n    tasks: Array<{ id: string; title?: string }>,\n    context: string\n): void {\n    if (!isDev) return\n\n    const counts = new Map<string, number>()\n    for (const task of tasks) {\n        counts.set(task.id, (counts.get(task.id) ?? 0) + 1)\n    }\n\n    const duplicates = Array.from(counts.entries())\n        .filter(([, count]) => count > 1)\n        .map(([id, count]) => ({ id: id.slice(0, 8), count }))\n\n    if (duplicates.length > 0) {\n        console.error(`[SUPABASE-DUPLICATES] ${context}`, {\n            duplicates,\n            totalCount: tasks.length,\n            uniqueCount: counts.size\n        })\n    } else {\n        console.debug(`[SUPABASE-HISTOGRAM] ${context}`, {\n            totalCount: tasks.length,\n            uniqueCount: counts.size\n        })\n    }\n}\n\n/**\n * Log group ID histogram from Supabase fetch results\n *\n * Call after fetchGroups() to detect if Supabase returns duplicates.\n * This would indicate a database-level issue (multiple rows with same ID).\n *\n * @param groups - Array of groups from Supabase\n * @param context - Description of the fetch (e.g., 'loadFromDatabase')\n */\nexport function logSupabaseGroupIdHistogram(\n    groups: Array<{ id: string; name?: string }>,\n    context: string\n): void {\n    if (!isDev) return\n\n    const counts = new Map<string, number>()\n    for (const group of groups) {\n        counts.set(group.id, (counts.get(group.id) ?? 0) + 1)\n    }\n\n    const duplicates = Array.from(counts.entries())\n        .filter(([, count]) => count > 1)\n        .map(([id, count]) => ({ id: id.slice(0, 8), count }))\n\n    if (duplicates.length > 0) {\n        console.error(`[SUPABASE-GROUP-DUPLICATES] ${context}`, {\n            duplicates,\n            totalCount: groups.length,\n            uniqueCount: counts.size\n        })\n    } else {\n        console.debug(`[SUPABASE-GROUP-HISTOGRAM] ${context}`, {\n            totalCount: groups.length,\n            uniqueCount: counts.size\n        })\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/positionCalculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/resourceManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/spatialContainment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/canvas/storeHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":244,"column":54,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":244,"endColumn":62,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[8394,8395],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Task } from '@/types/tasks'\nimport { type CanvasGroup, type ContainerBounds } from '@/types/canvas'\nimport { assertNoDuplicateIds } from '@/utils/canvas/invariants'\nimport { getGroupAbsolutePosition } from '@/utils/canvas/coordinates'\nimport { isNodeCompletelyInside } from '@/utils/canvas/spatialContainment'\nimport { detectPowerKeyword } from '@/composables/usePowerKeywords'\n\n/**\n * DIAGNOSTIC HELPER: Log group ID histogram to detect duplicates (AUTHORITATIVE)\n */\nexport const logGroupIdHistogram = (label: string, groups: CanvasGroup[]) => {\n    if (!import.meta.env.DEV) return\n\n    const checkResult = assertNoDuplicateIds(groups, label)\n\n    if (checkResult.hasDuplicates) {\n        console.error('[GROUP-ID-HISTOGRAM] DUPLICATES', label, {\n            duplicates: checkResult.duplicates.map(d => ({ id: d.id.slice(0, 8), count: d.count })),\n            totalCount: checkResult.totalCount,\n            uniqueIdCount: checkResult.uniqueIdCount\n        })\n    } else if (groups.length > 0) {\n        console.debug('[GROUP-ID-HISTOGRAM]', label, {\n            uniqueIdCount: checkResult.uniqueIdCount,\n            totalCount: checkResult.totalCount\n        })\n    }\n}\n\n/**\n * CYCLE & INVALID PARENT CLEANUP: Break cycles and clear invalid parentGroupId references\n *\n * This function runs on load to fix data integrity issues:\n * 1. Breaks parent cycles (A → B → A)\n * 2. Clears references to non-existent groups\n * 3. Clears references to task IDs (groups can only have group parents)\n */\nexport function breakGroupCycles(groups: CanvasGroup[]): CanvasGroup[] {\n    console.log('[GROUPS] breakGroupCycles called with', groups.length, 'groups')\n\n    const byId = new Map(groups.map(g => [g.id, g]))\n    const validGroupIds = new Set(groups.map(g => g.id))\n    let cyclesBroken = 0\n    let invalidParentsCleared = 0\n\n    for (const g of groups) {\n        if (!g.parentGroupId || g.parentGroupId === 'NONE') continue\n\n        // CHECK 1: Parent must be a valid group ID (not a task ID, not non-existent)\n        if (!validGroupIds.has(g.parentGroupId)) {\n            console.warn('[GROUPS] Clearing invalid parentGroupId (not a valid group)', {\n                groupId: g.id,\n                groupName: g.name,\n                invalidParentGroupId: g.parentGroupId,\n            })\n            g.parentGroupId = null\n            invalidParentsCleared++\n            continue\n        }\n\n        // CHECK 2: No cycles\n        const visited = new Set<string>()\n        let current: CanvasGroup | undefined = g\n        let hasCycle = false\n\n        while (current && current.parentGroupId && current.parentGroupId !== 'NONE') {\n            if (visited.has(current.id)) {\n                hasCycle = true\n                break\n            }\n            visited.add(current.id)\n            current = byId.get(current.parentGroupId)\n        }\n\n        if (current && visited.has(current.id)) {\n            hasCycle = true\n        }\n\n        if (hasCycle) {\n            console.warn('[GROUPS] Breaking cycle by clearing parentGroupId', {\n                groupId: g.id,\n                groupName: g.name,\n                oldParentGroupId: g.parentGroupId,\n            })\n            g.parentGroupId = null\n            cyclesBroken++\n        }\n    }\n\n    if (cyclesBroken > 0 || invalidParentsCleared > 0) {\n        console.log(`[GROUPS] Fixed ${cyclesBroken} cycle(s), ${invalidParentsCleared} invalid parent(s)`)\n    }\n\n    return groups\n}\n\n/**\n * EMERGENCY FIX: Reset all groups to root level (clears all parentGroupId)\n *\n * Use this when groups are incorrectly moving together due to corrupted parent relationships.\n * This makes all groups independent (root level) so they move independently.\n */\nexport function resetAllGroupsToRoot(groups: CanvasGroup[]): CanvasGroup[] {\n    let clearedCount = 0\n\n    for (const g of groups) {\n        if (g.parentGroupId && g.parentGroupId !== 'NONE') {\n            console.log('[GROUPS] Resetting to root:', {\n                groupId: g.id,\n                groupName: g.name,\n                wasParent: g.parentGroupId,\n            })\n            g.parentGroupId = null\n            clearedCount++\n        }\n    }\n\n    if (clearedCount > 0) {\n        console.log(`[GROUPS] Reset ${clearedCount} group(s) to root level`)\n    }\n\n    return groups\n}\n\n/**\n * Helper: Normalize Smart Group names and colors\n */\nexport const applySmartGroupNormalizations = (group: Omit<CanvasGroup, 'id'> | Partial<CanvasGroup>) => {\n    if (!group.name) return\n\n    const nameLower = group.name.toLowerCase().trim()\n\n    if (nameLower === 'overdue') {\n        group.name = 'Overdue'\n        group.color = '#ef4444'\n        return\n    }\n\n    const powerInfo = detectPowerKeyword(group.name)\n    if (powerInfo) {\n        group.name = powerInfo.displayName\n\n        if (!group.color || group.color === '#6366f1') {\n            switch (powerInfo.category) {\n                case 'priority':\n                    if (powerInfo.value === 'high') group.color = '#ef4444'\n                    else if (powerInfo.value === 'medium') group.color = '#f59e0b'\n                    else if (powerInfo.value === 'low') group.color = '#3b82f6'\n                    break\n                case 'status':\n                    if (powerInfo.value === 'done') group.color = '#10b981'\n                    else if (powerInfo.value === 'in_progress') group.color = '#f59e0b'\n                    break\n                case 'date':\n                    group.color = '#8b5cf6'\n                    break\n            }\n        }\n    }\n}\n\n/**\n * Visual Containment Count - counts tasks that are VISUALLY inside the group bounds\n */\nexport const getTaskCountInGroupRecursive = (groupId: string, groups: CanvasGroup[], tasks: Task[], visited = new Set<string>()): number => {\n    if (visited.has(groupId)) {\n        console.warn(`🔄[CANVAS] Cycle detected in group hierarchy at ${groupId}`)\n        return 0\n    }\n    visited.add(groupId)\n\n    const group = groups.find(g => g.id === groupId)\n    if (!group) return 0\n\n    const groupAbsolutePos = getGroupAbsolutePosition(groupId, groups)\n\n    const containerBounds: ContainerBounds = {\n        position: groupAbsolutePos,\n        width: group.position.width,\n        height: group.position.height\n    }\n\n    let count = tasks.filter(t => {\n        if (!t.canvasPosition || t._soft_deleted) return false\n        const taskNode = { position: t.canvasPosition }\n        return isNodeCompletelyInside(taskNode, containerBounds)\n    }).length\n\n    const childGroups = groups.filter(g => g.parentGroupId === groupId)\n    for (const child of childGroups) {\n        count += getTaskCountInGroupRecursive(child.id, groups, tasks, visited)\n    }\n\n    return count\n}\n\n/**\n * Get parent chain for a group (bottom-up: child -> parent -> grandparent)\n * Cycle-safe via visited set.\n *\n * TASK-1177: Used for property inheritance in nested groups.\n * When a task is dropped into a child group, we traverse up the chain\n * to collect properties from all ancestor groups.\n *\n * @param groupId - The starting group ID\n * @param groups - All canvas groups\n * @param maxDepth - Maximum depth to traverse (default: 10)\n * @returns Array of groups from child to root [child, parent, grandparent, ...]\n */\nexport function getParentChain(\n    groupId: string,\n    groups: CanvasGroup[],\n    maxDepth: number = 10\n): CanvasGroup[] {\n    // Safety check: require valid groupId and groups array\n    if (!groupId || !groups || groups.length === 0) {\n        return []\n    }\n\n    const chain: CanvasGroup[] = []\n    const visited = new Set<string>()\n    let current = groups.find(g => g.id === groupId)\n\n    if (import.meta.env.DEV) {\n        console.log(`[CANVAS:PARENT-CHAIN] Starting for groupId=${groupId.slice(0, 8)}`, {\n            found: !!current,\n            currentName: current?.name,\n            currentParentGroupId: current?.parentGroupId ?? 'NONE/UNDEFINED'\n        })\n    }\n\n    while (current && chain.length < maxDepth) {\n        if (visited.has(current.id)) break // Cycle detected\n        visited.add(current.id)\n        chain.push(current)\n\n        if (!current.parentGroupId || current.parentGroupId === 'NONE') {\n            if (import.meta.env.DEV) {\n                console.log(`[CANVAS:PARENT-CHAIN] Stopping at \"${current.name}\" - no parentGroupId`)\n            }\n            break\n        }\n\n        const nextParent = groups.find(g => g.id === current!.parentGroupId)\n        if (import.meta.env.DEV) {\n            console.log(`[CANVAS:PARENT-CHAIN] \"${current.name}\" has parent ${current.parentGroupId.slice(0, 8)} -> found: ${nextParent?.name ?? 'NOT FOUND'}`)\n        }\n        current = nextParent\n    }\n\n    return chain // [child, parent, grandparent, ...]\n}\n\n/**\n * Get all descendant group IDs for a given root group (depth-first)\n */\nexport const getAllDescendantGroupIds = (rootGroupId: string, groups: CanvasGroup[]): string[] => {\n    const result: string[] = [rootGroupId]\n    const visited = new Set<string>([rootGroupId])\n\n    const collectDescendants = (parentId: string) => {\n        const children = groups.filter(g => g.parentGroupId === parentId)\n        for (const child of children) {\n            if (!visited.has(child.id)) {\n                visited.add(child.id)\n                result.push(child.id)\n                collectDescendants(child.id)\n            }\n        }\n    }\n\n    collectDescendants(rootGroupId)\n    return result\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/contextMenuCoordinates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/cspManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/dateUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/deletedGroupsTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/demoContentGuard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/dom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/durationCategories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/emojiSvgMap.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/globalKeyboardHandlerSimple.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/guestModeStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/integrity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/markdown.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2407,2410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2407,2410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2696,2699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2696,2699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { marked } from 'marked'\nimport DOMPurify from 'dompurify'\n\n/**\n * Sanitize URL to prevent XSS via javascript:, data:, and other dangerous protocols\n * Returns the safe URL or null if the URL is unsafe\n */\nconst SAFE_PROTOCOLS = new Set(['http:', 'https:', 'mailto:'])\nconst BLOCKED_PROTOCOLS = new Set(['javascript:', 'vbscript:', 'data:', 'file:', 'blob:'])\n\nfunction sanitizeUrl(href: string | null | undefined): string | null {\n  if (!href || typeof href !== 'string') return null\n\n  // Normalize and trim\n  const normalizedHref = href.trim().toLowerCase()\n\n  // Check for blocked protocols BEFORE URL parsing (catches obfuscation)\n  for (const blocked of BLOCKED_PROTOCOLS) {\n    if (normalizedHref.startsWith(blocked) ||\n      normalizedHref.includes('\\n' + blocked) ||\n      normalizedHref.includes('\\r' + blocked) ||\n      normalizedHref.includes('\\t' + blocked)) {\n      return null\n    }\n  }\n\n  // Check for URL-encoded dangerous protocols\n  try {\n    const decoded = decodeURIComponent(href)\n    const decodedLower = decoded.toLowerCase()\n    if (decodedLower.startsWith('javascript:') ||\n      decodedLower.startsWith('vbscript:') ||\n      decodedLower.startsWith('data:')) {\n      return null\n    }\n  } catch {\n    // decodeURIComponent failed - URL might be malformed, allow URL parsing to handle it\n  }\n\n  try {\n    const url = new URL(href, window.location.origin)\n\n    // Explicit protocol allowlist check\n    if (!SAFE_PROTOCOLS.has(url.protocol)) {\n      return null\n    }\n\n    // Block protocol-relative URLs that could redirect to malicious sites\n    if (href.startsWith('//')) {\n      return null\n    }\n\n    return url.href\n  } catch {\n    // Invalid URL - return null for safety\n    return null\n  }\n}\n\n/**\n * Configure marked for our needs\n * IMPORTANT: For Tiptap compatibility, task lists must use data-type attributes\n */\nmarked.use({\n  gfm: true,\n  breaks: true,\n  silent: true,\n  renderer: {\n    link({ href, title, text }) {\n      // Sanitize URL to prevent XSS attacks\n      const safeHref = sanitizeUrl(href)\n      if (!safeHref) {\n        // Unsafe URL - render as plain text instead of link\n        return text\n      }\n      return `<a href=\"${safeHref}\" title=\"${title || ''}\" target=\"_blank\" rel=\"noopener noreferrer\">${text}</a>`\n    },\n    list({ items, ordered, start }) {\n      const tag = ordered ? 'ol' : 'ul'\n      const isTask = items.some(item => (item as any).task)\n      // For Tiptap: use data-type=\"taskList\" instead of class\n      const dataAttr = isTask ? ' data-type=\"taskList\"' : ''\n      const startAttr = ordered && start !== 1 ? ` start=\"${start}\"` : ''\n\n      let body = ''\n      for (const item of items) {\n        body += (this as any).listitem(item)\n      }\n\n      return `<${tag}${dataAttr}${startAttr}>\\n${body}</${tag}>\\n`\n    },\n    // For Tiptap: task list items need data-type=\"taskItem\" and data-checked attributes\n    listitem({ text, task, checked }) {\n      if (task) {\n        // Tiptap TaskItem format: <li data-type=\"taskItem\" data-checked=\"true/false\">\n        const checkedVal = checked ? 'true' : 'false'\n        return `<li data-type=\"taskItem\" data-checked=\"${checkedVal}\"><label><input type=\"checkbox\" ${checked ? 'checked' : ''}></label><div>${text}</div></li>\\n`\n      }\n      return `<li>${text}</li>\\n`\n    }\n  }\n})\n\n/**\n * Parses markdown into safe HTML\n */\nexport const parseMarkdown = (content: string): string => {\n  if (!content) return ''\n\n  try {\n    // marked.parse is synchronous for strings in most environments\n    const rawHtml = marked.parse(content) as string\n\n    // Sanitize with checkbox support and Tiptap data attributes\n    const sanitized = DOMPurify.sanitize(rawHtml, {\n      ADD_TAGS: ['input', 'mark'],\n      ADD_ATTR: ['type', 'checked', 'class', 'disabled', 'data-type', 'data-checked']\n    })\n\n    // Convert ==highlight== syntax to <mark> for Tiptap's Highlight extension\n    // This is a non-standard markdown extension commonly used in Obsidian and other editors\n    const withHighlight = sanitized.replace(/==(.*?)==/g, '<mark>$1</mark>')\n\n    return withHighlight\n  } catch (error) {\n    console.error('Error parsing markdown:', error)\n    return content // Fallback to raw text\n  }\n}\n\n/**\n * Convert HTML to Markdown (BUG-013 FIX)\n * Simple conversion for Tiptap output - handles common formatting\n */\nexport function htmlToMarkdown(html: string): string {\n  if (!html || typeof html !== 'string') return ''\n\n  let markdown = html\n\n  // Sanitize first to prevent any XSS in the processing\n  markdown = DOMPurify.sanitize(markdown)\n\n  // BUG-276 FIX: Process TipTap TaskItem elements FIRST\n  // TipTap structure: <li data-type=\"taskItem\" data-checked=\"true/false\"><label><input...></label><div>content</div></li>\n  // Extract text from the <div> inside and convert based on data-checked attribute\n  // Handle both attribute orders (data-type before data-checked and vice versa)\n  markdown = markdown.replace(/<li[^>]*data-type=[\"']taskItem[\"'][^>]*data-checked=[\"']true[\"'][^>]*>[\\s\\S]*?<div[^>]*>([\\s\\S]*?)<\\/div>[\\s\\S]*?<\\/li>/gi, '- [x] $1\\n')\n  markdown = markdown.replace(/<li[^>]*data-type=[\"']taskItem[\"'][^>]*data-checked=[\"']false[\"'][^>]*>[\\s\\S]*?<div[^>]*>([\\s\\S]*?)<\\/div>[\\s\\S]*?<\\/li>/gi, '- [ ] $1\\n')\n  markdown = markdown.replace(/<li[^>]*data-checked=[\"']true[\"'][^>]*data-type=[\"']taskItem[\"'][^>]*>[\\s\\S]*?<div[^>]*>([\\s\\S]*?)<\\/div>[\\s\\S]*?<\\/li>/gi, '- [x] $1\\n')\n  markdown = markdown.replace(/<li[^>]*data-checked=[\"']false[\"'][^>]*data-type=[\"']taskItem[\"'][^>]*>[\\s\\S]*?<div[^>]*>([\\s\\S]*?)<\\/div>[\\s\\S]*?<\\/li>/gi, '- [ ] $1\\n')\n\n  // Remove any remaining checkbox inputs and labels (they've been processed above)\n  markdown = markdown.replace(/<label[^>]*>[\\s\\S]*?<\\/label>/gi, '')\n  markdown = markdown.replace(/<input[^>]*type=[\"']?checkbox[\"']?[^>]*>/gi, '')\n\n  // Bold: <strong> or <b> -> **text**\n  markdown = markdown.replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '**$1**')\n  markdown = markdown.replace(/<b[^>]*>(.*?)<\\/b>/gi, '**$1**')\n\n  // Italic: <em> or <i> -> *text*\n  markdown = markdown.replace(/<em[^>]*>(.*?)<\\/em>/gi, '*$1*')\n  markdown = markdown.replace(/<i[^>]*>(.*?)<\\/i>/gi, '*$1*')\n\n  // Strikethrough: <s> or <del> -> ~~text~~\n  markdown = markdown.replace(/<s[^>]*>(.*?)<\\/s>/gi, '~~$1~~')\n  markdown = markdown.replace(/<del[^>]*>(.*?)<\\/del>/gi, '~~$1~~')\n\n  // Underline: <u> -> no standard markdown, keep as HTML for now\n  // Some parsers support __text__ but it conflicts with bold\n  markdown = markdown.replace(/<u[^>]*>(.*?)<\\/u>/gi, '<u>$1</u>')\n\n  // Highlight: <mark> -> ==text== (some markdown flavors support this)\n  markdown = markdown.replace(/<mark[^>]*>(.*?)<\\/mark>/gi, '==$1==')\n\n  // Tables: Convert HTML tables to markdown tables\n  // This is a simplified conversion - handles basic tables\n  markdown = markdown.replace(/<table[^>]*>([\\s\\S]*?)<\\/table>/gi, (_, tableContent) => {\n    const rows: string[][] = []\n    const headerMatch = tableContent.match(/<thead[^>]*>([\\s\\S]*?)<\\/thead>/i)\n    const bodyMatch = tableContent.match(/<tbody[^>]*>([\\s\\S]*?)<\\/tbody>/i)\n\n    // Process header\n    if (headerMatch) {\n      const headerRow = headerMatch[1].match(/<tr[^>]*>([\\s\\S]*?)<\\/tr>/i)\n      if (headerRow) {\n        const cells = headerRow[1].match(/<th[^>]*>([\\s\\S]*?)<\\/th>/gi) || []\n        rows.push(cells.map((cell: string) => cell.replace(/<th[^>]*>([\\s\\S]*?)<\\/th>/i, '$1').replace(/<[^>]+>/g, '').trim()))\n      }\n    }\n\n    // Process body rows\n    const content = bodyMatch ? bodyMatch[1] : tableContent\n    const bodyRows = content.match(/<tr[^>]*>[\\s\\S]*?<\\/tr>/gi) || []\n    for (const row of bodyRows) {\n      const cells = row.match(/<t[dh][^>]*>([\\s\\S]*?)<\\/t[dh]>/gi) || []\n      if (cells.length > 0) {\n        rows.push(cells.map((cell: string) => cell.replace(/<t[dh][^>]*>([\\s\\S]*?)<\\/t[dh]>/i, '$1').replace(/<[^>]+>/g, '').trim()))\n      }\n    }\n\n    if (rows.length === 0) return ''\n\n    // Build markdown table\n    const colCount = Math.max(...rows.map(r => r.length))\n    let mdTable = '\\n'\n\n    // First row (header or first data row)\n    mdTable += '| ' + rows[0].map(c => c || ' ').join(' | ') + ' |\\n'\n    // Separator\n    mdTable += '| ' + Array(colCount).fill('---').join(' | ') + ' |\\n'\n    // Remaining rows\n    for (let i = 1; i < rows.length; i++) {\n      mdTable += '| ' + rows[i].map(c => c || ' ').join(' | ') + ' |\\n'\n    }\n\n    return mdTable\n  })\n\n  // Horizontal rule: <hr> -> ---\n  markdown = markdown.replace(/<hr[^>]*\\/?>/gi, '\\n---\\n')\n\n  // Links: <a href=\"url\">text</a> -> [text](url)\n  markdown = markdown.replace(/<a[^>]*href=[\"']([^\"']*)[\"'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)')\n\n  // Code blocks: <pre><code> -> ```code```\n  markdown = markdown.replace(/<pre[^>]*><code[^>]*>([\\s\\S]*?)<\\/code><\\/pre>/gi, '\\n```\\n$1\\n```\\n')\n  markdown = markdown.replace(/<pre[^>]*>([\\s\\S]*?)<\\/pre>/gi, '\\n```\\n$1\\n```\\n')\n\n  // Inline code: <code> -> `text`\n  markdown = markdown.replace(/<code[^>]*>(.*?)<\\/code>/gi, '`$1`')\n\n  // Headings\n  markdown = markdown.replace(/<h1[^>]*>(.*?)<\\/h1>/gi, '# $1\\n')\n  markdown = markdown.replace(/<h2[^>]*>(.*?)<\\/h2>/gi, '## $1\\n')\n  markdown = markdown.replace(/<h3[^>]*>(.*?)<\\/h3>/gi, '### $1\\n')\n\n  // List items: <li> -> - (task items with data-type=\"taskItem\" already handled at top of function)\n  // BUG-276 FIX: Only handle regular list items here, task items are processed earlier\n  markdown = markdown.replace(/<li[^>]*>(.*?)<\\/li>/gi, '- $1\\n')\n\n  // Remove list wrappers\n  markdown = markdown.replace(/<\\/?ul[^>]*>/gi, '')\n  markdown = markdown.replace(/<\\/?ol[^>]*>/gi, '')\n\n  // Paragraphs: <p> -> text with newline\n  markdown = markdown.replace(/<p[^>]*>(.*?)<\\/p>/gi, '$1\\n')\n\n  // Line breaks\n  markdown = markdown.replace(/<br\\s*\\/?>/gi, '\\n')\n\n  // Blockquotes\n  markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\\/blockquote>/gi, '> $1\\n')\n\n  // Remove any remaining HTML tags\n  markdown = markdown.replace(/<[^>]+>/g, '')\n\n  // Decode HTML entities\n  markdown = markdown.replace(/&nbsp;/g, ' ')\n  markdown = markdown.replace(/&amp;/g, '&')\n  markdown = markdown.replace(/&lt;/g, '<')\n  markdown = markdown.replace(/&gt;/g, '>')\n  markdown = markdown.replace(/&quot;/g, '\"')\n  markdown = markdown.replace(/&#39;/g, \"'\")\n\n  // Clean up extra whitespace\n  markdown = markdown.replace(/\\n{3,}/g, '\\n\\n')\n  markdown = markdown.trim()\n\n  return markdown\n}\n\n// Export sanitizeUrl for use in TiptapEditor link validation (BUG-014 FIX)\nexport { sanitizeUrl }\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/mockTaskDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/notificationDelivery.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[660,663],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[660,663],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TASK-1219: Shared notification delivery utility\n *\n * BUG-1289: tauri-plugin-notification v2.3.3 on Linux calls block_on() inside\n * the tokio runtime, causing a fatal panic. Browser Notification API avoids Rust.\n *\n * BUG-1302: Added logging, error handling, and native Linux notify-send support.\n * In Tauri on Linux, Browser Notification API doesn't integrate with KDE Plasma.\n * We use `notify-send` (freedesktop DBus) which shows in KDE's notification area.\n */\n\ninterface DeliveryOptions {\n  title: string\n  body: string\n  tag?: string\n  sound?: boolean\n}\n\n/** Detect if running inside Tauri */\nfunction isTauri(): boolean {\n  return !!(window as any).__TAURI_INTERNALS__\n}\n\n/**\n * Send native Linux desktop notification via notify-send (freedesktop DBus).\n * Works with KDE Plasma, GNOME, XFCE, and other freedesktop-compliant DEs.\n */\nasync function deliverViaNativeLinux(options: DeliveryOptions): Promise<boolean> {\n  try {\n    const { Command } = await import('@tauri-apps/plugin-shell')\n\n    const args = [\n      '--app-name=FlowState',\n      '--icon=dialog-information',\n      options.title,\n      options.body\n    ]\n\n    const result = await Command.create('notify-send', args).execute()\n\n    if (result.code === 0) {\n      console.log('[NOTIFY] Native Linux notification delivered via notify-send')\n      return true\n    } else {\n      console.warn('[NOTIFY] notify-send failed:', result.stderr)\n      return false\n    }\n  } catch (error) {\n    console.warn('[NOTIFY] Native Linux delivery failed:', error)\n    return false\n  }\n}\n\n/**\n * Deliver a notification via Browser Notification API (fallback for non-Tauri).\n */\nasync function deliverViaBrowserAPI(options: DeliveryOptions): Promise<boolean> {\n  const { title, body, tag, sound = true } = options\n\n  if (!('Notification' in window)) {\n    console.warn('[NOTIFY] Browser Notification API not available')\n    return false\n  }\n\n  try {\n    if (Notification.permission === 'granted') {\n      new Notification(title, {\n        body,\n        icon: '/favicon.ico',\n        tag: tag || undefined,\n        silent: !sound\n      })\n      return true\n    } else if (Notification.permission === 'default') {\n      // BUG-1303: Skip Notification.requestPermission() in Tauri — WebKitGTK hangs\n      if (isTauri()) {\n        console.warn('[NOTIFY] Skipping permission request in Tauri (WebKitGTK hangs)')\n        return false\n      }\n      console.log('[NOTIFY] Permission not yet granted, requesting...')\n      const permission = await Notification.requestPermission()\n      console.log('[NOTIFY] Permission result:', permission)\n      if (permission === 'granted') {\n        new Notification(title, {\n          body,\n          icon: '/favicon.ico',\n          tag: tag || undefined,\n          silent: !sound\n        })\n        return true\n      }\n      console.warn('[NOTIFY] Permission not granted:', permission)\n      return false\n    } else {\n      console.warn('[NOTIFY] Permission denied — cannot deliver OS notification')\n      return false\n    }\n  } catch (error) {\n    console.error('[NOTIFY] Browser API failed:', error)\n    return false\n  }\n}\n\n/**\n * Deliver a notification using the best available method:\n * - Tauri + Linux → notify-send (KDE Plasma / freedesktop compatible)\n * - Browser / PWA → Browser Notification API\n */\nexport async function deliverNotification(options: DeliveryOptions): Promise<boolean> {\n  // In Tauri on Linux, use notify-send for native KDE Plasma integration\n  if (isTauri() && navigator.platform?.toLowerCase().includes('linux')) {\n    const nativeSuccess = await deliverViaNativeLinux(options)\n    if (nativeSuccess) return true\n    // Fall through to Browser API if notify-send fails (e.g., not installed)\n    console.log('[NOTIFY] Falling back to Browser Notification API')\n  }\n\n  return deliverViaBrowserAPI(options)\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/performanceBenchmark.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4749,4752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4749,4752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5039,5042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5039,5042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":170,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5107,5110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5107,5110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5653,5656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5653,5656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5684,5687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5684,5687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5710,5713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5710,5713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5779,5782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5779,5782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5808,5811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5808,5811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5830,5833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5830,5833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Benchmarking Suite\n * Comprehensive performance testing and validation for the Pomo-Flow application\n */\n\nimport { ref } from 'vue'\nimport { usePerformanceManager } from '@/composables/usePerformanceManager'\nimport { useVirtualScrolling } from '@/composables/useVirtualScrolling'\nimport { useNetworkOptimizer } from '@/composables/useNetworkOptimizer'\nimport { useRenderOptimization } from '@/composables/useRenderOptimization'\n\nexport interface BenchmarkConfig {\n  iterations?: number\n  timeout?: number\n  warmupIterations?: number\n  enableMemoryProfiling?: boolean\n  enableCPUGProfiling?: boolean\n  enableNetworkProfiling?: boolean\n}\n\nexport interface BenchmarkResult {\n  name: string\n  iterations: number\n  totalTime: number\n  averageTime: number\n  minTime: number\n  maxTime: number\n  standardDeviation: number\n  throughput: number\n  memoryUsage?: number\n  memoryDelta?: number\n  cpuUsage?: number\n  successRate: number\n  errors: string[]\n}\n\nexport interface BenchmarkSuite {\n  canvasPerformance: BenchmarkResult\n  virtualScrolling: BenchmarkResult\n  taskStoreOperations: BenchmarkResult\n  networkRequests: BenchmarkResult\n  renderPerformance: BenchmarkResult\n  memoryEfficiency: BenchmarkResult\n  bundleSize: BenchmarkResult\n}\n\nexport interface PerformanceThresholds {\n  maxAverageRenderTime: number\n  maxMemoryUsage: number\n  minCacheHitRate: number\n  minNetworkEfficiency: number\n  maxBundleSize: number\n  minThroughput: number\n}\n\nexport const PERFORMANCE_THRESHOLDS: PerformanceThresholds = {\n  maxAverageRenderTime: 16, // 60fps\n  maxMemoryUsage: 100 * 1024 * 1024, // 100MB\n  minCacheHitRate: 0.8, // 80%\n  minNetworkEfficiency: 0.7, // 70%\n  maxBundleSize: 500 * 1024, // 500KB\n  minThroughput: 1000 // operations per second\n}\n\nexport class PerformanceBenchmark {\n  private performanceManager = usePerformanceManager()\n  private networkOptimizer = useNetworkOptimizer()\n  private renderOptimizer = useRenderOptimization()\n\n  private results = ref<Partial<BenchmarkSuite>>({})\n  private isRunning = ref(false)\n  private progress = ref(0)\n\n  // Memory tracking\n  private initialMemory = 0\n  private memorySnapshots: number[] = []\n\n  // CPU tracking\n  private cpuSnapshots: number[] = []\n\n  constructor(private config: BenchmarkConfig = {}) {\n    this.config = {\n      iterations: 100,\n      timeout: 30000,\n      warmupIterations: 10,\n      enableMemoryProfiling: true,\n      enableCPUGProfiling: true,\n      enableNetworkProfiling: true,\n      ...config\n    }\n  }\n\n  // Main benchmark execution\n  async runFullSuite(): Promise<BenchmarkSuite> {\n    console.log('🚀 Starting performance benchmark suite...')\n    this.isRunning.value = true\n    this.progress.value = 0\n\n    try {\n      // Initial memory snapshot\n      this.initialMemory = this.getMemoryUsage()\n\n      // Run benchmarks\n      const results = {\n        canvasPerformance: await this.benchmarkCanvasPerformance(),\n        virtualScrolling: await this.benchmarkVirtualScrolling(),\n        taskStoreOperations: await this.benchmarkTaskStoreOperations(),\n        networkRequests: await this.benchmarkNetworkRequests(),\n        renderPerformance: await this.benchmarkRenderPerformance(),\n        memoryEfficiency: await this.benchmarkMemoryEfficiency(),\n        bundleSize: await this.benchmarkBundleSize()\n      }\n\n      this.results.value = results\n\n      // Generate report\n      await this.generateReport(results)\n\n      this.progress.value = 100\n      return results\n\n    } finally {\n      this.isRunning.value = false\n    }\n  }\n\n  // Canvas performance benchmark\n  private async benchmarkCanvasPerformance(): Promise<BenchmarkResult> {\n    console.log('🖼️ Benchmarking canvas performance...')\n    const times: number[] = []\n    const errors: string[] = []\n\n    const nodeCounts = [100, 500, 1000]\n\n    try {\n      // Lazy load stores to avoid circular dependencies\n      const { useTaskStore } = await import('@/stores/tasks')\n      const { useCanvasStore } = await import('@/stores/canvas')\n      const taskStore = useTaskStore()\n      const canvasStore = useCanvasStore()\n\n      for (const nodeCount of nodeCounts) {\n        const startTime = performance.now()\n\n        // 1. Create tasks\n        const testTasks = Array.from({ length: nodeCount }, (_, i) => ({\n          id: `bench-task-${nodeCount}-${i}`,\n          title: `Benchmark Task ${i}`,\n          status: 'planned' as const,\n          priority: 'medium' as const,\n          projectId: 'bench-project',\n          canvasPosition: { x: (i % 20) * 250, y: Math.floor(i / 20) * 150 },\n          isInInbox: false,\n          subtasks: [],\n          tags: [],\n          createdAt: new Date(),\n          updatedAt: new Date()\n        }))\n\n          // Measure batch addition\n          ; (taskStore as any)._rawTasks.push(...testTasks)\n\n        // Wait for next tick to ensure computed properties update\n        const { nextTick } = await import('vue')\n        await nextTick()\n\n        // 2. Measure Canvas Sync\n        const syncStart = performance.now()\n        if (typeof (canvasStore as any).syncTasksToCanvas === 'function') {\n           (canvasStore as any).syncTasksToCanvas(taskStore.tasks || [])\n        }\n        const syncEnd = performance.now()\n\n        // 3. Measure Render (wait for multiple frames to ensure layout)\n        await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)))\n        const renderEnd = performance.now()\n\n        const duration = renderEnd - startTime\n        // Ensure duration is at least very small but non-zero for stats if work was done\n        times.push(Math.max(duration, 0.001))\n\n          // Cleanup\n          ; (taskStore as any)._rawTasks = (taskStore as any)._rawTasks.filter((t: any) => !t.id.startsWith('bench-task-'))\n          ; (canvasStore as any).nodes = (canvasStore as any).nodes.filter((n: any) => !n.id.startsWith('bench-task-'))\n        await nextTick()\n\n        console.log(`   - ${nodeCount} nodes: ${duration.toFixed(2)}ms (Sync: ${(syncEnd - syncStart).toFixed(2)}ms)`)\n      }\n\n    } catch (error) {\n      errors.push(error instanceof Error ? error.message : String(error))\n    }\n\n    this.progress.value = 10\n    return this.calculateBenchmarkResult('Canvas Performance', times, errors)\n  }\n\n  // Virtual scrolling benchmark\n  private async benchmarkVirtualScrolling(): Promise<BenchmarkResult> {\n    console.log('📊 Benchmarking virtual scrolling...')\n\n    const itemCounts = [100, 500, 1000, 5000, 10000]\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupVirtualScrolling()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const itemCount = itemCounts[i % itemCounts.length]\n      const items = Array.from({ length: itemCount }, (_, index) => ({\n        id: index,\n        title: `Task ${index}`,\n        height: 60 + Math.random() * 40,\n        data: { id: index, title: `Task ${index}` }\n      }))\n\n      try {\n        const startTime = performance.now()\n\n        // Create virtual scrolling instance\n        const virtualScroll = useVirtualScrolling(items, {\n          itemHeight: 80,\n          containerHeight: 600,\n          threshold: 100\n        })\n\n        // Simulate scrolling operations\n        for (let scroll = 0; scroll < 10; scroll++) {\n          virtualScroll.scrollToItem(Math.floor(Math.random() * itemCount))\n          await new Promise(resolve => setTimeout(resolve, 10))\n        }\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n        // Memory snapshot\n        if (this.config.enableMemoryProfiling) {\n          this.memorySnapshots.push(this.getMemoryUsage())\n        }\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = (i / (this.config.iterations || 5)) * 20 // 20% of total\n    }\n\n    return this.calculateBenchmarkResult('Virtual Scrolling', times, errors)\n  }\n\n  // Task store operations benchmark\n  private async benchmarkTaskStoreOperations(): Promise<BenchmarkResult> {\n    console.log('💾 Benchmarking task store operations...')\n\n    const operations = ['create', 'read', 'update', 'delete'] as const\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupTaskStore()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const operation = operations[i % operations.length]\n      const task = {\n        id: `task-${i}`,\n        title: `Test Task ${i}`,\n        status: 'pending',\n        priority: 'medium',\n        timestamp: Date.now()\n      }\n\n      try {\n        const startTime = performance.now()\n\n        // Simulate task store operation\n        switch (operation) {\n          case 'create':\n            await this.simulateTaskCreate(task)\n            break\n          case 'read':\n            await this.simulateTaskRead(task.id)\n            break\n          case 'update':\n            await this.simulateTaskUpdate(task)\n            break\n          case 'delete':\n            await this.simulateTaskDelete(task.id)\n            break\n        }\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 20 + (i / (this.config.iterations || 5)) * 15 // 20-35% of total\n    }\n\n    return this.calculateBenchmarkResult('Task Store Operations', times, errors)\n  }\n\n  // Network requests benchmark\n  private async benchmarkNetworkRequests(): Promise<BenchmarkResult> {\n    console.log('🌐 Benchmarking network requests...')\n\n    const endpoints = [\n      { url: 'https://in-theflow.com', method: 'GET' as const },\n      { url: 'https://in-theflow.com', method: 'GET' as const },\n      { url: 'https://in-theflow.com', method: 'GET' as const }\n    ]\n\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupNetworkRequests()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const endpoint = endpoints[i % endpoints.length]\n      const data = i % 2 === 0 ? null : { test: 'data', index: i }\n\n      try {\n        const startTime = performance.now()\n\n        // Use network optimizer for request\n        await this.networkOptimizer.makeRequest({\n          url: endpoint.url,\n          method: endpoint.method,\n          data,\n          priority: 'normal'\n        })\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 35 + (i / (this.config.iterations || 5)) * 15 // 35-50% of total\n    }\n\n    return this.calculateBenchmarkResult('Network Requests', times, errors)\n  }\n\n  // Render performance benchmark\n  private async benchmarkRenderPerformance(): Promise<BenchmarkResult> {\n    console.log('🎨 Benchmarking render performance...')\n\n    const componentCounts = [10, 50, 100, 250, 500]\n    const times: number[] = []\n    const errors: string[] = []\n\n    // Warmup\n    await this.warmupRenderPerformance()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      const componentCount = componentCounts[i % componentCounts.length]\n\n      try {\n        const startTime = performance.now()\n\n        // Simulate component rendering\n        for (let j = 0; j < componentCount; j++) {\n          this.renderOptimizer.optimizedRender(() => {\n            // Simulate DOM operations\n            const div = document.createElement('div')\n            div.textContent = `Component ${j}`\n            document.body.appendChild(div)\n            document.body.removeChild(div)\n          }, `component-${j}`)\n        }\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 50 + (i / (this.config.iterations || 5)) * 15 // 50-65% of total\n    }\n\n    return this.calculateBenchmarkResult('Render Performance', times, errors)\n  }\n\n  // Memory efficiency benchmark\n  private async benchmarkMemoryEfficiency(): Promise<BenchmarkResult> {\n    console.log('🧠 Benchmarking memory efficiency...')\n\n    const times: number[] = []\n    const errors: string[] = []\n    const memoryUsage: number[] = []\n\n    const initialMemory = this.getMemoryUsage()\n\n    for (let i = 0; i < (this.config.iterations || 5); i++) {\n      try {\n        const startTime = performance.now()\n\n        // Create large dataset\n        const largeDataset = Array.from({ length: 10000 }, (_, index) => ({\n          id: index,\n          data: new Array(1000).fill(Math.random()),\n          metadata: {\n            created: Date.now(),\n            updated: Date.now(),\n            tags: Array.from({ length: 10 }, (_, j) => `tag-${j}`)\n          }\n        }))\n\n        // Use performance manager to cache data\n        this.performanceManager.setCache(`dataset-${i}`, largeDataset, 60000)\n\n        // Retrieve from cache\n        const _cached = this.performanceManager.getCache(`dataset-${i}`)\n\n        // Clean up\n        this.performanceManager.deleteCache(`dataset-${i}`)\n\n        const duration = performance.now() - startTime\n        times.push(duration)\n\n        const currentMemory = this.getMemoryUsage()\n        memoryUsage.push(currentMemory)\n\n      } catch (error) {\n        errors.push(error instanceof Error ? error.message : String(error))\n      }\n\n      this.progress.value = 65 + (i / (this.config.iterations || 5)) * 15 // 65-80% of total\n    }\n\n    const finalMemory = this.getMemoryUsage()\n    const memoryDelta = finalMemory - initialMemory\n\n    const result = this.calculateBenchmarkResult('Memory Efficiency', times, errors)\n    result.memoryDelta = memoryDelta\n    result.memoryUsage = finalMemory\n\n    return result\n  }\n\n  // Bundle size benchmark\n  private async benchmarkBundleSize(): Promise<BenchmarkResult> {\n    console.log('📦 Benchmarking bundle size...')\n\n    const times: number[] = []\n    const errors: string[] = []\n    let bundleSize = 0\n\n    try {\n      const startTime = performance.now()\n\n      // Analyze bundle size (simplified version)\n      const scripts = document.querySelectorAll('script[src]')\n      let totalSize = 0\n\n      for (const script of scripts) {\n        const src = script.getAttribute('src')\n        if (src && src.includes('/src/')) {\n          try {\n            // Simulate bundle size calculation\n            // In a real app, you'd fetch and calculate actual sizes\n            totalSize += Math.random() * 100000 // Simulated size\n          } catch (_error) {\n            errors.push(`Failed to calculate bundle size for ${src}`)\n          }\n        }\n      }\n\n      bundleSize = totalSize\n\n      const duration = performance.now() - startTime\n      times.push(duration)\n\n    } catch (error) {\n      errors.push(error instanceof Error ? error.message : String(error))\n    }\n\n    this.progress.value = 80 + 20 // 100% of total\n\n    const result = this.calculateBenchmarkResult('Bundle Size Analysis', times, errors)\n    result.throughput = bundleSize / 1024 // Convert to KB\n\n    return result\n  }\n\n  // Warmup functions\n  private async warmupVirtualScrolling() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      const items = Array.from({ length: 100 }, (_, index) => ({ id: index, data: null }))\n      useVirtualScrolling(items, { threshold: 50 })\n      await new Promise(resolve => setTimeout(resolve, 10))\n    }\n  }\n\n  private async warmupTaskStore() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      await this.simulateTaskCreate({ id: `warmup-${i}`, title: 'Warmup Task' })\n    }\n  }\n\n  private async warmupNetworkRequests() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      try {\n        await fetch('https://in-theflow.com')\n      } catch {\n        // Ignore warmup errors\n      }\n    }\n  }\n\n  private async warmupRenderPerformance() {\n    for (let i = 0; i < (this.config.warmupIterations || 2); i++) {\n      this.renderOptimizer.optimizedRender(() => {\n        document.createElement('div')\n      })\n    }\n  }\n\n  // Simulation functions\n  private async simulateTaskCreate(_task: unknown): Promise<void> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 10))\n  }\n\n  private async simulateTaskRead(id: string): Promise<unknown> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 5))\n    return { id, title: `Task ${id}` }\n  }\n\n  private async simulateTaskUpdate(_task: unknown): Promise<void> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 8))\n  }\n\n  private async simulateTaskDelete(_id: string): Promise<void> {\n    // Simulate database operation\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 3))\n  }\n\n  // Utility functions\n  private calculateBenchmarkResult(name: string, times: number[], errors: string[]): BenchmarkResult {\n    const validTimes = times.length > 0 ? times : [0]\n\n    const total = validTimes.reduce((sum, time) => sum + time, 0)\n    const average = total / validTimes.length\n    const min = Math.min(...validTimes)\n    const max = Math.max(...validTimes)\n\n    // Calculate standard deviation\n    const variance = validTimes.reduce((sum, time) => sum + Math.pow(time - average, 2), 0) / validTimes.length\n    const standardDeviation = Math.sqrt(variance)\n\n    return {\n      name,\n      iterations: times.length,\n      totalTime: total,\n      averageTime: average,\n      minTime: min,\n      maxTime: max,\n      standardDeviation,\n      throughput: total > 0 ? (times.length / (total / 1000)) : 0, // operations per second\n      successRate: times.length > 0 ? (((times.length - errors.length) / times.length) * 100) : 0,\n      errors\n    }\n  }\n\n  private getMemoryUsage(): number {\n    if ('memory' in performance) {\n      return (performance as unknown as { memory: { usedJSHeapSize: number } }).memory.usedJSHeapSize\n    }\n    return 0\n  }\n\n  private async generateReport(results: BenchmarkSuite): Promise<void> {\n    console.log('\\n📊 PERFORMANCE BENCHMARK REPORT')\n    console.log('=====================================')\n\n    const report = {\n      timestamp: new Date().toISOString(),\n      config: this.config,\n      results,\n      thresholds: PERFORMANCE_THRESHOLDS,\n      summary: this.generateSummary(results)\n    }\n\n    // Log results\n    for (const [category, result] of Object.entries(results)) {\n      console.log(`\\n🏷️  ${category.toUpperCase()}:`)\n      console.log(`   Average Time: ${result.averageTime.toFixed(2)}ms`)\n      console.log(`   Throughput: ${result.throughput.toFixed(0)} ops/sec`)\n      console.log(`   Success Rate: ${result.successRate.toFixed(1)}%`)\n      console.log(`   Min/Max: ${result.minTime.toFixed(2)}ms / ${result.maxTime.toFixed(2)}ms`)\n\n      if (result.memoryUsage) {\n        console.log(`   Memory Usage: ${(result.memoryUsage / 1024 / 1024).toFixed(1)}MB`)\n      }\n\n      if (result.errors.length > 0) {\n        console.log(`   Errors: ${result.errors.length}`)\n      }\n    }\n\n    // Performance comparison\n    console.log('\\n🎯 PERFORMANCE COMPARISON:')\n    for (const [threshold, _value] of Object.entries(PERFORMANCE_THRESHOLDS)) {\n      const passed = this.checkThreshold(threshold as keyof PerformanceThresholds, results)\n      console.log(`   ${threshold}: ${passed ? '✅ PASS' : '❌ FAIL'}`)\n    }\n\n    console.log('\\n📈 SUMMARY:')\n    console.log(report.summary)\n\n    // Save to localStorage for persistence\n    try {\n      localStorage.setItem('flow-state-benchmark-report', JSON.stringify(report))\n      console.log('\\n💾 Report saved to localStorage')\n    } catch (error) {\n      console.warn('Failed to save report to localStorage:', error)\n    }\n  }\n\n  private generateSummary(results: BenchmarkSuite): string {\n    const overallPerformance = Object.values(results).reduce((sum, result) => {\n      const score = (result.successRate / 100) * (1000 / Math.max(result.averageTime, 1))\n      return sum + score\n    }, 0) / Object.keys(results).length\n\n    let summary = `Overall Performance Score: ${overallPerformance.toFixed(0)}/1000\\n`\n\n    if (overallPerformance > 800) {\n      summary += 'Status: 🟢 EXCELLENT - Application performs exceptionally well'\n    } else if (overallPerformance > 600) {\n      summary += 'Status: 🟡 GOOD - Application performs well with minor optimizations possible'\n    } else if (overallPerformance > 400) {\n      summary += 'Status: 🟠 FAIR - Application needs performance optimizations'\n    } else {\n      summary += 'Status: 🔴 POOR - Application requires significant performance improvements'\n    }\n\n    return summary\n  }\n\n  private checkThreshold(threshold: keyof PerformanceThresholds, results: BenchmarkSuite): boolean {\n    switch (threshold) {\n      case 'maxAverageRenderTime':\n        return results.renderPerformance.averageTime <= PERFORMANCE_THRESHOLDS[threshold]\n      case 'maxMemoryUsage': {\n        const memoryUsage = results.memoryEfficiency.memoryUsage || 0\n        return memoryUsage <= PERFORMANCE_THRESHOLDS[threshold]\n      }\n      case 'minThroughput':\n        return results.taskStoreOperations.throughput >= PERFORMANCE_THRESHOLDS[threshold]\n      default:\n        return true\n    }\n  }\n\n  // Public API\n  get isBenchmarkRunning(): boolean {\n    return this.isRunning.value\n  }\n\n  get currentProgress(): number {\n    return this.progress.value\n  }\n\n  get benchmarkResults(): Partial<BenchmarkSuite> {\n    return this.results.value\n  }\n\n  async getLatestReport(): Promise<unknown> {\n    try {\n      const report = localStorage.getItem('flow-state-benchmark-report')\n      return report ? JSON.parse(report) : null\n    } catch {\n      return null\n    }\n  }\n\n  clearResults(): void {\n    this.results.value = {}\n    this.progress.value = 0\n  }\n}\n\n// Export singleton instance\nexport const performanceBenchmark = new PerformanceBenchmark()\n\nexport default PerformanceBenchmark","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/productionLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/safariITPProtection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/scriptDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/securityHeaderManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/securityHeaders.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/securityMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/supabaseMappers.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":432,"column":24,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":432,"endColumn":87}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport type { Task, Project, Subtask, TaskInstance, TaskRecurrence, RecurringTaskInstance, NotificationPreferences } from '../types/tasks'\nimport type { ScheduledNotification } from '../types/recurrence'\nimport type { CanvasGroup } from '../types/canvas'\nimport type { PinnedTask } from '../types/quickTasks'\nimport type { AppSettings } from '../stores/settings'\nimport type { PomodoroSession } from '../stores/timer'\nimport type { SessionSummary } from '../stores/quickSort'\nimport { UNCATEGORIZED_PROJECT_ID } from '../stores/tasks/taskOperations'\n\n// -- Validation Helpers --\n\n/**\n * Validates if a string is a valid UUID v4 format\n */\nconst isValidUUID = (str: string | null | undefined): boolean => {\n    if (!str) return false\n    // BUG-FIX: Allow both UUIDs (v4) and Timestamp IDs (legacy/current task creation)\n    // Timestamp IDs are usually 13 digits, UUIDs are 36 chars\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n    const timestampRegex = /^\\d{10,20}$/ // Simple numeric check for timestamps\n    return uuidRegex.test(str) || timestampRegex.test(str)\n}\n\n/**\n * Sanitizes a potential UUID field - returns null for invalid/placeholder values\n */\n// BUG-1320: Track already-warned invalid UUIDs to avoid log spam on every sync cycle\nconst warnedInvalidUUIDs = new Set<string>()\n\nconst sanitizeUUID = (value: string | null | undefined): string | null => {\n    // Handle null/undefined\n    if (value === null || value === undefined) return null\n    // Handle string literals that should be null\n    if (value === 'undefined' || value === 'null' || value === '') return null\n    // Handle non-UUID placeholder values\n    if (value === UNCATEGORIZED_PROJECT_ID || value === '1') return null\n    // Validate UUID format\n    if (!isValidUUID(value)) {\n        if (!warnedInvalidUUIDs.has(value)) {\n            warnedInvalidUUIDs.add(value)\n            console.warn(`[SUPABASE-MAPPER] Invalid UUID detected: \"${value}\", converting to null`)\n        }\n        return null\n    }\n    return value\n}\n\n/**\n * Sanitize timestamp/date values to prevent \"null\" string errors in Postgres\n */\nconst sanitizeTimestamp = (value: string | Date | null | undefined): string | null => {\n    // Handle null/undefined\n    if (value === null || value === undefined) return null\n    // Handle string literals that should be null\n    if (value === 'undefined' || value === 'null' || value === '') return null\n    // Handle Date objects\n    if (value instanceof Date) {\n        return isNaN(value.getTime()) ? null : value.toISOString()\n    }\n    // BUG-1286: Preserve date-only strings (YYYY-MM-DD) without adding T00:00:00.000Z\n    // This prevents timezone-induced time artifacts (e.g., 2am in UTC+2)\n    if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n        // Validate it's a real date\n        const [y, m, d] = value.split('-').map(Number)\n        const date = new Date(y, m - 1, d)\n        if (date.getFullYear() === y && date.getMonth() === m - 1 && date.getDate() === d) {\n            return value\n        }\n        return null\n    }\n    // Handle ISO string - validate it's a real date\n    try {\n        const date = new Date(value)\n        return isNaN(date.getTime()) ? null : date.toISOString()\n    } catch {\n        return null\n    }\n}\n\n// -- Types matching the Supabase Schema --\n\nexport interface SupabaseProject {\n    id: string\n    user_id: string\n    name: string\n    color?: string\n    color_type?: 'hex' | 'emoji'\n    view_type?: 'status' | 'date' | 'priority' | 'list' | 'board'\n    parent_id?: string | null\n    order?: number\n    is_deleted?: boolean\n    deleted_at?: string | null\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseTask {\n    id: string\n    user_id: string\n    project_id?: string | null\n    title: string\n    description?: string\n    status: string\n    priority?: string | null\n\n    // Progress\n    progress?: number\n    total_pomodoros?: number\n    estimated_pomodoros?: number\n    completed_pomodoros?: number\n\n    // Timing\n    due_date?: string | null\n    due_time?: string | null\n    estimated_duration?: number\n\n    // JSON & Arrays\n    subtasks?: Subtask[] | null // stored as jsonb, Supabase client handles object/array\n    tags?: string[] | null\n    depends_on?: string[] | null\n\n    // Complex JSON fields (mapped to camelCase in jsonb)\n    position?: { x: number; y: number; parentId?: string; format?: 'absolute' | 'relative' } | null\n    position_version?: number // Optimistic locking for canvas position sync\n    instances?: TaskInstance[] | null\n    connection_types?: Record<string, 'sequential' | 'blocker' | 'reference'> | null\n    recurrence?: TaskRecurrence | null\n    recurring_instances?: RecurringTaskInstance[] | null\n    notification_prefs?: NotificationPreferences | null\n\n    // Hierarchy\n    parent_task_id?: string | null\n\n    // Metadata\n    order?: number\n    column_id?: string | null\n    is_in_inbox?: boolean\n\n    // BUG-1051: Add missing scheduled fields\n    scheduled_date?: string | null\n    scheduled_time?: string | null\n    is_uncategorized?: boolean\n\n    is_deleted?: boolean\n    deleted_at?: string | null\n    completed_at?: string | null\n    created_at?: string\n    updated_at?: string\n\n    // \"Done for now\" feature - tracks when task was rescheduled via this feature\n    done_for_now_until?: string | null\n}\n\nexport interface SupabaseGroup {\n    id: string\n    user_id: string\n    name: string\n    type: string\n    color?: string\n\n    position_json?: { x: number; y: number; width: number; height: number;[key: string]: unknown } | null // Fixed: Use legacy database column name\n    position_version?: number // Optimistic locking for canvas position sync\n    position_format?: string // TASK-240: Transition to relative-only\n    layout?: string\n\n    is_visible?: boolean\n    is_collapsed?: boolean\n    collapsed_height?: number\n\n    parent_group_id?: string | null\n\n    filters_json?: import('../types/canvas').GroupFilter | null\n    is_power_mode?: boolean\n    power_keyword_json?: import('../composables/useTaskSmartGroups').PowerKeywordResult | null\n    assign_on_drop_json?: import('../types/canvas').AssignOnDropSettings | null\n    collect_filter_json?: import('../types/canvas').CollectFilterSettings | null\n    auto_collect?: boolean\n    is_pinned?: boolean\n    property_value?: string | number | boolean | Record<string, unknown> | null\n\n    is_deleted?: boolean\n    deleted_at?: string | null  // TASK-317: Added for deletion-aware restore\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseNotification {\n    id: string\n    user_id: string\n    task_id: string\n    title: string\n    body: string\n    scheduled_time: string\n    snoozed_until?: string | null\n    is_shown?: boolean\n    is_dismissed?: boolean\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseTimerSession {\n    id: string\n    user_id: string\n    task_id: string\n    start_time: string\n    duration: number\n    remaining_time: number\n    is_active?: boolean\n    is_paused?: boolean\n    is_break?: boolean\n    completed_at?: string | null\n    device_leader_id?: string | null\n    device_leader_last_seen?: string | null\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseUserSettings {\n    id?: string\n    user_id: string\n    work_duration?: number\n    short_break_duration?: number\n    long_break_duration?: number\n    auto_start_breaks?: boolean\n    auto_start_pomodoros?: boolean\n    play_notification_sounds?: boolean\n    theme?: string\n    language?: string\n    sidebar_collapsed?: boolean\n    board_density?: string\n    kanban_settings?: Record<string, unknown> | null\n    canvas_viewport?: { x: number; y: number; zoom: number } | null\n    created_at?: string\n    updated_at?: string\n}\n\nexport interface SupabaseQuickSortSession {\n    id: string\n    user_id: string\n    tasks_processed: number\n    time_spent: number\n    efficiency: number\n    streak_days: number\n    completed_at: string\n}\n\nexport interface SupabasePinnedTask {\n    id: string\n    user_id: string\n    title: string\n    description?: string\n    project_id?: string | null\n    priority?: string | null\n    sort_order?: number\n    created_at?: string\n    updated_at?: string\n}\n\n// -- Work Profile Types (FEATURE-1317) --\n\nexport interface SupabaseWorkProfile {\n    id: string\n    user_id: string\n    work_days: string[]\n    days_off: string[]\n    heavy_meeting_days: string[]\n    max_tasks_per_day: number\n    preferred_work_style: string\n    top_priority_note: string | null\n    avg_work_minutes_per_day: number | null\n    avg_tasks_completed_per_day: number | null\n    peak_productivity_days: string[] | null\n    avg_plan_accuracy: number | null\n    weekly_history: unknown[]\n    profile_version: number\n    interview_completed: boolean\n    created_at?: string\n    updated_at?: string\n    memory_graph: unknown[]\n}\n\nexport interface WorkProfile {\n    id: string\n    userId: string\n    workDays: string[]\n    daysOff: string[]\n    heavyMeetingDays: string[]\n    maxTasksPerDay: number\n    preferredWorkStyle: 'frontload' | 'balanced' | 'backload'\n    topPriorityNote: string | null\n    avgWorkMinutesPerDay: number | null\n    avgTasksCompletedPerDay: number | null\n    peakProductivityDays: string[] | null\n    avgPlanAccuracy: number | null\n    weeklyHistory: Array<{\n        weekStart: string\n        plannedCount: number\n        completedCount: number\n        accuracy: number\n    }>\n    profileVersion: number\n    interviewCompleted: boolean\n    createdAt?: string\n    updatedAt?: string\n    memoryGraph: MemoryObservation[]\n}\n\n// -- Mappers --\n\n// BUG-1320: Track legacy group IDs we've already warned about to avoid log spam\nconst warnedLegacyGroupIds = new Set<string>()\n\nexport function toSupabaseGroup(group: CanvasGroup, userId: string): SupabaseGroup | null {\n    // BUG-1184: Validate group ID is valid UUID - skip legacy timestamp IDs gracefully\n    // Legacy groups created before UUID requirement have IDs like \"group-1768138473081-54fxz7t\"\n    // These can't sync to Supabase but shouldn't break user's workflow\n    if (!isValidUUID(group.id)) {\n        if (!warnedLegacyGroupIds.has(group.id)) {\n            warnedLegacyGroupIds.add(group.id)\n            console.warn(`[SUPABASE-MAPPER] Group \"${group.name}\" has legacy ID: \"${group.id}\" - skipping Supabase sync (local only)`)\n        }\n        return null\n    }\n\n    // SAFETY: Sanitize parent_group_id - must be valid UUID or null\n    const sanitizedParentGroupId = sanitizeUUID(group.parentGroupId)\n\n    if (group.parentGroupId && !sanitizedParentGroupId) {\n        console.warn(`[SUPABASE-MAPPER] Group \"${group.name}\" had invalid parentGroupId: \"${group.parentGroupId}\", sanitized to null`)\n    }\n\n    return {\n        id: group.id,\n        user_id: userId,\n        name: group.name,\n        type: group.type,\n        color: group.color,\n\n        position_json: group.position, // Fixed: Map internal position to DB position_json\n        // Note: position_version is managed by DB triggers, not sent on update\n        layout: group.layout,\n\n        is_visible: group.isVisible,\n        is_collapsed: group.isCollapsed,\n        collapsed_height: group.collapsedHeight,\n\n        parent_group_id: sanitizedParentGroupId,\n\n        filters_json: group.filters,\n        is_power_mode: group.isPowerMode,\n        power_keyword_json: group.powerKeyword,\n        assign_on_drop_json: group.assignOnDrop,\n        collect_filter_json: group.collectFilter,\n        auto_collect: group.autoCollect,\n        is_pinned: group.isPinned,\n        property_value: typeof group.propertyValue === 'object' ? JSON.stringify(group.propertyValue) : group.propertyValue,\n\n        // Let the database default handle new groups (default: false)\n        // Upsert will only update fields present in the payload\n        // position_format removed - column does not exist in DB\n        updated_at: new Date().toISOString()\n    }\n}\n\nexport function fromSupabaseGroup(record: SupabaseGroup): CanvasGroup {\n    return {\n        id: record.id,\n        name: record.name,\n        type: record.type as CanvasGroup['type'],\n        color: record.color || '#cccccc',\n\n        position: record.position_json, // Fixed: Map DB position_json to internal position\n        positionVersion: record.position_version ?? 0, // Read position_version for optimistic locking\n        layout: (record.layout as CanvasGroup['layout']) || 'vertical',\n\n        isVisible: record.is_visible ?? true,\n        isCollapsed: record.is_collapsed ?? false,\n        collapsedHeight: record.collapsed_height,\n\n        parentGroupId: record.parent_group_id, // TASK-138: Using current DB field name\n\n        filters: record.filters_json,\n        isPowerMode: record.is_power_mode,\n        powerKeyword: record.power_keyword_json,\n        assignOnDrop: record.assign_on_drop_json,\n        collectFilter: record.collect_filter_json,\n        autoCollect: record.auto_collect,\n        isPinned: record.is_pinned,\n        propertyValue: record.property_value, // Might need parsing if it was stringified object\n        positionFormat: 'absolute', // Default to absolute since DB column is missing\n\n        updatedAt: record.updated_at\n    } as CanvasGroup\n}\n\nexport function toSupabaseProject(project: Project, userId: string): SupabaseProject {\n    // Determine color type and extract primary color (handling legacy array colors if any)\n    const primaryColor = Array.isArray(project.color) ? project.color[0] : project.color;\n    // Check if color is likely an emoji (if not hex)\n    const isEmoji = project.colorType === 'emoji' || (project.emoji && !primaryColor?.startsWith('#'));\n\n    // Store emoji in color field when colorType is emoji, otherwise use the hex color\n    const colorValue = isEmoji && project.emoji ? project.emoji : primaryColor;\n\n    // SAFETY: Validate UUID fields to prevent 400 errors from Supabase\n    const sanitizedId = project.id\n    const sanitizedParentId = sanitizeUUID(project.parentId)\n\n    // SAFETY: Ensure name is never null (required by DB constraint)\n    const sanitizedName = project.name || 'Unnamed Project'\n\n    // Log if we're sanitizing invalid data\n    if (project.parentId && !sanitizedParentId) {\n        console.warn(`[SUPABASE-MAPPER] Project \"${sanitizedName}\" had invalid parentId: \"${project.parentId}\", sanitized to null`)\n    }\n    if (!project.name) {\n        console.warn(`[SUPABASE-MAPPER] Project \"${sanitizedId}\" had null/empty name, defaulting to \"Unnamed Project\"`)\n    }\n\n    return {\n        id: sanitizedId,\n        user_id: userId,\n        name: sanitizedName,\n        color: colorValue,\n        color_type: project.colorType || (isEmoji ? 'emoji' : 'hex'),\n        view_type: project.viewType || 'status',\n        parent_id: sanitizedParentId,\n        order: (project as Project & { order?: number }).order || 0,\n        is_deleted: (project as Project & { isDeleted?: boolean }).isDeleted || false,\n        deleted_at: (project as Project & { deletedAt?: string | Date }).deletedAt\n            ? new Date((project as Project & { deletedAt?: string | Date }).deletedAt!).toISOString()\n            : null,\n        created_at: project.createdAt instanceof Date ? project.createdAt.toISOString() : project.createdAt,\n        updated_at: new Date().toISOString()\n    }\n}\n\nexport function fromSupabaseProject(record: SupabaseProject): Project {\n    return {\n        id: record.id,\n        name: record.name,\n        color: record.color || '#000000',\n        colorType: (record.color_type as Project['colorType']) || 'hex',\n        emoji: record.color_type === 'emoji' ? record.color : undefined,\n        viewType: (record.view_type as Project['viewType']) || 'status',\n        parentId: record.parent_id || null,\n        createdAt: new Date(record.created_at || Date.now()),\n        updatedAt: new Date(record.updated_at || Date.now())\n    }\n}\n\n// Valid status values per database constraint\nconst VALID_TASK_STATUSES = ['planned', 'in_progress', 'done', 'backlog', 'on_hold'] as const\n\nexport function toSupabaseTask(task: Task, userId: string): SupabaseTask {\n    const now = new Date().toISOString()\n\n    // SAFETY: Sanitize UUID fields to prevent 400 errors from Supabase\n    const sanitizedProjectId = sanitizeUUID(task.projectId)\n    const sanitizedParentTaskId = sanitizeUUID(task.parentTaskId)\n\n    // Sanitize depends_on array - filter out invalid UUIDs\n    const sanitizedDependsOn = (task.dependsOn || []).filter(id => isValidUUID(id))\n\n    // SAFETY: Ensure status is valid per database constraint (tasks_status_check)\n    const sanitizedStatus = VALID_TASK_STATUSES.includes(task.status as typeof VALID_TASK_STATUSES[number])\n        ? task.status\n        : 'planned' // Default fallback\n\n    return {\n        id: task.id,\n        user_id: userId,\n        project_id: sanitizedProjectId,\n        title: task.title,\n        description: task.description,\n        status: sanitizedStatus,\n        priority: task.priority,\n\n        progress: task.progress,\n        total_pomodoros: task.completedPomodoros,\n        completed_pomodoros: task.completedPomodoros,\n        estimated_pomodoros: task.estimatedPomodoros,\n\n        due_date: sanitizeTimestamp(task.dueDate),\n        due_time: task.dueTime || null,\n        estimated_duration: task.estimatedDuration,\n\n        subtasks: task.subtasks || [],\n        tags: task.tags || [],\n        depends_on: sanitizedDependsOn.length > 0 ? sanitizedDependsOn : null,\n\n        // JSONB mappings\n        // TASK-1183: parentId in position JSONB — allow legacy group IDs (e.g. \"group-1768138473081-54fxz7t\")\n        // BUG-FIX: sanitizeUUID was stripping valid legacy group IDs to null on every save.\n        // Realtime echo then overwrote the correct local parentId with undefined → tasks lost their parent group.\n        // Position is a JSONB column — no UUID constraint. Pass through any non-placeholder value.\n        position: task.canvasPosition ? {\n            x: task.canvasPosition.x,\n            y: task.canvasPosition.y,\n            parentId: (task.parentId && task.parentId !== 'NONE' && task.parentId !== 'undefined' && task.parentId !== 'null' && task.parentId !== '') ? task.parentId : undefined,\n            format: 'absolute' // Default for existing tasks during migration\n        } : null,\n        // Note: position_version is managed by DB triggers, not sent on update\n        instances: task.instances || [],\n        connection_types: task.connectionTypes || null,\n        recurrence: task.recurrence || null,\n        recurring_instances: task.recurringInstances || [],\n        notification_prefs: task.notificationPreferences || null,\n\n        parent_task_id: sanitizedParentTaskId,\n\n        order: task.order || 0,\n        column_id: task.columnId || null,\n        is_in_inbox: task.isInInbox || false,\n\n        // BUG-1051: Add missing scheduled fields\n        scheduled_date: sanitizeTimestamp(task.scheduledDate),\n        scheduled_time: task.scheduledTime || null,\n        is_uncategorized: task.isUncategorized || false,\n\n        is_deleted: task._soft_deleted || false,\n        deleted_at: sanitizeTimestamp(task.deletedAt),\n        completed_at: sanitizeTimestamp(task.completedAt),\n\n        // \"Done for now\" feature\n        done_for_now_until: sanitizeTimestamp(task.doneForNowUntil),\n\n        created_at: sanitizeTimestamp(task.createdAt) || now,\n        updated_at: now\n    }\n}\n\nexport function fromSupabaseTask(record: SupabaseTask): Task {\n    return {\n        id: record.id,\n        title: record.title,\n        description: record.description || '',\n        status: record.status as Task['status'],\n        priority: (record.priority as Task['priority']) || null,\n\n        projectId: record.project_id || UNCATEGORIZED_PROJECT_ID,\n        parentTaskId: record.parent_task_id || null,\n\n        completedPomodoros: record.completed_pomodoros || 0,\n        estimatedPomodoros: record.estimated_pomodoros || 1,\n        progress: record.progress || 0,\n\n        dueDate: record.due_date || '', // App uses empty string for no date sometimes? Types say string.\n        dueTime: record.due_time || undefined,\n        estimatedDuration: record.estimated_duration || undefined,\n\n        subtasks: record.subtasks || [],\n        tags: record.tags || undefined,\n        dependsOn: record.depends_on || undefined,\n\n        // BUG-1051: Add missing scheduled fields\n        scheduledDate: record.scheduled_date || undefined,\n        scheduledTime: record.scheduled_time || undefined,\n        isUncategorized: record.is_uncategorized || false,\n\n        canvasPosition: record.position ? { x: record.position.x, y: record.position.y } : undefined,\n        positionVersion: record.position_version ?? 0, // Read position_version for optimistic locking\n        parentId: record.position?.parentId,\n        positionFormat: record.position?.format || 'absolute',\n        instances: record.instances || [],\n        connectionTypes: record.connection_types || undefined,\n        recurrence: record.recurrence || undefined,\n        recurringInstances: record.recurring_instances || [],\n        notificationPreferences: record.notification_prefs || undefined,\n\n        isInInbox: record.is_in_inbox || false,\n        order: record.order || 0,\n        columnId: record.column_id || undefined,\n\n        createdAt: new Date(record.created_at || Date.now()),\n        updatedAt: new Date(record.updated_at || Date.now()),\n        completedAt: record.completed_at ? new Date(record.completed_at) : undefined,\n\n        _soft_deleted: record.is_deleted || false,\n        deletedAt: record.deleted_at ? new Date(record.deleted_at) : undefined,\n\n        // \"Done for now\" feature\n        doneForNowUntil: record.done_for_now_until || undefined\n    }\n}\n\n// -- User Settings Mappers --\n\nexport function toSupabaseUserSettings(settings: AppSettings, userId: string): SupabaseUserSettings {\n    return {\n        user_id: userId,\n        work_duration: settings.workDuration,\n        short_break_duration: settings.shortBreakDuration,\n        long_break_duration: settings.longBreakDuration,\n        auto_start_breaks: settings.autoStartBreaks,\n        auto_start_pomodoros: settings.autoStartPomodoros,\n        play_notification_sounds: settings.playNotificationSounds,\n        theme: settings.theme || 'system',\n        language: settings.language || 'en',\n        sidebar_collapsed: (settings as AppSettings & { sidebarCollapsed?: boolean }).sidebarCollapsed || false,\n        board_density: settings.boardDensity || 'comfortable',\n        kanban_settings: (settings as AppSettings & { kanbanSettings?: Record<string, unknown> }).kanbanSettings || {},\n        canvas_viewport: (settings as AppSettings & { canvasViewport?: { x: number; y: number; zoom: number } }).canvasViewport || null\n    }\n}\n\nexport function fromSupabaseUserSettings(record: SupabaseUserSettings): AppSettings {\n    return {\n        workDuration: record.work_duration,\n        shortBreakDuration: record.short_break_duration,\n        longBreakDuration: record.long_break_duration,\n        autoStartBreaks: record.auto_start_breaks,\n        autoStartPomodoros: record.auto_start_pomodoros,\n        playNotificationSounds: record.play_notification_sounds,\n        theme: record.theme,\n        language: record.language,\n        sidebarCollapsed: record.sidebar_collapsed,\n        boardDensity: record.board_density,\n        kanbanSettings: record.kanban_settings,\n        canvasViewport: record.canvas_viewport,\n        // Default values for fields missing in DB but required in AppSettings\n        showDoneColumn: true,\n        powerGroupOverrideMode: 'only_empty',\n        textDirection: 'auto',\n        enableDayGroupSuggestions: true\n    } as unknown as AppSettings // Cast back for store consumption, or we need a bigger interface\n}\n\n// -- Notification Mappers --\n\nexport function toSupabaseNotification(notification: ScheduledNotification, userId: string): SupabaseNotification {\n    return {\n        id: notification.id,\n        user_id: userId,\n        task_id: notification.taskId,\n        title: notification.title,\n        body: notification.body,\n        scheduled_time: notification.scheduledTime.toISOString(),\n        snoozed_until: notification.snoozedUntil?.toISOString() || null,\n        is_shown: notification.isShown,\n        is_dismissed: notification.isDismissed,\n        created_at: notification.createdAt.toISOString()\n    }\n}\n\nexport function fromSupabaseNotification(record: SupabaseNotification): ScheduledNotification {\n    return {\n        id: record.id,\n        taskId: record.task_id,\n        title: record.title,\n        body: record.body,\n        scheduledTime: new Date(record.scheduled_time),\n        isShown: record.is_shown || false,\n        isDismissed: record.is_dismissed || false,\n        snoozedUntil: record.snoozed_until ? new Date(record.snoozed_until) : undefined,\n        createdAt: new Date(record.created_at || Date.now())\n    }\n}\n\n// -- Timer Session Mappers --\n\nexport function toSupabaseTimerSession(session: PomodoroSession, userId: string, deviceId: string): SupabaseTimerSession {\n    // SAFETY: Validate session ID - generate new UUID if invalid (prevents timestamp IDs from breaking DB)\n    const validSessionId = isValidUUID(session.id) ? session.id : crypto.randomUUID()\n\n    if (!isValidUUID(session.id)) {\n        console.warn(`[SUPABASE-MAPPER] Timer session had invalid ID: \"${session.id}\", generated new UUID: ${validSessionId}`)\n    }\n\n    // BUG-1056: Ensure startTime is a Date object (might be string from localStorage)\n    const startTime = session.startTime instanceof Date\n        ? session.startTime\n        : new Date(session.startTime)\n\n    return {\n        id: validSessionId,\n        user_id: userId,\n        task_id: session.taskId,\n        start_time: startTime.toISOString(),\n        duration: session.duration,\n        remaining_time: session.remainingTime,\n        is_active: session.isActive,\n        is_paused: session.isPaused,\n        is_break: session.isBreak,\n        completed_at: session.completedAt?.toISOString() || null,\n        device_leader_id: deviceId,\n        device_leader_last_seen: new Date().toISOString()\n    }\n}\n\nexport function fromSupabaseTimerSession(record: SupabaseTimerSession): PomodoroSession & { deviceLeaderId?: string | null, deviceLeaderLastSeen?: number } {\n    // SAFETY: Ensure ID is valid UUID when loading (in case DB has corrupted data)\n    const validId = isValidUUID(record.id) ? record.id : crypto.randomUUID()\n\n    if (!isValidUUID(record.id)) {\n        console.warn(`[SUPABASE-MAPPER] Loaded timer session had invalid ID: \"${record.id}\", generated new UUID: ${validId}`)\n    }\n\n    return {\n        id: validId,\n        taskId: record.task_id,\n        startTime: new Date(record.start_time),\n        duration: record.duration,\n        remainingTime: record.remaining_time,\n        isActive: record.is_active ?? false,\n        isPaused: record.is_paused ?? false,\n        isBreak: record.is_break ?? false,\n        completedAt: record.completed_at ? new Date(record.completed_at) : undefined,\n        deviceLeaderId: record.device_leader_id,\n        deviceLeaderLastSeen: record.device_leader_last_seen ? new Date(record.device_leader_last_seen).getTime() : undefined\n    }\n}\n\n// -- Quick Sort Mappers --\n\nexport function toSupabaseQuickSortSession(summary: SessionSummary, userId: string): SupabaseQuickSortSession {\n    // SAFETY: Validate session ID - generate new UUID if invalid\n    const validId = isValidUUID(summary.id) ? summary.id : crypto.randomUUID()\n\n    if (!isValidUUID(summary.id)) {\n        console.warn(`[SUPABASE-MAPPER] QuickSort session had invalid ID: \"${summary.id}\", generated new UUID: ${validId}`)\n    }\n\n    return {\n        id: validId,\n        user_id: userId,\n        tasks_processed: summary.tasksProcessed,\n        time_spent: summary.timeSpent,\n        efficiency: summary.efficiency,\n        streak_days: summary.streakDays,\n        completed_at: summary.completedAt.toISOString()\n    }\n}\n\nexport function fromSupabaseQuickSortSession(record: SupabaseQuickSortSession): SessionSummary {\n    return {\n        id: record.id,\n        tasksProcessed: record.tasks_processed,\n        timeSpent: record.time_spent,\n        efficiency: record.efficiency,\n        streakDays: record.streak_days,\n        completedAt: new Date(record.completed_at)\n    }\n}\n\n// -- Memory Observation Types (FEATURE-1317 Phase 2) --\n\nexport interface MemoryObservation {\n    entity: string      // e.g. \"project:dashboard\", \"day:monday\", \"user\", \"tasktype:bugfix\"\n    relation: string    // e.g. \"takes_longer\", \"overplanned\", \"avg_duration\", \"insight\"\n    value: string       // e.g. \"2x estimated\", \"3 of 4 weeks\", \"45min\"\n    confidence: number  // 0.0 - 1.0\n    source: string      // \"pomodoro_data\" | \"weekly_history\" | \"ai_observation\"\n    createdAt: string   // ISO date\n}\n\n// -- Pinned Task Mappers (FEATURE-1248) --\n\nexport function toSupabasePinnedTask(pin: PinnedTask, userId: string): SupabasePinnedTask {\n    return {\n        id: pin.id,\n        user_id: userId,\n        title: pin.title,\n        description: pin.description || '',\n        project_id: sanitizeUUID(pin.projectId),\n        priority: pin.priority || null,\n        sort_order: pin.sortOrder || 0,\n        updated_at: new Date().toISOString()\n    }\n}\n\nexport function fromSupabasePinnedTask(record: SupabasePinnedTask): PinnedTask {\n    return {\n        id: record.id,\n        userId: record.user_id,\n        title: record.title,\n        description: record.description || '',\n        projectId: record.project_id || null,\n        priority: record.priority || null,\n        sortOrder: record.sort_order || 0,\n        createdAt: new Date(record.created_at || Date.now()),\n        updatedAt: new Date(record.updated_at || Date.now())\n    }\n}\n\n// -- Work Profile Mappers (FEATURE-1317) --\n\nexport function toSupabaseWorkProfile(profile: Partial<WorkProfile>, userId: string): Partial<SupabaseWorkProfile> {\n    return {\n        user_id: userId,\n        ...(profile.workDays !== undefined && { work_days: profile.workDays }),\n        ...(profile.daysOff !== undefined && { days_off: profile.daysOff }),\n        ...(profile.heavyMeetingDays !== undefined && { heavy_meeting_days: profile.heavyMeetingDays }),\n        ...(profile.maxTasksPerDay !== undefined && { max_tasks_per_day: profile.maxTasksPerDay }),\n        ...(profile.preferredWorkStyle !== undefined && { preferred_work_style: profile.preferredWorkStyle }),\n        ...(profile.topPriorityNote !== undefined && { top_priority_note: profile.topPriorityNote }),\n        ...(profile.avgWorkMinutesPerDay !== undefined && { avg_work_minutes_per_day: profile.avgWorkMinutesPerDay }),\n        ...(profile.avgTasksCompletedPerDay !== undefined && { avg_tasks_completed_per_day: profile.avgTasksCompletedPerDay }),\n        ...(profile.peakProductivityDays !== undefined && { peak_productivity_days: profile.peakProductivityDays }),\n        ...(profile.avgPlanAccuracy !== undefined && { avg_plan_accuracy: profile.avgPlanAccuracy }),\n        ...(profile.weeklyHistory !== undefined && { weekly_history: profile.weeklyHistory }),\n        ...(profile.interviewCompleted !== undefined && { interview_completed: profile.interviewCompleted }),\n        ...(profile.memoryGraph !== undefined && { memory_graph: profile.memoryGraph }),\n        updated_at: new Date().toISOString()\n    }\n}\n\nexport function fromSupabaseWorkProfile(record: SupabaseWorkProfile): WorkProfile {\n    return {\n        id: record.id,\n        userId: record.user_id,\n        workDays: record.work_days || ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],\n        daysOff: record.days_off || [],\n        heavyMeetingDays: record.heavy_meeting_days || [],\n        maxTasksPerDay: record.max_tasks_per_day || 6,\n        preferredWorkStyle: (record.preferred_work_style as WorkProfile['preferredWorkStyle']) || 'balanced',\n        topPriorityNote: record.top_priority_note || null,\n        avgWorkMinutesPerDay: record.avg_work_minutes_per_day,\n        avgTasksCompletedPerDay: record.avg_tasks_completed_per_day,\n        peakProductivityDays: record.peak_productivity_days,\n        avgPlanAccuracy: record.avg_plan_accuracy,\n        weeklyHistory: (record.weekly_history || []) as WorkProfile['weeklyHistory'],\n        profileVersion: record.profile_version || 1,\n        interviewCompleted: record.interview_completed || false,\n        memoryGraph: (record.memory_graph || []) as MemoryObservation[],\n        createdAt: record.created_at,\n        updatedAt: record.updated_at\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/taskValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":315,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9346,9349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9346,9349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Task Validation Utility\n * BUG-060 FIX: Multi-layer defense against undefined/invalid task IDs\n *\n * This utility provides centralized validation for task data integrity,\n * preventing phantom tasks, sync loops, and data corruption.\n */\n\nimport type { Task } from '@/types/tasks'\nimport { UNCATEGORIZED_PROJECT_ID } from '@/stores/tasks/taskOperations'\n\n/**\n * Validation result with detailed error information\n */\nexport interface TaskValidationResult {\n  isValid: boolean\n  errors: string[]\n  warnings: string[]\n  taskId: string | undefined\n}\n\n/**\n * Batch validation result\n */\nexport interface BatchValidationResult {\n  validTasks: Task[]\n  invalidTasks: { task: unknown; errors: string[] }[]\n  totalProcessed: number\n  validCount: number\n  invalidCount: number\n}\n\n/**\n * UUID regex pattern for validation\n */\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n\n/**\n * Check if a task ID is valid\n * Valid IDs must be:\n * - Non-empty strings\n * - Not 'undefined' or 'null' literals\n * - Valid UUID format OR legacy prefixed format (group-xxx, instance-xxx, etc.)\n */\nexport function isValidTaskId(id: unknown): id is string {\n  if (typeof id !== 'string') return false\n  if (id === '') return false\n  if (id === 'undefined') return false\n  if (id === 'null') return false\n  if (id.trim() === '') return false\n\n  // Check for valid UUID format (Supabase requirement)\n  if (UUID_REGEX.test(id)) return true\n\n  // Allow legacy prefixed IDs (group-xxx, instance-xxx, recovered-xxx, etc.)\n  if (id.includes('-') && !id.match(/^\\d+$/)) return true\n\n  // Block pure numeric IDs (e.g., \"1767970660403\") - these break Supabase\n  if (/^\\d+$/.test(id)) {\n    console.warn(`🛡️ [VALIDATION] Blocking numeric ID: ${id} (not UUID compatible)`)\n    return false\n  }\n\n  return true\n}\n\n/**\n * Generate a fallback task ID\n * Used when a task has no valid ID but needs to be preserved\n */\nexport function generateFallbackId(prefix: string = 'recovered'): string {\n  return `${prefix}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`\n}\n\n/**\n * Validate a single task object\n */\nexport function validateTask(task: unknown): TaskValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  // Check if task is an object\n  if (!task || typeof task !== 'object') {\n    return {\n      isValid: false,\n      errors: ['Task is not a valid object'],\n      warnings: [],\n      taskId: undefined\n    }\n  }\n\n  const taskObj = task as Record<string, unknown>\n\n  // Critical: Check ID\n  if (!isValidTaskId(taskObj.id)) {\n    errors.push(`Invalid task ID: ${JSON.stringify(taskObj.id)} (type: ${typeof taskObj.id})`)\n  }\n\n  // Check title (optional but warned)\n  if (!taskObj.title || typeof taskObj.title !== 'string' || taskObj.title.trim() === '') {\n    warnings.push('Task has no valid title')\n  }\n\n  // Check for required fields\n  if (!taskObj.status) {\n    warnings.push('Task has no status, will default to \"planned\"')\n  }\n\n  // Check dates\n  if (taskObj.createdAt && !(taskObj.createdAt instanceof Date) && typeof taskObj.createdAt !== 'string') {\n    warnings.push('Task has invalid createdAt format')\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n    taskId: isValidTaskId(taskObj.id) ? taskObj.id : undefined\n  }\n}\n\n/**\n * Validate and sanitize a batch of tasks\n * Returns valid tasks and reports on invalid ones\n */\nexport function validateAndSanitizeTasks(tasks: unknown[]): BatchValidationResult {\n  const validTasks: Task[] = []\n  const invalidTasks: { task: unknown; errors: string[] }[] = []\n\n  if (!Array.isArray(tasks)) {\n    console.error('🛡️ [VALIDATION] validateAndSanitizeTasks received non-array:', typeof tasks)\n    return {\n      validTasks: [],\n      invalidTasks: [],\n      totalProcessed: 0,\n      validCount: 0,\n      invalidCount: 0\n    }\n  }\n\n  for (const task of tasks) {\n    const result = validateTask(task)\n\n    if (result.isValid) {\n      validTasks.push(task as Task)\n    } else {\n      invalidTasks.push({ task, errors: result.errors })\n      console.warn('🛡️ [VALIDATION] Invalid task detected:', {\n        errors: result.errors,\n        taskSnapshot: JSON.stringify(task).substring(0, 200)\n      })\n    }\n\n    // Log warnings even for valid tasks\n    if (result.warnings.length > 0 && result.isValid) {\n      console.warn(`🛡️ [VALIDATION] Task ${result.taskId} has warnings:`, result.warnings)\n    }\n  }\n\n  return {\n    validTasks,\n    invalidTasks,\n    totalProcessed: tasks.length,\n    validCount: validTasks.length,\n    invalidCount: invalidTasks.length\n  }\n}\n\n/**\n * Sanitize a task by fixing recoverable issues\n * Returns null if task is unrecoverable\n */\nexport function sanitizeTask(task: unknown, options: {\n  generateIdIfMissing?: boolean\n  idPrefix?: string\n} = {}): Task | null {\n  const { generateIdIfMissing = true, idPrefix = 'sanitized' } = options\n\n  if (!task || typeof task !== 'object') {\n    return null\n  }\n\n  const taskObj = task as Record<string, unknown>\n\n  // Handle missing/invalid ID\n  let taskId = taskObj.id as string | undefined\n  if (!isValidTaskId(taskId)) {\n    if (generateIdIfMissing) {\n      taskId = generateFallbackId(idPrefix)\n      // console.log(`🛡️ [SANITIZE] Generated fallback ID: ${taskId}`)\n    } else {\n      console.error('🛡️ [SANITIZE] Task has invalid ID and generateIdIfMissing is false')\n      return null\n    }\n  }\n\n  // Build sanitized task\n  const sanitizedTask: Task = {\n    id: taskId,\n    title: (typeof taskObj.title === 'string' && taskObj.title.trim())\n      ? taskObj.title\n      : 'Recovered Task',\n    description: typeof taskObj.description === 'string' ? taskObj.description : '',\n    status: isValidStatus(taskObj.status) ? taskObj.status : 'planned',\n    priority: isValidPriority(taskObj.priority) ? taskObj.priority : 'medium',\n    progress: typeof taskObj.progress === 'number' ? taskObj.progress : 0,\n    completedPomodoros: typeof taskObj.completedPomodoros === 'number' ? taskObj.completedPomodoros : 0,\n    subtasks: Array.isArray(taskObj.subtasks) ? taskObj.subtasks : [],\n    dueDate: typeof taskObj.dueDate === 'string' ? taskObj.dueDate : new Date().toISOString().split('T')[0],\n    projectId: typeof taskObj.projectId === 'string' ? taskObj.projectId : UNCATEGORIZED_PROJECT_ID,\n    createdAt: parseDate(taskObj.createdAt) || new Date(),\n    updatedAt: parseDate(taskObj.updatedAt) || new Date(),\n    instances: Array.isArray(taskObj.instances) ? taskObj.instances : [],\n    isInInbox: typeof taskObj.isInInbox === 'boolean' ? taskObj.isInInbox : true,\n    canvasPosition: taskObj.canvasPosition as Task['canvasPosition'],\n    parentTaskId: typeof taskObj.parentTaskId === 'string' ? taskObj.parentTaskId : null\n  }\n\n  return sanitizedTask\n}\n\n/**\n * Load-time sanitization for tasks from database\n * Filters out invalid tasks and sanitizes recoverable ones\n */\nexport function sanitizeLoadedTasks(loadedData: unknown): Task[] {\n  if (!Array.isArray(loadedData)) {\n    console.warn('🛡️ [LOAD-SANITIZE] Loaded data is not an array')\n    return []\n  }\n\n  const sanitizedTasks: Task[] = []\n  const droppedCount = { invalid: 0, recovered: 0 }\n\n  for (const item of loadedData) {\n    const validation = validateTask(item)\n\n    if (validation.isValid) {\n      // Task is valid, add directly\n      sanitizedTasks.push(item as Task)\n    } else {\n      // Try to sanitize\n      const sanitized = sanitizeTask(item, {\n        generateIdIfMissing: true,\n        idPrefix: 'db-recovery'\n      })\n\n      if (sanitized) {\n        sanitizedTasks.push(sanitized)\n        droppedCount.recovered++\n        // console.log(`🛡️ [LOAD-SANITIZE] Recovered task: ${sanitized.id}`)\n      } else {\n        droppedCount.invalid++\n        console.error('🛡️ [LOAD-SANITIZE] Dropped unrecoverable task:', item)\n      }\n    }\n  }\n\n  if (droppedCount.invalid > 0 || droppedCount.recovered > 0) {\n    // console.log(`🛡️ [LOAD-SANITIZE] Summary: ${sanitizedTasks.length} valid, ${droppedCount.recovered} recovered, ${droppedCount.invalid} dropped`)\n  }\n\n  return sanitizedTasks\n}\n\n/**\n * Pre-save validation - blocks saving of invalid tasks\n */\nexport function validateBeforeSave(tasks: Task[]): {\n  canSave: boolean\n  validTasks: Task[]\n  blockedTasks: Task[]\n  reason?: string\n} {\n  const validTasks: Task[] = []\n  const blockedTasks: Task[] = []\n\n  for (const task of tasks) {\n    if (isValidTaskId(task.id)) {\n      validTasks.push(task)\n    } else {\n      blockedTasks.push(task)\n      console.error(`🛡️ [PRE-SAVE] BLOCKED task with invalid ID:`, {\n        id: task.id,\n        title: task.title,\n        stack: new Error().stack\n      })\n    }\n  }\n\n  if (blockedTasks.length > 0) {\n    return {\n      canSave: true, // Still save valid tasks\n      validTasks,\n      blockedTasks,\n      reason: `Blocked ${blockedTasks.length} tasks with invalid IDs`\n    }\n  }\n\n  return {\n    canSave: true,\n    validTasks,\n    blockedTasks: []\n  }\n}\n\n// Helper functions\nfunction isValidStatus(status: unknown): status is Task['status'] {\n  const validStatuses = ['planned', 'in_progress', 'done', 'backlog', 'on_hold']\n  return typeof status === 'string' && validStatuses.includes(status)\n}\n\nfunction isValidPriority(priority: unknown): priority is Task['priority'] {\n  const validPriorities = ['low', 'medium', 'high', null]\n  return validPriorities.includes(priority as any)\n}\n\nfunction parseDate(value: unknown): Date | null {\n  if (value instanceof Date) return value\n  if (typeof value === 'string') {\n    const parsed = new Date(value)\n    return isNaN(parsed.getTime()) ? null : parsed\n  }\n  if (typeof value === 'number') {\n    return new Date(value)\n  }\n  return null\n}\n\n/**\n * Debug utility: Log task ID statistics\n */\nexport function logTaskIdStats(tasks: Task[], context: string = 'unknown'): void {\n  const stats = {\n    total: tasks.length,\n    validIds: 0,\n    emptyStringIds: 0,\n    undefinedStringIds: 0,\n    nullStringIds: 0,\n    actualUndefined: 0,\n    actualNull: 0,\n    otherInvalid: 0\n  }\n\n  for (const task of tasks) {\n    if (isValidTaskId(task.id)) {\n      stats.validIds++\n    } else if (task.id === '') {\n      stats.emptyStringIds++\n    } else if (task.id === 'undefined') {\n      stats.undefinedStringIds++\n    } else if (task.id === 'null') {\n      stats.nullStringIds++\n    } else if (task.id === undefined) {\n      stats.actualUndefined++\n    } else if (task.id === null) {\n      stats.actualNull++\n    } else {\n      stats.otherInvalid++\n    }\n  }\n\n  if (stats.validIds !== stats.total) {\n    console.warn(`🛡️ [ID-STATS] ${context}:`, stats)\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/timer/formatTime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/utils/urlTruncate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/AIChatView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/AIHubView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/AllTasksView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/BoardView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/CalendarView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/CalendarViewVueCal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/CanvasView.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":308,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11720,11723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11720,11723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'menuX' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":377,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":377,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'menuY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":378,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":378,"endColumn":14}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<!-- /// <reference types=\"vite/client\" /> -->\n<!--\n  ⚠️ CRITICAL: Vue Flow Integration Rules - DO NOT VIOLATE\n\n  During refactoring, the following Vue Flow elements MUST NEVER be extracted\n  from this component into separate components:\n\n  ❌ DO NOT EXTRACT:\n    - v-model:nodes and v-model:edges bindings (lines ~153-154)\n    - @node-drag-stop, @connect, @edge-created event handlers (lines ~172-181)\n    - VueFlow component itself and its direct children (lines ~151-236)\n    - Node/edge calculation and synchronization logic\n    - useVueFlow() composable usage and its return values\n    - syncNodes() function calls that refresh VueFlow state\n\n  ✅ SAFE TO EXTRACT (these don't depend on Vue Flow):\n    - Canvas controls (zoom, pan, toolbar buttons)\n    - Modals and overlays\n    - Context menus (if they don't depend on VueFlow state)\n    - Sidebar panels\n\n  VIOLATION OF THESE RULES WILL BREAK:\n    - Drag and drop functionality\n    - Node connections and edges\n    - State synchronization\n    - Canvas viewport controls\n\n  These rules are based on analysis of previous refactoring failures in\n  old-flow-state-worktrees where Vue Flow extraction caused complete\n  breakage of canvas functionality.\n-->\n\n<template>\n  <div\n    class=\"canvas-layout canvas-contour\"\n    :class=\"{ 'shift-selecting': shift }\"\n  >\n    <!-- MAIN CANVAS AREA -->\n    <!-- Vue Flow Canvas -->\n    <div\n      class=\"canvas-drop-zone relative\"\n      @drop=\"handleDrop\"\n      @dragover.prevent\n      @contextmenu.prevent=\"handleCanvasRightClick\"\n    >\n      <!-- Loading overlay while canvas initializes -->\n      <CanvasLoadingOverlay \n        v-if=\"!isCanvasReady && !hasNoTasks && tasksWithCanvasPositions && tasksWithCanvasPositions.length > 0\"\n        message=\"Loading canvas...\"\n      />\n\n      <!-- Empty state when no tasks exist -->\n      <CanvasEmptyState\n        v-if=\"hasNoTasks\"\n        @add-task=\"handleAddTask\"\n        @create-group=\"createGroup()\"\n      />\n\n      <!-- Filter Status Indicator -->\n      <CanvasStatusBanner \n        :active-status-filter=\"taskStore.activeStatusFilter\"\n        @clear-filter=\"clearStatusFilter\"\n      />\n\n      <!-- Inbox Sidebar -->\n      <UnifiedInboxPanel key=\"canvas-inbox\" context=\"canvas\" />\n\n      <!-- Canvas Toolbar - Actions & Filters (MUST be after InboxPanel for z-index stacking) -->\n      <CanvasToolbar\n        @add-task=\"handleAddTask\"\n        @create-group=\"handleToolbarCreateGroup\"\n      />\n\n      <!-- Canvas Container -->\n      <div\n        class=\"canvas-container\"\n        @mousedown=\"handleMouseDown\"\n        @mousemove=\"handleMouseMove\"\n        @mouseup=\"handleMouseUp\"\n        @click=\"handleCanvasContainerClick\"\n      >\n        <!-- BUG-1216: virtualization disabled — mount/unmount during pan causes sluggishness.\n             For typical canvas sizes (<100 nodes), keeping all nodes in DOM is faster. -->\n        <VueFlow\n          ref=\"vueFlowRef\"\n          :nodes=\"nodes\"\n          :edges=\"edges\"\n          :class=\"{ 'canvas-ready': isCanvasReady }\"\n          class=\"vue-flow-container\"\n          :node-types=\"nodeTypes\"\n          edges-focusable\n          :elevate-nodes-on-select=\"false\"\n          elevate-edges-on-select\n          zoom-on-scroll\n          :pan-on-scroll=\"false\"\n          zoom-on-pinch\n          :pan-on-drag=\"!shift && !control && !meta\"\n          :nodes-draggable=\"!control && !meta && !shift\"\n          :selection-on-drag=\"shift\"\n          :multi-selection-key-code=\"['Control', 'Meta', 'Shift']\"\n          snap-to-grid\n          :snap-grid=\"[16, 16]\"\n          :node-extent=\"dynamicNodeExtent\"\n          :min-zoom=\"0.05\"\n          :max-zoom=\"4.0\"\n          :fit-view-on-init=\"false\"\n          connect-on-drag-nodes\n          :zoom-scroll-sensitivity=\"1.0\"\n          :zoom-activation-key-code=\"null\"\n          prevent-scrolling\n          :default-viewport=\"initialViewport\"\n          dir=\"ltr\"\n          @pane-ready=\"onPaneReady\"\n          @node-click=\"handleNodeClick\"\n          @node-double-click=\"handleNodeDoubleClick\"\n          @node-drag-start=\"handleNodeDragStart\"\n          @node-drag=\"handleNodeDrag\"\n          @node-drag-stop=\"handleNodeDragStop\"\n          @nodes-change=\"handleNodesChange\"\n          @edges-change=\"handleEdgesChange\"\n          @selection-change=\"handleSelectionChange\"\n          @pane-click=\"handlePaneClick\"\n          @pane-context-menu=\"handlePaneContextMenu\"\n          @node-context-menu=\"handleNodeContextMenu\"\n          @edge-context-menu=\"handleEdgeContextMenu\"\n          @edge-double-click=\"handleEdgeDoubleClick\"\n          @connect=\"handleConnect\"\n          @connect-start=\"handleConnectStart\"\n          @connect-end=\"handleConnectEnd\"\n          @keydown=\"handleKeyDown\"\n        >\n          <Background\n            pattern-color=\"#e5e7eb\"\n            pattern=\"dots\"\n            :gap=\"16\"\n            :size=\"1\"\n          />\n\n          <!-- Section Node Template -->\n          <template #node-sectionNode=\"nodeProps\">\n            <GroupNodeSimple\n              :id=\"nodeProps.id\"\n              v-memo=\"[nodeProps.id, nodeProps.data, nodeProps.selected, nodeProps.dragging]\"\n              :data=\"nodeProps.data\"\n              :selected=\"nodeProps.selected\"\n              :dragging=\"nodeProps.dragging\"\n              @update=\"(data) => handleSectionUpdate(nodeProps.id, data)\"\n              @collect=\"collectTasksForSection\"\n              @context-menu=\"handleSectionContextMenu\"\n              @open-settings=\"handleOpenSectionSettings\"\n              @resize-start=\"handleSectionResizeStart\"\n              @resize=\"handleSectionResize\"\n              @resize-end=\"handleSectionResizeEnd\"\n            />\n          </template>\n\n\n\n          <!-- Custom Task Node Template -->\n          <!-- TASK-262: Using onSelect callback prop instead of @select emit -->\n          <!-- Vue's emit system doesn't work reliably in Vue Flow custom nodes -->\n          <!-- TASK-279: Using editCallback prop instead of @edit emit -->\n          <!-- Vue's emit system doesn't work reliably in Vue Flow custom nodes -->\n          <template #node-taskNode=\"nodeProps\">\n            <TaskNode\n              :task=\"nodeProps.data.task\"\n              :is-selected=\"nodeProps.selected\"\n              :is-dragging=\"nodeProps.dragging\"\n              :multi-select-mode=\"canvasStore.multiSelectMode\"\n              :show-priority=\"canvasStore.showPriorityIndicator\"\n              :show-status=\"canvasStore.showStatusBadge\"\n              :show-duration=\"canvasStore.showDurationBadge\"\n              :show-schedule=\"canvasStore.showScheduleBadge\"\n              :select-callback=\"handleTaskSelect\"\n              :edit-callback=\"handleEditTask\"\n              @edit=\"handleEditTask\"\n              @select=\"handleTaskSelect\"\n              @context-menu=\"handleTaskContextMenu\"\n            />\n          </template>\n\n          <!-- SVG markers for connection arrows -->\n          <svg style=\"position: absolute; width: 0; height: 0; pointer-events: none;\">\n            <defs>\n              <marker\n                id=\"arrowhead\"\n                markerWidth=\"10\"\n                markerHeight=\"10\"\n                refX=\"9\"\n                refY=\"3\"\n                orient=\"auto\"\n                markerUnits=\"strokeWidth\"\n              >\n                <polygon points=\"0 0, 10 3, 0 6\" fill=\"var(--border-secondary)\" />\n              </marker>\n              <marker\n                id=\"arrowhead-hover\"\n                markerWidth=\"10\"\n                markerHeight=\"10\"\n                refX=\"9\"\n                refY=\"3\"\n                orient=\"auto\"\n                markerUnits=\"strokeWidth\"\n              >\n                <polygon points=\"0 0, 10 3, 0 6\" fill=\"var(--color-navigation)\" />\n              </marker>\n            </defs>\n          </svg>\n        </VueFlow>\n\n        <!-- Selection box outside VueFlow to avoid transform issues -->\n        <CanvasSelectionBox :selection-box=\"selectionBox\" />\n\n        <CanvasLoadingOverlay\n          v-if=\"!isCanvasReady\"\n          message=\"Initializing Canvas...\"\n        />\n      </div>\n    </div>\n\n    <!-- Modals -->\n    <CanvasModals\n      @handle-quick-task-create=\"handleQuickTaskCreate\"\n      @handle-batch-edit-applied=\"handleBatchEditApplied\"\n      @handle-section-settings-save=\"handleSectionSettingsSave\"\n      @handle-group-created=\"handleGroupCreated\"\n      @handle-group-updated=\"handleGroupUpdated\"\n      @handle-group-edit-save=\"handleGroupEditSave\"\n      @confirm-delete-group=\"confirmDeleteGroup\"\n      @confirm-bulk-delete=\"confirmBulkDelete\"\n    />\n\n    <CanvasContextMenus\n      @create-task-here=\"createTaskHere\"\n      @create-group=\"createGroup\"\n      @edit-group=\"editGroup\"\n      @delete-group=\"deleteGroup\"\n      @move-to-inbox=\"moveSelectedTasksToInbox\"\n      @done-for-now=\"doneForNowSelectedTasks\"\n      @delete-tasks=\"deleteSelectedTasks\"\n      @align-left=\"alignLeft\"\n      @align-right=\"alignRight\"\n      @align-top=\"alignTop\"\n      @align-bottom=\"alignBottom\"\n      @align-center-horizontal=\"alignCenterHorizontal\"\n      @align-center-vertical=\"alignCenterVertical\"\n      @distribute-horizontal=\"distributeHorizontal\"\n      @distribute-vertical=\"distributeVertical\"\n      @arrange-in-row=\"arrangeInRow\"\n      @arrange-in-column=\"arrangeInColumn\"\n      @arrange-in-grid=\"arrangeInGrid\"\n      @create-task-in-group=\"handleCreateTaskInGroupDebug\"\n      @open-group-settings=\"handleOpenSectionSettingsFromContext\"\n      @toggle-power-mode=\"handleToggleFocusMode\"\n      @collect-tasks=\"handleCollectTasksFromMenu\"\n      @collect-overdue-tasks=\"handleCollectOverdueFromMenu\"\n      @disconnect-edge=\"disconnectEdge\"\n      @delete-node=\"deleteNode\"\n      @create-group-from-selection=\"createGroupFromSelection\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { markRaw } from 'vue'\nimport { VueFlow, type NodeMouseEvent } from '@vue-flow/core'\nimport { Background } from '@vue-flow/background'\nimport '@vue-flow/node-resizer/dist/style.css'\nimport '@vue-flow/core/dist/style.css'\nimport '@vue-flow/core/dist/theme-default.css'\nimport '../assets/vue-flow-overrides.css'\nimport { useEventListener } from '@vueuse/core'\n\nimport { useTaskStore } from '../stores/tasks'\nimport { useCanvasStore } from '../stores/canvas'\nimport { useUIStore } from '../stores/ui'\nimport { useCanvasContextMenuStore } from '../stores/canvas/contextMenus'\nimport { getViewportCoordinates } from '@/utils/contextMenuCoordinates'\nimport type { Task } from '@/types/tasks'\nimport type { CanvasGroup } from '@/types/canvas'\n\nimport TaskNode from '../components/canvas/TaskNode.vue'\nimport GroupNodeSimple from '../components/canvas/GroupNodeSimple.vue'\nimport UnifiedInboxPanel from '../components/inbox/UnifiedInboxPanel.vue'\nimport CanvasModals from '../components/canvas/CanvasModals.vue'\nimport CanvasEmptyState from '../components/canvas/CanvasEmptyState.vue'\nimport CanvasContextMenus from '../components/canvas/CanvasContextMenus.vue'\n\nimport { useCanvasModalsStore } from '@/stores/canvas/modals'\nimport CanvasToolbar from '../components/canvas/CanvasToolbar.vue'\nimport CanvasStatusBanner from '../components/canvas/CanvasStatusBanner.vue'\nimport CanvasLoadingOverlay from '../components/canvas/CanvasLoadingOverlay.vue'\nimport CanvasSelectionBox from '../components/canvas/CanvasSelectionBox.vue'\n\nimport { useCanvasContextMenus } from '@/composables/canvas/useCanvasContextMenus'\nimport { useCanvasOrchestrator } from '../composables/canvas/useCanvasOrchestrator'\n\nconst taskStore = useTaskStore()\nconst canvasStore = useCanvasStore()\nconst uiStore = useUIStore()\nconst modalsStore = useCanvasModalsStore()\nconst contextMenuStore = useCanvasContextMenuStore()\n\n// Register custom node types\nconst nodeTypes = {\n  taskNode: markRaw(TaskNode),\n  sectionNode: markRaw(GroupNodeSimple)\n} as any\n\n// Initialize Orchestrator\nconst orchestrator = useCanvasOrchestrator()\nconst {\n  nodes, edges, isCanvasReady, initialViewport, shift, control, meta, vueFlowRef,\n  tasksWithCanvasPosition, dynamicNodeExtent, hasNoTasks,\n  handleNodeDragStart, handleNodeDrag, handleNodeDragStop, handleKeyDown,\n  handleSectionResizeStart, handleSectionResize, handleSectionResizeEnd,\n  onPaneReady,\n  handlePaneClick, handleCanvasRightClick, handlePaneContextMenu, handleDrop,\n  // BUG-208: Canvas context menu state now comes from contextMenuStore, not orchestrator\n  createTaskHere, createGroup, editGroup, deleteGroup,\n  moveSelectedTasksToInbox, doneForNowSelectedTasks, deleteSelectedTasks, createTaskInGroup,\n  deleteNode, createGroupFromSelection,\n  isSectionSettingsOpen, editingSection,\n  handleQuickTaskCreate,\n  handleBatchEditApplied, handleSectionSettingsSave,\n  handleGroupCreated, handleGroupUpdated,\n  handleGroupEditSave, confirmDeleteGroup, confirmBulkDelete, handleConnect, handleConnectStart, handleConnectEnd,\n  handleEdgesChange, handleNodesChange,\n  handleNodeContextMenu, handleEdgeContextMenu, handleEdgeDoubleClick,\n  handleNodeClick, handleSelectionChange,\n  \n  // From consolidated features\n  selectionBox, handleMouseDown, handleMouseMove, handleMouseUp, handleCanvasContainerClick, handleTaskSelect,\n  alignLeft, alignRight, alignTop, alignBottom, alignCenterHorizontal, alignCenterVertical,\n  distributeHorizontal, distributeVertical, arrangeInRow, arrangeInColumn, arrangeInGrid,\n  collectTasksForSection, autoCollectOverdueTasks: handleCollectTasksFromMenu, collectOverdueTasksNearGroup, disconnectEdge\n} = orchestrator\n\n// Register global hotkeys\nuseEventListener(window, 'keydown', (e) => {\n  // Only handle if canvas is active/visible\n  handleKeyDown(e)\n})\n\n// Aliases for template compatibility\nconst tasksWithCanvasPositions = tasksWithCanvasPosition\nconst handleToolbarCreateGroup = createGroup\nconst handleAddTask = () => createTaskHere()\nconst clearStatusFilter = () => { taskStore.activeStatusFilter = null }\n// UI Wrappers\nconst handleOpenSectionSettings = (id: string) => {\n    const section = canvasStore.groups.find(g => g.id === id)\n    if (section) { editingSection.value = section; isSectionSettingsOpen.value = true }\n}\nconst handleOpenSectionSettingsFromContext = () => {\n    // BUG-208: Use store for context menu state\n    if (contextMenuStore.canvasContextSection) handleOpenSectionSettings(contextMenuStore.canvasContextSection.id)\n}\nconst handleToggleFocusMode = () => uiStore.toggleFocusMode()\n\n// TASK-1222: Collect overdue tasks near a group\nconst handleCollectOverdueFromMenu = (section: CanvasGroup) => {\n  collectOverdueTasksNearGroup(section.id)\n}\n\n// TASK-1222: Listen for AI tool collect-overdue-tasks events\nuseEventListener(window, 'collect-overdue-tasks', (e: Event) => {\n  const detail = (e as CustomEvent).detail\n  if (detail?.groupId) {\n    collectOverdueTasksNearGroup(detail.groupId)\n  }\n})\n\n// TASK-288 DEBUG: Wrapper to trace createTaskInGroup call\nconst handleCreateTaskInGroupDebug = (section: CanvasGroup) => {\n  // Get context menu position from store directly\n  const menuX = contextMenuStore.canvasContextMenuX\n  const menuY = contextMenuStore.canvasContextMenuY\n\n  createTaskInGroup(section)\n}\n\nconst handleSectionUpdate = (id: string, data: Record<string, unknown>) => canvasStore.updateSection(id, data)\nconst { closeAllContextMenus: closeCanvasContextMenu } = useCanvasContextMenus()\nconst handleEditTask = (task: Task) => { modalsStore.openEditModal(task); closeCanvasContextMenu() }\n// Handle double-click on nodes to open edit modal for tasks\nconst handleNodeDoubleClick = ({ node }: NodeMouseEvent) => {\n    if (node.type === 'taskNode' && node.data?.task) {\n        handleEditTask(node.data.task)\n    }\n}\nconst handleTaskContextMenu = (event: MouseEvent, task: Task) => {\n    if (event) event.preventDefault()\n    // Dispatch global event for ModalManager to handle (shared TaskContextMenu)\n    window.dispatchEvent(new CustomEvent('task-context-menu', {\n        detail: { event, task }\n    }))\n}\n\nconst handleSectionContextMenu = (event: MouseEvent, section: CanvasGroup) => {\n    if (event) {\n        event.preventDefault()\n        event.stopPropagation() // STOP PROPAGATION to prevent pane menu\n    }\n    // BUG-208 FIX: Use Pinia store instead of local refs\n    // CanvasContextMenus.vue reads from the store, so we must write to it\n    // BUG-1096: Use normalized coordinates for Tauri compatibility\n    const { x, y } = getViewportCoordinates(event)\n    contextMenuStore.openCanvasContextMenu(x, y, section as unknown as CanvasGroup)\n}\n\n// Expose for testing purposes (Fundamental Stability)\nif (process.env.NODE_ENV === 'development' || (window as unknown as Record<string, unknown>).PLAYWRIGHT_TEST) {\n  (window as unknown as Record<string, unknown>).__POMO_FLOW_DEBUG__ = {\n    orchestrator,\n    canvasStore,\n    taskStore,\n    uiStore,\n    // Debug Access to Singletons\n    get positionManager() { return import('../services/canvas/PositionManager').then(m => m.positionManager) },\n    get lockManager() { return import('../services/canvas/LockManager').then(m => m.lockManager) }\n  }\n}\n</script>\n\n<style scoped src=\"@/assets/canvas-view-layout.css\"></style>\n\n<style src=\"@/assets/canvas-view-overrides.css\"></style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/CyberflowView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/FocusView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/PerformanceView.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4530,4533],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4530,4533],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5388,5391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5388,5391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5435,5438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5435,5438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6197,6200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6197,6200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6302,6305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6302,6305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7192,7195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7192,7195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7678,7681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7678,7681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8801,8804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8801,8804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"performance-view\">\n    <header class=\"page-header glass\">\n      <div class=\"header-content--performance\">\n        <h1>Performance Dashboard</h1>\n        <p>System health and benchmarking suite for FlowState</p>\n      </div>\n      <div class=\"actions\">\n        <button \n          class=\"btn btn-primary glass flex items-center gap-2\" \n          :disabled=\"isRunning\" \n          aria-label=\"Run full performance benchmark suite\"\n          @click=\"runFullSuite\"\n        >\n          <span>{{ isRunning ? '⚡ Running...' : '🚀 Run Full Suite' }}</span>\n        </button>\n      </div>\n    </header>\n\n    <div class=\"dashboard-grid\">\n      <!-- Summary Cards -->\n      <div class=\"summary-cards\">\n        <div class=\"card glass score-card\" :class=\"performanceGradeClass\">\n          <h3>Overall Grade</h3>\n          <div class=\"grade-display\">\n            {{ performanceGrade }}\n          </div>\n          <p>{{ statusMessage }}</p>\n        </div>\n\n        <div class=\"card glass stat-card\">\n          <h3>Canvas Latency</h3>\n          <div class=\"stat-value\">\n            {{ canvasLatency }}ms\n          </div>\n          <div class=\"stat-label\">\n            1000 nodes sync\n          </div>\n        </div>\n\n        <div class=\"card glass stat-card\">\n          <h3>Memory Usage</h3>\n          <div class=\"stat-value\">\n            {{ memoryUsage }}MB\n          </div>\n          <div class=\"stat-label\">\n            Heap size\n          </div>\n        </div>\n      </div>\n\n      <!-- Main Results Table -->\n      <div class=\"results-container glass\">\n        <h2>Benchmark Results</h2>\n        <div class=\"table-wrapper\">\n          <table v-if=\"hasResults\">\n            <thead>\n              <tr>\n                <th>Test Category</th>\n                <th>Average</th>\n                <th>Min/Max</th>\n                <th>Throughput</th>\n                <th>Success</th>\n                <th>Status</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr v-for=\"(result, key) in results\" :key=\"key\">\n                <td class=\"test-name\">\n                  {{ result.name }}\n                </td>\n                <td>{{ result.averageTime.toFixed(2) }}ms</td>\n                <td>{{ result.minTime.toFixed(1) }} / {{ result.maxTime.toFixed(1) }}ms</td>\n                <td>{{ (result.throughput || 0).toFixed(1) }} ops/s</td>\n                <td>\n                  <div class=\"progress-bar\">\n                    <div class=\"progress\" :style=\"{ width: result.successRate + '%' }\" />\n                  </div>\n                  {{ Math.round(result.successRate) }}%\n                </td>\n                <td>\n                  <span class=\"status-badge\" :class=\"getStatusClass(result)\">\n                    {{ getStatusLabel(result) }}\n                  </span>\n                </td>\n              </tr>\n            </tbody>\n          </table>\n          <div v-else class=\"empty-state\">\n            <p>No results yet. Run the benchmark suite to see metrics.</p>\n          </div>\n        </div>\n      </div>\n\n      <!-- Documentation/Recommendations -->\n      <div class=\"sidebar glass\">\n        <h2>Recommendations</h2>\n        <ul v-if=\"recommendations.length > 0\">\n          <li v-for=\"(rec, i) in recommendations\" :key=\"i\">\n            <strong>{{ rec.type }}:</strong> {{ rec.message }}\n          </li>\n        </ul>\n        <p v-else>\n          System is performing optimally. No recommendations at this time.\n        </p>\n\n        <div class=\"baseline-tools\">\n          <div class=\"flex items-center justify-between mb-4\">\n            <h3 class=\"text-lg font-semibold flex items-center gap-2\">\n              <Zap :size=\"20\" class=\"text-indigo-400\" />\n              Baseline Management\n            </h3>\n          </div>\n          <button \n            class=\"btn btn-secondary glass w-full flex items-center justify-center gap-2\"\n            :disabled=\"!hasResults\"\n            aria-label=\"Save current results as new performance baseline\"\n            @click=\"saveAsBaseline\"\n          >\n            <Save :size=\"18\" />\n            <span>Save as New Baseline</span>\n          </button>\n          <div class=\"footer-note\">\n            Baselines are stored in <code>docs/performance/</code>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, onMounted } from 'vue'\nimport { performanceBenchmark } from '@/utils/performanceBenchmark'\n\nimport { Zap, Save } from 'lucide-vue-next' // Import icons\n\nconst results = ref<any>({})\nconst isRunning = ref(false) // Renamed from isBenchmarkRunning\nconst currentProgress = ref(0)\nconst hasResults = computed(() => Object.keys(results.value).length > 0)\n\nconst runFullSuite = async () => { // Renamed from runBenchmark\n  isRunning.value = true\n  currentProgress.value = 0\n  \n  // Update progress in background\n  const progressInterval = setInterval(() => {\n    currentProgress.value = performanceBenchmark.currentProgress\n  }, 100)\n\n  try {\n    const suiteResponse = await performanceBenchmark.runFullSuite()\n    results.value = suiteResponse\n  } catch (err) {\n    console.error('Benchmark failed:', err)\n  } finally {\n    clearInterval(progressInterval)\n    isRunning.value = false\n    currentProgress.value = 100\n  }\n}\n\nonMounted(async () => {\n  const latest = await performanceBenchmark.getLatestReport()\n  if (latest && (latest as any).results) {\n    results.value = (latest as any).results\n  }\n})\n\n// Metrics helpers\nconst canvasLatency = computed(() => {\n  if (results.value?.canvasPerformance) {\n    return results.value.canvasPerformance.averageTime.toFixed(1)\n  }\n  return '0.0'\n})\n\nconst memoryUsage = computed(() => {\n  if (results.value?.memoryEfficiency?.memoryUsage) {\n    return (results.value.memoryEfficiency.memoryUsage / 1024 / 1024).toFixed(1)\n  }\n  return '0.0'\n})\n\nconst performanceGrade = computed(() => {\n  if (!hasResults.value) return '-'\n  // Weight the grade more towards critical UI metrics (Canvas & Render)\n  const canvasTime = results.value.canvasPerformance?.averageTime || 0\n  const renderTime = results.value.renderPerformance?.averageTime || 0\n  const otherAvg = Object.values(results.value)\n    .filter((r: any) => r.name !== 'Canvas Performance' && r.name !== 'Render Performance')\n    .reduce((sum: number, r: any) => sum + r.averageTime, 0) / (Object.keys(results.value).length - 2 || 1)\n\n  const weightedAvg = (canvasTime * 0.4) + (renderTime * 0.4) + (otherAvg * 0.2)\n  \n  if (weightedAvg < 16) return 'A+'\n  if (weightedAvg < 48) return 'A'\n  if (weightedAvg < 96) return 'B'\n  if (weightedAvg < 192) return 'C'\n  return 'D'\n})\n\nconst performanceGradeClass = computed(() => {\n  const grade = performanceGrade.value\n  if (grade === 'A+' || grade === 'A') return 'grade-a'\n  if (grade === 'B') return 'grade-b'\n  if (grade === 'C') return 'grade-c'\n  return 'grade-d'\n})\n\nconst statusMessage = computed(() => {\n  if (!hasResults.value) return 'System status unknown'\n  const grade = performanceGrade.value\n  if (grade === 'A+' || grade === 'A') return 'Excellent Performance'\n  if (grade === 'B') return 'Good Performance'\n  return 'Performance Needs Attention'\n})\n\nconst getStatusClass = (result: any) => {\n  // Relaxed thresholds for batch operations (Canvas)\n  if (result.name === 'Canvas Performance') {\n    if (result.averageTime < 100) return 'status-fast'\n    if (result.averageTime < 250) return 'status-medium'\n    return 'status-badge slow'\n  }\n  // Strict thresholds for frame-based ops (Render, Store)\n  if (result.averageTime < 16) return 'status-fast'\n  if (result.averageTime < 50) return 'status-medium'\n  return 'status-badge slow'\n}\n\nconst getStatusLabel = (result: any) => {\n  if (result.name === 'Canvas Performance') {\n    if (result.averageTime < 100) return 'FAST'\n    if (result.averageTime < 250) return 'OK'\n    return 'SLOW'\n  }\n  if (result.averageTime < 16) return 'FAST'\n  if (result.averageTime < 50) return 'OK'\n  return 'SLOW'\n}\n\nconst recommendations = computed(() => {\n  const recs = []\n  if (results.value?.canvasPerformance?.averageTime > 50) {\n    recs.push({ type: 'Canvas', message: 'High latency detected with many nodes. Consider LOD optimization.' })\n  }\n  if (results.value?.memoryEfficiency?.memoryUsage > 200 * 1024 * 1024) {\n    recs.push({ type: 'Memory', message: 'Memory usage is elevated. Check for leaks in node pooling.' })\n  }\n  if (results.value?.renderPerformance?.averageTime > 20) {\n    recs.push({ type: 'Render', message: 'Main thread is taking too long for UI updates. Review watcher complexity.' })\n  }\n  return recs\n})\n\nconst saveAsBaseline = () => {\n  const data = JSON.stringify({\n    timestamp: new Date().toISOString(),\n    results: results.value,\n    environment: {\n      userAgent: navigator.userAgent,\n      memoryLimit: (performance as any).memory?.jsHeapSizeLimit || 'unknown'\n    }\n  }, null, 2)\n  \n  const blob = new Blob([data], { type: 'application/json' })\n  const url = URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = `performance-baseline-${new Date().toISOString().split('T')[0]}.json`\n  a.click()\n  URL.revokeObjectURL(url)\n}\n</script>\n\n<style scoped>\n.performance-view {\n  padding: 2rem;\n  max-width: 1400px;\n  margin: 0 auto;\n  color: #e2e8f0;\n  height: 100vh;\n  overflow-y: auto;\n  scrollbar-width: auto; /* Revert to auto for better accessibility grab area */\n  scrollbar-color: rgba(99, 102, 241, 0.5) rgba(15, 23, 42, 0.1);\n}\n\n/* Custom scrollbar for Webkit browsers with wider handle */\n.performance-view::-webkit-scrollbar {\n  width: 14px;\n}\n\n.performance-view::-webkit-scrollbar-track {\n  background: rgba(15, 23, 42, 0.1);\n}\n\n.performance-view::-webkit-scrollbar-thumb {\n  background: rgba(99, 102, 241, 0.3);\n  border-radius: 7px;\n  border: 3px solid transparent;\n  background-clip: content-box;\n}\n\n.performance-view::-webkit-scrollbar-thumb:hover {\n  background: rgba(99, 102, 241, 0.5);\n  background-clip: content-box;\n}\n\n.glass {\n  background: var(--glass-bg-tint);\n  backdrop-filter: blur(12px);\n  border: 1px solid var(--border-subtle);\n  border-radius: var(--radius-lg);\n}\n\n.page-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--space-6) 2rem;\n  margin-bottom: 2rem;\n}\n\n.header-content--performance h1 {\n  margin: 0;\n  font-size: var(--text-3xl);\n  background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n}\n\n.header-content--performance p {\n  margin: var(--space-1) 0 0;\n  opacity: 0.6;\n}\n\n.dashboard-grid {\n  display: grid;\n  grid-template-columns: 1fr 300px;\n  gap: 2rem;\n}\n\n.summary-cards {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: var(--space-6);\n  grid-column: 1 / -1;\n}\n\n.card {\n  padding: var(--space-6);\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  transition: transform var(--duration-normal);\n}\n\n.card:hover {\n  transform: translateY(-4px);\n}\n\n.card h3 {\n  margin: 0;\n  font-size: var(--text-sm);\n  text-transform: uppercase;\n  letter-spacing: 0.05em;\n  opacity: 0.5;\n}\n\n.stat-value {\n  font-size: var(--text-2xl);\n  font-weight: 700;\n  margin: var(--space-2) 0;\n  color: var(--color-indigo);\n}\n\n.grade-display {\n  font-size: 5rem;\n  font-weight: 800;\n  margin: var(--space-4) 0;\n  line-height: 1;\n  text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);\n  color: #ff6b6b; /* Brighter red for accessibility */\n}\n\n.grade-a { color: #10b981; border-color: rgba(16, 185, 129, 0.3); }\n.grade-b { color: #f59e0b; border-color: rgba(245, 158, 11, 0.3); }\n.grade-c { color: #ef4444; border-color: rgba(239, 68, 68, 0.3); }\n.grade-d { color: #ef4444; border-color: rgba(239, 68, 68, 0.3); } /* Added for consistency */\n\n.results-container {\n  padding: var(--space-6);\n}\n\n.table-wrapper {\n  margin-top: var(--space-6);\n  overflow-x: auto;\n}\n\ntable {\n  width: 100%;\n  border-collapse: collapse;\n}\n\nth {\n  text-align: left;\n  padding: var(--space-4);\n  border-bottom: 1px solid var(--glass-border);\n  opacity: 0.6;\n  font-weight: 500;\n}\n\ntd {\n  padding: var(--space-4);\n  border-bottom: 1px solid var(--glass-border-faint);\n}\n\n.test-name {\n  font-weight: 600;\n}\n\n.sidebar {\n  padding: var(--space-6);\n  height: fit-content;\n}\n\n.sidebar h2 {\n  font-size: var(--space-5);\n  margin-top: 0;\n}\n\n.sidebar ul {\n  padding-left: var(--space-5);\n  margin: var(--space-4) 0;\n}\n\n.sidebar li {\n  margin-bottom: var(--space-3);\n  font-size: var(--text-sm);\n  line-height: 1.4;\n}\n\n.baseline-tools {\n  margin-top: 2rem;\n  padding-top: var(--space-6);\n  border-top: 1px solid var(--glass-border);\n}\n\n.footer-note {\n  margin-top: var(--space-4);\n  font-size: var(--text-xs);\n  opacity: 0.5;\n}\n\n.status-badge {\n  padding: var(--space-1) 0.6rem;\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  font-weight: 700;\n}\n\n.status-fast { background: rgba(16, 185, 129, 0.15); color: #10b981; }\n.status-medium { background: rgba(245, 158, 11, 0.15); color: #f59e0b; }\n.status-badge.slow {\n  background: rgba(239, 68, 68, 0.15);\n  color: #ff8a8a; /* Brighter red for contrast on dark background */\n  border: 1px solid rgba(239, 68, 68, 0.3);\n}\n\n.btn {\n  padding: 0.6rem 1.2rem;\n  border-radius: var(--radius-md);\n  border: none;\n  font-weight: 600;\n  cursor: pointer;\n  transition: all var(--duration-normal);\n}\n\n.btn-primary { background: #6366f1; color: white; }\n.btn-primary:hover { background: #4f46e5; }\n.btn-secondary { background: rgba(255, 255, 255, 0.1); color: white; }\n.btn-secondary:hover { background: rgba(255, 255, 255, 0.15); }\n.btn:disabled { opacity: 0.5; cursor: not-allowed; }\n\n.progress-bar {\n  width: 60px;\n  height: 6px;\n  background: var(--glass-border);\n  border-radius: 3px;\n  display: inline-block;\n  margin-right: var(--space-2);\n  vertical-align: middle;\n}\n\n.progress {\n  height: 100%;\n  background: var(--color-indigo);\n  border-radius: 3px;\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/QuickSortView.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]},{"filePath":"/media/endlessblink/data/my-projects/ai-development/productivity/flow-state/src/views/WeeklyPlanView.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":398,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":398,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13156,13159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13156,13159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<template>\n  <div class=\"weekly-plan-view\">\n    <!-- Idle: Choose Quick or Thorough -->\n    <div v-if=\"state.status === 'idle'\" class=\"wp-centered\">\n      <CalendarDays :size=\"48\" class=\"wp-hero-icon\" />\n      <h2 class=\"wp-title\">\n        Plan Your Week\n      </h2>\n      <p class=\"wp-subtitle\">\n        {{ eligibleTaskCount }} tasks ready to schedule\n      </p>\n      <div class=\"wp-mode-selector\">\n        <button class=\"wp-btn wp-btn-primary\" @click=\"onQuickPlan\">\n          <Zap :size=\"16\" />\n          Quick Plan\n        </button>\n        <button class=\"wp-btn wp-btn-ghost\" @click=\"onThoroughPlan\">\n          <MessageCircle :size=\"16\" />\n          Thorough Plan\n        </button>\n      </div>\n      <p class=\"wp-hint\">\n        Quick skips the interview. Thorough asks a few questions first.\n      </p>\n    </div>\n\n    <!-- Interview State -->\n    <div v-else-if=\"state.status === 'interview'\" class=\"wp-centered wp-interview\">\n      <div class=\"interview-header\">\n        <MessageCircle :size=\"28\" class=\"wp-title-icon\" />\n        <h2 class=\"wp-title\">\n          A few quick questions\n        </h2>\n      </div>\n\n      <div class=\"interview-cards\">\n        <!-- Q1: Top priority -->\n        <div class=\"interview-card\">\n          <label class=\"interview-label\">What's your top priority this week?</label>\n          <input\n            v-model=\"interviewForm.topPriority\"\n            type=\"text\"\n            class=\"interview-input\"\n            placeholder=\"e.g. Ship the new dashboard, fix auth bugs...\"\n          >\n        </div>\n\n        <!-- Q2: Days off -->\n        <div class=\"interview-card\">\n          <label class=\"interview-label\">Any days off or light days?</label>\n          <div class=\"day-toggle-row\">\n            <button\n              v-for=\"d in dayOptions\"\n              :key=\"d.key\"\n              class=\"day-toggle\"\n              :class=\"{ active: interviewForm.daysOff.includes(d.key) }\"\n              @click=\"toggleDayOff(d.key)\"\n            >\n              {{ d.short }}\n            </button>\n          </div>\n        </div>\n\n        <!-- Q3: Heavy meeting days -->\n        <div class=\"interview-card\">\n          <label class=\"interview-label\">Heavy meeting days?</label>\n          <div class=\"day-toggle-row\">\n            <button\n              v-for=\"d in dayOptions\"\n              :key=\"d.key\"\n              class=\"day-toggle meeting\"\n              :class=\"{ active: interviewForm.heavyMeetingDays.includes(d.key) }\"\n              @click=\"toggleMeetingDay(d.key)\"\n            >\n              {{ d.short }}\n            </button>\n          </div>\n        </div>\n\n        <!-- Q4: Max tasks per day -->\n        <div class=\"interview-card\">\n          <label class=\"interview-label\">Max tasks per day?</label>\n          <div class=\"max-tasks-row\">\n            <button\n              v-for=\"n in maxTaskOptions\"\n              :key=\"n\"\n              class=\"max-task-chip\"\n              :class=\"{ active: interviewForm.maxTasksPerDay === n }\"\n              @click=\"interviewForm.maxTasksPerDay = n\"\n            >\n              {{ n }}\n            </button>\n          </div>\n        </div>\n\n        <!-- Q5: Work style preference -->\n        <div class=\"interview-card\">\n          <label class=\"interview-label\">How do you prefer to distribute work?</label>\n          <div class=\"work-style-row\">\n            <button\n              v-for=\"ws in workStyleOptions\"\n              :key=\"ws.key\"\n              class=\"work-style-chip\"\n              :class=\"{ active: interviewForm.preferredWorkStyle === ws.key }\"\n              @click=\"interviewForm.preferredWorkStyle = ws.key\"\n            >\n              <span class=\"ws-label\">{{ ws.label }}</span>\n              <span class=\"ws-desc\">{{ ws.desc }}</span>\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"interview-actions\">\n        <button class=\"wp-btn wp-btn-primary\" @click=\"onSubmitInterview\">\n          <Sparkles :size=\"16\" />\n          Generate Plan\n        </button>\n        <button class=\"wp-btn wp-btn-ghost\" @click=\"onCancelInterview\">\n          Cancel\n        </button>\n      </div>\n    </div>\n\n    <!-- Loading State -->\n    <div v-else-if=\"state.status === 'loading'\" class=\"wp-centered\">\n      <Loader2 :size=\"48\" class=\"wp-spinner\" />\n      <p class=\"wp-loading-text\">\n        AI is analyzing your tasks...\n      </p>\n      <div class=\"wp-skeleton-columns\">\n        <div v-for=\"i in 7\" :key=\"i\" class=\"wp-skeleton-col\" />\n      </div>\n    </div>\n\n    <!-- Review State -->\n    <div v-else-if=\"state.status === 'review' && state.plan\" class=\"wp-review\">\n      <div class=\"wp-review-header\">\n        <div class=\"wp-title-row\">\n          <CalendarDays :size=\"18\" class=\"wp-title-icon\" />\n          <h2 class=\"wp-title\">\n            Your Week\n          </h2>\n          <span class=\"wp-stats-inline\">{{ scheduledCount }} tasks · {{ daysUsed }} days</span>\n        </div>\n        <div class=\"wp-action-bar\">\n          <button class=\"wp-btn wp-btn-sm wp-btn-primary\" @click=\"onApply\">\n            <Check :size=\"14\" />\n            Apply\n          </button>\n          <button class=\"wp-btn wp-btn-sm wp-btn-ghost\" @click=\"onRegenerate\">\n            <RefreshCw :size=\"14\" />\n            Regenerate\n          </button>\n          <button class=\"wp-btn wp-btn-sm wp-btn-ghost\" @click=\"onCancel\">\n            <X :size=\"14\" />\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div v-if=\"state.weekTheme\" class=\"wp-week-theme\">\n        <Sparkles :size=\"14\" class=\"wp-theme-icon\" />\n        <span class=\"wp-theme-text\">{{ state.weekTheme }}</span>\n      </div>\n\n      <details v-if=\"state.reasoning\" class=\"wp-reasoning-details\">\n        <summary class=\"wp-reasoning-summary\">\n          <CalendarDays :size=\"12\" />\n          AI reasoning\n        </summary>\n        <p class=\"wp-reasoning-text\">\n          {{ state.reasoning }}\n        </p>\n      </details>\n\n      <WeeklyPlanGrid\n        :plan=\"state.plan\"\n        :task-map=\"taskMap\"\n        :week-start=\"state.weekStart\"\n        :task-reasons=\"state.taskReasons\"\n        @move-task=\"onMoveTask\"\n        @resuggest=\"onResuggest\"\n        @remove-task=\"onRemoveTask\"\n        @change-priority=\"onChangePriority\"\n        @snooze-task=\"onSnoozeTask\"\n      />\n    </div>\n\n    <!-- Applied State -->\n    <div v-else-if=\"state.status === 'applied'\" class=\"wp-centered\">\n      <div class=\"wp-success-icon\">\n        <Check :size=\"32\" />\n      </div>\n      <h2 class=\"wp-title\">\n        Week planned!\n      </h2>\n      <p class=\"wp-applied-stats\">\n        {{ scheduledCount }} tasks scheduled across {{ daysUsed }} days\n      </p>\n      <button class=\"wp-btn wp-btn-primary\" @click=\"router.push('/')\">\n        <ArrowRight :size=\"18\" />\n        Go to Canvas\n      </button>\n    </div>\n\n    <!-- Error State -->\n    <div v-else-if=\"state.status === 'error'\" class=\"wp-centered\">\n      <div class=\"wp-error-icon\">\n        <X :size=\"32\" />\n      </div>\n      <p class=\"wp-error-text\">\n        {{ state.error }}\n      </p>\n      <div class=\"wp-error-actions\">\n        <button class=\"wp-btn wp-btn-primary\" @click=\"generatePlan()\">\n          <RefreshCw :size=\"16\" />\n          Try Again\n        </button>\n        <button class=\"wp-btn wp-btn-ghost\" @click=\"onCancel\">\n          Go Back\n        </button>\n      </div>\n    </div>\n\n    <!-- Applying (brief transitional) -->\n    <div v-else class=\"wp-centered\">\n      <Loader2 :size=\"48\" class=\"wp-spinner\" />\n      <p class=\"wp-loading-text\">\n        Applying plan...\n      </p>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { onMounted, onUnmounted, computed, reactive } from 'vue'\nimport { useRouter } from 'vue-router'\nimport { useWeeklyPlan } from '@/composables/useWeeklyPlan'\nimport { useWorkProfile } from '@/composables/useWorkProfile'\nimport { useSettingsStore } from '@/stores/settings'\nimport WeeklyPlanGrid from '@/components/weeklyplan/WeeklyPlanGrid.vue'\nimport type { WeeklyPlan, InterviewAnswers } from '@/composables/useWeeklyPlanAI'\nimport {\n  CalendarDays, RefreshCw, Check, ArrowRight, X, Loader2,\n  Zap, MessageCircle, Sparkles,\n} from 'lucide-vue-next'\n\nconst router = useRouter()\nconst {\n  state, taskMap, generatePlan, moveTask, applyPlan,\n  removeTaskFromPlan, snoozeTask, changePriority,\n  regenerateDay, startInterview, submitInterview,\n  eligibleTaskCount, reset,\n} = useWeeklyPlan()\n\nconst { loadProfile, savePreferences } = useWorkProfile()\nconst settingsStore = useSettingsStore()\n\n// Interview form state\nconst interviewForm = reactive({\n  topPriority: '',\n  daysOff: [] as string[],\n  heavyMeetingDays: [] as string[],\n  maxTasksPerDay: 5,\n  preferredWorkStyle: 'balanced' as 'frontload' | 'balanced' | 'backload',\n})\n\n// TASK-1321: Dynamic day options based on weekStartsOn setting\nconst dayOptions = computed(() => {\n  const allDays = [\n    { key: 'sunday', short: 'Sun' },\n    { key: 'monday', short: 'Mon' },\n    { key: 'tuesday', short: 'Tue' },\n    { key: 'wednesday', short: 'Wed' },\n    { key: 'thursday', short: 'Thu' },\n    { key: 'friday', short: 'Fri' },\n    { key: 'saturday', short: 'Sat' },\n  ]\n  const startDay = settingsStore.weekStartsOn ?? 0\n  return [...allDays.slice(startDay), ...allDays.slice(0, startDay)]\n})\n\nconst maxTaskOptions = [3, 5, 8, 10]\n\nconst workStyleOptions = [\n  { key: 'frontload' as const, label: 'Front-load', desc: 'Heavy Mon-Tue' },\n  { key: 'balanced' as const, label: 'Balanced', desc: 'Even spread' },\n  { key: 'backload' as const, label: 'Back-load', desc: 'Ramp to Friday' },\n]\n\nfunction toggleDayOff(key: string) {\n  const idx = interviewForm.daysOff.indexOf(key)\n  if (idx === -1) {\n    interviewForm.daysOff.push(key)\n    // Remove from meeting days if present\n    const mIdx = interviewForm.heavyMeetingDays.indexOf(key)\n    if (mIdx !== -1) interviewForm.heavyMeetingDays.splice(mIdx, 1)\n  } else {\n    interviewForm.daysOff.splice(idx, 1)\n  }\n}\n\nfunction toggleMeetingDay(key: string) {\n  const idx = interviewForm.heavyMeetingDays.indexOf(key)\n  if (idx === -1) {\n    interviewForm.heavyMeetingDays.push(key)\n    // Remove from days off if present\n    const dIdx = interviewForm.daysOff.indexOf(key)\n    if (dIdx !== -1) interviewForm.daysOff.splice(dIdx, 1)\n  } else {\n    interviewForm.heavyMeetingDays.splice(idx, 1)\n  }\n}\n\n// Mode actions\nfunction onQuickPlan() {\n  generatePlan()\n}\n\nfunction onThoroughPlan() {\n  startInterview()\n}\n\nfunction onSubmitInterview() {\n  const answers: InterviewAnswers = {}\n  if (interviewForm.topPriority.trim()) answers.topPriority = interviewForm.topPriority.trim()\n  if (interviewForm.daysOff.length > 0) answers.daysOff = [...interviewForm.daysOff]\n  if (interviewForm.heavyMeetingDays.length > 0) answers.heavyMeetingDays = [...interviewForm.heavyMeetingDays]\n  if (interviewForm.maxTasksPerDay) answers.maxTasksPerDay = interviewForm.maxTasksPerDay\n  answers.preferredWorkStyle = interviewForm.preferredWorkStyle\n\n  // FEATURE-1317: Persist preferences to work profile\n  savePreferences({\n    topPriorityNote: interviewForm.topPriority.trim() || null,\n    daysOff: [...interviewForm.daysOff],\n    heavyMeetingDays: [...interviewForm.heavyMeetingDays],\n    maxTasksPerDay: interviewForm.maxTasksPerDay,\n    preferredWorkStyle: interviewForm.preferredWorkStyle,\n  }).catch(err => console.warn('[WeeklyPlan] Failed to save preferences:', err))\n\n  submitInterview(answers)\n}\n\nfunction onCancelInterview() {\n  state.value.status = 'idle'\n}\n\n// Keyboard + FEATURE-1317: Load work profile\nonMounted(async () => {\n  window.addEventListener('keydown', handleKeydown)\n\n  // FEATURE-1317: Load work profile and pre-populate interview form\n  const savedProfile = await loadProfile()\n  if (savedProfile) {\n    if (savedProfile.topPriorityNote) interviewForm.topPriority = savedProfile.topPriorityNote\n    if (savedProfile.daysOff?.length) interviewForm.daysOff = [...savedProfile.daysOff]\n    if (savedProfile.heavyMeetingDays?.length) interviewForm.heavyMeetingDays = [...savedProfile.heavyMeetingDays]\n    if (savedProfile.maxTasksPerDay) interviewForm.maxTasksPerDay = savedProfile.maxTasksPerDay\n    if (savedProfile.preferredWorkStyle) interviewForm.preferredWorkStyle = savedProfile.preferredWorkStyle\n  }\n})\n\nonUnmounted(() => {\n  window.removeEventListener('keydown', handleKeydown)\n})\n\n// Stats for review state\nconst scheduledCount = computed(() => {\n  if (!state.value.plan) return 0\n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const\n  return days.reduce((sum, d) => sum + state.value.plan![d].length, 0)\n})\n\nconst daysUsed = computed(() => {\n  if (!state.value.plan) return 0\n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const\n  return days.filter(d => state.value.plan![d].length > 0).length\n})\n\nfunction onMoveTask(taskId: string, fromDay: keyof WeeklyPlan, toDay: keyof WeeklyPlan) {\n  moveTask(taskId, fromDay, toDay)\n}\n\nfunction onRemoveTask(taskId: string) {\n  removeTaskFromPlan(taskId)\n}\n\nfunction onChangePriority(taskId: string) {\n  changePriority(taskId)\n}\n\nfunction onSnoozeTask(taskId: string) {\n  snoozeTask(taskId)\n}\n\nfunction onResuggest(dayKey: string) {\n  regenerateDay(dayKey as any)\n}\n\nfunction onApply() {\n  applyPlan()\n}\n\nfunction onRegenerate() {\n  generatePlan()\n}\n\nfunction onCancel() {\n  reset()\n  router.back()\n}\n\nfunction handleKeydown(event: KeyboardEvent) {\n  const target = event.target as HTMLElement\n  if (target?.tagName === 'INPUT' || target?.tagName === 'TEXTAREA' || target?.isContentEditable) return\n\n  if (event.key === 'Enter' && state.value.status === 'review') {\n    event.preventDefault()\n    onApply()\n  }\n  if (event.key === 'Escape') {\n    event.preventDefault()\n    if (state.value.status === 'interview') {\n      onCancelInterview()\n    } else {\n      onCancel()\n    }\n  }\n}\n</script>\n\n<style scoped>\n.weekly-plan-view {\n  flex: 1;\n  min-height: 0;\n  display: flex;\n  flex-direction: column;\n  padding: var(--space-3) var(--space-4);\n  overflow-y: auto;\n}\n\n/* Centered layout for loading/applied/error/idle states */\n.wp-centered {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: var(--space-6);\n  text-align: center;\n}\n\n.wp-hero-icon {\n  color: var(--brand-primary);\n  opacity: 0.8;\n}\n\n.wp-subtitle {\n  font-size: var(--text-base);\n  color: var(--text-muted);\n  margin: 0;\n}\n\n.wp-hint {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  margin: 0;\n  opacity: 0.7;\n}\n\n.wp-mode-selector {\n  display: flex;\n  gap: var(--space-3);\n}\n\n.wp-spinner {\n  color: var(--brand-primary);\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n.wp-loading-text {\n  font-size: var(--text-lg);\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n/* Skeleton columns */\n.wp-skeleton-columns {\n  display: flex;\n  gap: var(--space-4);\n  margin-top: var(--space-8);\n}\n\n.wp-skeleton-col {\n  width: 180px;\n  height: 300px;\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-lg);\n  animation: skeletonPulse 1.5s ease-in-out infinite;\n}\n\n@keyframes skeletonPulse {\n  0%, 100% { opacity: 0.4; }\n  50% { opacity: 0.7; }\n}\n\n/* Interview State */\n.wp-interview {\n  max-width: 600px;\n  margin: 0 auto;\n  gap: var(--space-8);\n}\n\n.interview-header {\n  display: flex;\n  align-items: center;\n  gap: var(--space-3);\n}\n\n.interview-cards {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-5);\n  width: 100%;\n}\n\n.interview-card {\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  padding: var(--space-4) var(--space-5);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-md);\n  text-align: left;\n}\n\n.interview-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n}\n\n.interview-input {\n  width: 100%;\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  color: var(--text-primary);\n  font-size: var(--text-sm);\n  outline: none;\n  transition: border-color var(--duration-fast);\n}\n\n.interview-input:focus {\n  border-color: var(--brand-primary);\n}\n\n.interview-input::placeholder {\n  color: var(--text-muted);\n}\n\n.day-toggle-row {\n  display: flex;\n  gap: var(--space-1_5);\n  flex-wrap: wrap;\n}\n\n.day-toggle {\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-medium);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.day-toggle:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.day-toggle.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.day-toggle.meeting.active {\n  background: rgba(245, 158, 11, 0.12);\n  border-color: var(--color-warning);\n  color: var(--color-warning);\n}\n\n.max-tasks-row {\n  display: flex;\n  gap: var(--space-2);\n}\n\n.max-task-chip {\n  width: 40px;\n  height: 36px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-medium);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.max-task-chip:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.max-task-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.interview-actions {\n  display: flex;\n  gap: var(--space-3);\n}\n\n.work-style-row {\n  display: flex;\n  gap: var(--space-2);\n}\n\n.work-style-chip {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--space-0_5);\n  padding: var(--space-2) var(--space-3);\n  border: 1px solid var(--glass-border);\n  border-radius: var(--radius-sm);\n  background: var(--glass-bg-medium);\n  color: var(--text-secondary);\n  cursor: pointer;\n  transition: all var(--duration-fast);\n}\n\n.work-style-chip:hover {\n  border-color: var(--glass-border-hover);\n  color: var(--text-primary);\n}\n\n.work-style-chip.active {\n  background: rgba(78, 205, 196, 0.12);\n  border-color: var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.ws-label {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n}\n\n.ws-desc {\n  font-size: var(--text-xs);\n  opacity: 0.7;\n}\n\n/* Review State */\n.wp-review {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: var(--space-2);\n  min-height: 0;\n}\n\n.wp-review-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--space-3);\n  flex-shrink: 0;\n}\n\n.wp-title-row {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n}\n\n.wp-title-icon {\n  color: var(--brand-primary);\n  flex-shrink: 0;\n}\n\n.wp-title {\n  font-size: var(--text-lg);\n  font-weight: var(--font-bold);\n  color: var(--text-primary);\n  margin: 0;\n}\n\n.wp-stats-inline {\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  white-space: nowrap;\n}\n\n/* Week theme badge */\n.wp-week-theme {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2) var(--space-3);\n  background: rgba(78, 205, 196, 0.06);\n  border: 1px solid rgba(78, 205, 196, 0.15);\n  border-radius: var(--radius-md);\n  flex-shrink: 0;\n}\n\n.wp-theme-icon {\n  color: var(--brand-primary);\n  flex-shrink: 0;\n  opacity: 0.8;\n}\n\n.wp-theme-text {\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  color: var(--text-primary);\n  letter-spacing: 0.01em;\n}\n\n/* Collapsible reasoning */\n.wp-reasoning-details {\n  flex-shrink: 0;\n}\n\n.wp-reasoning-summary {\n  display: flex;\n  align-items: center;\n  gap: var(--space-1_5);\n  font-size: var(--text-xs);\n  color: var(--text-muted);\n  cursor: pointer;\n  user-select: none;\n  list-style: none;\n  padding: var(--space-1) 0;\n}\n\n.wp-reasoning-summary::-webkit-details-marker {\n  display: none;\n}\n\n.wp-reasoning-summary::before {\n  content: '▸';\n  font-size: 10px;\n  transition: transform var(--duration-fast);\n}\n\n.wp-reasoning-details[open] .wp-reasoning-summary::before {\n  transform: rotate(90deg);\n}\n\n.wp-reasoning-text {\n  margin: var(--space-1) 0 0 0;\n  padding: var(--space-2) var(--space-3);\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border);\n  border-left: 2px solid var(--brand-primary);\n  border-radius: var(--radius-sm);\n  font-size: var(--text-xs);\n  color: var(--text-tertiary);\n  line-height: var(--leading-relaxed);\n}\n\n/* Action bar — inline in header */\n.wp-action-bar {\n  display: flex;\n  align-items: center;\n  gap: var(--space-2);\n  flex-shrink: 0;\n}\n\n.wp-btn-sm {\n  padding: var(--space-1_5) var(--space-3);\n  font-size: var(--text-xs);\n}\n\n/* Buttons */\n.wp-btn {\n  display: inline-flex;\n  align-items: center;\n  gap: var(--space-2);\n  padding: var(--space-2_5) var(--space-5);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  border-radius: var(--radius-lg);\n  cursor: pointer;\n  transition: all var(--duration-normal) var(--spring-smooth);\n  white-space: nowrap;\n}\n\n.wp-btn-primary {\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--brand-primary);\n  color: var(--brand-primary);\n  backdrop-filter: blur(8px);\n  -webkit-backdrop-filter: blur(8px);\n}\n\n.wp-btn-primary:hover {\n  background: rgba(78, 205, 196, 0.08);\n  border-color: var(--brand-hover);\n  color: var(--brand-hover);\n  transform: translateY(-1px);\n  box-shadow: var(--state-hover-shadow);\n}\n\n.wp-btn-ghost {\n  background: var(--glass-bg-soft);\n  border: 1px solid var(--glass-border-hover);\n  color: var(--text-secondary);\n  backdrop-filter: blur(8px);\n  -webkit-backdrop-filter: blur(8px);\n}\n\n.wp-btn-ghost:hover {\n  background: var(--glass-bg-medium);\n  border-color: var(--glass-border-strong);\n  color: var(--text-primary);\n  transform: translateY(-1px);\n}\n\n/* Success icon */\n.wp-success-icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 64px;\n  height: 64px;\n  border-radius: var(--radius-full);\n  background: var(--glass-bg-soft);\n  border: 2px solid var(--brand-primary);\n  color: var(--brand-primary);\n}\n\n.wp-applied-stats {\n  font-size: var(--text-base);\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n/* Error state */\n.wp-error-icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 64px;\n  height: 64px;\n  border-radius: var(--radius-full);\n  background: var(--danger-bg-subtle);\n  border: 2px solid var(--color-danger);\n  color: var(--color-danger);\n}\n\n.wp-error-text {\n  font-size: var(--text-base);\n  color: var(--color-danger);\n  margin: 0;\n}\n\n.wp-error-actions {\n  display: flex;\n  gap: var(--space-3);\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n  .weekly-plan-view {\n    padding: var(--space-3) var(--space-4);\n  }\n\n  .wp-skeleton-columns {\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n\n  .wp-skeleton-col {\n    width: 80px;\n    height: 120px;\n  }\n\n  .wp-action-bar {\n    flex-wrap: wrap;\n  }\n\n  .wp-interview {\n    max-width: 100%;\n  }\n}\n\n/* Reduced motion */\n@media (prefers-reduced-motion: reduce) {\n  .wp-spinner {\n    animation: none;\n  }\n\n  .wp-skeleton-col {\n    animation: none;\n  }\n}\n</style>\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"vue/component-tags-order","replacedBy":["block-order"]},{"ruleId":"vue/script-setup-uses-vars","replacedBy":[]}]}]
